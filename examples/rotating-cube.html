<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>threecs | Examples: Rotating Cube</title>
    <style>
      html, body {
        margin: 0;
        background-color: black
      }
    </style>
  </head>
  <body>
    <script type="module">
      import { addEntity, createWorld, registerComponents, pipe, defineQuery, defineSystem, defineComponent, addComponent, removeComponent, Types } from "bitecs";
      import {
        WebGLRenderer,
        Scene,
        PerspectiveCamera,
        Clock,
        Mesh,
        BoxBufferGeometry,
        MeshBasicMaterial,
        Vector3,
        TextureLoader,
      } from "three";
      import {
        RendererComponent,
        addRendererComponent,
        Object3DComponent,
        addObject3DComponent,
        RendererSystem,
        initRendererSystem,
        addObject3DEntity,
        initObject3DStorage,
        removeObject3DEntity
      } from "../src/threecs";
      import crateTextureUrl from "./assets/crate.gif";

      const RotateComponent = defineComponent(new Map());

      function addRotateComponent(world, eid, axis, speed) {
        addComponent(world, RotateComponent, eid);
        RotateComponent.set(eid, { axis, speed });
      }

      function removeRotateComponent(world, eid) {
        removeComponent(world, RotateComponent, eid);
        RotateComponent.delete(eid);
      }

      const rotateQuery = defineQuery([RotateComponent, Object3DComponent]);

      const RotateSystem = defineSystem((world) => {
        const entities = rotateQuery(world);

        entities.forEach((eid) => {
          const dt = world.dt;
          const object3D = Object3DComponent.get(eid);
          const { speed, axis } = RotateComponent.get(eid);
          object3D.rotateOnAxis(axis, speed * dt);
        });
      });

      const DeferredRemovalComponent = defineComponent({
        removeAfter: Types.f32
      });

      const deferredRemovalQuery = defineQuery([DeferredRemovalComponent, Object3DComponent]);

      const DeferredRemovalSystem = defineSystem((world) => {
        const entities = deferredRemovalQuery(world);

        entities.forEach((eid) => {
          const removeAfter = DeferredRemovalComponent.removeAfter[eid];

          if (world.time > removeAfter) {
            removeObject3DEntity(world, eid);
          }
        });
      });

      const world = createWorld();
      initObject3DStorage(world);

      registerComponents(world, [
        RendererComponent,
        Object3DComponent,
        RotateComponent,
        DeferredRemovalComponent
      ]);

      const scene = new Scene();
      const sceneEid = addObject3DEntity(world, scene);

      const camera = new PerspectiveCamera();
      camera.position.z = 5;
      const cameraEid = addObject3DEntity(world, camera, scene);

      const canvas = document.getElementById("canvas");
      const rendererEid = addEntity(world);
      const renderer = new WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);
      addRendererComponent(world, rendererEid, renderer, scene, camera);
      initRendererSystem(world);

      const clock = new Clock();

      const crateTexture = new TextureLoader().load(crateTextureUrl);
      const cube = new Mesh(
        new BoxBufferGeometry(),
        new MeshBasicMaterial({ map: crateTexture })
      );
      const cubeEid = addObject3DEntity(world, cube, scene);
      addRotateComponent(world, cubeEid, new Vector3(0.5, 1, 0).normalize(), 1);
      addComponent(world, DeferredRemovalComponent, cubeEid);
      DeferredRemovalComponent.removeAfter[cubeEid] = clock.getElapsedTime() + 1;
      const cube2 = new Mesh(
        new BoxBufferGeometry(),
        new MeshBasicMaterial({ map: crateTexture })
      );
      const cube2Eid = addObject3DEntity(world, cube2, cube);
      addRotateComponent(world, cube2Eid, new Vector3(0.5, 1, 0).normalize(), 1);
      cube2.position.x = 1;

      const pipeline = pipe([RotateSystem, DeferredRemovalSystem, RendererSystem]);

      renderer.setAnimationLoop(() => {
        world.dt = clock.getDelta();
        world.time = clock.getElapsedTime();
        pipeline(world);
      });
    </script>
  </body>
</html>
