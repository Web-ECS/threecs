var __defProp = Object.defineProperty;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __assign = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = "127";
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const FlatShading = 1;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;
const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const CubeUVRefractionMapping = 307;
const RepeatWrapping = 1e3;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedShort565Type = 1019;
const UnsignedInt248Type = 1020;
const AlphaFormat = 1021;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBIntegerFormat = 1032;
const RGBAIntegerFormat = 1033;
const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
const LoopOnce = 2200;
const LoopRepeat = 2201;
const LoopPingPong = 2202;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const TrianglesDrawMode = 0;
const TriangleStripDrawMode = 1;
const TriangleFanDrawMode = 2;
const LinearEncoding = 3e3;
const sRGBEncoding = 3001;
const GammaEncoding = 3007;
const RGBEEncoding = 3002;
const LogLuvEncoding = 3003;
const RGBM7Encoding = 3004;
const RGBM16Encoding = 3005;
const RGBDEncoding = 3006;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;
const KeepStencilOp = 7680;
const AlwaysStencilFunc = 519;
const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;
const GLSL3 = "300 es";
function EventDispatcher() {
}
Object.assign(EventDispatcher.prototype, {
  addEventListener: function(type, listener) {
    if (this._listeners === void 0)
      this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  },
  hasEventListener: function(type, listener) {
    if (this._listeners === void 0)
      return false;
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  },
  removeEventListener: function(type, listener) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  },
  dispatchEvent: function(event) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
      event.target = null;
    }
  }
});
const _lut = [];
for (let i = 0; i < 256; i++) {
  _lut[i] = (i < 16 ? "0" : "") + i.toString(16);
}
let _seed = 1234567;
const MathUtils = {
  DEG2RAD: Math.PI / 180,
  RAD2DEG: 180 / Math.PI,
  generateUUID: function() {
    const d0 = Math.random() * 4294967295 | 0;
    const d1 = Math.random() * 4294967295 | 0;
    const d2 = Math.random() * 4294967295 | 0;
    const d3 = Math.random() * 4294967295 | 0;
    const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
    return uuid.toUpperCase();
  },
  clamp: function(value, min, max) {
    return Math.max(min, Math.min(max, value));
  },
  euclideanModulo: function(n, m) {
    return (n % m + m) % m;
  },
  mapLinear: function(x, a1, a2, b1, b2) {
    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
  },
  inverseLerp: function(x, y, value) {
    if (x !== y) {
      return (value - x) / (y - x);
    } else {
      return 0;
    }
  },
  lerp: function(x, y, t) {
    return (1 - t) * x + t * y;
  },
  damp: function(x, y, lambda, dt) {
    return MathUtils.lerp(x, y, 1 - Math.exp(-lambda * dt));
  },
  pingpong: function(x, length = 1) {
    return length - Math.abs(MathUtils.euclideanModulo(x, length * 2) - length);
  },
  smoothstep: function(x, min, max) {
    if (x <= min)
      return 0;
    if (x >= max)
      return 1;
    x = (x - min) / (max - min);
    return x * x * (3 - 2 * x);
  },
  smootherstep: function(x, min, max) {
    if (x <= min)
      return 0;
    if (x >= max)
      return 1;
    x = (x - min) / (max - min);
    return x * x * x * (x * (x * 6 - 15) + 10);
  },
  randInt: function(low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
  },
  randFloat: function(low, high) {
    return low + Math.random() * (high - low);
  },
  randFloatSpread: function(range) {
    return range * (0.5 - Math.random());
  },
  seededRandom: function(s) {
    if (s !== void 0)
      _seed = s % 2147483647;
    _seed = _seed * 16807 % 2147483647;
    return (_seed - 1) / 2147483646;
  },
  degToRad: function(degrees) {
    return degrees * MathUtils.DEG2RAD;
  },
  radToDeg: function(radians) {
    return radians * MathUtils.RAD2DEG;
  },
  isPowerOfTwo: function(value) {
    return (value & value - 1) === 0 && value !== 0;
  },
  ceilPowerOfTwo: function(value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
  },
  floorPowerOfTwo: function(value) {
    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
  },
  setQuaternionFromProperEuler: function(q, a, b, c, order) {
    const cos = Math.cos;
    const sin = Math.sin;
    const c2 = cos(b / 2);
    const s2 = sin(b / 2);
    const c13 = cos((a + c) / 2);
    const s13 = sin((a + c) / 2);
    const c1_3 = cos((a - c) / 2);
    const s1_3 = sin((a - c) / 2);
    const c3_1 = cos((c - a) / 2);
    const s3_1 = sin((c - a) / 2);
    switch (order) {
      case "XYX":
        q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
        break;
      case "YZY":
        q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
        break;
      case "ZXZ":
        q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
        break;
      case "XZX":
        q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
        break;
      case "YXY":
        q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
        break;
      case "ZYZ":
        q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
        break;
      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
    }
  }
};
class Vector2 {
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  }
  add(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  }
  sub(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m) {
    const x = this.x, y = this.y;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6];
    this.y = e[1] * x + e[4] * y + e[7];
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y;
  }
  cross(v) {
    return this.x * v.y - this.y * v.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  }
  rotateAround(center, angle) {
    const c = Math.cos(angle), s = Math.sin(angle);
    const x = this.x - center.x;
    const y = this.y - center.y;
    this.x = x * c - y * s + center.x;
    this.y = x * s + y * c + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
}
Vector2.prototype.isVector2 = true;
class Matrix3 {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  }
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m) {
    const me = m.elements;
    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
    return this;
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[3], a13 = ae[6];
    const a21 = ae[1], a22 = ae[4], a23 = ae[7];
    const a31 = ae[2], a32 = ae[5], a33 = ae[8];
    const b11 = be[0], b12 = be[3], b13 = be[6];
    const b21 = be[1], b22 = be[4], b23 = be[7];
    const b31 = be[2], b32 = be[5], b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  }
  determinant() {
    const te = this.elements;
    const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp;
    const m = this.elements;
    tmp = m[1];
    m[1] = m[3];
    m[3] = tmp;
    tmp = m[2];
    m[2] = m[6];
    m[6] = tmp;
    tmp = m[5];
    m[5] = m[7];
    m[7] = tmp;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  transposeIntoArray(r) {
    const m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c = Math.cos(rotation);
    const s = Math.sin(rotation);
    this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
    return this;
  }
  scale(sx, sy) {
    const te = this.elements;
    te[0] *= sx;
    te[3] *= sx;
    te[6] *= sx;
    te[1] *= sy;
    te[4] *= sy;
    te[7] *= sy;
    return this;
  }
  rotate(theta) {
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    const te = this.elements;
    const a11 = te[0], a12 = te[3], a13 = te[6];
    const a21 = te[1], a22 = te[4], a23 = te[7];
    te[0] = c * a11 + s * a21;
    te[3] = c * a12 + s * a22;
    te[6] = c * a13 + s * a23;
    te[1] = -s * a11 + c * a21;
    te[4] = -s * a12 + c * a22;
    te[7] = -s * a13 + c * a23;
    return this;
  }
  translate(tx, ty) {
    const te = this.elements;
    te[0] += tx * te[2];
    te[3] += tx * te[5];
    te[6] += tx * te[8];
    te[1] += ty * te[2];
    te[4] += ty * te[5];
    te[7] += ty * te[8];
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 9; i++) {
      if (te[i] !== me[i])
        return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
Matrix3.prototype.isMatrix3 = true;
let _canvas;
const ImageUtils = {
  getDataURL: function(image) {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }
    if (typeof HTMLCanvasElement == "undefined") {
      return image.src;
    }
    let canvas;
    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === void 0)
        _canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      _canvas.width = image.width;
      _canvas.height = image.height;
      const context = _canvas.getContext("2d");
      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas = _canvas;
    }
    if (canvas.width > 2048 || canvas.height > 2048) {
      console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
      return canvas.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas.toDataURL("image/png");
    }
  }
};
let textureId = 0;
class Texture extends EventDispatcher {
  constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
    super();
    Object.defineProperty(this, "id", {value: textureId++});
    this.uuid = MathUtils.generateUUID();
    this.name = "";
    this.image = image;
    this.mipmaps = [];
    this.mapping = mapping;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.encoding = encoding;
    this.version = 0;
    this.onUpdate = null;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.image = source.image;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.encoding = source.encoding;
    return this;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (this.image !== void 0) {
      const image = this.image;
      if (image.uuid === void 0) {
        image.uuid = MathUtils.generateUUID();
      }
      if (!isRootObject && meta.images[image.uuid] === void 0) {
        let url;
        if (Array.isArray(image)) {
          url = [];
          for (let i = 0, l = image.length; i < l; i++) {
            if (image[i].isDataTexture) {
              url.push(serializeImage(image[i].image));
            } else {
              url.push(serializeImage(image[i]));
            }
          }
        } else {
          url = serializeImage(image);
        }
        meta.images[image.uuid] = {
          uuid: image.uuid,
          url
        };
      }
      output.image = image.uuid;
    }
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  }
  dispose() {
    this.dispatchEvent({type: "dispose"});
  }
  transformUv(uv) {
    if (this.mapping !== UVMapping)
      return uv;
    uv.applyMatrix3(this.matrix);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }
          break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
    return uv;
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
}
Texture.DEFAULT_IMAGE = void 0;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype.isTexture = true;
function serializeImage(image) {
  if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.prototype.slice.call(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
class Vector4 {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setW(w) {
    this.w = w;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== void 0 ? v.w : 1;
    return this;
  }
  add(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    this.w += v.w * s;
    return this;
  }
  sub(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    this.w *= v.w;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  applyMatrix4(m) {
    const x = this.x, y = this.y, z = this.z, w = this.w;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  setAxisAngleFromQuaternion(q) {
    this.w = 2 * Math.acos(q.w);
    const s = Math.sqrt(1 - q.w * q.w);
    if (s < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s;
      this.y = q.y / s;
      this.z = q.z / s;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m) {
    let angle, x, y, z;
    const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x = 0;
          y = 0.707106781;
          z = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y = xy / x;
          z = xz / x;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x = 0.707106781;
          y = 0;
          z = 0.707106781;
        } else {
          y = Math.sqrt(yy);
          x = xy / y;
          z = yz / y;
        }
      } else {
        if (zz < epsilon) {
          x = 0.707106781;
          y = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x = xz / z;
          y = yz / z;
        }
      }
      this.set(x, y, z, angle);
      return this;
    }
    let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s) < 1e-3)
      s = 1;
    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    this.w = Math.min(this.w, v.w);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    this.w = Math.max(this.w, v.w);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    this.w += (v.w - this.w) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    this.w = v1.w + (v2.w - v1.w) * alpha;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
}
Vector4.prototype.isVector4 = true;
class WebGLRenderTarget extends EventDispatcher {
  constructor(width, height, options) {
    super();
    this.width = width;
    this.height = height;
    this.depth = 1;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    options = options || {};
    this.texture = new Texture(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.image = {};
    this.texture.image.width = width;
    this.texture.image.height = height;
    this.texture.image.depth = 1;
    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
    this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : false;
    this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;
  }
  setTexture(texture) {
    texture.image = {
      width: this.width,
      height: this.height,
      depth: this.depth
    };
    this.texture = texture;
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.texture.image.width = width;
      this.texture.image.height = height;
      this.texture.image.depth = depth;
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    return this;
  }
  dispose() {
    this.dispatchEvent({type: "dispose"});
  }
}
WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
class Quaternion {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }
  static slerp(qa, qb, qm, t) {
    console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.");
    return qm.slerpQuaternions(qa, qb, t);
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (t === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }
    if (t === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s = 1 - t;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len) / sin;
        t = Math.sin(t * len) / sin;
      }
      const tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir;
      if (s === 1 - t) {
        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update) {
    if (!(euler && euler.isEuler)) {
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x / 2);
    const c2 = cos(y / 2);
    const c3 = cos(z / 2);
    const s1 = sin(x / 2);
    const s2 = sin(y / 2);
    const s3 = sin(z / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update !== false)
      this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2, s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m) {
    const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    let r = vFrom.dot(vTo) + 1;
    if (r < Number.EPSILON) {
      r = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r;
    }
    return this.normalize();
  }
  angleTo(q) {
    return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));
  }
  rotateTowards(q, step) {
    const angle = this.angleTo(q);
    if (angle === 0)
      return this;
    const t = Math.min(1, step / angle);
    this.slerp(q, t);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l = this.length();
    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q, p) {
    if (p !== void 0) {
      console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
      return this.multiplyQuaternions(q, p);
    }
    return this.multiplyQuaternions(this, q);
  }
  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }
  multiplyQuaternions(a, b) {
    const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(qb);
    const x = this._x, y = this._y, z = this._z, w = this._w;
    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s = 1 - t;
      this._w = s * w + t * this._w;
      this._x = s * x + t * this._x;
      this._y = s * y + t * this._y;
      this._z = s * z + t * this._z;
      this.normalize();
      this._onChangeCallback();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  slerpQuaternions(qa, qb, t) {
    this.copy(qa).slerp(qb, t);
  }
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    return this;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
}
Quaternion.prototype.isQuaternion = true;
class Vector3 {
  constructor(x = 0, y = 0, z = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  set(x, y, z) {
    if (z === void 0)
      z = this.z;
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }
  add(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  }
  sub(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  }
  multiply(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
      return this.multiplyVectors(v, w);
    }
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  }
  applyEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  }
  applyNormalMatrix(m) {
    return this.applyMatrix3(m).normalize();
  }
  applyMatrix4(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  }
  applyQuaternion(q) {
    const x = this.x, y = this.y, z = this.z;
    const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
    const ix = qw * x + qy * z - qz * y;
    const iy = qw * y + qz * x - qx * z;
    const iz = qw * z + qx * y - qy * x;
    const iw = -qx * x - qy * y - qz * z;
    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  }
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }
  transformDirection(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    return this.normalize();
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }
  cross(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
      return this.crossVectors(v, w);
    }
    return this.crossVectors(this, v);
  }
  crossVectors(a, b) {
    const ax = a.x, ay = a.y, az = a.z;
    const bx = b.x, by = b.y, bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  projectOnVector(v) {
    const denominator = v.lengthSq();
    if (denominator === 0)
      return this.set(0, 0, 0);
    const scalar = v.dot(this) / denominator;
    return this.copy(v).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector$c.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector$c);
  }
  reflect(normal) {
    return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0)
      return Math.PI / 2;
    const theta = this.dot(v) / denominator;
    return Math.acos(MathUtils.clamp(theta, -1, 1));
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  }
  setFromSpherical(s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  }
  setFromCylindricalCoords(radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  }
  setFromMatrixScale(m) {
    const sx = this.setFromMatrixColumn(m, 0).length();
    const sy = this.setFromMatrixColumn(m, 1).length();
    const sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m, index) {
    return this.fromArray(m.elements, index * 4);
  }
  setFromMatrix3Column(m, index) {
    return this.fromArray(m.elements, index * 3);
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
}
Vector3.prototype.isVector3 = true;
const _vector$c = /* @__PURE__ */ new Vector3();
const _quaternion$4 = /* @__PURE__ */ new Quaternion();
class Box3 {
  constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromArray(array) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i = 0, l = array.length; i < l; i += 3) {
      const x = array[i];
      const y = array[i + 1];
      const z = array[i + 2];
      if (x < minX)
        minX = x;
      if (y < minY)
        minY = y;
      if (z < minZ)
        minZ = z;
      if (x > maxX)
        maxX = x;
      if (y > maxY)
        maxY = y;
      if (z > maxZ)
        maxZ = z;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromBufferAttribute(attribute) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i = 0, l = attribute.count; i < l; i++) {
      const x = attribute.getX(i);
      const y = attribute.getY(i);
      const z = attribute.getZ(i);
      if (x < minX)
        minX = x;
      if (y < minY)
        minY = y;
      if (z < minZ)
        minZ = z;
      if (x > maxX)
        maxX = x;
      if (y > maxY)
        maxY = y;
      if (z > maxZ)
        maxZ = z;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  setFromObject(object) {
    this.makeEmpty();
    return this.expandByObject(object);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .getCenter() target is now required");
      target = new Vector3();
    }
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .getSize() target is now required");
      target = new Vector3();
    }
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  expandByObject(object) {
    object.updateWorldMatrix(false, false);
    const geometry = object.geometry;
    if (geometry !== void 0) {
      if (geometry.boundingBox === null) {
        geometry.computeBoundingBox();
      }
      _box$3.copy(geometry.boundingBox);
      _box$3.applyMatrix4(object.matrixWorld);
      this.union(_box$3);
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      this.expandByObject(children[i]);
    }
    return this;
  }
  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }
  getParameter(point, target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .getParameter() target is now required");
      target = new Vector3();
    }
    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$b);
    return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  intersectsPlane(plane) {
    let min, max;
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }
    return min <= -plane.constant && max >= -plane.constant;
  }
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0$2.subVectors(triangle.a, _center);
    _v1$7.subVectors(triangle.b, _center);
    _v2$3.subVectors(triangle.c, _center);
    _f0.subVectors(_v1$7, _v0$2);
    _f1.subVectors(_v2$3, _v1$7);
    _f2.subVectors(_v0$2, _v2$3);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
  }
  clampPoint(point, target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .clampPoint() target is now required");
      target = new Vector3();
    }
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);
    return clampedPoint.sub(point).length();
  }
  getBoundingSphere(target) {
    if (target === void 0) {
      console.error("THREE.Box3: .getBoundingSphere() target is now required");
    }
    this.getCenter(target.center);
    target.radius = this.getSize(_vector$b).length() * 0.5;
    return target;
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty())
      this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty())
      return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
}
Box3.prototype.isBox3 = true;
const _points = [
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3()
];
const _vector$b = /* @__PURE__ */ new Vector3();
const _box$3 = /* @__PURE__ */ new Box3();
const _v0$2 = /* @__PURE__ */ new Vector3();
const _v1$7 = /* @__PURE__ */ new Vector3();
const _v2$3 = /* @__PURE__ */ new Vector3();
const _f0 = /* @__PURE__ */ new Vector3();
const _f1 = /* @__PURE__ */ new Vector3();
const _f2 = /* @__PURE__ */ new Vector3();
const _center = /* @__PURE__ */ new Vector3();
const _extents = /* @__PURE__ */ new Vector3();
const _triangleNormal = /* @__PURE__ */ new Vector3();
const _testAxis = /* @__PURE__ */ new Vector3();
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
    _testAxis.fromArray(axes, i);
    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
      return false;
    }
  }
  return true;
}
const _box$2 = /* @__PURE__ */ new Box3();
const _v1$6 = /* @__PURE__ */ new Vector3();
const _toFarthestPoint = /* @__PURE__ */ new Vector3();
const _toPoint = /* @__PURE__ */ new Vector3();
class Sphere {
  constructor(center = new Vector3(), radius = -1) {
    this.center = center;
    this.radius = radius;
  }
  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }
  setFromPoints(points, optionalCenter) {
    const center = this.center;
    if (optionalCenter !== void 0) {
      center.copy(optionalCenter);
    } else {
      _box$2.setFromPoints(points).getCenter(center);
    }
    let maxRadiusSq = 0;
    for (let i = 0, il = points.length; i < il; i++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    if (target === void 0) {
      console.warn("THREE.Sphere: .clampPoint() target is now required");
      target = new Vector3();
    }
    target.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  }
  getBoundingBox(target) {
    if (target === void 0) {
      console.warn("THREE.Sphere: .getBoundingBox() target is now required");
      target = new Box3();
    }
    if (this.isEmpty()) {
      target.makeEmpty();
      return target;
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  translate(offset) {
    this.center.add(offset);
    return this;
  }
  expandByPoint(point) {
    _toPoint.subVectors(point, this.center);
    const lengthSq = _toPoint.lengthSq();
    if (lengthSq > this.radius * this.radius) {
      const length = Math.sqrt(lengthSq);
      const missingRadiusHalf = (length - this.radius) * 0.5;
      this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
      this.radius += missingRadiusHalf;
    }
    return this;
  }
  union(sphere) {
    _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);
    this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
    this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
    return this;
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$a = /* @__PURE__ */ new Vector3();
const _segCenter = /* @__PURE__ */ new Vector3();
const _segDir = /* @__PURE__ */ new Vector3();
const _diff = /* @__PURE__ */ new Vector3();
const _edge1 = /* @__PURE__ */ new Vector3();
const _edge2 = /* @__PURE__ */ new Vector3();
const _normal$1 = /* @__PURE__ */ new Vector3();
class Ray {
  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction;
  }
  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  at(t, target) {
    if (target === void 0) {
      console.warn("THREE.Ray: .at() target is now required");
      target = new Vector3();
    }
    return target.copy(this.direction).multiplyScalar(t).add(this.origin);
  }
  lookAt(v) {
    this.direction.copy(v).sub(this.origin).normalize();
    return this;
  }
  recast(t) {
    this.origin.copy(this.at(t, _vector$a));
    return this;
  }
  closestPointToPoint(point, target) {
    if (target === void 0) {
      console.warn("THREE.Ray: .closestPointToPoint() target is now required");
      target = new Vector3();
    }
    target.subVectors(point, this.origin);
    const directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  }
  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }
  distanceSqToPoint(point) {
    const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }
    _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    return _vector$a.distanceToSquared(point);
  }
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
    _segDir.copy(v1).sub(v0).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b0 = _diff.dot(this.direction);
    const b1 = -_diff.dot(_segDir);
    const c = _diff.lengthSq();
    const det = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;
    if (det > 0) {
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            const invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
    }
    return sqrDist;
  }
  intersectSphere(sphere, target) {
    _vector$a.subVectors(sphere.center, this.origin);
    const tca = _vector$a.dot(this.direction);
    const d2 = _vector$a.dot(_vector$a) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2)
      return null;
    const thc = Math.sqrt(radius2 - d2);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t0 < 0 && t1 < 0)
      return null;
    if (t0 < 0)
      return this.at(t1, target);
    return this.at(t0, target);
  }
  intersectsSphere(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t >= 0 ? t : null;
  }
  intersectPlane(plane, target) {
    const t = this.distanceToPlane(plane);
    if (t === null) {
      return null;
    }
    return this.at(t, target);
  }
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax)
      return null;
    if (tymin > tmin || tmin !== tmin)
      tmin = tymin;
    if (tymax < tmax || tmax !== tmax)
      tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax)
      return null;
    if (tzmin > tmin || tmin !== tmin)
      tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax)
      tmax = tzmax;
    if (tmax < 0)
      return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }
  intersectsBox(box) {
    return this.intersectBox(box, _vector$a) !== null;
  }
  intersectTriangle(a, b, c, backfaceCulling, target) {
    _edge1.subVectors(b, a);
    _edge2.subVectors(c, a);
    _normal$1.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal$1);
    let sign;
    if (DdN > 0) {
      if (backfaceCulling)
        return null;
      sign = 1;
    } else if (DdN < 0) {
      sign = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a);
    const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign * _diff.dot(_normal$1);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target);
  }
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }
  equals(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Matrix4 {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }
  copyPosition(m) {
    const te = this.elements, me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }
  setFromMatrix3(m) {
    const me = m.elements;
    this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  }
  extractRotation(m) {
    const te = this.elements;
    const me = m.elements;
    const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
    const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    }
    const te = this.elements;
    const x = euler.x, y = euler.y, z = euler.z;
    const a = Math.cos(x), b = Math.sin(x);
    const c = Math.cos(y), d = Math.sin(y);
    const e = Math.cos(z), f = Math.sin(z);
    if (euler.order === "XYZ") {
      const ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === "YXZ") {
      const ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === "ZXY") {
      const ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === "ZYX") {
      const ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === "YZX") {
      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === "XZY") {
      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q) {
    return this.compose(_zero, q, _one);
  }
  lookAt(eye, target, up) {
    const te = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }
  multiply(m, n) {
    if (n !== void 0) {
      console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
      return this.multiplyMatrices(m, n);
    }
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  }
  determinant() {
    const te = this.elements;
    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te = this.elements;
    let tmp;
    tmp = te[1];
    te[1] = te[4];
    te[4] = tmp;
    tmp = te[2];
    te[2] = te[8];
    te[8] = tmp;
    tmp = te[6];
    te[6] = te[9];
    te[9] = tmp;
    tmp = te[3];
    te[3] = te[12];
    te[12] = tmp;
    tmp = te[7];
    te[7] = te[13];
    te[13] = tmp;
    tmp = te[11];
    te[11] = te[14];
    te[14] = tmp;
    return this;
  }
  setPosition(x, y, z) {
    const te = this.elements;
    if (x.isVector3) {
      te[12] = x.x;
      te[13] = x.y;
      te[14] = x.z;
    } else {
      te[12] = x;
      te[13] = y;
      te[14] = z;
    }
    return this;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v) {
    const te = this.elements;
    const x = v.x, y = v.y, z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  }
  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x, y, z) {
    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
    return this;
  }
  makeRotationX(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationY(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationZ(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationAxis(axis, angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c;
    const x = axis.x, y = axis.y, z = axis.z;
    const tx = t * x, ty = t * y;
    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
    return this;
  }
  makeScale(x, y, z) {
    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
    return this;
  }
  makeShear(x, y, z) {
    this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
    return this;
  }
  compose(position, quaternion, scale) {
    const te = this.elements;
    const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
    const x2 = x + x, y2 = y + y, z2 = z + z;
    const xx = x * x2, xy = x * y2, xz = x * z2;
    const yy = y * y2, yz = y * z2, zz = z * z2;
    const wx = w * x2, wy = w * y2, wz = w * z2;
    const sx = scale.x, sy = scale.y, sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }
  decompose(position, quaternion, scale) {
    const te = this.elements;
    let sx = _v1$5.set(te[0], te[1], te[2]).length();
    const sy = _v1$5.set(te[4], te[5], te[6]).length();
    const sz = _v1$5.set(te[8], te[9], te[10]).length();
    const det = this.determinant();
    if (det < 0)
      sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14];
    _m1$2.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1$2.elements[0] *= invSX;
    _m1$2.elements[1] *= invSX;
    _m1$2.elements[2] *= invSX;
    _m1$2.elements[4] *= invSY;
    _m1$2.elements[5] *= invSY;
    _m1$2.elements[6] *= invSY;
    _m1$2.elements[8] *= invSZ;
    _m1$2.elements[9] *= invSZ;
    _m1$2.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1$2);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }
  makePerspective(left, right, top, bottom, near, far) {
    if (far === void 0) {
      console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    }
    const te = this.elements;
    const x = 2 * near / (right - left);
    const y = 2 * near / (top - bottom);
    const a = (right + left) / (right - left);
    const b = (top + bottom) / (top - bottom);
    const c = -(far + near) / (far - near);
    const d = -2 * far * near / (far - near);
    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far) {
    const te = this.elements;
    const w = 1 / (right - left);
    const h = 1 / (top - bottom);
    const p = 1 / (far - near);
    const x = (right + left) * w;
    const y = (top + bottom) * h;
    const z = (far + near) * p;
    te[0] = 2 * w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = -2 * p;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 16; i++) {
      if (te[i] !== me[i])
        return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }
}
Matrix4.prototype.isMatrix4 = true;
const _v1$5 = /* @__PURE__ */ new Vector3();
const _m1$2 = /* @__PURE__ */ new Matrix4();
const _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
const _one = /* @__PURE__ */ new Vector3(1, 1, 1);
const _x = /* @__PURE__ */ new Vector3();
const _y = /* @__PURE__ */ new Vector3();
const _z = /* @__PURE__ */ new Vector3();
const _matrix$1 = /* @__PURE__ */ new Matrix4();
const _quaternion$3 = /* @__PURE__ */ new Quaternion();
class Euler {
  constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x, y, z, order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order || this._order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m, order, update) {
    const clamp = MathUtils.clamp;
    const te = m.elements;
    const m11 = te[0], m12 = te[4], m13 = te[8];
    const m21 = te[1], m22 = te[5], m23 = te[9];
    const m31 = te[2], m32 = te[6], m33 = te[10];
    order = order || this._order;
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
    }
    this._order = order;
    if (update !== false)
      this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q, order, update) {
    _matrix$1.makeRotationFromQuaternion(q);
    return this.setFromRotationMatrix(_matrix$1, order, update);
  }
  setFromVector3(v, order) {
    return this.set(v.x, v.y, v.z, order || this._order);
  }
  reorder(newOrder) {
    _quaternion$3.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$3, newOrder);
  }
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0)
      this._order = array[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }
  toVector3(optionalResult) {
    if (optionalResult) {
      return optionalResult.set(this._x, this._y, this._z);
    } else {
      return new Vector3(this._x, this._y, this._z);
    }
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
}
Euler.prototype.isEuler = true;
Euler.DefaultOrder = "XYZ";
Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class Layers {
  constructor() {
    this.mask = 1 | 0;
  }
  set(channel) {
    this.mask = 1 << channel | 0;
  }
  enable(channel) {
    this.mask |= 1 << channel | 0;
  }
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }
  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
}
let _object3DId = 0;
const _v1$4 = new Vector3();
const _q1 = new Quaternion();
const _m1$1 = new Matrix4();
const _target = new Vector3();
const _position$3 = new Vector3();
const _scale$2 = new Vector3();
const _quaternion$2 = new Quaternion();
const _xAxis = new Vector3(1, 0, 0);
const _yAxis = new Vector3(0, 1, 0);
const _zAxis = new Vector3(0, 0, 1);
const _addedEvent = {type: "added"};
const _removedEvent = {type: "removed"};
function Object3D() {
  Object.defineProperty(this, "id", {value: _object3DId++});
  this.uuid = MathUtils.generateUUID();
  this.name = "";
  this.type = "Object3D";
  this.parent = null;
  this.children = [];
  this.up = Object3D.DefaultUp.clone();
  const position = new Vector3();
  const rotation = new Euler();
  const quaternion = new Quaternion();
  const scale = new Vector3(1, 1, 1);
  function onRotationChange() {
    quaternion.setFromEuler(rotation, false);
  }
  function onQuaternionChange() {
    rotation.setFromQuaternion(quaternion, void 0, false);
  }
  rotation._onChange(onRotationChange);
  quaternion._onChange(onQuaternionChange);
  Object.defineProperties(this, {
    position: {
      configurable: true,
      enumerable: true,
      value: position
    },
    rotation: {
      configurable: true,
      enumerable: true,
      value: rotation
    },
    quaternion: {
      configurable: true,
      enumerable: true,
      value: quaternion
    },
    scale: {
      configurable: true,
      enumerable: true,
      value: scale
    },
    modelViewMatrix: {
      value: new Matrix4()
    },
    normalMatrix: {
      value: new Matrix3()
    }
  });
  this.matrix = new Matrix4();
  this.matrixWorld = new Matrix4();
  this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
  this.matrixWorldNeedsUpdate = false;
  this.layers = new Layers();
  this.visible = true;
  this.castShadow = false;
  this.receiveShadow = false;
  this.frustumCulled = true;
  this.renderOrder = 0;
  this.animations = [];
  this.userData = {};
}
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Object3D,
  isObject3D: true,
  onBeforeRender: function() {
  },
  onAfterRender: function() {
  },
  applyMatrix4: function(matrix) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  applyQuaternion: function(q) {
    this.quaternion.premultiply(q);
    return this;
  },
  setRotationFromAxisAngle: function(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  },
  setRotationFromEuler: function(euler) {
    this.quaternion.setFromEuler(euler, true);
  },
  setRotationFromMatrix: function(m) {
    this.quaternion.setFromRotationMatrix(m);
  },
  setRotationFromQuaternion: function(q) {
    this.quaternion.copy(q);
  },
  rotateOnAxis: function(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  },
  rotateOnWorldAxis: function(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  },
  rotateX: function(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  },
  rotateY: function(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  },
  rotateZ: function(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  },
  translateOnAxis: function(axis, distance) {
    _v1$4.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$4.multiplyScalar(distance));
    return this;
  },
  translateX: function(distance) {
    return this.translateOnAxis(_xAxis, distance);
  },
  translateY: function(distance) {
    return this.translateOnAxis(_yAxis, distance);
  },
  translateZ: function(distance) {
    return this.translateOnAxis(_zAxis, distance);
  },
  localToWorld: function(vector) {
    return vector.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function(vector) {
    return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
  },
  lookAt: function(x, y, z) {
    if (x.isVector3) {
      _target.copy(x);
    } else {
      _target.set(x, y, z);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position$3.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$1.lookAt(_position$3, _target, this.up);
    } else {
      _m1$1.lookAt(_target, _position$3, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$1);
    if (parent) {
      _m1$1.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$1);
      this.quaternion.premultiply(_q1.invert());
    }
  },
  add: function(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }
      return this;
    }
    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  },
  remove: function(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }
      return this;
    }
    const index = this.children.indexOf(object);
    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
    }
    return this;
  },
  clear: function() {
    for (let i = 0; i < this.children.length; i++) {
      const object = this.children[i];
      object.parent = null;
      object.dispatchEvent(_removedEvent);
    }
    this.children.length = 0;
    return this;
  },
  attach: function(object) {
    this.updateWorldMatrix(true, false);
    _m1$1.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1$1.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1$1);
    this.add(object);
    object.updateWorldMatrix(false, true);
    return this;
  },
  getObjectById: function(id) {
    return this.getObjectByProperty("id", id);
  },
  getObjectByName: function(name) {
    return this.getObjectByProperty("name", name);
  },
  getObjectByProperty: function(name, value) {
    if (this[name] === value)
      return this;
    for (let i = 0, l = this.children.length; i < l; i++) {
      const child = this.children[i];
      const object = child.getObjectByProperty(name, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  },
  getWorldPosition: function(target) {
    if (target === void 0) {
      console.warn("THREE.Object3D: .getWorldPosition() target is now required");
      target = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  },
  getWorldQuaternion: function(target) {
    if (target === void 0) {
      console.warn("THREE.Object3D: .getWorldQuaternion() target is now required");
      target = new Quaternion();
    }
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, target, _scale$2);
    return target;
  },
  getWorldScale: function(target) {
    if (target === void 0) {
      console.warn("THREE.Object3D: .getWorldScale() target is now required");
      target = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, _quaternion$2, target);
    return target;
  },
  getWorldDirection: function(target) {
    if (target === void 0) {
      console.warn("THREE.Object3D: .getWorldDirection() target is now required");
      target = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  },
  raycast: function() {
  },
  traverse: function(callback) {
    callback(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverse(callback);
    }
  },
  traverseVisible: function(callback) {
    if (this.visible === false)
      return;
    callback(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverseVisible(callback);
    }
  },
  traverseAncestors: function(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  },
  updateMatrix: function() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  },
  updateMatrixWorld: function(force) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].updateMatrixWorld(force);
    }
  },
  updateWorldMatrix: function(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    }
    if (updateChildren === true) {
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        children[i].updateWorldMatrix(false, true);
      }
    }
  },
  toJSON: function(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {}
      };
      output.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "")
      object.name = this.name;
    if (this.castShadow === true)
      object.castShadow = true;
    if (this.receiveShadow === true)
      object.receiveShadow = true;
    if (this.visible === false)
      object.visible = false;
    if (this.frustumCulled === false)
      object.frustumCulled = false;
    if (this.renderOrder !== 0)
      object.renderOrder = this.renderOrder;
    if (JSON.stringify(this.userData) !== "{}")
      object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    if (this.matrixAutoUpdate === false)
      object.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object.type = "InstancedMesh";
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null)
        object.instanceColor = this.instanceColor.toJSON();
    }
    function serialize(library, element) {
      if (library[element.uuid] === void 0) {
        library[element.uuid] = element.toJSON(meta);
      }
      return element.uuid;
    }
    if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i = 0, l = shapes.length; i < l; i++) {
            const shape = shapes[i];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i = 0, l = this.material.length; i < l; i++) {
          uuids.push(serialize(meta.materials, this.material[i]));
        }
        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (let i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object.animations = [];
      for (let i = 0; i < this.animations.length; i++) {
        const animation = this.animations[i];
        object.animations.push(serialize(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      if (geometries.length > 0)
        output.geometries = geometries;
      if (materials.length > 0)
        output.materials = materials;
      if (textures.length > 0)
        output.textures = textures;
      if (images.length > 0)
        output.images = images;
      if (shapes.length > 0)
        output.shapes = shapes;
      if (skeletons.length > 0)
        output.skeletons = skeletons;
      if (animations.length > 0)
        output.animations = animations;
    }
    output.object = object;
    return output;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  },
  clone: function(recursive) {
    return new this.constructor().copy(this, recursive);
  },
  copy: function(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i = 0; i < source.children.length; i++) {
        const child = source.children[i];
        this.add(child.clone());
      }
    }
    return this;
  }
});
const _vector1 = /* @__PURE__ */ new Vector3();
const _vector2$1 = /* @__PURE__ */ new Vector3();
const _normalMatrix = /* @__PURE__ */ new Matrix3();
class Plane {
  constructor(normal = new Vector3(1, 0, 0), constant = 0) {
    this.normal = normal;
    this.constant = constant;
  }
  set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  }
  setComponents(x, y, z, w) {
    this.normal.set(x, y, z);
    this.constant = w;
    return this;
  }
  setFromNormalAndCoplanarPoint(normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  }
  setFromCoplanarPoints(a, b, c) {
    const normal = _vector1.subVectors(c, b).cross(_vector2$1.subVectors(a, b)).normalize();
    this.setFromNormalAndCoplanarPoint(normal, a);
    return this;
  }
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  projectPoint(point, target) {
    if (target === void 0) {
      console.warn("THREE.Plane: .projectPoint() target is now required");
      target = new Vector3();
    }
    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
  }
  intersectLine(line, target) {
    if (target === void 0) {
      console.warn("THREE.Plane: .intersectLine() target is now required");
      target = new Vector3();
    }
    const direction = line.delta(_vector1);
    const denominator = this.normal.dot(direction);
    if (denominator === 0) {
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      }
      return null;
    }
    const t = -(line.start.dot(this.normal) + this.constant) / denominator;
    if (t < 0 || t > 1) {
      return null;
    }
    return target.copy(direction).multiplyScalar(t).add(line.start);
  }
  intersectsLine(line) {
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  coplanarPoint(target) {
    if (target === void 0) {
      console.warn("THREE.Plane: .coplanarPoint() target is now required");
      target = new Vector3();
    }
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }
  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
Plane.prototype.isPlane = true;
const _v0$1 = /* @__PURE__ */ new Vector3();
const _v1$3 = /* @__PURE__ */ new Vector3();
const _v2$2 = /* @__PURE__ */ new Vector3();
const _v3$1 = /* @__PURE__ */ new Vector3();
const _vab = /* @__PURE__ */ new Vector3();
const _vac = /* @__PURE__ */ new Vector3();
const _vbc = /* @__PURE__ */ new Vector3();
const _vap = /* @__PURE__ */ new Vector3();
const _vbp = /* @__PURE__ */ new Vector3();
const _vcp = /* @__PURE__ */ new Vector3();
class Triangle {
  constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  static getNormal(a, b, c, target) {
    if (target === void 0) {
      console.warn("THREE.Triangle: .getNormal() target is now required");
      target = new Vector3();
    }
    target.subVectors(c, b);
    _v0$1.subVectors(a, b);
    target.cross(_v0$1);
    const targetLengthSq = target.lengthSq();
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target.set(0, 0, 0);
  }
  static getBarycoord(point, a, b, c, target) {
    _v0$1.subVectors(c, a);
    _v1$3.subVectors(b, a);
    _v2$2.subVectors(point, a);
    const dot00 = _v0$1.dot(_v0$1);
    const dot01 = _v0$1.dot(_v1$3);
    const dot02 = _v0$1.dot(_v2$2);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$2);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (target === void 0) {
      console.warn("THREE.Triangle: .getBarycoord() target is now required");
      target = new Vector3();
    }
    if (denom === 0) {
      return target.set(-2, -1, -1);
    }
    const invDenom = 1 / denom;
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target.set(1 - u - v, v, u);
  }
  static containsPoint(point, a, b, c) {
    this.getBarycoord(point, a, b, c, _v3$1);
    return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
  }
  static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
    this.getBarycoord(point, p1, p2, p3, _v3$1);
    target.set(0, 0);
    target.addScaledVector(uv1, _v3$1.x);
    target.addScaledVector(uv2, _v3$1.y);
    target.addScaledVector(uv3, _v3$1.z);
    return target;
  }
  static isFrontFacing(a, b, c, direction) {
    _v0$1.subVectors(c, b);
    _v1$3.subVectors(a, b);
    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
  }
  set(a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  }
  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }
  getArea() {
    _v0$1.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$1.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(target) {
    if (target === void 0) {
      console.warn("THREE.Triangle: .getMidpoint() target is now required");
      target = new Vector3();
    }
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }
  getPlane(target) {
    if (target === void 0) {
      console.warn("THREE.Triangle: .getPlane() target is now required");
      target = new Plane();
    }
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }
  getUV(point, uv1, uv2, uv3, target) {
    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
  }
  containsPoint(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  }
  isFrontFacing(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  closestPointToPoint(p, target) {
    if (target === void 0) {
      console.warn("THREE.Triangle: .closestPointToPoint() target is now required");
      target = new Vector3();
    }
    const a = this.a, b = this.b, c = this.c;
    let v, w;
    _vab.subVectors(b, a);
    _vac.subVectors(c, a);
    _vap.subVectors(p, a);
    const d1 = _vab.dot(_vap);
    const d2 = _vac.dot(_vap);
    if (d1 <= 0 && d2 <= 0) {
      return target.copy(a);
    }
    _vbp.subVectors(p, b);
    const d3 = _vab.dot(_vbp);
    const d4 = _vac.dot(_vbp);
    if (d3 >= 0 && d4 <= d3) {
      return target.copy(b);
    }
    const vc = d1 * d4 - d3 * d2;
    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v = d1 / (d1 - d3);
      return target.copy(a).addScaledVector(_vab, v);
    }
    _vcp.subVectors(p, c);
    const d5 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d5 <= d6) {
      return target.copy(c);
    }
    const vb = d5 * d2 - d1 * d6;
    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w = d2 / (d2 - d6);
      return target.copy(a).addScaledVector(_vac, w);
    }
    const va = d3 * d6 - d5 * d4;
    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c, b);
      w = (d4 - d3) / (d4 - d3 + (d5 - d6));
      return target.copy(b).addScaledVector(_vbc, w);
    }
    const denom = 1 / (va + vb + vc);
    v = vb * denom;
    w = vc * denom;
    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
  }
  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
}
let materialId = 0;
function Material() {
  Object.defineProperty(this, "id", {value: materialId++});
  this.uuid = MathUtils.generateUUID();
  this.name = "";
  this.type = "Material";
  this.fog = true;
  this.blending = NormalBlending;
  this.side = FrontSide;
  this.vertexColors = false;
  this.opacity = 1;
  this.transparent = false;
  this.blendSrc = SrcAlphaFactor;
  this.blendDst = OneMinusSrcAlphaFactor;
  this.blendEquation = AddEquation;
  this.blendSrcAlpha = null;
  this.blendDstAlpha = null;
  this.blendEquationAlpha = null;
  this.depthFunc = LessEqualDepth;
  this.depthTest = true;
  this.depthWrite = true;
  this.stencilWriteMask = 255;
  this.stencilFunc = AlwaysStencilFunc;
  this.stencilRef = 0;
  this.stencilFuncMask = 255;
  this.stencilFail = KeepStencilOp;
  this.stencilZFail = KeepStencilOp;
  this.stencilZPass = KeepStencilOp;
  this.stencilWrite = false;
  this.clippingPlanes = null;
  this.clipIntersection = false;
  this.clipShadows = false;
  this.shadowSide = null;
  this.colorWrite = true;
  this.precision = null;
  this.polygonOffset = false;
  this.polygonOffsetFactor = 0;
  this.polygonOffsetUnits = 0;
  this.dithering = false;
  this.alphaTest = 0;
  this.alphaToCoverage = false;
  this.premultipliedAlpha = false;
  this.visible = true;
  this.toneMapped = true;
  this.userData = {};
  this.version = 0;
}
Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Material,
  isMaterial: true,
  onBeforeCompile: function() {
  },
  customProgramCacheKey: function() {
    return this.onBeforeCompile.toString();
  },
  setValues: function(values) {
    if (values === void 0)
      return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        console.warn("THREE.Material: '" + key + "' parameter is undefined.");
        continue;
      }
      if (key === "shading") {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        this.flatShading = newValue === FlatShading ? true : false;
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  },
  toJSON: function(meta) {
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {}
      };
    }
    const data = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (this.color && this.color.isColor)
      data.color = this.color.getHex();
    if (this.roughness !== void 0)
      data.roughness = this.roughness;
    if (this.metalness !== void 0)
      data.metalness = this.metalness;
    if (this.sheen && this.sheen.isColor)
      data.sheen = this.sheen.getHex();
    if (this.emissive && this.emissive.isColor)
      data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity && this.emissiveIntensity !== 1)
      data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor)
      data.specular = this.specular.getHex();
    if (this.shininess !== void 0)
      data.shininess = this.shininess;
    if (this.clearcoat !== void 0)
      data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== void 0)
      data.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.map && this.map.isTexture)
      data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture)
      data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture)
      data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta).uuid;
      data.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture)
      data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture)
      data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture)
      data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture)
      data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      data.reflectivity = this.reflectivity;
      data.refractionRatio = this.refractionRatio;
      if (this.combine !== void 0)
        data.combine = this.combine;
      if (this.envMapIntensity !== void 0)
        data.envMapIntensity = this.envMapIntensity;
    }
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.size !== void 0)
      data.size = this.size;
    if (this.shadowSide !== null)
      data.shadowSide = this.shadowSide;
    if (this.sizeAttenuation !== void 0)
      data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending)
      data.blending = this.blending;
    if (this.side !== FrontSide)
      data.side = this.side;
    if (this.vertexColors)
      data.vertexColors = true;
    if (this.opacity < 1)
      data.opacity = this.opacity;
    if (this.transparent === true)
      data.transparent = this.transparent;
    data.depthFunc = this.depthFunc;
    data.depthTest = this.depthTest;
    data.depthWrite = this.depthWrite;
    data.colorWrite = this.colorWrite;
    data.stencilWrite = this.stencilWrite;
    data.stencilWriteMask = this.stencilWriteMask;
    data.stencilFunc = this.stencilFunc;
    data.stencilRef = this.stencilRef;
    data.stencilFuncMask = this.stencilFuncMask;
    data.stencilFail = this.stencilFail;
    data.stencilZFail = this.stencilZFail;
    data.stencilZPass = this.stencilZPass;
    if (this.rotation && this.rotation !== 0)
      data.rotation = this.rotation;
    if (this.polygonOffset === true)
      data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0)
      data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0)
      data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth && this.linewidth !== 1)
      data.linewidth = this.linewidth;
    if (this.dashSize !== void 0)
      data.dashSize = this.dashSize;
    if (this.gapSize !== void 0)
      data.gapSize = this.gapSize;
    if (this.scale !== void 0)
      data.scale = this.scale;
    if (this.dithering === true)
      data.dithering = true;
    if (this.alphaTest > 0)
      data.alphaTest = this.alphaTest;
    if (this.alphaToCoverage === true)
      data.alphaToCoverage = this.alphaToCoverage;
    if (this.premultipliedAlpha === true)
      data.premultipliedAlpha = this.premultipliedAlpha;
    if (this.wireframe === true)
      data.wireframe = this.wireframe;
    if (this.wireframeLinewidth > 1)
      data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round")
      data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round")
      data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.morphTargets === true)
      data.morphTargets = true;
    if (this.morphNormals === true)
      data.morphNormals = true;
    if (this.skinning === true)
      data.skinning = true;
    if (this.flatShading === true)
      data.flatShading = this.flatShading;
    if (this.visible === false)
      data.visible = false;
    if (this.toneMapped === false)
      data.toneMapped = false;
    if (JSON.stringify(this.userData) !== "{}")
      data.userData = this.userData;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
    }
    return data;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(source) {
    this.name = source.name;
    this.fog = source.fog;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n = srcPlanes.length;
      dstPlanes = new Array(n);
      for (let i = 0; i !== n; ++i) {
        dstPlanes[i] = srcPlanes[i].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.alphaToCoverage = source.alphaToCoverage;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  },
  dispose: function() {
    this.dispatchEvent({type: "dispose"});
  }
});
Object.defineProperty(Material.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
const _colorKeywords = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
const _hslA = {h: 0, s: 0, l: 0};
const _hslB = {h: 0, s: 0, l: 0};
function hue2rgb(p, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p + (q - p) * 6 * (2 / 3 - t);
  return p;
}
function SRGBToLinear(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c) {
  return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
class Color {
  constructor(r, g, b) {
    if (g === void 0 && b === void 0) {
      return this.set(r);
    }
    return this.setRGB(r, g, b);
  }
  set(value) {
    if (value && value.isColor) {
      this.copy(value);
    } else if (typeof value === "number") {
      this.setHex(value);
    } else if (typeof value === "string") {
      this.setStyle(value);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    return this;
  }
  setRGB(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
    return this;
  }
  setHSL(h, s, l) {
    h = MathUtils.euclideanModulo(h, 1);
    s = MathUtils.clamp(s, 0, 1);
    l = MathUtils.clamp(l, 0, 1);
    if (s === 0) {
      this.r = this.g = this.b = l;
    } else {
      const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
      const q = 2 * l - p;
      this.r = hue2rgb(q, p, h + 1 / 3);
      this.g = hue2rgb(q, p, h);
      this.b = hue2rgb(q, p, h - 1 / 3);
    }
    return this;
  }
  setStyle(style) {
    function handleAlpha(string) {
      if (string === void 0)
        return;
      if (parseFloat(string) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    let m;
    if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
      let color;
      const name = m[1];
      const components = m[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
            handleAlpha(color[4]);
            return this;
          }
          if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
            handleAlpha(color[4]);
            return this;
          }
          break;
        case "hsl":
        case "hsla":
          if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            const h = parseFloat(color[1]) / 360;
            const s = parseInt(color[2], 10) / 100;
            const l = parseInt(color[3], 10) / 100;
            handleAlpha(color[4]);
            return this.setHSL(h, s, l);
          }
          break;
      }
    } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      const hex = m[1];
      const size = hex.length;
      if (size === 3) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
        return this;
      } else if (size === 6) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
        return this;
      }
    }
    if (style && style.length > 0) {
      return this.setColorName(style);
    }
    return this;
  }
  setColorName(style) {
    const hex = _colorKeywords[style];
    if (hex !== void 0) {
      this.setHex(hex);
    } else {
      console.warn("THREE.Color: Unknown color " + style);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  }
  copyGammaToLinear(color, gammaFactor = 2) {
    this.r = Math.pow(color.r, gammaFactor);
    this.g = Math.pow(color.g, gammaFactor);
    this.b = Math.pow(color.b, gammaFactor);
    return this;
  }
  copyLinearToGamma(color, gammaFactor = 2) {
    const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
    this.r = Math.pow(color.r, safeInverse);
    this.g = Math.pow(color.g, safeInverse);
    this.b = Math.pow(color.b, safeInverse);
    return this;
  }
  convertGammaToLinear(gammaFactor) {
    this.copyGammaToLinear(this, gammaFactor);
    return this;
  }
  convertLinearToGamma(gammaFactor) {
    this.copyLinearToGamma(this, gammaFactor);
    return this;
  }
  copySRGBToLinear(color) {
    this.r = SRGBToLinear(color.r);
    this.g = SRGBToLinear(color.g);
    this.b = SRGBToLinear(color.b);
    return this;
  }
  copyLinearToSRGB(color) {
    this.r = LinearToSRGB(color.r);
    this.g = LinearToSRGB(color.g);
    this.b = LinearToSRGB(color.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex() {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  }
  getHexString() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }
  getHSL(target) {
    if (target === void 0) {
      console.warn("THREE.Color: .getHSL() target is now required");
      target = {h: 0, s: 0, l: 0};
    }
    const r = this.r, g = this.g, b = this.b;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let hue, saturation;
    const lightness = (min + max) / 2;
    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
      switch (max) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;
        case g:
          hue = (b - r) / delta + 2;
          break;
        case b:
          hue = (r - g) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }
  getStyle() {
    return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
  }
  offsetHSL(h, s, l) {
    this.getHSL(_hslA);
    _hslA.h += h;
    _hslA.s += s;
    _hslA.l += l;
    this.setHSL(_hslA.h, _hslA.s, _hslA.l);
    return this;
  }
  add(color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  addScalar(s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  }
  sub(color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  }
  multiply(color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  }
  multiplyScalar(s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  }
  lerp(color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  }
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  lerpHSL(color, alpha) {
    this.getHSL(_hslA);
    color.getHSL(_hslB);
    const h = MathUtils.lerp(_hslA.h, _hslB.h, alpha);
    const s = MathUtils.lerp(_hslA.s, _hslB.s, alpha);
    const l = MathUtils.lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h, s, l);
    return this;
  }
  equals(c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  }
  fromArray(array, offset = 0) {
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.r = attribute.getX(index);
    this.g = attribute.getY(index);
    this.b = attribute.getZ(index);
    if (attribute.normalized === true) {
      this.r /= 255;
      this.g /= 255;
      this.b /= 255;
    }
    return this;
  }
  toJSON() {
    return this.getHex();
  }
}
Color.NAMES = _colorKeywords;
Color.prototype.isColor = true;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;
class MeshBasicMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    return this;
  }
}
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
const _vector$9 = new Vector3();
const _vector2 = new Vector2();
function BufferAttribute(array, itemSize, normalized) {
  if (Array.isArray(array)) {
    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
  }
  this.name = "";
  this.array = array;
  this.itemSize = itemSize;
  this.count = array !== void 0 ? array.length / itemSize : 0;
  this.normalized = normalized === true;
  this.usage = StaticDrawUsage;
  this.updateRange = {offset: 0, count: -1};
  this.version = 0;
}
Object.defineProperty(BufferAttribute.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
Object.assign(BufferAttribute.prototype, {
  isBufferAttribute: true,
  onUploadCallback: function() {
  },
  setUsage: function(value) {
    this.usage = value;
    return this;
  },
  copy: function(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    return this;
  },
  copyAt: function(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (let i = 0, l = this.itemSize; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  },
  copyArray: function(array) {
    this.array.set(array);
    return this;
  },
  copyColorsArray: function(colors) {
    const array = this.array;
    let offset = 0;
    for (let i = 0, l = colors.length; i < l; i++) {
      let color = colors[i];
      if (color === void 0) {
        console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i);
        color = new Color();
      }
      array[offset++] = color.r;
      array[offset++] = color.g;
      array[offset++] = color.b;
    }
    return this;
  },
  copyVector2sArray: function(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i);
        vector = new Vector2();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
    }
    return this;
  },
  copyVector3sArray: function(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i);
        vector = new Vector3();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
    }
    return this;
  },
  copyVector4sArray: function(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i);
        vector = new Vector4();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
      array[offset++] = vector.w;
    }
    return this;
  },
  applyMatrix3: function(m) {
    if (this.itemSize === 2) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector2.fromBufferAttribute(this, i);
        _vector2.applyMatrix3(m);
        this.setXY(i, _vector2.x, _vector2.y);
      }
    } else if (this.itemSize === 3) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$9.fromBufferAttribute(this, i);
        _vector$9.applyMatrix3(m);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
    }
    return this;
  },
  applyMatrix4: function(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$9.x = this.getX(i);
      _vector$9.y = this.getY(i);
      _vector$9.z = this.getZ(i);
      _vector$9.applyMatrix4(m);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  },
  applyNormalMatrix: function(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$9.x = this.getX(i);
      _vector$9.y = this.getY(i);
      _vector$9.z = this.getZ(i);
      _vector$9.applyNormalMatrix(m);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  },
  transformDirection: function(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$9.x = this.getX(i);
      _vector$9.y = this.getY(i);
      _vector$9.z = this.getZ(i);
      _vector$9.transformDirection(m);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  },
  set: function(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  },
  getX: function(index) {
    return this.array[index * this.itemSize];
  },
  setX: function(index, x) {
    this.array[index * this.itemSize] = x;
    return this;
  },
  getY: function(index) {
    return this.array[index * this.itemSize + 1];
  },
  setY: function(index, y) {
    this.array[index * this.itemSize + 1] = y;
    return this;
  },
  getZ: function(index) {
    return this.array[index * this.itemSize + 2];
  },
  setZ: function(index, z) {
    this.array[index * this.itemSize + 2] = z;
    return this;
  },
  getW: function(index) {
    return this.array[index * this.itemSize + 3];
  },
  setW: function(index, w) {
    this.array[index * this.itemSize + 3] = w;
    return this;
  },
  setXY: function(index, x, y) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    return this;
  },
  setXYZ: function(index, x, y, z) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    return this;
  },
  setXYZW: function(index, x, y, z, w) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    this.array[index + 3] = w;
    return this;
  },
  onUpload: function(callback) {
    this.onUploadCallback = callback;
    return this;
  },
  clone: function() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  },
  toJSON: function() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    };
    if (this.name !== "")
      data.name = this.name;
    if (this.usage !== StaticDrawUsage)
      data.usage = this.usage;
    if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
      data.updateRange = this.updateRange;
    return data;
  }
});
function Int8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
}
Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
function Uint8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
}
Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
}
Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
function Int16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
}
Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
function Uint16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}
Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
function Int32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
}
Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
function Uint32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
}
Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
function Float16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}
Float16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float16BufferAttribute.prototype.constructor = Float16BufferAttribute;
Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
function Float32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
}
Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
function Float64BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
}
Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
function arrayMax(array) {
  if (array.length === 0)
    return -Infinity;
  let max = array[0];
  for (let i = 1, l = array.length; i < l; ++i) {
    if (array[i] > max)
      max = array[i];
  }
  return max;
}
let _id = 0;
const _m1 = new Matrix4();
const _obj = new Object3D();
const _offset = new Vector3();
const _box$1 = new Box3();
const _boxMorphTargets = new Box3();
const _vector$8 = new Vector3();
function BufferGeometry() {
  Object.defineProperty(this, "id", {value: _id++});
  this.uuid = MathUtils.generateUUID();
  this.name = "";
  this.type = "BufferGeometry";
  this.index = null;
  this.attributes = {};
  this.morphAttributes = {};
  this.morphTargetsRelative = false;
  this.groups = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.drawRange = {start: 0, count: Infinity};
  this.userData = {};
}
BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: BufferGeometry,
  isBufferGeometry: true,
  getIndex: function() {
    return this.index;
  },
  setIndex: function(index) {
    if (Array.isArray(index)) {
      this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }
    return this;
  },
  getAttribute: function(name) {
    return this.attributes[name];
  },
  setAttribute: function(name, attribute) {
    this.attributes[name] = attribute;
    return this;
  },
  deleteAttribute: function(name) {
    delete this.attributes[name];
    return this;
  },
  hasAttribute: function(name) {
    return this.attributes[name] !== void 0;
  },
  addGroup: function(start, count, materialIndex = 0) {
    this.groups.push({
      start,
      count,
      materialIndex
    });
  },
  clearGroups: function() {
    this.groups = [];
  },
  setDrawRange: function(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  },
  applyMatrix4: function(matrix) {
    const position = this.attributes.position;
    if (position !== void 0) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }
    const normal = this.attributes.normal;
    if (normal !== void 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  },
  rotateX: function(angle) {
    _m1.makeRotationX(angle);
    this.applyMatrix4(_m1);
    return this;
  },
  rotateY: function(angle) {
    _m1.makeRotationY(angle);
    this.applyMatrix4(_m1);
    return this;
  },
  rotateZ: function(angle) {
    _m1.makeRotationZ(angle);
    this.applyMatrix4(_m1);
    return this;
  },
  translate: function(x, y, z) {
    _m1.makeTranslation(x, y, z);
    this.applyMatrix4(_m1);
    return this;
  },
  scale: function(x, y, z) {
    _m1.makeScale(x, y, z);
    this.applyMatrix4(_m1);
    return this;
  },
  lookAt: function(vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  },
  center: function() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  },
  setFromPoints: function(points) {
    const position = [];
    for (let i = 0, l = points.length; i < l; i++) {
      const point = points[i];
      position.push(point.x, point.y, point.z || 0);
    }
    this.setAttribute("position", new Float32BufferAttribute(position, 3));
    return this;
  },
  computeBoundingBox: function() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(Infinity, Infinity, Infinity));
      return;
    }
    if (position !== void 0) {
      this.boundingBox.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          _box$1.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(this.boundingBox.min, _box$1.min);
            this.boundingBox.expandByPoint(_vector$8);
            _vector$8.addVectors(this.boundingBox.max, _box$1.max);
            this.boundingBox.expandByPoint(_vector$8);
          } else {
            this.boundingBox.expandByPoint(_box$1.min);
            this.boundingBox.expandByPoint(_box$1.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  },
  computeBoundingSphere: function() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingSphere.set(new Vector3(), Infinity);
      return;
    }
    if (position) {
      const center = this.boundingSphere.center;
      _box$1.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);
            _box$1.expandByPoint(_vector$8);
            _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);
            _box$1.expandByPoint(_vector$8);
          } else {
            _box$1.expandByPoint(_boxMorphTargets.min);
            _box$1.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$1.getCenter(center);
      let maxRadiusSq = 0;
      for (let i = 0, il = position.count; i < il; i++) {
        _vector$8.fromBufferAttribute(position, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
      }
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
            _vector$8.fromBufferAttribute(morphAttribute, j);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j);
              _vector$8.add(_offset);
            }
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  },
  computeFaceNormals: function() {
  },
  computeTangents: function() {
    const index = this.index;
    const attributes = this.attributes;
    if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const indices = index.array;
    const positions = attributes.position.array;
    const normals = attributes.normal.array;
    const uvs = attributes.uv.array;
    const nVertices = positions.length / 3;
    if (attributes.tangent === void 0) {
      this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
    }
    const tangents = attributes.tangent.array;
    const tan1 = [], tan2 = [];
    for (let i = 0; i < nVertices; i++) {
      tan1[i] = new Vector3();
      tan2[i] = new Vector3();
    }
    const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
    function handleTriangle(a, b, c) {
      vA.fromArray(positions, a * 3);
      vB.fromArray(positions, b * 3);
      vC.fromArray(positions, c * 3);
      uvA.fromArray(uvs, a * 2);
      uvB.fromArray(uvs, b * 2);
      uvC.fromArray(uvs, c * 2);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r))
        return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
      tan1[a].add(sdir);
      tan1[b].add(sdir);
      tan1[c].add(sdir);
      tan2[a].add(tdir);
      tan2[b].add(tdir);
      tan2[c].add(tdir);
    }
    let groups = this.groups;
    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: indices.length
      }];
    }
    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
      }
    }
    const tmp = new Vector3(), tmp2 = new Vector3();
    const n = new Vector3(), n2 = new Vector3();
    function handleVertex(v) {
      n.fromArray(normals, v * 3);
      n2.copy(n);
      const t = tan1[v];
      tmp.copy(t);
      tmp.sub(n.multiplyScalar(n.dot(t))).normalize();
      tmp2.crossVectors(n2, t);
      const test = tmp2.dot(tan2[v]);
      const w = test < 0 ? -1 : 1;
      tangents[v * 4] = tmp.x;
      tangents[v * 4 + 1] = tmp.y;
      tangents[v * 4 + 2] = tmp.z;
      tangents[v * 4 + 3] = w;
    }
    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleVertex(indices[j + 0]);
        handleVertex(indices[j + 1]);
        handleVertex(indices[j + 2]);
      }
    }
  },
  computeVertexNormals: function() {
    const index = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i = 0, il = normalAttribute.count; i < il; i++) {
          normalAttribute.setXYZ(i, 0, 0, 0);
        }
      }
      const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
      const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
      const cb = new Vector3(), ab = new Vector3();
      if (index) {
        for (let i = 0, il = index.count; i < il; i += 3) {
          const vA = index.getX(i + 0);
          const vB = index.getX(i + 1);
          const vC = index.getX(i + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
          pA.fromBufferAttribute(positionAttribute, i + 0);
          pB.fromBufferAttribute(positionAttribute, i + 1);
          pC.fromBufferAttribute(positionAttribute, i + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  },
  merge: function(geometry, offset) {
    if (!(geometry && geometry.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
      return;
    }
    if (offset === void 0) {
      offset = 0;
      console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      if (geometry.attributes[key] === void 0)
        continue;
      const attribute1 = attributes[key];
      const attributeArray1 = attribute1.array;
      const attribute2 = geometry.attributes[key];
      const attributeArray2 = attribute2.array;
      const attributeOffset = attribute2.itemSize * offset;
      const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
      for (let i = 0, j = attributeOffset; i < length; i++, j++) {
        attributeArray1[j] = attributeArray2[i];
      }
    }
    return this;
  },
  normalizeNormals: function() {
    const normals = this.attributes.normal;
    for (let i = 0, il = normals.count; i < il; i++) {
      _vector$8.fromBufferAttribute(normals, i);
      _vector$8.normalize();
      normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
    }
  },
  toNonIndexed: function() {
    function convertBufferAttribute(attribute, indices2) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices2.length * itemSize);
      let index = 0, index2 = 0;
      for (let i = 0, l = indices2.length; i < l; i++) {
        index = indices2[i] * itemSize;
        for (let j = 0; j < itemSize; j++) {
          array2[index2++] = array[index++];
        }
      }
      return new BufferAttribute(array2, itemSize, normalized);
    }
    if (this.index === null) {
      console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
      return this;
    }
    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name];
      for (let i = 0, il = morphAttribute.length; i < il; i++) {
        const attribute = morphAttribute[i];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups = this.groups;
    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  },
  toJSON: function() {
    const data = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (Object.keys(this.userData).length > 0)
      data.userData = this.userData;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== void 0)
          data[key] = parameters[key];
      }
      return data;
    }
    data.data = {attributes: {}};
    const index = this.index;
    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      data.data.attributes[key] = attribute.toJSON(data.data);
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];
      for (let i = 0, il = attributeArray.length; i < il; i++) {
        const attribute = attributeArray[i];
        array.push(attribute.toJSON(data.data));
      }
      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups = this.groups;
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data;
  },
  clone: function() {
    return new BufferGeometry().copy(this);
  },
  copy: function(source) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data = {};
    this.name = source.name;
    const index = source.index;
    if (index !== null) {
      this.setIndex(index.clone(data));
    }
    const attributes = source.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data));
    }
    const morphAttributes = source.morphAttributes;
    for (const name in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name];
      for (let i = 0, l = morphAttribute.length; i < l; i++) {
        array.push(morphAttribute[i].clone(data));
      }
      this.morphAttributes[name] = array;
    }
    this.morphTargetsRelative = source.morphTargetsRelative;
    const groups = source.groups;
    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    const boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    return this;
  },
  dispose: function() {
    this.dispatchEvent({type: "dispose"});
  }
});
const _inverseMatrix$2 = new Matrix4();
const _ray$2 = new Ray();
const _sphere$3 = new Sphere();
const _vA$1 = new Vector3();
const _vB$1 = new Vector3();
const _vC$1 = new Vector3();
const _tempA = new Vector3();
const _tempB = new Vector3();
const _tempC = new Vector3();
const _morphA = new Vector3();
const _morphB = new Vector3();
const _morphC = new Vector3();
const _uvA$1 = new Vector2();
const _uvB$1 = new Vector2();
const _uvC$1 = new Vector2();
const _intersectionPoint = new Vector3();
const _intersectionPointWorld = new Vector3();
function Mesh(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
  Object3D.call(this);
  this.type = "Mesh";
  this.geometry = geometry;
  this.material = material;
  this.updateMorphTargets();
}
Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Mesh,
  isMesh: true,
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  updateMorphTargets: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  },
  raycast: function(raycaster, intersects) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0)
      return;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$3.copy(geometry.boundingSphere);
    _sphere$3.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere$3) === false)
      return;
    _inverseMatrix$2.copy(matrixWorld).invert();
    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
    if (geometry.boundingBox !== null) {
      if (_ray$2.intersectsBox(geometry.boundingBox) === false)
        return;
    }
    let intersection;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const position = geometry.attributes.position;
      const morphPosition = geometry.morphAttributes.position;
      const morphTargetsRelative = geometry.morphTargetsRelative;
      const uv = geometry.attributes.uv;
      const uv2 = geometry.attributes.uv2;
      const groups = geometry.groups;
      const drawRange = geometry.drawRange;
      if (index !== null) {
        if (Array.isArray(material)) {
          for (let i = 0, il = groups.length; i < il; i++) {
            const group = groups[i];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
            for (let j = start, jl = end; j < jl; j += 3) {
              const a = index.getX(j);
              const b = index.getX(j + 1);
              const c = index.getX(j + 2);
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(index.count, drawRange.start + drawRange.count);
          for (let i = start, il = end; i < il; i += 3) {
            const a = index.getX(i);
            const b = index.getX(i + 1);
            const c = index.getX(i + 2);
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3);
              intersects.push(intersection);
            }
          }
        }
      } else if (position !== void 0) {
        if (Array.isArray(material)) {
          for (let i = 0, il = groups.length; i < il; i++) {
            const group = groups[i];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
            for (let j = start, jl = end; j < jl; j += 3) {
              const a = j;
              const b = j + 1;
              const c = j + 2;
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(position.count, drawRange.start + drawRange.count);
          for (let i = start, il = end; i < il; i += 3) {
            const a = i;
            const b = i + 1;
            const c = i + 2;
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3);
              intersects.push(intersection);
            }
          }
        }
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
});
function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
  let intersect;
  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
  }
  if (intersect === null)
    return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far)
    return null;
  return {
    distance,
    point: _intersectionPointWorld.clone(),
    object
  };
}
function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
  _vA$1.fromBufferAttribute(position, a);
  _vB$1.fromBufferAttribute(position, b);
  _vC$1.fromBufferAttribute(position, c);
  const morphInfluences = object.morphTargetInfluences;
  if (material.morphTargets && morphPosition && morphInfluences) {
    _morphA.set(0, 0, 0);
    _morphB.set(0, 0, 0);
    _morphC.set(0, 0, 0);
    for (let i = 0, il = morphPosition.length; i < il; i++) {
      const influence = morphInfluences[i];
      const morphAttribute = morphPosition[i];
      if (influence === 0)
        continue;
      _tempA.fromBufferAttribute(morphAttribute, a);
      _tempB.fromBufferAttribute(morphAttribute, b);
      _tempC.fromBufferAttribute(morphAttribute, c);
      if (morphTargetsRelative) {
        _morphA.addScaledVector(_tempA, influence);
        _morphB.addScaledVector(_tempB, influence);
        _morphC.addScaledVector(_tempC, influence);
      } else {
        _morphA.addScaledVector(_tempA.sub(_vA$1), influence);
        _morphB.addScaledVector(_tempB.sub(_vB$1), influence);
        _morphC.addScaledVector(_tempC.sub(_vC$1), influence);
      }
    }
    _vA$1.add(_morphA);
    _vB$1.add(_morphB);
    _vC$1.add(_morphC);
  }
  if (object.isSkinnedMesh && material.skinning) {
    object.boneTransform(a, _vA$1);
    object.boneTransform(b, _vB$1);
    object.boneTransform(c, _vC$1);
  }
  const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (intersection) {
    if (uv) {
      _uvA$1.fromBufferAttribute(uv, a);
      _uvB$1.fromBufferAttribute(uv, b);
      _uvC$1.fromBufferAttribute(uv, c);
      intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    if (uv2) {
      _uvA$1.fromBufferAttribute(uv2, a);
      _uvB$1.fromBufferAttribute(uv2, b);
      _uvC$1.fromBufferAttribute(uv2, c);
      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    const face = {
      a,
      b,
      c,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
    intersection.face = face;
  }
  return intersection;
}
class BoxGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      depthSegments
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
    buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
    buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
    buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
    buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
    buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(u, v, w, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
      const segmentWidth = width2 / gridX;
      const segmentHeight = height2 / gridY;
      const widthHalf = width2 / 2;
      const heightHalf = height2 / 2;
      const depthHalf = depth2 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3();
      for (let iy = 0; iy < gridY1; iy++) {
        const y = iy * segmentHeight - heightHalf;
        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segmentWidth - widthHalf;
          vector[u] = x * udir;
          vector[v] = y * vdir;
          vector[w] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u] = 0;
          vector[v] = 0;
          vector[w] = depth2 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = numberOfVertices + ix + gridX1 * iy;
          const b = numberOfVertices + ix + gridX1 * (iy + 1);
          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices.push(a, b, d);
          indices.push(b, c, d);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
}
function cloneUniforms(src) {
  const dst = {};
  for (const u in src) {
    dst[u] = {};
    for (const p in src[u]) {
      const property = src[u][p];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        dst[u][p] = property.clone();
      } else if (Array.isArray(property)) {
        dst[u][p] = property.slice();
      } else {
        dst[u][p] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u = 0; u < uniforms.length; u++) {
    const tmp = cloneUniforms(uniforms[u]);
    for (const p in tmp) {
      merged[p] = tmp[p];
    }
  }
  return merged;
}
const UniformsUtils = {clone: cloneUniforms, merge: mergeUniforms};
var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
function ShaderMaterial(parameters) {
  Material.call(this);
  this.type = "ShaderMaterial";
  this.defines = {};
  this.uniforms = {};
  this.vertexShader = default_vertex;
  this.fragmentShader = default_fragment;
  this.linewidth = 1;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.lights = false;
  this.clipping = false;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.extensions = {
    derivatives: false,
    fragDepth: false,
    drawBuffers: false,
    shaderTextureLOD: false
  };
  this.defaultAttributeValues = {
    color: [1, 1, 1],
    uv: [0, 0],
    uv2: [0, 0]
  };
  this.index0AttributeName = void 0;
  this.uniformsNeedUpdate = false;
  this.glslVersion = null;
  if (parameters !== void 0) {
    if (parameters.attributes !== void 0) {
      console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
    }
    this.setValues(parameters);
  }
}
ShaderMaterial.prototype = Object.create(Material.prototype);
ShaderMaterial.prototype.constructor = ShaderMaterial;
ShaderMaterial.prototype.isShaderMaterial = true;
ShaderMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.fragmentShader = source.fragmentShader;
  this.vertexShader = source.vertexShader;
  this.uniforms = cloneUniforms(source.uniforms);
  this.defines = Object.assign({}, source.defines);
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.lights = source.lights;
  this.clipping = source.clipping;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  this.extensions = Object.assign({}, source.extensions);
  this.glslVersion = source.glslVersion;
  return this;
};
ShaderMaterial.prototype.toJSON = function(meta) {
  const data = Material.prototype.toJSON.call(this, meta);
  data.glslVersion = this.glslVersion;
  data.uniforms = {};
  for (const name in this.uniforms) {
    const uniform = this.uniforms[name];
    const value = uniform.value;
    if (value && value.isTexture) {
      data.uniforms[name] = {
        type: "t",
        value: value.toJSON(meta).uuid
      };
    } else if (value && value.isColor) {
      data.uniforms[name] = {
        type: "c",
        value: value.getHex()
      };
    } else if (value && value.isVector2) {
      data.uniforms[name] = {
        type: "v2",
        value: value.toArray()
      };
    } else if (value && value.isVector3) {
      data.uniforms[name] = {
        type: "v3",
        value: value.toArray()
      };
    } else if (value && value.isVector4) {
      data.uniforms[name] = {
        type: "v4",
        value: value.toArray()
      };
    } else if (value && value.isMatrix3) {
      data.uniforms[name] = {
        type: "m3",
        value: value.toArray()
      };
    } else if (value && value.isMatrix4) {
      data.uniforms[name] = {
        type: "m4",
        value: value.toArray()
      };
    } else {
      data.uniforms[name] = {
        value
      };
    }
  }
  if (Object.keys(this.defines).length > 0)
    data.defines = this.defines;
  data.vertexShader = this.vertexShader;
  data.fragmentShader = this.fragmentShader;
  const extensions = {};
  for (const key in this.extensions) {
    if (this.extensions[key] === true)
      extensions[key] = true;
  }
  if (Object.keys(extensions).length > 0)
    data.extensions = extensions;
  return data;
};
function Camera() {
  Object3D.call(this);
  this.type = "Camera";
  this.matrixWorldInverse = new Matrix4();
  this.projectionMatrix = new Matrix4();
  this.projectionMatrixInverse = new Matrix4();
}
Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Camera,
  isCamera: true,
  copy: function(source, recursive) {
    Object3D.prototype.copy.call(this, source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    return this;
  },
  getWorldDirection: function(target) {
    if (target === void 0) {
      console.warn("THREE.Camera: .getWorldDirection() target is now required");
      target = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(-e[8], -e[9], -e[10]).normalize();
  },
  updateMatrixWorld: function(force) {
    Object3D.prototype.updateMatrixWorld.call(this, force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  },
  updateWorldMatrix: function(updateParents, updateChildren) {
    Object3D.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  },
  clone: function() {
    return new this.constructor().copy(this);
  }
});
function PerspectiveCamera(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
  Camera.call(this);
  this.type = "PerspectiveCamera";
  this.fov = fov2;
  this.zoom = 1;
  this.near = near;
  this.far = far;
  this.focus = 10;
  this.aspect = aspect2;
  this.view = null;
  this.filmGauge = 35;
  this.filmOffset = 0;
  this.updateProjectionMatrix();
}
PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
  constructor: PerspectiveCamera,
  isPerspectiveCamera: true,
  copy: function(source, recursive) {
    Camera.prototype.copy.call(this, source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  },
  setFocalLength: function(focalLength) {
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  },
  getFocalLength: function() {
    const vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  },
  getEffectiveFOV: function() {
    return MathUtils.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);
  },
  getFilmWidth: function() {
    return this.filmGauge * Math.min(this.aspect, 1);
  },
  getFilmHeight: function() {
    return this.filmGauge / Math.max(this.aspect, 1);
  },
  setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  },
  clearViewOffset: function() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function() {
    const near = this.near;
    let top = near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0)
      left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  },
  toJSON: function(meta) {
    const data = Object3D.prototype.toJSON.call(this, meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
});
const fov = 90, aspect = 1;
class CubeCamera extends Object3D {
  constructor(near, far, renderTarget) {
    super();
    this.type = "CubeCamera";
    if (renderTarget.isWebGLCubeRenderTarget !== true) {
      console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
      return;
    }
    this.renderTarget = renderTarget;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector3(1, 0, 0));
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector3(-1, 0, 0));
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector3(0, 1, 0));
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector3(0, -1, 0));
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector3(0, 0, 1));
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector3(0, 0, -1));
    this.add(cameraNZ);
  }
  update(renderer, scene) {
    if (this.parent === null)
      this.updateMatrixWorld();
    const renderTarget = this.renderTarget;
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
    const currentXrEnabled = renderer.xr.enabled;
    const currentRenderTarget = renderer.getRenderTarget();
    renderer.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.xr.enabled = currentXrEnabled;
  }
}
class CubeTexture extends Texture {
  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    images = images !== void 0 ? images : [];
    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
    format = format !== void 0 ? format : RGBFormat;
    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this._needsFlipEnvMap = true;
    this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
}
CubeTexture.prototype.isCubeTexture = true;
class WebGLCubeRenderTarget extends WebGLRenderTarget {
  constructor(size, options, dummy) {
    if (Number.isInteger(options)) {
      console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )");
      options = dummy;
    }
    super(size, size, options);
    options = options || {};
    this.texture = new CubeTexture(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
    this.texture._needsFlipEnvMap = false;
  }
  fromEquirectangularTexture(renderer, texture) {
    this.texture.type = texture.type;
    this.texture.format = RGBAFormat;
    this.texture.encoding = texture.encoding;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
      uniforms: {
        tEquirect: {value: null}
      },
      vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
      fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
    };
    const geometry = new BoxGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh(geometry, material);
    const currentMinFilter = texture.minFilter;
    if (texture.minFilter === LinearMipmapLinearFilter)
      texture.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
  clear(renderer, color, depth, stencil) {
    const currentRenderTarget = renderer.getRenderTarget();
    for (let i = 0; i < 6; i++) {
      renderer.setRenderTarget(this, i);
      renderer.clear(color, depth, stencil);
    }
    renderer.setRenderTarget(currentRenderTarget);
  }
}
WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
class DataTexture extends Texture {
  constructor(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {data: data || null, width: width || 1, height: height || 1};
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }
}
DataTexture.prototype.isDataTexture = true;
const _sphere$2 = /* @__PURE__ */ new Sphere();
const _vector$7 = /* @__PURE__ */ new Vector3();
class Frustum {
  constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
    this.planes = [p0, p1, p2, p3, p4, p5];
  }
  set(p0, p1, p2, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  }
  copy(frustum) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      planes[i].copy(frustum.planes[i]);
    }
    return this;
  }
  setFromProjectionMatrix(m) {
    const planes = this.planes;
    const me = m.elements;
    const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
    const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
    const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
    const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  }
  intersectsObject(object) {
    const geometry = object.geometry;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
    return this.intersectsSphere(_sphere$2);
  }
  intersectsSprite(sprite) {
    _sphere$2.center.set(0, 0, 0);
    _sphere$2.radius = 0.7071067811865476;
    _sphere$2.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(_sphere$2);
  }
  intersectsSphere(sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;
    for (let i = 0; i < 6; i++) {
      const distance = planes[i].distanceToPoint(center);
      if (distance < negRadius) {
        return false;
      }
    }
    return true;
  }
  intersectsBox(box) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      const plane = planes[i];
      _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
      if (plane.distanceToPoint(_vector$7) < 0) {
        return false;
      }
    }
    return true;
  }
  containsPoint(point) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      if (planes[i].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating === true)
        return;
      if (animationLoop === null)
        return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context = value;
    }
  };
}
function WebGLAttributes(gl, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  const buffers = new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type = 5126;
    if (array instanceof Float32Array) {
      type = 5126;
    } else if (array instanceof Float64Array) {
      console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        if (isWebGL2) {
          type = 5131;
        } else {
          console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
        }
      } else {
        type = 5123;
      }
    } else if (array instanceof Int16Array) {
      type = 5122;
    } else if (array instanceof Uint32Array) {
      type = 5125;
    } else if (array instanceof Int32Array) {
      type = 5124;
    } else if (array instanceof Int8Array) {
      type = 5120;
    } else if (array instanceof Uint8Array) {
      type = 5121;
    }
    return {
      buffer,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }
  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer);
    if (updateRange.count === -1) {
      gl.bufferSubData(bufferType, 0, array);
    } else {
      if (isWebGL2) {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
      } else {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
      }
      updateRange.count = -1;
    }
  }
  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  function update(attribute, bufferType) {
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get,
    remove,
    update
  };
}
class PlaneGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = "PlaneGeometry";
    this.parameters = {
      width,
      height,
      widthSegments,
      heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy < gridY1; iy++) {
      const y = iy * segment_height - height_half;
      for (let ix = 0; ix < gridX1; ix++) {
        const x = ix * segment_width - width_half;
        vertices.push(x, -y, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a = ix + gridX1 * iy;
        const b = ix + gridX1 * (iy + 1);
        const c = ix + 1 + gridX1 * (iy + 1);
        const d = ix + 1 + gridX1 * iy;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
}
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n#else\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n	return Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	return specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n	float invAlpha = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifndef ENVMAP_TYPE_CUBE_UV\n		envColor = envMapTexelToLinear( envColor );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n	fogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n	varying float fogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif";
var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float sigma = PI * roughness * roughness / ( 1.0 + roughness );\n		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n		#else\n			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheen;\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float specularRoughness;\n	vec3 specularColor;\n#ifdef CLEARCOAT\n	float clearcoat;\n	float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	vec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifdef CLEARCOAT\n		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = ccDotNL * directLight.color;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			ccIrradiance *= PI;\n		#endif\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n			material.specularRoughness,\n			directLight.direction,\n			geometry,\n			material.sheenColor\n		);\n	#else\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n	#endif\n	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef CLEARCOAT\n		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n		float ccDotNL = ccDotNV;\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	float clearcoatInv = 1.0 - clearcoatDHR;\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n	#ifdef CLEARCOAT\n		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n	#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifndef USE_MORPHNORMALS\n		uniform float morphTargetInfluences[ 8 ];\n	#else\n		uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n		transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n		transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n		transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n		transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n	#endif\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmissionmap_fragment = "#ifdef USE_TRANSMISSIONMAP\n	totalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif";
var transmissionmap_pars_fragment = "#ifdef USE_TRANSMISSIONMAP\n	uniform sampler2D transmissionMap;\n#endif";
var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
var uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
var uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
var depth_frag = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n	\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#ifndef FLAT_SHADED\n		vNormal = normalize( transformedNormal );\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n	#define REFLECTIVITY\n	#define CLEARCOAT\n	#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n	uniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n	uniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#ifdef TRANSMISSION\n		float totalTransmission = transmission;\n	#endif\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <transmissionmap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#ifdef TRANSMISSION\n		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n	#endif\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
const ShaderChunk = {
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  encodings_fragment,
  encodings_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_fragment,
  lightmap_pars_fragment,
  lights_lambert_vertex,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmissionmap_fragment,
  transmissionmap_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  uv2_pars_fragment,
  uv2_pars_vertex,
  uv2_vertex,
  worldpos_vertex,
  background_frag,
  background_vert,
  cube_frag,
  cube_vert,
  depth_frag,
  depth_vert,
  distanceRGBA_frag,
  distanceRGBA_vert,
  equirect_frag,
  equirect_vert,
  linedashed_frag,
  linedashed_vert,
  meshbasic_frag,
  meshbasic_vert,
  meshlambert_frag,
  meshlambert_vert,
  meshmatcap_frag,
  meshmatcap_vert,
  meshtoon_frag,
  meshtoon_vert,
  meshphong_frag,
  meshphong_vert,
  meshphysical_frag,
  meshphysical_vert,
  normal_frag,
  normal_vert,
  points_frag,
  points_vert,
  shadow_frag,
  shadow_vert,
  sprite_frag,
  sprite_vert
};
const UniformsLib = {
  common: {
    diffuse: {value: new Color(15658734)},
    opacity: {value: 1},
    map: {value: null},
    uvTransform: {value: new Matrix3()},
    uv2Transform: {value: new Matrix3()},
    alphaMap: {value: null}
  },
  specularmap: {
    specularMap: {value: null}
  },
  envmap: {
    envMap: {value: null},
    flipEnvMap: {value: -1},
    reflectivity: {value: 1},
    refractionRatio: {value: 0.98},
    maxMipLevel: {value: 0}
  },
  aomap: {
    aoMap: {value: null},
    aoMapIntensity: {value: 1}
  },
  lightmap: {
    lightMap: {value: null},
    lightMapIntensity: {value: 1}
  },
  emissivemap: {
    emissiveMap: {value: null}
  },
  bumpmap: {
    bumpMap: {value: null},
    bumpScale: {value: 1}
  },
  normalmap: {
    normalMap: {value: null},
    normalScale: {value: new Vector2(1, 1)}
  },
  displacementmap: {
    displacementMap: {value: null},
    displacementScale: {value: 1},
    displacementBias: {value: 0}
  },
  roughnessmap: {
    roughnessMap: {value: null}
  },
  metalnessmap: {
    metalnessMap: {value: null}
  },
  gradientmap: {
    gradientMap: {value: null}
  },
  fog: {
    fogDensity: {value: 25e-5},
    fogNear: {value: 1},
    fogFar: {value: 2e3},
    fogColor: {value: new Color(16777215)}
  },
  lights: {
    ambientLightColor: {value: []},
    lightProbe: {value: []},
    directionalLights: {value: [], properties: {
      direction: {},
      color: {}
    }},
    directionalLightShadows: {value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    }},
    directionalShadowMap: {value: []},
    directionalShadowMatrix: {value: []},
    spotLights: {value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    }},
    spotLightShadows: {value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    }},
    spotShadowMap: {value: []},
    spotShadowMatrix: {value: []},
    pointLights: {value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    }},
    pointLightShadows: {value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    }},
    pointShadowMap: {value: []},
    pointShadowMatrix: {value: []},
    hemisphereLights: {value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    }},
    rectAreaLights: {value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    }},
    ltc_1: {value: null},
    ltc_2: {value: null}
  },
  points: {
    diffuse: {value: new Color(15658734)},
    opacity: {value: 1},
    size: {value: 1},
    scale: {value: 1},
    map: {value: null},
    alphaMap: {value: null},
    uvTransform: {value: new Matrix3()}
  },
  sprite: {
    diffuse: {value: new Color(15658734)},
    opacity: {value: 1},
    center: {value: new Vector2(0.5, 0.5)},
    rotation: {value: 0},
    map: {value: null},
    alphaMap: {value: null},
    uvTransform: {value: new Matrix3()}
  }
};
const ShaderLib = {
  basic: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color(0)}
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color(0)},
        specular: {value: new Color(1118481)},
        shininess: {value: 30}
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color(0)},
        roughness: {value: 1},
        metalness: {value: 0},
        envMapIntensity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color(0)}
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: {value: null}
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: {value: 1},
        dashSize: {value: 1},
        totalSize: {value: 2}
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk.normal_vert,
    fragmentShader: ShaderChunk.normal_frag
  },
  sprite: {
    uniforms: mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: {value: new Matrix3()},
      t2D: {value: null}
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  cube: {
    uniforms: mergeUniforms([
      UniformsLib.envmap,
      {
        opacity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: {value: null}
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: {value: new Vector3()},
        nearDistance: {value: 1},
        farDistance: {value: 1e3}
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: {value: new Color(0)},
        opacity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: {value: 0},
      clearcoatMap: {value: null},
      clearcoatRoughness: {value: 0},
      clearcoatRoughnessMap: {value: null},
      clearcoatNormalScale: {value: new Vector2(1, 1)},
      clearcoatNormalMap: {value: null},
      sheen: {value: new Color(0)},
      transmission: {value: 0},
      transmissionMap: {value: null}
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
function WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {
  const clearColor = new Color(0);
  let clearAlpha = 0;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function render(renderList, scene, camera, forceClear) {
    let background = scene.isScene === true ? scene.background : null;
    if (background && background.isTexture) {
      background = cubemaps.get(background);
    }
    const xr = renderer.xr;
    const session = xr.getSession && xr.getSession();
    if (session && session.environmentBlendMode === "additive") {
      background = null;
    }
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
          name: "BackgroundCubeMaterial",
          uniforms: cloneUniforms(ShaderLib.cube.uniforms),
          vertexShader: ShaderLib.cube.vertexShader,
          fragmentShader: ShaderLib.cube.fragmentShader,
          side: BackSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function(renderer2, scene2, camera2) {
          this.matrixWorld.copyPosition(camera2.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background._needsFlipEnvMap ? -1 : 1;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
          name: "BackgroundMaterial",
          uniforms: cloneUniforms(ShaderLib.background.uniforms),
          vertexShader: ShaderLib.background.vertexShader,
          fragmentShader: ShaderLib.background.fragmentShader,
          side: FrontSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color, alpha) {
    state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color, alpha = 1) {
      clearColor.set(color);
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha) {
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    render
  };
}
function WebGLBindingStates(gl, extensions, attributes, capabilities) {
  const maxVertexAttributes = gl.getParameter(34921);
  const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
  const vaoAvailable = capabilities.isWebGL2 || extension !== null;
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  function setup(object, material, program, geometry, index) {
    let updateBuffers = false;
    if (vaoAvailable) {
      const state = getBindingState(geometry, program, material);
      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }
      updateBuffers = needsUpdate(geometry, index);
      if (updateBuffers)
        saveCache(geometry, index);
    } else {
      const wireframe = material.wireframe === true;
      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
        currentState.geometry = geometry.id;
        currentState.program = program.id;
        currentState.wireframe = wireframe;
        updateBuffers = true;
      }
    }
    if (object.isInstancedMesh === true) {
      updateBuffers = true;
    }
    if (index !== null) {
      attributes.update(index, 34963);
    }
    if (updateBuffers) {
      setupVertexAttributes(object, material, program, geometry);
      if (index !== null) {
        gl.bindBuffer(34963, attributes.get(index).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    if (capabilities.isWebGL2)
      return gl.createVertexArray();
    return extension.createVertexArrayOES();
  }
  function bindVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.bindVertexArray(vao);
    return extension.bindVertexArrayOES(vao);
  }
  function deleteVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.deleteVertexArray(vao);
    return extension.deleteVertexArrayOES(vao);
  }
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === void 0) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === void 0) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i = 0; i < maxVertexAttributes; i++) {
      newAttributes[i] = 0;
      enabledAttributes[i] = 0;
      attributeDivisors[i] = 0;
    }
    return {
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  function needsUpdate(geometry, index) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;
    for (const key in geometryAttributes) {
      const cachedAttribute = cachedAttributes[key];
      const geometryAttribute = geometryAttributes[key];
      if (cachedAttribute === void 0)
        return true;
      if (cachedAttribute.attribute !== geometryAttribute)
        return true;
      if (cachedAttribute.data !== geometryAttribute.data)
        return true;
      attributesNum++;
    }
    if (currentState.attributesNum !== attributesNum)
      return true;
    if (currentState.index !== index)
      return true;
    return false;
  }
  function saveCache(geometry, index) {
    const cache = {};
    const attributes2 = geometry.attributes;
    let attributesNum = 0;
    for (const key in attributes2) {
      const attribute = attributes2[key];
      const data = {};
      data.attribute = attribute;
      if (attribute.data) {
        data.data = attribute.data;
      }
      cache[key] = data;
      attributesNum++;
    }
    currentState.attributes = cache;
    currentState.attributesNum = attributesNum;
    currentState.index = index;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i = 0, il = newAttributes.length; i < il; i++) {
      newAttributes[i] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      const extension2 = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
      extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i = 0, il = enabledAttributes.length; i < il; i++) {
      if (enabledAttributes[i] !== newAttributes[i]) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }
  }
  function vertexAttribPointer(index, size, type, normalized, stride, offset) {
    if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
      gl.vertexAttribIPointer(index, size, type, stride, offset);
    } else {
      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
  }
  function setupVertexAttributes(object, material, program, geometry) {
    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
      if (extensions.get("ANGLE_instanced_arrays") === null)
        return;
    }
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute >= 0) {
        const geometryAttribute = geometryAttributes[name];
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset = geometryAttribute.offset;
            if (data && data.isInstancedInterleavedBuffer) {
              enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
              if (geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              enableAttribute(programAttribute);
            }
            gl.bindBuffer(34962, buffer);
            vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
              if (geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              enableAttribute(programAttribute);
            }
            gl.bindBuffer(34962, buffer);
            vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
          }
        } else if (name === "instanceMatrix") {
          const attribute = attributes.get(object.instanceMatrix);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          enableAttributeAndDivisor(programAttribute + 0, 1);
          enableAttributeAndDivisor(programAttribute + 1, 1);
          enableAttributeAndDivisor(programAttribute + 2, 1);
          enableAttributeAndDivisor(programAttribute + 3, 1);
          gl.bindBuffer(34962, buffer);
          gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);
          gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);
          gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);
          gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
        } else if (name === "instanceColor") {
          const attribute = attributes.get(object.instanceColor);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          enableAttributeAndDivisor(programAttribute, 1);
          gl.bindBuffer(34962, buffer);
          gl.vertexAttribPointer(programAttribute, 3, type, false, 12, 0);
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute, value);
                break;
              case 3:
                gl.vertexAttrib3fv(programAttribute, value);
                break;
              case 4:
                gl.vertexAttrib4fv(programAttribute, value);
                break;
              default:
                gl.vertexAttrib1fv(programAttribute, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose() {
    reset();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === void 0)
      return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === void 0)
        continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset() {
    resetDefaultState();
    if (currentState === defaultState)
      return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup,
    reset,
    resetDefaultState,
    dispose,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes
  };
}
function WebGLBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  function render(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawArraysInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawArraysInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, start, count, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLCapabilities(gl, extensions, parameters) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0)
      return maxAnisotropy;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
  let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const maxTextures = gl.getParameter(34930);
  const maxVertexTextures = gl.getParameter(35660);
  const maxTextureSize = gl.getParameter(3379);
  const maxCubemapSize = gl.getParameter(34076);
  const maxAttributes = gl.getParameter(34921);
  const maxVertexUniforms = gl.getParameter(36347);
  const maxVaryings = gl.getParameter(36348);
  const maxFragmentUniforms = gl.getParameter(36349);
  const vertexTextures = maxVertexTextures > 0;
  const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
  const floatVertexTextures = vertexTextures && floatFragmentTextures;
  const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
  return {
    isWebGL2,
    getMaxAnisotropy,
    getMaxPrecision,
    precision,
    logarithmicDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    floatFragmentTextures,
    floatVertexTextures,
    maxSamples
  };
}
function WebGLClipping(properties) {
  const scope = this;
  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
  const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = {value: null, needsUpdate: false};
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping, camera) {
    const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
    resetGlobalState();
  };
  this.setState = function(material, camera, useCache) {
    const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, useCache);
      for (let i = 0; i !== lGlobal; ++i) {
        dstArray[i] = globalState[i];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLCubeMaps(renderer) {
  let cubemaps = new WeakMap();
  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }
    return texture;
  }
  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;
      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image = texture.image;
          if (image && image.height > 0) {
            const currentRenderTarget = renderer.getRenderTarget();
            const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            cubemaps.set(texture, renderTarget);
            renderer.setRenderTarget(currentRenderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemap = cubemaps.get(texture);
    if (cubemap !== void 0) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }
  function dispose() {
    cubemaps = new WeakMap();
  }
  return {
    get,
    dispose
  };
}
function WebGLExtensions(gl) {
  const extensions = {};
  function getExtension(name) {
    if (extensions[name] !== void 0) {
      return extensions[name];
    }
    let extension;
    switch (name) {
      case "WEBGL_depth_texture":
        extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        extension = gl.getExtension(name);
    }
    extensions[name] = extension;
    return extension;
  }
  return {
    has: function(name) {
      return getExtension(name) !== null;
    },
    init: function(capabilities) {
      if (capabilities.isWebGL2) {
        getExtension("EXT_color_buffer_float");
      } else {
        getExtension("WEBGL_depth_texture");
        getExtension("OES_texture_float");
        getExtension("OES_texture_half_float");
        getExtension("OES_texture_half_float_linear");
        getExtension("OES_standard_derivatives");
        getExtension("OES_element_index_uint");
        getExtension("OES_vertex_array_object");
        getExtension("ANGLE_instanced_arrays");
      }
      getExtension("OES_texture_float_linear");
      getExtension("EXT_color_buffer_half_float");
    },
    get: function(name) {
      const extension = getExtension(name);
      if (extension === null) {
        console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
      }
      return extension;
    }
  };
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries = {};
  const wireframeAttributes = new WeakMap();
  function onGeometryDispose(event) {
    const geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (const name in geometry.attributes) {
      attributes.remove(geometry.attributes[name]);
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    delete geometries[geometry.id];
    const attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  function get(object, geometry) {
    if (geometries[geometry.id] === true)
      return geometry;
    geometry.addEventListener("dispose", onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  function update(geometry) {
    const geometryAttributes = geometry.attributes;
    for (const name in geometryAttributes) {
      attributes.update(geometryAttributes[name], 34962);
    }
    const morphAttributes = geometry.morphAttributes;
    for (const name in morphAttributes) {
      const array = morphAttributes[name];
      for (let i = 0, l = array.length; i < l; i++) {
        attributes.update(array[i], 34962);
      }
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version = 0;
    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version = geometryIndex.version;
      for (let i = 0, l = array.length; i < l; i += 3) {
        const a = array[i + 0];
        const b = array[i + 1];
        const c = array[i + 2];
        indices.push(a, b, b, c, c, a);
      }
    } else {
      const array = geometryPosition.array;
      version = geometryPosition.version;
      for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
        const a = i + 0;
        const b = i + 1;
        const c = i + 2;
        indices.push(a, b, b, c, c, a);
      }
    }
    const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version;
    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute)
      attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get,
    update,
    getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawElementsInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawElementsInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLInfo(gl) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update(count, mode, instanceCount) {
    render.calls++;
    switch (mode) {
      case 4:
        render.triangles += instanceCount * (count / 3);
        break;
      case 1:
        render.lines += instanceCount * (count / 2);
        break;
      case 3:
        render.lines += instanceCount * (count - 1);
        break;
      case 2:
        render.lines += instanceCount * count;
        break;
      case 0:
        render.points += instanceCount * count;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  function reset() {
    render.frame++;
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }
  return {
    memory,
    render,
    programs: null,
    autoReset: true,
    reset,
    update
  };
}
function numericalSort(a, b) {
  return a[0] - b[0];
}
function absNumericalSort(a, b) {
  return Math.abs(b[1]) - Math.abs(a[1]);
}
function WebGLMorphtargets(gl) {
  const influencesList = {};
  const morphInfluences = new Float32Array(8);
  const workInfluences = [];
  for (let i = 0; i < 8; i++) {
    workInfluences[i] = [i, 0];
  }
  function update(object, geometry, material, program) {
    const objectInfluences = object.morphTargetInfluences;
    const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
    let influences = influencesList[geometry.id];
    if (influences === void 0) {
      influences = [];
      for (let i = 0; i < length; i++) {
        influences[i] = [i, 0];
      }
      influencesList[geometry.id] = influences;
    }
    for (let i = 0; i < length; i++) {
      const influence = influences[i];
      influence[0] = i;
      influence[1] = objectInfluences[i];
    }
    influences.sort(absNumericalSort);
    for (let i = 0; i < 8; i++) {
      if (i < length && influences[i][1]) {
        workInfluences[i][0] = influences[i][0];
        workInfluences[i][1] = influences[i][1];
      } else {
        workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
        workInfluences[i][1] = 0;
      }
    }
    workInfluences.sort(numericalSort);
    const morphTargets = material.morphTargets && geometry.morphAttributes.position;
    const morphNormals = material.morphNormals && geometry.morphAttributes.normal;
    let morphInfluencesSum = 0;
    for (let i = 0; i < 8; i++) {
      const influence = workInfluences[i];
      const index = influence[0];
      const value = influence[1];
      if (index !== Number.MAX_SAFE_INTEGER && value) {
        if (morphTargets && geometry.getAttribute("morphTarget" + i) !== morphTargets[index]) {
          geometry.setAttribute("morphTarget" + i, morphTargets[index]);
        }
        if (morphNormals && geometry.getAttribute("morphNormal" + i) !== morphNormals[index]) {
          geometry.setAttribute("morphNormal" + i, morphNormals[index]);
        }
        morphInfluences[i] = value;
        morphInfluencesSum += value;
      } else {
        if (morphTargets && geometry.hasAttribute("morphTarget" + i) === true) {
          geometry.deleteAttribute("morphTarget" + i);
        }
        if (morphNormals && geometry.hasAttribute("morphNormal" + i) === true) {
          geometry.deleteAttribute("morphNormal" + i);
        }
        morphInfluences[i] = 0;
      }
    }
    const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
    program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
    program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
  }
  return {
    update
  };
}
function WebGLObjects(gl, geometries, attributes, info) {
  let updateMap = new WeakMap();
  function update(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries.get(object, geometry);
    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object.isInstancedMesh) {
      if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
        object.addEventListener("dispose", onInstancedMeshDispose);
      }
      attributes.update(object.instanceMatrix, 34962);
      if (object.instanceColor !== null) {
        attributes.update(object.instanceColor, 34962);
      }
    }
    return buffergeometry;
  }
  function dispose() {
    updateMap = new WeakMap();
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null)
      attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update,
    dispose
  };
}
class DataTexture2DArray extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.image = {data, width, height, depth};
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
  }
}
DataTexture2DArray.prototype.isDataTexture2DArray = true;
class DataTexture3D extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.image = {data, width, height, depth};
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
  }
}
DataTexture3D.prototype.isDataTexture3D = true;
const emptyTexture = new Texture();
const emptyTexture2dArray = new DataTexture2DArray();
const emptyTexture3d = new DataTexture3D();
const emptyCubeTexture = new CubeTexture();
const arrayCacheF32 = [];
const arrayCacheI32 = [];
const mat4array = new Float32Array(16);
const mat3array = new Float32Array(9);
const mat2array = new Float32Array(4);
function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0)
    return array;
  const n = nBlocks * blockSize;
  let r = arrayCacheF32[n];
  if (r === void 0) {
    r = new Float32Array(n);
    arrayCacheF32[n] = r;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r, 0);
    for (let i = 1, offset = 0; i !== nBlocks; ++i) {
      offset += blockSize;
      array[i].toArray(r, offset);
    }
  }
  return r;
}
function arraysEqual(a, b) {
  if (a.length !== b.length)
    return false;
  for (let i = 0, l = a.length; i < l; i++) {
    if (a[i] !== b[i])
      return false;
  }
  return true;
}
function copyArray(a, b) {
  for (let i = 0, l = b.length; i < l; i++) {
    a[i] = b[i];
  }
}
function allocTexUnits(textures, n) {
  let r = arrayCacheI32[n];
  if (r === void 0) {
    r = new Int32Array(n);
    arrayCacheI32[n] = r;
  }
  for (let i = 0; i !== n; ++i) {
    r[i] = textures.allocateTextureUnit();
  }
  return r;
}
function setValueV1f(gl, v) {
  const cache = this.cache;
  if (cache[0] === v)
    return;
  gl.uniform1f(this.addr, v);
  cache[0] = v;
}
function setValueV2f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2f(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform2fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV3f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3f(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else if (v.r !== void 0) {
    if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
      gl.uniform3f(this.addr, v.r, v.g, v.b);
      cache[0] = v.r;
      cache[1] = v.g;
      cache[2] = v.b;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform3fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV4f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform4fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueM2(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v))
      return;
    gl.uniformMatrix2fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}
function setValueM3(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v))
      return;
    gl.uniformMatrix3fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}
function setValueM4(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v))
      return;
    gl.uniformMatrix4fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
}
function setValueV1i(gl, v) {
  const cache = this.cache;
  if (cache[0] === v)
    return;
  gl.uniform1i(this.addr, v);
  cache[0] = v;
}
function setValueV2i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform2iv(this.addr, v);
  copyArray(cache, v);
}
function setValueV3i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform3iv(this.addr, v);
  copyArray(cache, v);
}
function setValueV4i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform4iv(this.addr, v);
  copyArray(cache, v);
}
function setValueV1ui(gl, v) {
  const cache = this.cache;
  if (cache[0] === v)
    return;
  gl.uniform1ui(this.addr, v);
  cache[0] = v;
}
function setValueV2ui(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform2uiv(this.addr, v);
  copyArray(cache, v);
}
function setValueV3ui(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform3uiv(this.addr, v);
  copyArray(cache, v);
}
function setValueV4ui(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform4uiv(this.addr, v);
  copyArray(cache, v);
}
function setValueT1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.safeSetTexture2D(v || emptyTexture, unit);
}
function setValueT3D1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture3D(v || emptyTexture3d, unit);
}
function setValueT6(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.safeSetTextureCube(v || emptyCubeTexture, unit);
}
function setValueT2DArray1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2DArray(v || emptyTexture2dArray, unit);
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 36294:
      return setValueV2ui;
    case 36295:
      return setValueV3ui;
    case 36296:
      return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(gl, v) {
  gl.uniform1fv(this.addr, v);
}
function setValueV2fArray(gl, v) {
  const data = flatten(v, this.size, 2);
  gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v) {
  const data = flatten(v, this.size, 3);
  gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniform4fv(this.addr, data);
}
function setValueM2Array(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v) {
  const data = flatten(v, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v) {
  const data = flatten(v, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
}
function setValueV1iArray(gl, v) {
  gl.uniform1iv(this.addr, v);
}
function setValueV2iArray(gl, v) {
  gl.uniform2iv(this.addr, v);
}
function setValueV3iArray(gl, v) {
  gl.uniform3iv(this.addr, v);
}
function setValueV4iArray(gl, v) {
  gl.uniform4iv(this.addr, v);
}
function setValueV1uiArray(gl, v) {
  gl.uniform1uiv(this.addr, v);
}
function setValueV2uiArray(gl, v) {
  gl.uniform2uiv(this.addr, v);
}
function setValueV3uiArray(gl, v) {
  gl.uniform3uiv(this.addr, v);
}
function setValueV4uiArray(gl, v) {
  gl.uniform4uiv(this.addr, v);
}
function setValueT1Array(gl, v, textures) {
  const n = v.length;
  const units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);
  for (let i = 0; i !== n; ++i) {
    textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);
  }
}
function setValueT6Array(gl, v, textures) {
  const n = v.length;
  const units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);
  for (let i = 0; i !== n; ++i) {
    textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 5125:
      return setValueV1uiArray;
    case 36294:
      return setValueV2uiArray;
    case 36295:
      return setValueV3uiArray;
    case 36296:
      return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
  }
}
function SingleUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.setValue = getSingularSetter(activeInfo.type);
}
function PureArrayUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type);
}
PureArrayUniform.prototype.updateCache = function(data) {
  const cache = this.cache;
  if (data instanceof Float32Array && cache.length !== data.length) {
    this.cache = new Float32Array(data.length);
  }
  copyArray(cache, data);
};
function StructuredUniform(id) {
  this.id = id;
  this.seq = [];
  this.map = {};
}
StructuredUniform.prototype.setValue = function(gl, value, textures) {
  const seq = this.seq;
  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i];
    u.setValue(gl, value[u.id], textures);
  }
};
const RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
    let id = match[1];
    const idIsIndex = match[2] === "]", subscript = match[3];
    if (idIsIndex)
      id = id | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      const map = container.map;
      let next = map[id];
      if (next === void 0) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }
      container = next;
    }
  }
}
function WebGLUniforms(gl, program) {
  this.seq = [];
  this.map = {};
  const n = gl.getProgramParameter(program, 35718);
  for (let i = 0; i < n; ++i) {
    const info = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info.name);
    parseUniform(info, addr, this);
  }
}
WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
  const u = this.map[name];
  if (u !== void 0)
    u.setValue(gl, value, textures);
};
WebGLUniforms.prototype.setOptional = function(gl, object, name) {
  const v = object[name];
  if (v !== void 0)
    this.setValue(gl, name, v);
};
WebGLUniforms.upload = function(gl, seq, values, textures) {
  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i], v = values[u.id];
    if (v.needsUpdate !== false) {
      u.setValue(gl, v.value, textures);
    }
  }
};
WebGLUniforms.seqWithValue = function(seq, values) {
  const r = [];
  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i];
    if (u.id in values)
      r.push(u);
  }
  return r;
};
function WebGLShader(gl, type, string) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}
let programIdCount = 0;
function addLineNumbers(string) {
  const lines = string.split("\n");
  for (let i = 0; i < lines.length; i++) {
    lines[i] = i + 1 + ": " + lines[i];
  }
  return lines.join("\n");
}
function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ["Linear", "( value )"];
    case sRGBEncoding:
      return ["sRGB", "( value )"];
    case RGBEEncoding:
      return ["RGBE", "( value )"];
    case RGBM7Encoding:
      return ["RGBM", "( value, 7.0 )"];
    case RGBM16Encoding:
      return ["RGBM", "( value, 16.0 )"];
    case RGBDEncoding:
      return ["RGBD", "( value, 256.0 )"];
    case GammaEncoding:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    case LogLuvEncoding:
      return ["LogLuv", "( value )"];
    default:
      console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
      return ["Linear", "( value )"];
  }
}
function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, 35713);
  const log = gl.getShaderInfoLog(shader).trim();
  if (status && log === "")
    return "";
  const source = gl.getShaderSource(shader);
  return "THREE.WebGLShader: gl.getShaderInfoLog() " + type + "\n" + log + addLineNumbers(source);
}
function getTexelDecodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
}
function getTexelEncodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
}
function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case CineonToneMapping:
      toneMappingName = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    case CustomToneMapping:
      toneMappingName = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
      toneMappingName = "Linear";
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
function generateExtensions(parameters) {
  const chunks = [
    parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  const chunks = [];
  for (const name in defines) {
    const value = defines[name];
    if (value === false)
      continue;
    chunks.push("#define " + name + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl, program) {
  const attributes = {};
  const n = gl.getProgramParameter(program, 35721);
  for (let i = 0; i < n; i++) {
    const info = gl.getActiveAttrib(program, i);
    const name = info.name;
    attributes[name] = gl.getAttribLocation(program, name);
  }
  return attributes;
}
function filterEmptyLine(string) {
  return string !== "";
}
function replaceLightNums(string, parameters) {
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}
function includeReplacer(match, include) {
  const string = ShaderChunk[include];
  if (string === void 0) {
    throw new Error("Can not resolve #include <" + include + ">");
  }
  return resolveIncludes(string);
}
const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}
function deprecatedLoopReplacer(match, start, end, snippet) {
  console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
  return loopReplacer(match, start, end, snippet);
}
function loopReplacer(match, start, end, snippet) {
  let string = "";
  for (let i = parseInt(start); i < parseInt(end); i++) {
    string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
  }
  return string;
}
function generatePrecision(parameters) {
  let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
  }
  return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
      case CubeUVRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  }
  return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
      case CubeUVRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return envMapBlendingDefine;
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  const gl = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
  const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      customExtensions,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      "#define MAX_BONES " + parameters.maxBones,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#ifdef USE_MORPHTARGETS",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      customExtensions,
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest + (parameters.alphaTest % 1 ? "" : ".0") : "",
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      ShaderChunk["encodings_pars_fragment"],
      parameters.map ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "",
      parameters.matcap ? getTexelDecodingFunction("matcapTexelToLinear", parameters.matcapEncoding) : "",
      parameters.envMap ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "",
      parameters.emissiveMap ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "",
      parameters.lightMap ? getTexelDecodingFunction("lightMapTexelToLinear", parameters.lightMapEncoding) : "",
      getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
      parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
    versionString = "#version 300 es\n";
    prefixVertex = [
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "#define varying in",
      parameters.glslVersion === GLSL3 ? "" : "out highp vec4 pc_fragColor;",
      parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader;
  const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== void 0) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, "position");
  }
  gl.linkProgram(program);
  if (renderer.debug.checkShaderErrors) {
    const programLog = gl.getProgramInfoLog(program).trim();
    const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
    const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
    let runnable = true;
    let haveDiagnostics = true;
    if (gl.getProgramParameter(program, 35714) === false) {
      runnable = false;
      const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
      const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
      console.error("THREE.WebGLProgram: shader error: ", gl.getError(), "35715", gl.getProgramParameter(program, 35715), "gl.getProgramInfoLog", programLog, vertexErrors, fragmentErrors);
    } else if (programLog !== "") {
      console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", programLog);
    } else if (vertexLog === "" || fragmentLog === "") {
      haveDiagnostics = false;
    }
    if (haveDiagnostics) {
      this.diagnostics = {
        runnable,
        programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
  }
  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader);
  let cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      cachedUniforms = new WebGLUniforms(gl, program);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }
    return cachedAttributes;
  };
  this.destroy = function() {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = void 0;
  };
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
function WebGLPrograms(renderer, cubemaps, extensions, capabilities, bindingStates, clipping) {
  const programs = [];
  const isWebGL2 = capabilities.isWebGL2;
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const floatVertexTextures = capabilities.floatVertexTextures;
  const maxVertexUniforms = capabilities.maxVertexUniforms;
  const vertexTextures = capabilities.vertexTextures;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  const parameterNames = [
    "precision",
    "isWebGL2",
    "supportsVertexTextures",
    "outputEncoding",
    "instancing",
    "instancingColor",
    "map",
    "mapEncoding",
    "matcap",
    "matcapEncoding",
    "envMap",
    "envMapMode",
    "envMapEncoding",
    "envMapCubeUV",
    "lightMap",
    "lightMapEncoding",
    "aoMap",
    "emissiveMap",
    "emissiveMapEncoding",
    "bumpMap",
    "normalMap",
    "objectSpaceNormalMap",
    "tangentSpaceNormalMap",
    "clearcoatMap",
    "clearcoatRoughnessMap",
    "clearcoatNormalMap",
    "displacementMap",
    "specularMap",
    "roughnessMap",
    "metalnessMap",
    "gradientMap",
    "alphaMap",
    "combine",
    "vertexColors",
    "vertexAlphas",
    "vertexTangents",
    "vertexUvs",
    "uvsVertexOnly",
    "fog",
    "useFog",
    "fogExp2",
    "flatShading",
    "sizeAttenuation",
    "logarithmicDepthBuffer",
    "skinning",
    "maxBones",
    "useVertexTexture",
    "morphTargets",
    "morphNormals",
    "premultipliedAlpha",
    "numDirLights",
    "numPointLights",
    "numSpotLights",
    "numHemiLights",
    "numRectAreaLights",
    "numDirLightShadows",
    "numPointLightShadows",
    "numSpotLightShadows",
    "shadowMapEnabled",
    "shadowMapType",
    "toneMapping",
    "physicallyCorrectLights",
    "alphaTest",
    "doubleSided",
    "flipSided",
    "numClippingPlanes",
    "numClipIntersection",
    "depthPacking",
    "dithering",
    "sheen",
    "transmissionMap"
  ];
  function getMaxBones(object) {
    const skeleton = object.skeleton;
    const bones = skeleton.bones;
    if (floatVertexTextures) {
      return 1024;
    } else {
      const nVertexUniforms = maxVertexUniforms;
      const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      const maxBones = Math.min(nVertexMatrices, bones.length);
      if (maxBones < bones.length) {
        console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
        return 0;
      }
      return maxBones;
    }
  }
  function getTextureEncodingFromMap(map) {
    let encoding;
    if (map && map.isTexture) {
      encoding = map.encoding;
    } else if (map && map.isWebGLRenderTarget) {
      console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
      encoding = map.texture.encoding;
    } else {
      encoding = LinearEncoding;
    }
    return encoding;
  }
  function getParameters(material, lights, shadows, scene, object) {
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const envMap = cubemaps.get(material.envMap || environment);
    const shaderID = shaderIDs[material.type];
    const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
      }
    }
    let vertexShader, fragmentShader;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
    }
    const currentRenderTarget = renderer.getRenderTarget();
    const parameters = {
      isWebGL2,
      shaderID,
      shaderName: material.type,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision,
      instancing: object.isInstancedMesh === true,
      instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
      supportsVertexTextures: vertexTextures,
      outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
      map: !!material.map,
      mapEncoding: getTextureEncodingFromMap(material.map),
      matcap: !!material.matcap,
      matcapEncoding: getTextureEncodingFromMap(material.matcap),
      envMap: !!envMap,
      envMapMode: envMap && envMap.mapping,
      envMapEncoding: getTextureEncodingFromMap(envMap),
      envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
      lightMap: !!material.lightMap,
      lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
      clearcoatMap: !!material.clearcoatMap,
      clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
      clearcoatNormalMap: !!material.clearcoatNormalMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      alphaMap: !!material.alphaMap,
      gradientMap: !!material.gradientMap,
      sheen: !!material.sheen,
      transmissionMap: !!material.transmissionMap,
      combine: material.combine,
      vertexTangents: material.normalMap && material.vertexTangents,
      vertexColors: material.vertexColors,
      vertexAlphas: material.vertexColors === true && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap,
      uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmissionMap) && !!material.displacementMap,
      fog: !!fog,
      useFog: material.fog,
      fogExp2: fog && fog.isFogExp2,
      flatShading: !!material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer,
      skinning: material.skinning && maxBones > 0,
      maxBones,
      useVertexTexture: floatVertexTextures,
      morphTargets: material.morphTargets,
      morphNormals: material.morphNormals,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
      physicallyCorrectLights: renderer.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      alphaTest: material.alphaTest,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives: material.extensions && material.extensions.derivatives,
      extensionFragDepth: material.extensions && material.extensions.fragDepth,
      extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
      extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.fragmentShader);
      array.push(parameters.vertexShader);
    }
    if (parameters.defines !== void 0) {
      for (const name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      for (let i = 0; i < parameterNames.length; i++) {
        array.push(parameters[parameterNames[i]]);
      }
      array.push(renderer.outputEncoding);
      array.push(renderer.gammaFactor);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    let program;
    for (let p = 0, pl = programs.length; p < pl; p++) {
      const preexistingProgram = programs[p];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i = programs.indexOf(program);
      programs[i] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    programs
  };
}
function WebGLProperties() {
  let properties = new WeakMap();
  function get(object) {
    let map = properties.get(object);
    if (map === void 0) {
      map = {};
      properties.set(object, map);
    }
    return map;
  }
  function remove(object) {
    properties.delete(object);
  }
  function update(object, key, value) {
    properties.get(object)[key] = value;
  }
  function dispose() {
    properties = new WeakMap();
  }
  return {
    get,
    remove,
    update,
    dispose
  };
}
function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.program !== b.program) {
    return a.program.id - b.program.id;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}
function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}
function WebGLRenderList(properties) {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transparent = [];
  const defaultProgram = {id: -1};
  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
    let renderItem = renderItems[renderItemsIndex];
    const materialProperties = properties.get(material);
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        program: materialProperties.program || defaultProgram,
        groupOrder,
        renderOrder: object.renderOrder,
        z,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.program = materialProperties.program || defaultProgram;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    (material.transparent === true ? transparent : opaque).push(renderItem);
  }
  function unshift(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    (material.transparent === true ? transparent : opaque).unshift(renderItem);
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1)
      opaque.sort(customOpaqueSort || painterSortStable);
    if (transparent.length > 1)
      transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
      const renderItem = renderItems[i];
      if (renderItem.id === null)
        break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.program = null;
      renderItem.group = null;
    }
  }
  return {
    opaque,
    transparent,
    init,
    push,
    unshift,
    finish,
    sort
  };
}
function WebGLRenderLists(properties) {
  let lists = new WeakMap();
  function get(scene, renderCallDepth) {
    let list;
    if (lists.has(scene) === false) {
      list = new WebGLRenderList(properties);
      lists.set(scene, [list]);
    } else {
      if (renderCallDepth >= lists.get(scene).length) {
        list = new WebGLRenderList(properties);
        lists.get(scene).push(list);
      } else {
        list = lists.get(scene)[renderCallDepth];
      }
    }
    return list;
  }
  function dispose() {
    lists = new WeakMap();
  }
  return {
    get,
    dispose
  };
}
function UniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
let nextVersion = 0;
function shadowCastingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}
function WebGLLights(extensions, capabilities) {
  const cache = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  for (let i = 0; i < 9; i++)
    state.probe.push(new Vector3());
  const vector3 = new Vector3();
  const matrix4 = new Matrix4();
  const matrix42 = new Matrix4();
  function setup(lights) {
    let r = 0, g = 0, b = 0;
    for (let i = 0; i < 9; i++)
      state.probe[i].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    lights.sort(shadowCastingLightsFirst);
    for (let i = 0, l = lights.length; i < l; i++) {
      const light = lights[i];
      const color = light.color;
      const intensity = light.intensity;
      const distance = light.distance;
      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r += color.r * intensity;
        g += color.g * intensity;
        b += color.b * intensity;
      } else if (light.isLightProbe) {
        for (let j = 0; j < 9; j++) {
          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
        }
      } else if (light.isDirectionalLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.distance = distance;
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          state.spotShadowMatrix[spotLength] = light.shadow.matrix;
          numSpotShadows++;
        }
        state.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache.get(light);
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (capabilities.isWebGL2) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        if (extensions.has("OES_texture_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else if (extensions.has("OES_texture_half_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
        } else {
          console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
        }
      }
    }
    state.ambient[0] = r;
    state.ambient[1] = g;
    state.ambient[2] = b;
    const hash = state.hash;
    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotShadowMatrix.length = numSpotShadows;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera.matrixWorldInverse;
    for (let i = 0, l = lights.length; i < l; i++) {
      const light = lights[i];
      if (light.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.direction.normalize();
        hemiLength++;
      }
    }
  }
  return {
    setup,
    setupView,
    state
  };
}
function WebGLRenderState(extensions, capabilities) {
  const lights = new WebGLLights(extensions, capabilities);
  const lightsArray = [];
  const shadowsArray = [];
  function init() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights() {
    lights.setup(lightsArray);
  }
  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }
  const state = {
    lightsArray,
    shadowsArray,
    lights
  };
  return {
    init,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow
  };
}
function WebGLRenderStates(extensions, capabilities) {
  let renderStates = new WeakMap();
  function get(scene, renderCallDepth = 0) {
    let renderState;
    if (renderStates.has(scene) === false) {
      renderState = new WebGLRenderState(extensions, capabilities);
      renderStates.set(scene, [renderState]);
    } else {
      if (renderCallDepth >= renderStates.get(scene).length) {
        renderState = new WebGLRenderState(extensions, capabilities);
        renderStates.get(scene).push(renderState);
      } else {
        renderState = renderStates.get(scene)[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose() {
    renderStates = new WeakMap();
  }
  return {
    get,
    dispose
  };
}
class MeshDepthMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshDepthMaterial";
    this.depthPacking = BasicDepthPacking;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.depthPacking = source.depthPacking;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  }
}
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
class MeshDistanceMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshDistanceMaterial";
    this.referencePosition = new Vector3();
    this.nearDistance = 1;
    this.farDistance = 1e3;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.fog = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.referencePosition.copy(source.referencePosition);
    this.nearDistance = source.nearDistance;
    this.farDistance = source.farDistance;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
  }
}
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean * HALF_SAMPLE_RATE;\n	squared_mean = squared_mean * HALF_SAMPLE_RATE;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
var vsm_vert = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
function WebGLShadowMap(_renderer, _objects, _capabilities) {
  let _frustum = new Frustum();
  const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterials = [], _distanceMaterials = [], _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
  const shadowSide = {0: BackSide, 1: FrontSide, 2: DoubleSide};
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      SAMPLE_RATE: 2 / 8,
      HALF_SAMPLE_RATE: 1 / 8
    },
    uniforms: {
      shadow_pass: {value: null},
      resolution: {value: new Vector2()},
      radius: {value: 4}
    },
    vertexShader: vsm_vert,
    fragmentShader: vsm_frag
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  this.render = function(lights, scene, camera) {
    if (scope.enabled === false)
      return;
    if (scope.autoUpdate === false && scope.needsUpdate === false)
      return;
    if (lights.length === 0)
      return;
    const currentRenderTarget = _renderer.getRenderTarget();
    const activeCubeFace = _renderer.getActiveCubeFace();
    const activeMipmapLevel = _renderer.getActiveMipmapLevel();
    const _state = _renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    for (let i = 0, il = lights.length; i < il; i++) {
      const light = lights[i];
      const shadow = light.shadow;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false)
        continue;
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
        if (_shadowMapSize.x > _maxTextureSize) {
          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > _maxTextureSize) {
          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
        const pars = {minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat};
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.camera.updateProjectionMatrix();
      }
      if (shadow.map === null) {
        const pars = {minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat};
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      const viewportCount = shadow.getViewportCount();
      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp);
        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
        _state.viewport(_viewport);
        shadow.updateMatrices(light, vp);
        _frustum = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      }
      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }
      shadow.needsUpdate = false;
    }
    scope.needsUpdate = false;
    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera) {
    const geometry = _objects.update(fullScreenMesh);
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.mapPass);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.map);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
    const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
    let material = _depthMaterials[index];
    if (material === void 0) {
      material = new MeshDepthMaterial({
        depthPacking: RGBADepthPacking,
        morphTargets: useMorphing,
        skinning: useSkinning
      });
      _depthMaterials[index] = material;
    }
    return material;
  }
  function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {
    const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
    let material = _distanceMaterials[index];
    if (material === void 0) {
      material = new MeshDistanceMaterial({
        morphTargets: useMorphing,
        skinning: useSkinning
      });
      _distanceMaterials[index] = material;
    }
    return material;
  }
  function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
    let result = null;
    let getMaterialVariant = getDepthMaterialVariant;
    let customMaterial = object.customDepthMaterial;
    if (light.isPointLight === true) {
      getMaterialVariant = getDistanceMaterialVariant;
      customMaterial = object.customDistanceMaterial;
    }
    if (customMaterial === void 0) {
      let useMorphing = false;
      if (material.morphTargets === true) {
        useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
      }
      let useSkinning = false;
      if (object.isSkinnedMesh === true) {
        if (material.skinning === true) {
          useSkinning = true;
        } else {
          console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", object);
        }
      }
      const useInstancing = object.isInstancedMesh === true;
      result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
    } else {
      result = customMaterial;
    }
    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
      const keyA = result.uuid, keyB = material.uuid;
      let materialsForVariant = _materialCache[keyA];
      if (materialsForVariant === void 0) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }
      let cachedMaterial = materialsForVariant[keyB];
      if (cachedMaterial === void 0) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }
      result = cachedMaterial;
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      result.referencePosition.setFromMatrixPosition(light.matrixWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        const geometry = _objects.update(object);
        const material = object.material;
        if (Array.isArray(material)) {
          const groups = geometry.groups;
          for (let k = 0, kl = groups.length; k < kl; k++) {
            const group = groups[k];
            const groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);
          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
        }
      }
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      renderObject(children[i], camera, shadowCamera, light, type);
    }
  }
}
function WebGLState(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function ColorBuffer() {
    let locked = false;
    const color = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r, g, b, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r *= a;
          g *= a;
          b *= a;
        }
        color.set(r, g, b, a);
        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r, g, b, a);
          currentColorClear.copy(color);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    let locked = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setTest: function(depthTest) {
        if (depthTest) {
          enable(2929);
        } else {
          disable(2929);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(512);
                break;
              case AlwaysDepth:
                gl.depthFunc(519);
                break;
              case LessDepth:
                gl.depthFunc(513);
                break;
              case LessEqualDepth:
                gl.depthFunc(515);
                break;
              case EqualDepth:
                gl.depthFunc(514);
                break;
              case GreaterEqualDepth:
                gl.depthFunc(518);
                break;
              case GreaterDepth:
                gl.depthFunc(516);
                break;
              case NotEqualDepth:
                gl.depthFunc(517);
                break;
              default:
                gl.depthFunc(515);
            }
          } else {
            gl.depthFunc(515);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(2960);
          } else {
            disable(2960);
          }
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  let enabledCapabilities = {};
  let xrFramebuffer = null;
  let currentBoundFramebuffers = {};
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(35661);
  let lineWidthAvailable = false;
  let version = 0;
  const glVersion = gl.getParameter(7938);
  if (glVersion.indexOf("WebGL") !== -1) {
    version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const currentScissor = new Vector4(0, 0, gl.canvas.width, gl.canvas.height);
  const currentViewport = new Vector4(0, 0, gl.canvas.width, gl.canvas.height);
  function createTexture(type, target, count) {
    const data = new Uint8Array(4);
    const texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, 10241, 9728);
    gl.texParameteri(type, 10240, 9728);
    for (let i = 0; i < count; i++) {
      gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);
    }
    return texture;
  }
  const emptyTextures = {};
  emptyTextures[3553] = createTexture(3553, 3553, 1);
  emptyTextures[34067] = createTexture(34067, 34069, 6);
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(2929);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(2884);
  setBlending(NoBlending);
  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }
  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }
  function bindXRFramebuffer(framebuffer) {
    if (framebuffer !== xrFramebuffer) {
      gl.bindFramebuffer(36160, framebuffer);
      xrFramebuffer = framebuffer;
    }
  }
  function bindFramebuffer(target, framebuffer) {
    if (framebuffer === null && xrFramebuffer !== null)
      framebuffer = xrFramebuffer;
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;
    }
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: 32774,
    [SubtractEquation]: 32778,
    [ReverseSubtractEquation]: 32779
  };
  if (isWebGL2) {
    equationToGL[MinEquation] = 32775;
    equationToGL[MaxEquation] = 32776;
  } else {
    const extension = extensions.get("EXT_blend_minmax");
    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT;
      equationToGL[MaxEquation] = extension.MAX_EXT;
    }
  }
  const factorToGL = {
    [ZeroFactor]: 0,
    [OneFactor]: 1,
    [SrcColorFactor]: 768,
    [SrcAlphaFactor]: 770,
    [SrcAlphaSaturateFactor]: 776,
    [DstColorFactor]: 774,
    [DstAlphaFactor]: 772,
    [OneMinusSrcColorFactor]: 769,
    [OneMinusSrcAlphaFactor]: 771,
    [OneMinusDstColorFactor]: 775,
    [OneMinusDstAlphaFactor]: 773
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(3042);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(3042);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(32774);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(1, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(1, 1);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 0, 769, 771);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(770, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(770, 1);
              break;
            case SubtractiveBlending:
              gl.blendFunc(0, 769);
              break;
            case MultiplyBlending:
              gl.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = null;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(2884) : enable(2884);
    let flipSided = material.side === BackSide;
    if (frontFaceCW)
      flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true ? enable(32926) : disable(32926);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(2304);
      } else {
        gl.frontFace(2305);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(2884);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(1029);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(1028);
        } else {
          gl.cullFace(1032);
        }
      }
    } else {
      disable(2884);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable)
        gl.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(32823);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(32823);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(3089);
    } else {
      disable(3089);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0)
      webglSlot = 33984 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }
    let boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture === void 0) {
      boundTexture = {type: void 0, texture: void 0};
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function reset() {
    gl.disable(3042);
    gl.disable(2884);
    gl.disable(2929);
    gl.disable(32823);
    gl.disable(3089);
    gl.disable(2960);
    gl.disable(32926);
    gl.blendEquation(32774);
    gl.blendFunc(1, 0);
    gl.blendFuncSeparate(1, 0, 1, 0);
    gl.colorMask(true, true, true, true);
    gl.clearColor(0, 0, 0, 0);
    gl.depthMask(true);
    gl.depthFunc(513);
    gl.clearDepth(1);
    gl.stencilMask(4294967295);
    gl.stencilFunc(519, 0, 4294967295);
    gl.stencilOp(7680, 7680, 7680);
    gl.clearStencil(0);
    gl.cullFace(1029);
    gl.frontFace(2305);
    gl.polygonOffset(0, 0);
    gl.activeTexture(33984);
    gl.bindFramebuffer(36160, null);
    if (isWebGL2 === true) {
      gl.bindFramebuffer(36009, null);
      gl.bindFramebuffer(36008, null);
    }
    gl.useProgram(null);
    gl.lineWidth(1);
    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    xrFramebuffer = null;
    currentBoundFramebuffers = {};
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable,
    disable,
    bindFramebuffer,
    bindXRFramebuffer,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    texImage2D,
    texImage3D,
    scissor,
    viewport,
    reset
  };
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  const isWebGL2 = capabilities.isWebGL2;
  const maxTextures = capabilities.maxTextures;
  const maxCubemapSize = capabilities.maxCubemapSize;
  const maxTextureSize = capabilities.maxTextureSize;
  const maxSamples = capabilities.maxSamples;
  const _videoTextures = new WeakMap();
  let _canvas2;
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {
  }
  function createCanvas(width, height) {
    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  }
  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    let scale = 1;
    if (image.width > maxSize || image.height > maxSize) {
      scale = maxSize / Math.max(image.width, image.height);
    }
    if (scale < 1 || needsPowerOfTwo === true) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        const floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;
        const width = floor(scale * image.width);
        const height = floor(scale * image.height);
        if (_canvas2 === void 0)
          _canvas2 = createCanvas(width, height);
        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0, width, height);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
        return canvas;
      } else {
        if ("data" in image) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
        }
        return image;
      }
    }
    return image;
  }
  function isPowerOfTwo(image) {
    return MathUtils.isPowerOfTwo(image.width) && MathUtils.isPowerOfTwo(image.height);
  }
  function textureNeedsPowerOfTwo(texture) {
    if (isWebGL2)
      return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function generateMipmap(target, texture, width, height) {
    _gl.generateMipmap(target);
    const textureProperties = properties.get(texture);
    textureProperties.__maxMipLevel = Math.log2(Math.max(width, height));
  }
  function getInternalFormat(internalFormatName, glFormat, glType) {
    if (isWebGL2 === false)
      return glFormat;
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0)
        return _gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === 6403) {
      if (glType === 5126)
        internalFormat = 33326;
      if (glType === 5131)
        internalFormat = 33325;
      if (glType === 5121)
        internalFormat = 33321;
    }
    if (glFormat === 6407) {
      if (glType === 5126)
        internalFormat = 34837;
      if (glType === 5131)
        internalFormat = 34843;
      if (glType === 5121)
        internalFormat = 32849;
    }
    if (glFormat === 6408) {
      if (glType === 5126)
        internalFormat = 34836;
      if (glType === 5131)
        internalFormat = 34842;
      if (glType === 5121)
        internalFormat = 32856;
    }
    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  function filterFallback(f) {
    if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
      return 9728;
    }
    return 9729;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
    info.memory.textures--;
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
    info.memory.textures--;
  }
  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === void 0)
      return;
    _gl.deleteTexture(textureProperties.__webglTexture);
    properties.remove(texture);
  }
  function deallocateRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    if (!renderTarget)
      return;
    if (textureProperties.__webglTexture !== void 0) {
      _gl.deleteTexture(textureProperties.__webglTexture);
    }
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i = 0; i < 6; i++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      if (renderTargetProperties.__webglDepthbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer)
        _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
      if (renderTargetProperties.__webglDepthRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    properties.remove(texture);
    properties.remove(renderTarget);
  }
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= maxTextures) {
      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture)
      updateVideoTexture(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      const image = texture.image;
      if (image === void 0) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
      } else if (image.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(3553, textureProperties.__webglTexture);
  }
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(35866, textureProperties.__webglTexture);
  }
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(32879, textureProperties.__webglTexture);
  }
  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
  }
  const wrappingToGL = {
    [RepeatWrapping]: 10497,
    [ClampToEdgeWrapping]: 33071,
    [MirroredRepeatWrapping]: 33648
  };
  const filterToGL = {
    [NearestFilter]: 9728,
    [NearestMipmapNearestFilter]: 9984,
    [NearestMipmapLinearFilter]: 9986,
    [LinearFilter]: 9729,
    [LinearMipmapNearestFilter]: 9985,
    [LinearMipmapLinearFilter]: 9987
  };
  function setTextureParameters(textureType, texture, supportsMips) {
    if (supportsMips) {
      _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
      _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
      }
      _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
      _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
    } else {
      _gl.texParameteri(textureType, 10242, 33071);
      _gl.texParameteri(textureType, 10243, 33071);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, 33071);
      }
      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
      }
      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
      }
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false)
        return;
      if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false))
        return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      info.memory.textures++;
    }
  }
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = 3553;
    if (texture.isDataTexture2DArray)
      textureType = 35866;
    if (texture.isDataTexture3D)
      textureType = 32879;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(textureType, textureProperties.__webglTexture);
    _gl.pixelStorei(37440, texture.flipY);
    _gl.pixelStorei(37441, texture.premultiplyAlpha);
    _gl.pixelStorei(3317, texture.unpackAlignment);
    _gl.pixelStorei(37443, 0);
    const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
    const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
    const supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format);
    let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    setTextureParameters(textureType, texture, supportsMips);
    let mipmap;
    const mipmaps = texture.mipmaps;
    if (texture.isDepthTexture) {
      glInternalFormat = 6402;
      if (isWebGL2) {
        if (texture.type === FloatType) {
          glInternalFormat = 36012;
        } else if (texture.type === UnsignedIntType) {
          glInternalFormat = 33190;
        } else if (texture.type === UnsignedInt248Type) {
          glInternalFormat = 35056;
        } else {
          glInternalFormat = 33189;
        }
      } else {
        if (texture.type === FloatType) {
          console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
        }
      }
      if (texture.format === DepthFormat && glInternalFormat === 6402) {
        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
          console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
          texture.type = UnsignedShortType;
          glType = utils.convert(texture.type);
        }
      }
      if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
        glInternalFormat = 34041;
        if (texture.type !== UnsignedInt248Type) {
          console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
          texture.type = UnsignedInt248Type;
          glType = utils.convert(texture.type);
        }
      }
      state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
    } else if (texture.isDataTexture) {
      if (mipmaps.length > 0 && supportsMips) {
        for (let i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      }
    } else if (texture.isCompressedTexture) {
      for (let i = 0, il = mipmaps.length; i < il; i++) {
        mipmap = mipmaps[i];
        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
          if (glFormat !== null) {
            state.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
          } else {
            console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
          }
        } else {
          state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else if (texture.isDataTexture2DArray) {
      state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else if (texture.isDataTexture3D) {
      state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else {
      if (mipmaps.length > 0 && supportsMips) {
        for (let i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);
        }
        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
        textureProperties.__maxMipLevel = 0;
      }
    }
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(textureType, texture, image.width, image.height);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate)
      texture.onUpdate(texture);
  }
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6)
      return;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
    _gl.pixelStorei(37440, texture.flipY);
    _gl.pixelStorei(37441, texture.premultiplyAlpha);
    _gl.pixelStorei(3317, texture.unpackAlignment);
    _gl.pixelStorei(37443, 0);
    const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
    const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
    const cubeImage = [];
    for (let i = 0; i < 6; i++) {
      if (!isCompressed && !isDataTexture) {
        cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
      } else {
        cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
      }
    }
    const image = cubeImage[0], supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    setTextureParameters(34067, texture, supportsMips);
    let mipmaps;
    if (isCompressed) {
      for (let i = 0; i < 6; i++) {
        mipmaps = cubeImage[i].mipmaps;
        for (let j = 0; j < mipmaps.length; j++) {
          const mipmap = mipmaps[j];
          if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
            if (glFormat !== null) {
              state.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
            } else {
              console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
            }
          } else {
            state.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else {
      mipmaps = texture.mipmaps;
      for (let i = 0; i < 6; i++) {
        if (isDataTexture) {
          state.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            const mipmapImage = mipmap.image[i].image;
            state.texImage2D(34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
          }
        } else {
          state.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            state.texImage2D(34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
          }
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length;
    }
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(34067, texture, image.width, image.height);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate)
      texture.onUpdate(texture);
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
    const texture = renderTarget.texture;
    const glFormat = utils.convert(texture.format);
    const glType = utils.convert(texture.type);
    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    if (textureTarget === 32879 || textureTarget === 35866) {
      state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
    } else {
      state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
    }
    state.bindFramebuffer(36160, framebuffer);
    _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
    state.bindFramebuffer(36160, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(36161, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      let glInternalFormat = 33189;
      if (isMultisample) {
        const depthTexture = renderTarget.depthTexture;
        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          }
        }
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
    } else {
      const texture = renderTarget.texture;
      const glFormat = utils.convert(texture.format);
      const glType = utils.convert(texture.type);
      const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
    }
    _gl.bindRenderbuffer(36161, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube)
      throw new Error("Depth Texture with cube render targets is not supported");
    state.bindFramebuffer(36160, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    if (renderTarget.depthTexture.format === DepthFormat) {
      _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTarget.depthTexture) {
      if (isCube)
        throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i = 0; i < 6; i++) {
          state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);
          renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
        }
      } else {
        state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
      }
    }
    state.bindFramebuffer(36160, null);
  }
  function setupRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    textureProperties.__webglTexture = _gl.createTexture();
    textureProperties.__version = texture.version;
    info.memory.textures++;
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
    const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
    const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
    if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {
      texture.format = RGBAFormat;
      console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.");
    }
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i = 0; i < 6; i++) {
        renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      if (isMultisample) {
        if (isWebGL2) {
          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
          renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
          const glFormat = utils.convert(texture.format);
          const glType = utils.convert(texture.type);
          const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
          _gl.bindRenderbuffer(36161, null);
          if (renderTarget.depthBuffer) {
            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
          }
          state.bindFramebuffer(36160, null);
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        }
      }
    }
    if (isCube) {
      state.bindTexture(34067, textureProperties.__webglTexture);
      setTextureParameters(34067, texture, supportsMips);
      for (let i = 0; i < 6; i++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, 36064, 34069 + i);
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(34067, texture, renderTarget.width, renderTarget.height);
      }
      state.bindTexture(34067, null);
    } else {
      let glTextureType = 3553;
      if (isRenderTarget3D) {
        if (isWebGL2) {
          const isTexture3D = texture.isDataTexture3D;
          glTextureType = isTexture3D ? 32879 : 35866;
        } else {
          console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
        }
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture, supportsMips);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, glTextureType);
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(3553, texture, renderTarget.width, renderTarget.height);
      }
      state.bindTexture(3553, null);
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const texture = renderTarget.texture;
    const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
      const webglTexture = properties.get(texture).__webglTexture;
      state.bindTexture(target, webglTexture);
      generateMipmap(target, texture, renderTarget.width, renderTarget.height);
      state.bindTexture(target, null);
    }
  }
  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.isWebGLMultisampleRenderTarget) {
      if (isWebGL2) {
        const renderTargetProperties = properties.get(renderTarget);
        state.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
        state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
        const width = renderTarget.width;
        const height = renderTarget.height;
        let mask = 16384;
        if (renderTarget.depthBuffer)
          mask |= 256;
        if (renderTarget.stencilBuffer)
          mask |= 1024;
        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
        state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
      } else {
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
      }
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
  }
  function updateVideoTexture(texture) {
    const frame = info.render.frame;
    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);
      texture.update();
    }
  }
  let warnedTexture2D = false;
  let warnedTextureCube = false;
  function safeSetTexture2D(texture, slot) {
    if (texture && texture.isWebGLRenderTarget) {
      if (warnedTexture2D === false) {
        console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
        warnedTexture2D = true;
      }
      texture = texture.texture;
    }
    setTexture2D(texture, slot);
  }
  function safeSetTextureCube(texture, slot) {
    if (texture && texture.isWebGLCubeRenderTarget) {
      if (warnedTextureCube === false) {
        console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
        warnedTextureCube = true;
      }
      texture = texture.texture;
    }
    setTextureCube(texture, slot);
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.safeSetTexture2D = safeSetTexture2D;
  this.safeSetTextureCube = safeSetTextureCube;
}
function WebGLUtils(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function convert(p) {
    let extension;
    if (p === UnsignedByteType)
      return 5121;
    if (p === UnsignedShort4444Type)
      return 32819;
    if (p === UnsignedShort5551Type)
      return 32820;
    if (p === UnsignedShort565Type)
      return 33635;
    if (p === ByteType)
      return 5120;
    if (p === ShortType)
      return 5122;
    if (p === UnsignedShortType)
      return 5123;
    if (p === IntType)
      return 5124;
    if (p === UnsignedIntType)
      return 5125;
    if (p === FloatType)
      return 5126;
    if (p === HalfFloatType) {
      if (isWebGL2)
        return 5131;
      extension = extensions.get("OES_texture_half_float");
      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      } else {
        return null;
      }
    }
    if (p === AlphaFormat)
      return 6406;
    if (p === RGBFormat)
      return 6407;
    if (p === RGBAFormat)
      return 6408;
    if (p === LuminanceFormat)
      return 6409;
    if (p === LuminanceAlphaFormat)
      return 6410;
    if (p === DepthFormat)
      return 6402;
    if (p === DepthStencilFormat)
      return 34041;
    if (p === RedFormat)
      return 6403;
    if (p === RedIntegerFormat)
      return 36244;
    if (p === RGFormat)
      return 33319;
    if (p === RGIntegerFormat)
      return 33320;
    if (p === RGBIntegerFormat)
      return 36248;
    if (p === RGBAIntegerFormat)
      return 36249;
    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
      extension = extensions.get("WEBGL_compressed_texture_s3tc");
      if (extension !== null) {
        if (p === RGB_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT3_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (p === RGBA_S3TC_DXT5_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else {
        return null;
      }
    }
    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === RGB_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === RGBA_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === RGBA_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc1");
      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p === RGB_ETC2_Format)
          return extension.COMPRESSED_RGB8_ETC2;
        if (p === RGBA_ETC2_EAC_Format)
          return extension.COMPRESSED_RGBA8_ETC2_EAC;
      }
    }
    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        return p;
      } else {
        return null;
      }
    }
    if (p === RGBA_BPTC_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        return p;
      } else {
        return null;
      }
    }
    if (p === UnsignedInt248Type) {
      if (isWebGL2)
        return 34042;
      extension = extensions.get("WEBGL_depth_texture");
      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      } else {
        return null;
      }
    }
  }
  return {convert};
}
class ArrayCamera extends PerspectiveCamera {
  constructor(array = []) {
    super();
    this.cameras = array;
  }
}
ArrayCamera.prototype.isArrayCamera = true;
class Group extends Object3D {
  constructor() {
    super();
    this.type = "Group";
  }
}
Group.prototype.isGroup = true;
function WebXRController() {
  this._targetRay = null;
  this._grip = null;
  this._hand = null;
}
Object.assign(WebXRController.prototype, {
  constructor: WebXRController,
  getHandSpace: function() {
    if (this._hand === null) {
      this._hand = new Group();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = {pinching: false};
    }
    return this._hand;
  },
  getTargetRaySpace: function() {
    if (this._targetRay === null) {
      this._targetRay = new Group();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
    }
    return this._targetRay;
  },
  getGripSpace: function() {
    if (this._grip === null) {
      this._grip = new Group();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
    }
    return this._grip;
  },
  dispatchEvent: function(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }
    return this;
  },
  disconnect: function(inputSource) {
    this.dispatchEvent({type: "disconnected", data: inputSource});
    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }
    if (this._grip !== null) {
      this._grip.visible = false;
    }
    if (this._hand !== null) {
      this._hand.visible = false;
    }
    return this;
  },
  update: function(inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand = this._hand;
    if (inputSource && frame.session.visibilityState !== "visible-blurred") {
      if (targetRay !== null) {
        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
        if (inputPose !== null) {
          targetRay.matrix.fromArray(inputPose.transform.matrix);
          targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
        }
      }
      if (hand && inputSource.hand) {
        handPose = true;
        for (const inputjoint of inputSource.hand.values()) {
          const jointPose = frame.getJointPose(inputjoint, referenceSpace);
          if (hand.joints[inputjoint.jointName] === void 0) {
            const joint2 = new Group();
            joint2.matrixAutoUpdate = false;
            joint2.visible = false;
            hand.joints[inputjoint.jointName] = joint2;
            hand.add(joint2);
          }
          const joint = hand.joints[inputjoint.jointName];
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.jointRadius = jointPose.radius;
          }
          joint.visible = jointPose !== null;
        }
        const indexTip = hand.joints["index-finger-tip"];
        const thumbTip = hand.joints["thumb-tip"];
        const distance = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold = 5e-3;
        if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
          hand.inputState.pinching = false;
          this.dispatchEvent({
            type: "pinchend",
            handedness: inputSource.handedness,
            target: this
          });
        } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
          hand.inputState.pinching = true;
          this.dispatchEvent({
            type: "pinchstart",
            handedness: inputSource.handedness,
            target: this
          });
        }
      } else {
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
          }
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }
    if (grip !== null) {
      grip.visible = gripPose !== null;
    }
    if (hand !== null) {
      hand.visible = handPose !== null;
    }
    return this;
  }
});
function WebXRManager(renderer, gl) {
  const scope = this;
  const state = renderer.state;
  let session = null;
  let framebufferScaleFactor = 1;
  let referenceSpace = null;
  let referenceSpaceType = "local-floor";
  let pose = null;
  const controllers = [];
  const inputSourcesMap = new Map();
  const cameraL = new PerspectiveCamera();
  cameraL.layers.enable(1);
  cameraL.viewport = new Vector4();
  const cameraR = new PerspectiveCamera();
  cameraR.layers.enable(2);
  cameraR.viewport = new Vector4();
  const cameras = [cameraL, cameraR];
  const cameraVR = new ArrayCamera();
  cameraVR.layers.enable(1);
  cameraVR.layers.enable(2);
  let _currentDepthNear = null;
  let _currentDepthFar = null;
  this.enabled = false;
  this.isPresenting = false;
  this.getController = function(index) {
    let controller = controllers[index];
    if (controller === void 0) {
      controller = new WebXRController();
      controllers[index] = controller;
    }
    return controller.getTargetRaySpace();
  };
  this.getControllerGrip = function(index) {
    let controller = controllers[index];
    if (controller === void 0) {
      controller = new WebXRController();
      controllers[index] = controller;
    }
    return controller.getGripSpace();
  };
  this.getHand = function(index) {
    let controller = controllers[index];
    if (controller === void 0) {
      controller = new WebXRController();
      controllers[index] = controller;
    }
    return controller.getHandSpace();
  };
  function onSessionEvent(event) {
    const controller = inputSourcesMap.get(event.inputSource);
    if (controller) {
      controller.dispatchEvent({type: event.type, data: event.inputSource});
    }
  }
  function onSessionEnd() {
    inputSourcesMap.forEach(function(controller, inputSource) {
      controller.disconnect(inputSource);
    });
    inputSourcesMap.clear();
    _currentDepthNear = null;
    _currentDepthFar = null;
    state.bindXRFramebuffer(null);
    renderer.setRenderTarget(renderer.getRenderTarget());
    animation.stop();
    scope.isPresenting = false;
    scope.dispatchEvent({type: "sessionend"});
  }
  this.setFramebufferScaleFactor = function(value) {
    framebufferScaleFactor = value;
    if (scope.isPresenting === true) {
      console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }
  };
  this.setReferenceSpaceType = function(value) {
    referenceSpaceType = value;
    if (scope.isPresenting === true) {
      console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }
  };
  this.getReferenceSpace = function() {
    return referenceSpace;
  };
  this.getSession = function() {
    return session;
  };
  this.setSession = async function(value) {
    session = value;
    if (session !== null) {
      session.addEventListener("select", onSessionEvent);
      session.addEventListener("selectstart", onSessionEvent);
      session.addEventListener("selectend", onSessionEvent);
      session.addEventListener("squeeze", onSessionEvent);
      session.addEventListener("squeezestart", onSessionEvent);
      session.addEventListener("squeezeend", onSessionEvent);
      session.addEventListener("end", onSessionEnd);
      session.addEventListener("inputsourceschange", onInputSourcesChange);
      const attributes = gl.getContextAttributes();
      if (attributes.xrCompatible !== true) {
        await gl.makeXRCompatible();
      }
      const layerInit = {
        antialias: attributes.antialias,
        alpha: attributes.alpha,
        depth: attributes.depth,
        stencil: attributes.stencil,
        framebufferScaleFactor
      };
      const baseLayer = new XRWebGLLayer(session, gl, layerInit);
      session.updateRenderState({baseLayer});
      referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
      animation.setContext(session);
      animation.start();
      scope.isPresenting = true;
      scope.dispatchEvent({type: "sessionstart"});
    }
  };
  function onInputSourcesChange(event) {
    const inputSources = session.inputSources;
    for (let i = 0; i < controllers.length; i++) {
      inputSourcesMap.set(inputSources[i], controllers[i]);
    }
    for (let i = 0; i < event.removed.length; i++) {
      const inputSource = event.removed[i];
      const controller = inputSourcesMap.get(inputSource);
      if (controller) {
        controller.dispatchEvent({type: "disconnected", data: inputSource});
        inputSourcesMap.delete(inputSource);
      }
    }
    for (let i = 0; i < event.added.length; i++) {
      const inputSource = event.added[i];
      const controller = inputSourcesMap.get(inputSource);
      if (controller) {
        controller.dispatchEvent({type: "connected", data: inputSource});
      }
    }
  }
  const cameraLPos = new Vector3();
  const cameraRPos = new Vector3();
  function setProjectionFromUnion(camera, cameraL2, cameraR2) {
    cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
    cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
    const ipd = cameraLPos.distanceTo(cameraRPos);
    const projL = cameraL2.projectionMatrix.elements;
    const projR = cameraR2.projectionMatrix.elements;
    const near = projL[14] / (projL[10] - 1);
    const far = projL[14] / (projL[10] + 1);
    const topFov = (projL[9] + 1) / projL[5];
    const bottomFov = (projL[9] - 1) / projL[5];
    const leftFov = (projL[8] - 1) / projL[0];
    const rightFov = (projR[8] + 1) / projR[0];
    const left = near * leftFov;
    const right = near * rightFov;
    const zOffset = ipd / (-leftFov + rightFov);
    const xOffset = zOffset * -leftFov;
    cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
    camera.translateX(xOffset);
    camera.translateZ(zOffset);
    camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
    camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    const near2 = near + zOffset;
    const far2 = far + zOffset;
    const left2 = left - xOffset;
    const right2 = right + (ipd - xOffset);
    const top2 = topFov * far / far2 * near2;
    const bottom2 = bottomFov * far / far2 * near2;
    camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
  }
  function updateCamera(camera, parent) {
    if (parent === null) {
      camera.matrixWorld.copy(camera.matrix);
    } else {
      camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
    }
    camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
  }
  this.getCamera = function(camera) {
    cameraVR.near = cameraR.near = cameraL.near = camera.near;
    cameraVR.far = cameraR.far = cameraL.far = camera.far;
    if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
      session.updateRenderState({
        depthNear: cameraVR.near,
        depthFar: cameraVR.far
      });
      _currentDepthNear = cameraVR.near;
      _currentDepthFar = cameraVR.far;
    }
    const parent = camera.parent;
    const cameras2 = cameraVR.cameras;
    updateCamera(cameraVR, parent);
    for (let i = 0; i < cameras2.length; i++) {
      updateCamera(cameras2[i], parent);
    }
    camera.matrixWorld.copy(cameraVR.matrixWorld);
    camera.matrix.copy(cameraVR.matrix);
    camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
    const children = camera.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].updateMatrixWorld(true);
    }
    if (cameras2.length === 2) {
      setProjectionFromUnion(cameraVR, cameraL, cameraR);
    } else {
      cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
    }
    return cameraVR;
  };
  let onAnimationFrameCallback = null;
  function onAnimationFrame(time, frame) {
    pose = frame.getViewerPose(referenceSpace);
    if (pose !== null) {
      const views = pose.views;
      const baseLayer = session.renderState.baseLayer;
      state.bindXRFramebuffer(baseLayer.framebuffer);
      let cameraVRNeedsUpdate = false;
      if (views.length !== cameraVR.cameras.length) {
        cameraVR.cameras.length = 0;
        cameraVRNeedsUpdate = true;
      }
      for (let i = 0; i < views.length; i++) {
        const view = views[i];
        const viewport = baseLayer.getViewport(view);
        const camera = cameras[i];
        camera.matrix.fromArray(view.transform.matrix);
        camera.projectionMatrix.fromArray(view.projectionMatrix);
        camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
        if (i === 0) {
          cameraVR.matrix.copy(camera.matrix);
        }
        if (cameraVRNeedsUpdate === true) {
          cameraVR.cameras.push(camera);
        }
      }
    }
    const inputSources = session.inputSources;
    for (let i = 0; i < controllers.length; i++) {
      const controller = controllers[i];
      const inputSource = inputSources[i];
      controller.update(inputSource, frame, referenceSpace);
    }
    if (onAnimationFrameCallback)
      onAnimationFrameCallback(time, frame);
  }
  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
  };
  this.dispose = function() {
  };
}
Object.assign(WebXRManager.prototype, EventDispatcher.prototype);
function WebGLMaterials(properties) {
  function refreshFogUniforms(uniforms, fog) {
    uniforms.fogColor.value.copy(fog.color);
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material, pixelRatio, height) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsLambert(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material);
      } else {
        refreshUniformsStandard(uniforms, material);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDepth(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsNormal(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false;
    }
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMap.value = envMap;
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap._needsFlipEnvMap ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.refractionRatio.value = material.refractionRatio;
      const maxMipLevel = properties.get(envMap).__maxMipLevel;
      if (maxMipLevel !== void 0) {
        uniforms.maxMipLevel.value = maxMipLevel;
      }
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    } else if (material.clearcoatMap) {
      uvScaleMap = material.clearcoatMap;
    } else if (material.clearcoatNormalMap) {
      uvScaleMap = material.clearcoatNormalMap;
    } else if (material.clearcoatRoughnessMap) {
      uvScaleMap = material.clearcoatRoughnessMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
    let uv2ScaleMap;
    if (material.aoMap) {
      uv2ScaleMap = material.aoMap;
    } else if (material.lightMap) {
      uv2ScaleMap = material.lightMap;
    }
    if (uv2ScaleMap !== void 0) {
      if (uv2ScaleMap.isWebGLRenderTarget) {
        uv2ScaleMap = uv2ScaleMap.texture;
      }
      if (uv2ScaleMap.matrixAutoUpdate === true) {
        uv2ScaleMap.updateMatrix();
      }
      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsLambert(uniforms, material) {
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material) {
    refreshUniformsStandard(uniforms, material);
    uniforms.reflectivity.value = material.reflectivity;
    uniforms.clearcoat.value = material.clearcoat;
    uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
    if (material.sheen)
      uniforms.sheen.value.copy(material.sheen);
    if (material.clearcoatMap) {
      uniforms.clearcoatMap.value = material.clearcoatMap;
    }
    if (material.clearcoatRoughnessMap) {
      uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
    }
    if (material.clearcoatNormalMap) {
      uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
      uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
      if (material.side === BackSide) {
        uniforms.clearcoatNormalScale.value.negate();
      }
    }
    uniforms.transmission.value = material.transmission;
    if (material.transmissionMap) {
      uniforms.transmissionMap.value = material.transmissionMap;
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDepth(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    uniforms.referencePosition.value.copy(material.referencePosition);
    uniforms.nearDistance.value = material.nearDistance;
    uniforms.farDistance.value = material.farDistance;
  }
  function refreshUniformsNormal(uniforms, material) {
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms
  };
}
function createCanvasElement() {
  const canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  canvas.style.display = "block";
  return canvas;
}
function WebGLRenderer(parameters) {
  parameters = parameters || {};
  const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
  let currentRenderList = null;
  let currentRenderState = null;
  const renderListStack = [];
  const renderStateStack = [];
  this.domElement = _canvas2;
  this.debug = {
    checkShaderErrors: true
  };
  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;
  this.sortObjects = true;
  this.clippingPlanes = [];
  this.localClippingEnabled = false;
  this.gammaFactor = 2;
  this.outputEncoding = LinearEncoding;
  this.physicallyCorrectLights = false;
  this.toneMapping = NoToneMapping;
  this.toneMappingExposure = 1;
  const _this = this;
  let _isContextLost = false;
  let _currentActiveCubeFace = 0;
  let _currentActiveMipmapLevel = 0;
  let _currentRenderTarget = null;
  let _currentMaterialId = -1;
  let _currentCamera = null;
  const _currentViewport = new Vector4();
  const _currentScissor = new Vector4();
  let _currentScissorTest = null;
  let _width = _canvas2.width;
  let _height = _canvas2.height;
  let _pixelRatio = 1;
  let _opaqueSort = null;
  let _transparentSort = null;
  const _viewport = new Vector4(0, 0, _width, _height);
  const _scissor = new Vector4(0, 0, _width, _height);
  let _scissorTest = false;
  const _frustum = new Frustum();
  let _clippingEnabled = false;
  let _localClippingEnabled = false;
  const _projScreenMatrix2 = new Matrix4();
  const _vector3 = new Vector3();
  const _emptyScene = {background: null, fog: null, environment: null, overrideMaterial: null, isScene: true};
  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  }
  let _gl = _context;
  function getContext(contextNames, contextAttributes) {
    for (let i = 0; i < contextNames.length; i++) {
      const contextName = contextNames[i];
      const context = _canvas2.getContext(contextName, contextAttributes);
      if (context !== null)
        return context;
    }
    return null;
  }
  try {
    const contextAttributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference,
      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
    };
    _canvas2.addEventListener("webglcontextlost", onContextLost, false);
    _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
    if (_gl === null) {
      const contextNames = ["webgl2", "webgl", "experimental-webgl"];
      if (_this.isWebGL1Renderer === true) {
        contextNames.shift();
      }
      _gl = getContext(contextNames, contextAttributes);
      if (_gl === null) {
        if (getContext(contextNames)) {
          throw new Error("Error creating WebGL context with your selected attributes.");
        } else {
          throw new Error("Error creating WebGL context.");
        }
      }
    }
    if (_gl.getShaderPrecisionFormat === void 0) {
      _gl.getShaderPrecisionFormat = function() {
        return {rangeMin: 1, rangeMax: 1, precision: 1};
      };
    }
  } catch (error) {
    console.error("THREE.WebGLRenderer: " + error.message);
    throw error;
  }
  let extensions, capabilities, state, info;
  let properties, textures, cubemaps, attributes, geometries, objects;
  let programCache, materials, renderLists, renderStates, clipping, shadowMap;
  let background, morphtargets, bufferRenderer, indexedBufferRenderer;
  let utils, bindingStates;
  function initGLContext() {
    extensions = new WebGLExtensions(_gl);
    capabilities = new WebGLCapabilities(_gl, extensions, parameters);
    extensions.init(capabilities);
    utils = new WebGLUtils(_gl, extensions, capabilities);
    state = new WebGLState(_gl, extensions, capabilities);
    info = new WebGLInfo(_gl);
    properties = new WebGLProperties();
    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
    cubemaps = new WebGLCubeMaps(_this);
    attributes = new WebGLAttributes(_gl, capabilities);
    bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
    objects = new WebGLObjects(_gl, geometries, attributes, info);
    morphtargets = new WebGLMorphtargets(_gl);
    clipping = new WebGLClipping(properties);
    programCache = new WebGLPrograms(_this, cubemaps, extensions, capabilities, bindingStates, clipping);
    materials = new WebGLMaterials(properties);
    renderLists = new WebGLRenderLists(properties);
    renderStates = new WebGLRenderStates(extensions, capabilities);
    background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
    shadowMap = new WebGLShadowMap(_this, objects, capabilities);
    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
    info.programs = programCache.programs;
    _this.capabilities = capabilities;
    _this.extensions = extensions;
    _this.properties = properties;
    _this.renderLists = renderLists;
    _this.shadowMap = shadowMap;
    _this.state = state;
    _this.info = info;
  }
  initGLContext();
  const xr = new WebXRManager(_this, _gl);
  this.xr = xr;
  this.getContext = function() {
    return _gl;
  };
  this.getContextAttributes = function() {
    return _gl.getContextAttributes();
  };
  this.forceContextLoss = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.loseContext();
  };
  this.forceContextRestore = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.restoreContext();
  };
  this.getPixelRatio = function() {
    return _pixelRatio;
  };
  this.setPixelRatio = function(value) {
    if (value === void 0)
      return;
    _pixelRatio = value;
    this.setSize(_width, _height, false);
  };
  this.getSize = function(target) {
    if (target === void 0) {
      console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument");
      target = new Vector2();
    }
    return target.set(_width, _height);
  };
  this.setSize = function(width, height, updateStyle) {
    if (xr.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    _width = width;
    _height = height;
    _canvas2.width = Math.floor(width * _pixelRatio);
    _canvas2.height = Math.floor(height * _pixelRatio);
    if (updateStyle !== false) {
      _canvas2.style.width = width + "px";
      _canvas2.style.height = height + "px";
    }
    this.setViewport(0, 0, width, height);
  };
  this.getDrawingBufferSize = function(target) {
    if (target === void 0) {
      console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument");
      target = new Vector2();
    }
    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
  };
  this.setDrawingBufferSize = function(width, height, pixelRatio) {
    _width = width;
    _height = height;
    _pixelRatio = pixelRatio;
    _canvas2.width = Math.floor(width * pixelRatio);
    _canvas2.height = Math.floor(height * pixelRatio);
    this.setViewport(0, 0, width, height);
  };
  this.getCurrentViewport = function(target) {
    if (target === void 0) {
      console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument");
      target = new Vector4();
    }
    return target.copy(_currentViewport);
  };
  this.getViewport = function(target) {
    return target.copy(_viewport);
  };
  this.setViewport = function(x, y, width, height) {
    if (x.isVector4) {
      _viewport.set(x.x, x.y, x.z, x.w);
    } else {
      _viewport.set(x, y, width, height);
    }
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissor = function(target) {
    return target.copy(_scissor);
  };
  this.setScissor = function(x, y, width, height) {
    if (x.isVector4) {
      _scissor.set(x.x, x.y, x.z, x.w);
    } else {
      _scissor.set(x, y, width, height);
    }
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissorTest = function() {
    return _scissorTest;
  };
  this.setScissorTest = function(boolean) {
    state.setScissorTest(_scissorTest = boolean);
  };
  this.setOpaqueSort = function(method) {
    _opaqueSort = method;
  };
  this.setTransparentSort = function(method) {
    _transparentSort = method;
  };
  this.getClearColor = function(target) {
    if (target === void 0) {
      console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument");
      target = new Color();
    }
    return target.copy(background.getClearColor());
  };
  this.setClearColor = function() {
    background.setClearColor.apply(background, arguments);
  };
  this.getClearAlpha = function() {
    return background.getClearAlpha();
  };
  this.setClearAlpha = function() {
    background.setClearAlpha.apply(background, arguments);
  };
  this.clear = function(color, depth, stencil) {
    let bits = 0;
    if (color === void 0 || color)
      bits |= 16384;
    if (depth === void 0 || depth)
      bits |= 256;
    if (stencil === void 0 || stencil)
      bits |= 1024;
    _gl.clear(bits);
  };
  this.clearColor = function() {
    this.clear(true, false, false);
  };
  this.clearDepth = function() {
    this.clear(false, true, false);
  };
  this.clearStencil = function() {
    this.clear(false, false, true);
  };
  this.dispose = function() {
    _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
    _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
    renderLists.dispose();
    renderStates.dispose();
    properties.dispose();
    cubemaps.dispose();
    objects.dispose();
    bindingStates.dispose();
    xr.dispose();
    xr.removeEventListener("sessionstart", onXRSessionStart);
    xr.removeEventListener("sessionend", onXRSessionEnd);
    animation.stop();
  };
  function onContextLost(event) {
    event.preventDefault();
    console.log("THREE.WebGLRenderer: Context Lost.");
    _isContextLost = true;
  }
  function onContextRestore() {
    console.log("THREE.WebGLRenderer: Context Restored.");
    _isContextLost = false;
    const infoAutoReset = info.autoReset;
    const shadowMapEnabled = shadowMap.enabled;
    const shadowMapAutoUpdate = shadowMap.autoUpdate;
    const shadowMapNeedsUpdate = shadowMap.needsUpdate;
    const shadowMapType = shadowMap.type;
    initGLContext();
    info.autoReset = infoAutoReset;
    shadowMap.enabled = shadowMapEnabled;
    shadowMap.autoUpdate = shadowMapAutoUpdate;
    shadowMap.needsUpdate = shadowMapNeedsUpdate;
    shadowMap.type = shadowMapType;
  }
  function onMaterialDispose(event) {
    const material = event.target;
    material.removeEventListener("dispose", onMaterialDispose);
    deallocateMaterial(material);
  }
  function deallocateMaterial(material) {
    releaseMaterialProgramReferences(material);
    properties.remove(material);
  }
  function releaseMaterialProgramReferences(material) {
    const programs = properties.get(material).programs;
    if (programs !== void 0) {
      programs.forEach(function(program) {
        programCache.releaseProgram(program);
      });
    }
  }
  function renderObjectImmediate(object, program) {
    object.render(function(object2) {
      _this.renderBufferImmediate(object2, program);
    });
  }
  this.renderBufferImmediate = function(object, program) {
    bindingStates.initAttributes();
    const buffers = properties.get(object);
    if (object.hasPositions && !buffers.position)
      buffers.position = _gl.createBuffer();
    if (object.hasNormals && !buffers.normal)
      buffers.normal = _gl.createBuffer();
    if (object.hasUvs && !buffers.uv)
      buffers.uv = _gl.createBuffer();
    if (object.hasColors && !buffers.color)
      buffers.color = _gl.createBuffer();
    const programAttributes = program.getAttributes();
    if (object.hasPositions) {
      _gl.bindBuffer(34962, buffers.position);
      _gl.bufferData(34962, object.positionArray, 35048);
      bindingStates.enableAttribute(programAttributes.position);
      _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
    }
    if (object.hasNormals) {
      _gl.bindBuffer(34962, buffers.normal);
      _gl.bufferData(34962, object.normalArray, 35048);
      bindingStates.enableAttribute(programAttributes.normal);
      _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
    }
    if (object.hasUvs) {
      _gl.bindBuffer(34962, buffers.uv);
      _gl.bufferData(34962, object.uvArray, 35048);
      bindingStates.enableAttribute(programAttributes.uv);
      _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
    }
    if (object.hasColors) {
      _gl.bindBuffer(34962, buffers.color);
      _gl.bufferData(34962, object.colorArray, 35048);
      bindingStates.enableAttribute(programAttributes.color);
      _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
    }
    bindingStates.disableUnusedAttributes();
    _gl.drawArrays(4, 0, object.count);
    object.count = 0;
  };
  this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
    if (scene === null)
      scene = _emptyScene;
    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
    const program = setProgram(camera, scene, material, object);
    state.setMaterial(material, frontFaceCW);
    let index = geometry.index;
    const position = geometry.attributes.position;
    if (index === null) {
      if (position === void 0 || position.count === 0)
        return;
    } else if (index.count === 0) {
      return;
    }
    let rangeFactor = 1;
    if (material.wireframe === true) {
      index = geometries.getWireframeAttribute(geometry);
      rangeFactor = 2;
    }
    if (material.morphTargets || material.morphNormals) {
      morphtargets.update(object, geometry, material, program);
    }
    bindingStates.setup(object, material, program, geometry, index);
    let attribute;
    let renderer = bufferRenderer;
    if (index !== null) {
      attribute = attributes.get(index);
      renderer = indexedBufferRenderer;
      renderer.setIndex(attribute);
    }
    const dataCount = index !== null ? index.count : position.count;
    const rangeStart = geometry.drawRange.start * rangeFactor;
    const rangeCount = geometry.drawRange.count * rangeFactor;
    const groupStart = group !== null ? group.start * rangeFactor : 0;
    const groupCount = group !== null ? group.count * rangeFactor : Infinity;
    const drawStart = Math.max(rangeStart, groupStart);
    const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    const drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0)
      return;
    if (object.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer.setMode(1);
      } else {
        renderer.setMode(4);
      }
    } else if (object.isLine) {
      let lineWidth = material.linewidth;
      if (lineWidth === void 0)
        lineWidth = 1;
      state.setLineWidth(lineWidth * getTargetPixelRatio());
      if (object.isLineSegments) {
        renderer.setMode(1);
      } else if (object.isLineLoop) {
        renderer.setMode(2);
      } else {
        renderer.setMode(3);
      }
    } else if (object.isPoints) {
      renderer.setMode(0);
    } else if (object.isSprite) {
      renderer.setMode(4);
    }
    if (object.isInstancedMesh) {
      renderer.renderInstances(drawStart, drawCount, object.count);
    } else if (geometry.isInstancedBufferGeometry) {
      const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
      renderer.renderInstances(drawStart, drawCount, instanceCount);
    } else {
      renderer.render(drawStart, drawCount);
    }
  };
  this.compile = function(scene, camera) {
    currentRenderState = renderStates.get(scene);
    currentRenderState.init();
    scene.traverseVisible(function(object) {
      if (object.isLight && object.layers.test(camera.layers)) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      }
    });
    currentRenderState.setupLights();
    scene.traverse(function(object) {
      const material = object.material;
      if (material) {
        if (Array.isArray(material)) {
          for (let i = 0; i < material.length; i++) {
            const material2 = material[i];
            getProgram(material2, scene, object);
          }
        } else {
          getProgram(material, scene, object);
        }
      }
    });
  };
  let onAnimationFrameCallback = null;
  function onAnimationFrame(time) {
    if (onAnimationFrameCallback)
      onAnimationFrameCallback(time);
  }
  function onXRSessionStart() {
    animation.stop();
  }
  function onXRSessionEnd() {
    animation.start();
  }
  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  if (typeof window !== "undefined")
    animation.setContext(window);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
    xr.setAnimationLoop(callback);
    callback === null ? animation.stop() : animation.start();
  };
  xr.addEventListener("sessionstart", onXRSessionStart);
  xr.addEventListener("sessionend", onXRSessionEnd);
  this.render = function(scene, camera) {
    let renderTarget, forceClear;
    if (arguments[2] !== void 0) {
      console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
      renderTarget = arguments[2];
    }
    if (arguments[3] !== void 0) {
      console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
      forceClear = arguments[3];
    }
    if (camera !== void 0 && camera.isCamera !== true) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (_isContextLost === true)
      return;
    if (scene.autoUpdate === true)
      scene.updateMatrixWorld();
    if (camera.parent === null)
      camera.updateMatrixWorld();
    if (xr.enabled === true && xr.isPresenting === true) {
      camera = xr.getCamera(camera);
    }
    if (scene.isScene === true)
      scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);
    currentRenderState = renderStates.get(scene, renderStateStack.length);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);
    _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromProjectionMatrix(_projScreenMatrix2);
    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
    currentRenderList = renderLists.get(scene, renderListStack.length);
    currentRenderList.init();
    renderListStack.push(currentRenderList);
    projectObject(scene, camera, 0, _this.sortObjects);
    currentRenderList.finish();
    if (_this.sortObjects === true) {
      currentRenderList.sort(_opaqueSort, _transparentSort);
    }
    if (_clippingEnabled === true)
      clipping.beginShadows();
    const shadowsArray = currentRenderState.state.shadowsArray;
    shadowMap.render(shadowsArray, scene, camera);
    currentRenderState.setupLights();
    currentRenderState.setupLightsView(camera);
    if (_clippingEnabled === true)
      clipping.endShadows();
    if (this.info.autoReset === true)
      this.info.reset();
    if (renderTarget !== void 0) {
      this.setRenderTarget(renderTarget);
    }
    background.render(currentRenderList, scene, camera, forceClear);
    const opaqueObjects = currentRenderList.opaque;
    const transparentObjects = currentRenderList.transparent;
    if (opaqueObjects.length > 0)
      renderObjects(opaqueObjects, scene, camera);
    if (transparentObjects.length > 0)
      renderObjects(transparentObjects, scene, camera);
    if (_currentRenderTarget !== null) {
      textures.updateRenderTargetMipmap(_currentRenderTarget);
      textures.updateMultisampleRenderTarget(_currentRenderTarget);
    }
    if (scene.isScene === true)
      scene.onAfterRender(_this, scene, camera);
    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    state.setPolygonOffset(false);
    bindingStates.resetDefaultState();
    _currentMaterialId = -1;
    _currentCamera = null;
    renderStateStack.pop();
    if (renderStateStack.length > 0) {
      currentRenderState = renderStateStack[renderStateStack.length - 1];
    } else {
      currentRenderState = null;
    }
    renderListStack.pop();
    if (renderListStack.length > 0) {
      currentRenderList = renderListStack[renderListStack.length - 1];
    } else {
      currentRenderList = null;
    }
  };
  function projectObject(object, camera, groupOrder, sortObjects) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
      } else if (object.isLOD) {
        if (object.autoUpdate === true)
          object.update(camera);
      } else if (object.isLight) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry = objects.update(object);
          const material = object.material;
          if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      } else if (object.isImmediateRenderObject) {
        if (sortObjects) {
          _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
        }
        currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (object.isSkinnedMesh) {
          if (object.skeleton.frame !== info.render.frame) {
            object.skeleton.update();
            object.skeleton.frame = info.render.frame;
          }
        }
        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry = objects.update(object);
          const material = object.material;
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let i = 0, l = groups.length; i < l; i++) {
              const group = groups[i];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      }
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      projectObject(children[i], camera, groupOrder, sortObjects);
    }
  }
  function renderObjects(renderList, scene, camera) {
    const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
    for (let i = 0, l = renderList.length; i < l; i++) {
      const renderItem = renderList[i];
      const object = renderItem.object;
      const geometry = renderItem.geometry;
      const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
      const group = renderItem.group;
      if (camera.isArrayCamera) {
        const cameras = camera.cameras;
        for (let j = 0, jl = cameras.length; j < jl; j++) {
          const camera2 = cameras[j];
          if (object.layers.test(camera2.layers)) {
            state.viewport(_currentViewport.copy(camera2.viewport));
            currentRenderState.setupLightsView(camera2);
            renderObject(object, scene, camera2, geometry, material, group);
          }
        }
      } else {
        renderObject(object, scene, camera, geometry, material, group);
      }
    }
  }
  function renderObject(object, scene, camera, geometry, material, group) {
    object.onBeforeRender(_this, scene, camera, geometry, material, group);
    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
    if (object.isImmediateRenderObject) {
      const program = setProgram(camera, scene, material, object);
      state.setMaterial(material);
      bindingStates.reset();
      renderObjectImmediate(object, program);
    } else {
      _this.renderBufferDirect(camera, scene, geometry, material, object, group);
    }
    object.onAfterRender(_this, scene, camera, geometry, material, group);
  }
  function getProgram(material, scene, object) {
    if (scene.isScene !== true)
      scene = _emptyScene;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    const shadowsArray = currentRenderState.state.shadowsArray;
    const lightsStateVersion = lights.state.version;
    const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
    const programCacheKey = programCache.getProgramCacheKey(parameters2);
    let programs = materialProperties.programs;
    materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
    materialProperties.fog = scene.fog;
    materialProperties.envMap = cubemaps.get(material.envMap || materialProperties.environment);
    if (programs === void 0) {
      material.addEventListener("dispose", onMaterialDispose);
      programs = new Map();
      materialProperties.programs = programs;
    }
    let program = programs.get(programCacheKey);
    if (program !== void 0) {
      if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
        updateCommonMaterialProperties(material, parameters2);
        return program;
      }
    } else {
      parameters2.uniforms = programCache.getUniforms(material);
      material.onBeforeCompile(parameters2, _this);
      program = programCache.acquireProgram(parameters2, programCacheKey);
      programs.set(programCacheKey, program);
      materialProperties.uniforms = parameters2.uniforms;
    }
    const uniforms = materialProperties.uniforms;
    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
      uniforms.clippingPlanes = clipping.uniform;
    }
    updateCommonMaterialProperties(material, parameters2);
    materialProperties.needsLights = materialNeedsLights(material);
    materialProperties.lightsStateVersion = lightsStateVersion;
    if (materialProperties.needsLights) {
      uniforms.ambientLightColor.value = lights.state.ambient;
      uniforms.lightProbe.value = lights.state.probe;
      uniforms.directionalLights.value = lights.state.directional;
      uniforms.directionalLightShadows.value = lights.state.directionalShadow;
      uniforms.spotLights.value = lights.state.spot;
      uniforms.spotLightShadows.value = lights.state.spotShadow;
      uniforms.rectAreaLights.value = lights.state.rectArea;
      uniforms.ltc_1.value = lights.state.rectAreaLTC1;
      uniforms.ltc_2.value = lights.state.rectAreaLTC2;
      uniforms.pointLights.value = lights.state.point;
      uniforms.pointLightShadows.value = lights.state.pointShadow;
      uniforms.hemisphereLights.value = lights.state.hemi;
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
    }
    const progUniforms = program.getUniforms();
    const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.currentProgram = program;
    materialProperties.uniformsList = uniformsList;
    return program;
  }
  function updateCommonMaterialProperties(material, parameters2) {
    const materialProperties = properties.get(material);
    materialProperties.outputEncoding = parameters2.outputEncoding;
    materialProperties.instancing = parameters2.instancing;
    materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
    materialProperties.numIntersection = parameters2.numClipIntersection;
    materialProperties.vertexAlphas = parameters2.vertexAlphas;
  }
  function setProgram(camera, scene, material, object) {
    if (scene.isScene !== true)
      scene = _emptyScene;
    textures.resetTextureUnits();
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
    const envMap = cubemaps.get(material.envMap || environment);
    const vertexAlphas = material.vertexColors === true && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    if (_clippingEnabled === true) {
      if (_localClippingEnabled === true || camera !== _currentCamera) {
        const useCache = camera === _currentCamera && material.id === _currentMaterialId;
        clipping.setState(material, camera, useCache);
      }
    }
    let needsProgramChange = false;
    if (material.version === materialProperties.__version) {
      if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
        needsProgramChange = true;
      } else if (materialProperties.outputEncoding !== encoding) {
        needsProgramChange = true;
      } else if (object.isInstancedMesh && materialProperties.instancing === false) {
        needsProgramChange = true;
      } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
        needsProgramChange = true;
      } else if (materialProperties.envMap !== envMap) {
        needsProgramChange = true;
      } else if (material.fog && materialProperties.fog !== fog) {
        needsProgramChange = true;
      } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
        needsProgramChange = true;
      } else if (materialProperties.vertexAlphas !== vertexAlphas) {
        needsProgramChange = true;
      }
    } else {
      needsProgramChange = true;
      materialProperties.__version = material.version;
    }
    let program = materialProperties.currentProgram;
    if (needsProgramChange === true) {
      program = getProgram(material, scene, object);
    }
    let refreshProgram = false;
    let refreshMaterial = false;
    let refreshLights = false;
    const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
    if (state.useProgram(program.program)) {
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }
    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }
    if (refreshProgram || _currentCamera !== camera) {
      p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2));
      }
      if (_currentCamera !== camera) {
        _currentCamera = camera;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
        const uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
        }
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
        p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || material.skinning) {
        p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
      }
    }
    if (material.skinning) {
      p_uniforms.setOptional(_gl, object, "bindMatrix");
      p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
      const skeleton = object.skeleton;
      if (skeleton) {
        const bones = skeleton.bones;
        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === null) {
            let size = Math.sqrt(bones.length * 4);
            size = MathUtils.ceilPowerOfTwo(size);
            size = Math.max(size, 4);
            const boneMatrices = new Float32Array(size * size * 4);
            boneMatrices.set(skeleton.boneMatrices);
            const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
            skeleton.boneMatrices = boneMatrices;
            skeleton.boneTexture = boneTexture;
            skeleton.boneTextureSize = size;
          }
          p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
          p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
        } else {
          p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
        }
      }
    }
    if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
      materialProperties.receiveShadow = object.receiveShadow;
      p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
    }
    if (refreshMaterial) {
      p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
      if (materialProperties.needsLights) {
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      }
      if (fog && material.fog) {
        materials.refreshFogUniforms(m_uniforms, fog);
      }
      materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height);
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
    }
    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      material.uniformsNeedUpdate = false;
    }
    if (material.isSpriteMaterial) {
      p_uniforms.setValue(_gl, "center", object.center);
    }
    p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
    p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
    p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
    return program;
  }
  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.lightProbe.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.directionalLightShadows.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.pointLightShadows.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.spotLightShadows.needsUpdate = value;
    uniforms.rectAreaLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
  }
  function materialNeedsLights(material) {
    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
  }
  this.getActiveCubeFace = function() {
    return _currentActiveCubeFace;
  };
  this.getActiveMipmapLevel = function() {
    return _currentActiveMipmapLevel;
  };
  this.getRenderTarget = function() {
    return _currentRenderTarget;
  };
  this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
    _currentRenderTarget = renderTarget;
    _currentActiveCubeFace = activeCubeFace;
    _currentActiveMipmapLevel = activeMipmapLevel;
    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === void 0) {
      textures.setupRenderTarget(renderTarget);
    }
    let framebuffer = null;
    let isCube = false;
    let isRenderTarget3D = false;
    if (renderTarget) {
      const texture = renderTarget.texture;
      if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
        isRenderTarget3D = true;
      }
      const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget) {
        framebuffer = __webglFramebuffer[activeCubeFace];
        isCube = true;
      } else if (renderTarget.isWebGLMultisampleRenderTarget) {
        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
      } else {
        framebuffer = __webglFramebuffer;
      }
      _currentViewport.copy(renderTarget.viewport);
      _currentScissor.copy(renderTarget.scissor);
      _currentScissorTest = renderTarget.scissorTest;
    } else {
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
      _currentScissorTest = _scissorTest;
    }
    state.bindFramebuffer(36160, framebuffer);
    state.viewport(_currentViewport);
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);
    if (isCube) {
      const textureProperties = properties.get(renderTarget.texture);
      _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
    } else if (isRenderTarget3D) {
      const textureProperties = properties.get(renderTarget.texture);
      const layer = activeCubeFace || 0;
      _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
    }
  };
  this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let framebuffer = properties.get(renderTarget).__webglFramebuffer;
    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
      framebuffer = framebuffer[activeCubeFaceIndex];
    }
    if (framebuffer) {
      state.bindFramebuffer(36160, framebuffer);
      try {
        const texture = renderTarget.texture;
        const textureFormat = texture.format;
        const textureType = texture.type;
        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        if (_gl.checkFramebufferStatus(36160) === 36053) {
          if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
            _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } else {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
        }
      } finally {
        const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
        state.bindFramebuffer(36160, framebuffer2);
      }
    }
  };
  this.copyFramebufferToTexture = function(position, texture, level = 0) {
    const levelScale = Math.pow(2, -level);
    const width = Math.floor(texture.image.width * levelScale);
    const height = Math.floor(texture.image.height * levelScale);
    const glFormat = utils.convert(texture.format);
    textures.setTexture2D(texture, 0);
    _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);
    state.unbindTexture();
  };
  this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
    const width = srcTexture.image.width;
    const height = srcTexture.image.height;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    textures.setTexture2D(dstTexture, 0);
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
      } else {
        _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
      }
    }
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(3553);
    state.unbindTexture();
  };
  this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
    if (_this.isWebGL1Renderer) {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      return;
    }
    const {width, height, data} = srcTexture.image;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    let glTarget;
    if (dstTexture.isDataTexture3D) {
      textures.setTexture3D(dstTexture, 0);
      glTarget = 32879;
    } else if (dstTexture.isDataTexture2DArray) {
      textures.setTexture2DArray(dstTexture, 0);
      glTarget = 35866;
    } else {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      return;
    }
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    const unpackRowLen = _gl.getParameter(3314);
    const unpackImageHeight = _gl.getParameter(32878);
    const unpackSkipPixels = _gl.getParameter(3316);
    const unpackSkipRows = _gl.getParameter(3315);
    const unpackSkipImages = _gl.getParameter(32877);
    _gl.pixelStorei(3314, width);
    _gl.pixelStorei(32878, height);
    _gl.pixelStorei(3316, sourceBox.min.x);
    _gl.pixelStorei(3315, sourceBox.min.y);
    _gl.pixelStorei(32877, sourceBox.min.z);
    _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, sourceBox.max.x - sourceBox.min.x + 1, sourceBox.max.y - sourceBox.min.y + 1, sourceBox.max.z - sourceBox.min.z + 1, glFormat, glType, data);
    _gl.pixelStorei(3314, unpackRowLen);
    _gl.pixelStorei(32878, unpackImageHeight);
    _gl.pixelStorei(3316, unpackSkipPixels);
    _gl.pixelStorei(3315, unpackSkipRows);
    _gl.pixelStorei(32877, unpackSkipImages);
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(glTarget);
    state.unbindTexture();
  };
  this.initTexture = function(texture) {
    textures.setTexture2D(texture, 0);
    state.unbindTexture();
  };
  this.resetState = function() {
    _currentActiveCubeFace = 0;
    _currentActiveMipmapLevel = 0;
    _currentRenderTarget = null;
    state.reset();
    bindingStates.reset();
  };
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}));
  }
}
class Scene extends Object3D {
  constructor() {
    super();
    this.type = "Scene";
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.overrideMaterial = null;
    this.autoUpdate = true;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}));
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null)
      this.background = source.background.clone();
    if (source.environment !== null)
      this.environment = source.environment.clone();
    if (source.fog !== null)
      this.fog = source.fog.clone();
    if (source.overrideMaterial !== null)
      this.overrideMaterial = source.overrideMaterial.clone();
    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.background !== null)
      data.object.background = this.background.toJSON(meta);
    if (this.environment !== null)
      data.object.environment = this.environment.toJSON(meta);
    if (this.fog !== null)
      data.object.fog = this.fog.toJSON();
    return data;
  }
}
Scene.prototype.isScene = true;
function InterleavedBuffer(array, stride) {
  this.array = array;
  this.stride = stride;
  this.count = array !== void 0 ? array.length / stride : 0;
  this.usage = StaticDrawUsage;
  this.updateRange = {offset: 0, count: -1};
  this.version = 0;
  this.uuid = MathUtils.generateUUID();
}
Object.defineProperty(InterleavedBuffer.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
Object.assign(InterleavedBuffer.prototype, {
  isInterleavedBuffer: true,
  onUploadCallback: function() {
  },
  setUsage: function(value) {
    this.usage = value;
    return this;
  },
  copy: function(source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.usage = source.usage;
    return this;
  },
  copyAt: function(index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;
    for (let i = 0, l = this.stride; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  },
  set: function(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  },
  clone: function(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = MathUtils.generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }
    const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
    const ib = new InterleavedBuffer(array, this.stride);
    ib.setUsage(this.usage);
    return ib;
  },
  onUpload: function(callback) {
    this.onUploadCallback = callback;
    return this;
  },
  toJSON: function(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = MathUtils.generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
    }
    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
});
const _vector$6 = new Vector3();
function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
  this.name = "";
  this.data = interleavedBuffer;
  this.itemSize = itemSize;
  this.offset = offset;
  this.normalized = normalized === true;
}
Object.defineProperties(InterleavedBufferAttribute.prototype, {
  count: {
    get: function() {
      return this.data.count;
    }
  },
  array: {
    get: function() {
      return this.data.array;
    }
  },
  needsUpdate: {
    set: function(value) {
      this.data.needsUpdate = value;
    }
  }
});
Object.assign(InterleavedBufferAttribute.prototype, {
  isInterleavedBufferAttribute: true,
  applyMatrix4: function(m) {
    for (let i = 0, l = this.data.count; i < l; i++) {
      _vector$6.x = this.getX(i);
      _vector$6.y = this.getY(i);
      _vector$6.z = this.getZ(i);
      _vector$6.applyMatrix4(m);
      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  },
  applyNormalMatrix: function(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$6.x = this.getX(i);
      _vector$6.y = this.getY(i);
      _vector$6.z = this.getZ(i);
      _vector$6.applyNormalMatrix(m);
      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  },
  transformDirection: function(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$6.x = this.getX(i);
      _vector$6.y = this.getY(i);
      _vector$6.z = this.getZ(i);
      _vector$6.transformDirection(m);
      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  },
  setX: function(index, x) {
    this.data.array[index * this.data.stride + this.offset] = x;
    return this;
  },
  setY: function(index, y) {
    this.data.array[index * this.data.stride + this.offset + 1] = y;
    return this;
  },
  setZ: function(index, z) {
    this.data.array[index * this.data.stride + this.offset + 2] = z;
    return this;
  },
  setW: function(index, w) {
    this.data.array[index * this.data.stride + this.offset + 3] = w;
    return this;
  },
  getX: function(index) {
    return this.data.array[index * this.data.stride + this.offset];
  },
  getY: function(index) {
    return this.data.array[index * this.data.stride + this.offset + 1];
  },
  getZ: function(index) {
    return this.data.array[index * this.data.stride + this.offset + 2];
  },
  getW: function(index) {
    return this.data.array[index * this.data.stride + this.offset + 3];
  },
  setXY: function(index, x, y) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    return this;
  },
  setXYZ: function(index, x, y, z) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    return this;
  },
  setXYZW: function(index, x, y, z, w) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    this.data.array[index + 3] = w;
    return this;
  },
  clone: function(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
      const array = [];
      for (let i = 0; i < this.count; i++) {
        const index = i * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j]);
        }
      }
      return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
      }
      return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  },
  toJSON: function(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
      const array = [];
      for (let i = 0; i < this.count; i++) {
        const index = i * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j]);
        }
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array,
        normalized: this.normalized
      };
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
      }
      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
});
const _basePosition = new Vector3();
const _skinIndex = new Vector4();
const _skinWeight = new Vector4();
const _vector$5 = new Vector3();
const _matrix = new Matrix4();
function SkinnedMesh(geometry, material) {
  Mesh.call(this, geometry, material);
  this.type = "SkinnedMesh";
  this.bindMode = "attached";
  this.bindMatrix = new Matrix4();
  this.bindMatrixInverse = new Matrix4();
}
SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: SkinnedMesh,
  isSkinnedMesh: true,
  copy: function(source) {
    Mesh.prototype.copy.call(this, source);
    this.bindMode = source.bindMode;
    this.bindMatrix.copy(source.bindMatrix);
    this.bindMatrixInverse.copy(source.bindMatrixInverse);
    this.skeleton = source.skeleton;
    return this;
  },
  bind: function(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === void 0) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.copy(bindMatrix).invert();
  },
  pose: function() {
    this.skeleton.pose();
  },
  normalizeSkinWeights: function() {
    const vector = new Vector4();
    const skinWeight = this.geometry.attributes.skinWeight;
    for (let i = 0, l = skinWeight.count; i < l; i++) {
      vector.x = skinWeight.getX(i);
      vector.y = skinWeight.getY(i);
      vector.z = skinWeight.getZ(i);
      vector.w = skinWeight.getW(i);
      const scale = 1 / vector.manhattanLength();
      if (scale !== Infinity) {
        vector.multiplyScalar(scale);
      } else {
        vector.set(1, 0, 0, 0);
      }
      skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
    }
  },
  updateMatrixWorld: function(force) {
    Mesh.prototype.updateMatrixWorld.call(this, force);
    if (this.bindMode === "attached") {
      this.bindMatrixInverse.copy(this.matrixWorld).invert();
    } else if (this.bindMode === "detached") {
      this.bindMatrixInverse.copy(this.bindMatrix).invert();
    } else {
      console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
  },
  boneTransform: function(index, target) {
    const skeleton = this.skeleton;
    const geometry = this.geometry;
    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
    _basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);
    target.set(0, 0, 0);
    for (let i = 0; i < 4; i++) {
      const weight = _skinWeight.getComponent(i);
      if (weight !== 0) {
        const boneIndex = _skinIndex.getComponent(i);
        _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
        target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
      }
    }
    return target.applyMatrix4(this.bindMatrixInverse);
  }
});
function Bone() {
  Object3D.call(this);
  this.type = "Bone";
}
Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Bone,
  isBone: true
});
const _offsetMatrix = /* @__PURE__ */ new Matrix4();
const _identityMatrix = /* @__PURE__ */ new Matrix4();
class Skeleton {
  constructor(bones = [], boneInverses = []) {
    this.uuid = MathUtils.generateUUID();
    this.bones = bones.slice(0);
    this.boneInverses = boneInverses;
    this.boneMatrices = null;
    this.boneTexture = null;
    this.boneTextureSize = 0;
    this.frame = -1;
    this.init();
  }
  init() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    this.boneMatrices = new Float32Array(bones.length * 16);
    if (boneInverses.length === 0) {
      this.calculateInverses();
    } else {
      if (bones.length !== boneInverses.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
        this.boneInverses = [];
        for (let i = 0, il = this.bones.length; i < il; i++) {
          this.boneInverses.push(new Matrix4());
        }
      }
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const inverse = new Matrix4();
      if (this.bones[i]) {
        inverse.copy(this.bones[i].matrixWorld).invert();
      }
      this.boneInverses.push(inverse);
    }
  }
  pose() {
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone) {
        bone.matrixWorld.copy(this.boneInverses[i]).invert();
      }
    }
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.copy(bone.parent.matrixWorld).invert();
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  }
  update() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    const boneMatrices = this.boneMatrices;
    const boneTexture = this.boneTexture;
    for (let i = 0, il = bones.length; i < il; i++) {
      const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;
      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
      _offsetMatrix.toArray(boneMatrices, i * 16);
    }
    if (boneTexture !== null) {
      boneTexture.needsUpdate = true;
    }
  }
  clone() {
    return new Skeleton(this.bones, this.boneInverses);
  }
  getBoneByName(name) {
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone.name === name) {
        return bone;
      }
    }
    return void 0;
  }
  dispose() {
    if (this.boneTexture !== null) {
      this.boneTexture.dispose();
      this.boneTexture = null;
    }
  }
  fromJSON(json, bones) {
    this.uuid = json.uuid;
    for (let i = 0, l = json.bones.length; i < l; i++) {
      const uuid = json.bones[i];
      let bone = bones[uuid];
      if (bone === void 0) {
        console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
        bone = new Bone();
      }
      this.bones.push(bone);
      this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));
    }
    this.init();
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    data.uuid = this.uuid;
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    for (let i = 0, l = bones.length; i < l; i++) {
      const bone = bones[i];
      data.bones.push(bone.uuid);
      const boneInverse = boneInverses[i];
      data.boneInverses.push(boneInverse.toArray());
    }
    return data;
  }
}
const _instanceLocalMatrix = new Matrix4();
const _instanceWorldMatrix = new Matrix4();
const _instanceIntersects = [];
const _mesh = new Mesh();
function InstancedMesh(geometry, material, count) {
  Mesh.call(this, geometry, material);
  this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);
  this.instanceColor = null;
  this.count = count;
  this.frustumCulled = false;
}
InstancedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: InstancedMesh,
  isInstancedMesh: true,
  copy: function(source) {
    Mesh.prototype.copy.call(this, source);
    this.instanceMatrix.copy(source.instanceMatrix);
    if (source.instanceColor !== null)
      this.instanceColor = source.instanceColor.clone();
    this.count = source.count;
    return this;
  },
  getColorAt: function(index, color) {
    color.fromArray(this.instanceColor.array, index * 3);
  },
  getMatrixAt: function(index, matrix) {
    matrix.fromArray(this.instanceMatrix.array, index * 16);
  },
  raycast: function(raycaster, intersects) {
    const matrixWorld = this.matrixWorld;
    const raycastTimes = this.count;
    _mesh.geometry = this.geometry;
    _mesh.material = this.material;
    if (_mesh.material === void 0)
      return;
    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
      this.getMatrixAt(instanceId, _instanceLocalMatrix);
      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
      _mesh.matrixWorld = _instanceWorldMatrix;
      _mesh.raycast(raycaster, _instanceIntersects);
      for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
        const intersect = _instanceIntersects[i];
        intersect.instanceId = instanceId;
        intersect.object = this;
        intersects.push(intersect);
      }
      _instanceIntersects.length = 0;
    }
  },
  setColorAt: function(index, color) {
    if (this.instanceColor === null) {
      this.instanceColor = new BufferAttribute(new Float32Array(this.count * 3), 3);
    }
    color.toArray(this.instanceColor.array, index * 3);
  },
  setMatrixAt: function(index, matrix) {
    matrix.toArray(this.instanceMatrix.array, index * 16);
  },
  updateMorphTargets: function() {
  },
  dispose: function() {
    this.dispatchEvent({type: "dispose"});
  }
});
class LineBasicMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "LineBasicMaterial";
    this.color = new Color(16777215);
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.morphTargets = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    this.morphTargets = source.morphTargets;
    return this;
  }
}
LineBasicMaterial.prototype.isLineBasicMaterial = true;
const _start$1 = new Vector3();
const _end$1 = new Vector3();
const _inverseMatrix$1 = new Matrix4();
const _ray$1 = new Ray();
const _sphere$1 = new Sphere();
function Line(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
  Object3D.call(this);
  this.type = "Line";
  this.geometry = geometry;
  this.material = material;
  this.updateMorphTargets();
}
Line.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Line,
  isLine: true,
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  computeLineDistances: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [0];
        for (let i = 1, l = positionAttribute.count; i < l; i++) {
          _start$1.fromBufferAttribute(positionAttribute, i - 1);
          _end$1.fromBufferAttribute(positionAttribute, i);
          lineDistances[i] = lineDistances[i - 1];
          lineDistances[i] += _start$1.distanceTo(_end$1);
        }
        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    return this;
  },
  raycast: function(raycaster, intersects) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Line.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$1.copy(geometry.boundingSphere);
    _sphere$1.applyMatrix4(matrixWorld);
    _sphere$1.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$1) === false)
      return;
    _inverseMatrix$1.copy(matrixWorld).invert();
    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const vStart = new Vector3();
    const vEnd = new Vector3();
    const interSegment = new Vector3();
    const interRay = new Vector3();
    const step = this.isLineSegments ? 2 : 1;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index !== null) {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);
        for (let i = start, l = end - 1; i < l; i += step) {
          const a = index.getX(i);
          const b = index.getX(i + 1);
          vStart.fromBufferAttribute(positionAttribute, a);
          vEnd.fromBufferAttribute(positionAttribute, b);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far)
            continue;
          intersects.push({
            distance,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
        for (let i = start, l = end - 1; i < l; i += step) {
          vStart.fromBufferAttribute(positionAttribute, i);
          vEnd.fromBufferAttribute(positionAttribute, i + 1);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far)
            continue;
          intersects.push({
            distance,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  },
  updateMorphTargets: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
});
const _start = new Vector3();
const _end = new Vector3();
function LineSegments(geometry, material) {
  Line.call(this, geometry, material);
  this.type = "LineSegments";
}
LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
  constructor: LineSegments,
  isLineSegments: true,
  computeLineDistances: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [];
        for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
          _start.fromBufferAttribute(positionAttribute, i);
          _end.fromBufferAttribute(positionAttribute, i + 1);
          lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
          lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
        }
        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    return this;
  }
});
class LineLoop extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.type = "LineLoop";
  }
}
LineLoop.prototype.isLineLoop = true;
class PointsMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "PointsMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.morphTargets = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    this.morphTargets = source.morphTargets;
    return this;
  }
}
PointsMaterial.prototype.isPointsMaterial = true;
const _inverseMatrix = new Matrix4();
const _ray = new Ray();
const _sphere = new Sphere();
const _position$2 = new Vector3();
function Points(geometry = new BufferGeometry(), material = new PointsMaterial()) {
  Object3D.call(this);
  this.type = "Points";
  this.geometry = geometry;
  this.material = material;
  this.updateMorphTargets();
}
Points.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Points,
  isPoints: true,
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  raycast: function(raycaster, intersects) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Points.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere.copy(geometry.boundingSphere);
    _sphere.applyMatrix4(matrixWorld);
    _sphere.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere) === false)
      return;
    _inverseMatrix.copy(matrixWorld).invert();
    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index !== null) {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);
        for (let i = start, il = end; i < il; i++) {
          const a = index.getX(i);
          _position$2.fromBufferAttribute(positionAttribute, a);
          testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
        for (let i = start, l = end; i < l; i++) {
          _position$2.fromBufferAttribute(positionAttribute, i);
          testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this);
        }
      }
    } else {
      console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  },
  updateMorphTargets: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
});
function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
  const rayPointDistanceSq = _ray.distanceSqToPoint(point);
  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3();
    _ray.closestPointToPoint(point, intersectPoint);
    intersectPoint.applyMatrix4(matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far)
      return;
    intersects.push({
      distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index,
      face: null,
      object
    });
  }
}
class CompressedTexture extends Texture {
  constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {width, height};
    this.mipmaps = mipmaps;
    this.flipY = false;
    this.generateMipmaps = false;
  }
}
CompressedTexture.prototype.isCompressedTexture = true;
class CanvasTexture extends Texture {
  constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.needsUpdate = true;
  }
}
CanvasTexture.prototype.isCanvasTexture = true;
class CylinderGeometry extends BufferGeometry {
  constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CylinderGeometry";
    this.parameters = {
      radiusTop,
      radiusBottom,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
    const scope = this;
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let index = 0;
    const indexArray = [];
    const halfHeight = height / 2;
    let groupStart = 0;
    generateTorso();
    if (openEnded === false) {
      if (radiusTop > 0)
        generateCap(true);
      if (radiusBottom > 0)
        generateCap(false);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateTorso() {
      const normal = new Vector3();
      const vertex = new Vector3();
      let groupCount = 0;
      const slope = (radiusBottom - radiusTop) / height;
      for (let y = 0; y <= heightSegments; y++) {
        const indexRow = [];
        const v = y / heightSegments;
        const radius = v * (radiusBottom - radiusTop) + radiusTop;
        for (let x = 0; x <= radialSegments; x++) {
          const u = x / radialSegments;
          const theta = u * thetaLength + thetaStart;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta);
          vertex.x = radius * sinTheta;
          vertex.y = -v * height + halfHeight;
          vertex.z = radius * cosTheta;
          vertices.push(vertex.x, vertex.y, vertex.z);
          normal.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(u, 1 - v);
          indexRow.push(index++);
        }
        indexArray.push(indexRow);
      }
      for (let x = 0; x < radialSegments; x++) {
        for (let y = 0; y < heightSegments; y++) {
          const a = indexArray[y][x];
          const b = indexArray[y + 1][x];
          const c = indexArray[y + 1][x + 1];
          const d = indexArray[y][x + 1];
          indices.push(a, b, d);
          indices.push(b, c, d);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, 0);
      groupStart += groupCount;
    }
    function generateCap(top) {
      const centerIndexStart = index;
      const uv = new Vector2();
      const vertex = new Vector3();
      let groupCount = 0;
      const radius = top === true ? radiusTop : radiusBottom;
      const sign = top === true ? 1 : -1;
      for (let x = 1; x <= radialSegments; x++) {
        vertices.push(0, halfHeight * sign, 0);
        normals.push(0, sign, 0);
        uvs.push(0.5, 0.5);
        index++;
      }
      const centerIndexEnd = index;
      for (let x = 0; x <= radialSegments; x++) {
        const u = x / radialSegments;
        const theta = u * thetaLength + thetaStart;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);
        vertex.x = radius * sinTheta;
        vertex.y = halfHeight * sign;
        vertex.z = radius * cosTheta;
        vertices.push(vertex.x, vertex.y, vertex.z);
        normals.push(0, sign, 0);
        uv.x = cosTheta * 0.5 + 0.5;
        uv.y = sinTheta * 0.5 * sign + 0.5;
        uvs.push(uv.x, uv.y);
        index++;
      }
      for (let x = 0; x < radialSegments; x++) {
        const c = centerIndexStart + x;
        const i = centerIndexEnd + x;
        if (top === true) {
          indices.push(i, i + 1, c);
        } else {
          indices.push(i + 1, i, c);
        }
        groupCount += 3;
      }
      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
      groupStart += groupCount;
    }
  }
}
function ParametricGeometry(func, slices, stacks) {
  BufferGeometry.call(this);
  this.type = "ParametricGeometry";
  this.parameters = {
    func,
    slices,
    stacks
  };
  const indices = [];
  const vertices = [];
  const normals = [];
  const uvs = [];
  const EPS = 1e-5;
  const normal = new Vector3();
  const p0 = new Vector3(), p1 = new Vector3();
  const pu = new Vector3(), pv = new Vector3();
  if (func.length < 3) {
    console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
  }
  const sliceCount = slices + 1;
  for (let i = 0; i <= stacks; i++) {
    const v = i / stacks;
    for (let j = 0; j <= slices; j++) {
      const u = j / slices;
      func(u, v, p0);
      vertices.push(p0.x, p0.y, p0.z);
      if (u - EPS >= 0) {
        func(u - EPS, v, p1);
        pu.subVectors(p0, p1);
      } else {
        func(u + EPS, v, p1);
        pu.subVectors(p1, p0);
      }
      if (v - EPS >= 0) {
        func(u, v - EPS, p1);
        pv.subVectors(p0, p1);
      } else {
        func(u, v + EPS, p1);
        pv.subVectors(p1, p0);
      }
      normal.crossVectors(pu, pv).normalize();
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(u, v);
    }
  }
  for (let i = 0; i < stacks; i++) {
    for (let j = 0; j < slices; j++) {
      const a = i * sliceCount + j;
      const b = i * sliceCount + j + 1;
      const c = (i + 1) * sliceCount + j + 1;
      const d = (i + 1) * sliceCount + j;
      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  }
  this.setIndex(indices);
  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
ParametricGeometry.prototype = Object.create(BufferGeometry.prototype);
ParametricGeometry.prototype.constructor = ParametricGeometry;
class SphereGeometry extends BufferGeometry {
  constructor(radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    super();
    this.type = "SphereGeometry";
    this.parameters = {
      radius,
      widthSegments,
      heightSegments,
      phiStart,
      phiLength,
      thetaStart,
      thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index = 0;
    const grid = [];
    const vertex = new Vector3();
    const normal = new Vector3();
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v = iy / heightSegments;
      let uOffset = 0;
      if (iy == 0 && thetaStart == 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy == heightSegments && thetaEnd == Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix = 0; ix <= widthSegments; ix++) {
        const u = ix / widthSegments;
        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normal.copy(vertex).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u + uOffset, 1 - v);
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a = grid[iy][ix + 1];
        const b = grid[iy][ix];
        const c = grid[iy + 1][ix];
        const d = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0)
          indices.push(a, b, d);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
          indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
}
function MeshStandardMaterial(parameters) {
  Material.call(this);
  this.defines = {STANDARD: ""};
  this.type = "MeshStandardMaterial";
  this.color = new Color(16777215);
  this.roughness = 1;
  this.metalness = 0;
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.emissive = new Color(0);
  this.emissiveIntensity = 1;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.roughnessMap = null;
  this.metalnessMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.envMapIntensity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = "round";
  this.wireframeLinejoin = "round";
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.flatShading = false;
  this.vertexTangents = false;
  this.setValues(parameters);
}
MeshStandardMaterial.prototype = Object.create(Material.prototype);
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
MeshStandardMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.defines = {STANDARD: ""};
  this.color.copy(source.color);
  this.roughness = source.roughness;
  this.metalness = source.metalness;
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.roughnessMap = source.roughnessMap;
  this.metalnessMap = source.metalnessMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.envMapIntensity = source.envMapIntensity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  this.flatShading = source.flatShading;
  this.vertexTangents = source.vertexTangents;
  return this;
};
function MeshPhysicalMaterial(parameters) {
  MeshStandardMaterial.call(this);
  this.defines = {
    STANDARD: "",
    PHYSICAL: ""
  };
  this.type = "MeshPhysicalMaterial";
  this.clearcoat = 0;
  this.clearcoatMap = null;
  this.clearcoatRoughness = 0;
  this.clearcoatRoughnessMap = null;
  this.clearcoatNormalScale = new Vector2(1, 1);
  this.clearcoatNormalMap = null;
  this.reflectivity = 0.5;
  Object.defineProperty(this, "ior", {
    get: function() {
      return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
    },
    set: function(ior) {
      this.reflectivity = MathUtils.clamp(2.5 * (ior - 1) / (ior + 1), 0, 1);
    }
  });
  this.sheen = null;
  this.transmission = 0;
  this.transmissionMap = null;
  this.setValues(parameters);
}
MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
MeshPhysicalMaterial.prototype.copy = function(source) {
  MeshStandardMaterial.prototype.copy.call(this, source);
  this.defines = {
    STANDARD: "",
    PHYSICAL: ""
  };
  this.clearcoat = source.clearcoat;
  this.clearcoatMap = source.clearcoatMap;
  this.clearcoatRoughness = source.clearcoatRoughness;
  this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
  this.clearcoatNormalMap = source.clearcoatNormalMap;
  this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
  this.reflectivity = source.reflectivity;
  if (source.sheen) {
    this.sheen = (this.sheen || new Color()).copy(source.sheen);
  } else {
    this.sheen = null;
  }
  this.transmission = source.transmission;
  this.transmissionMap = source.transmissionMap;
  return this;
};
const AnimationUtils = {
  arraySlice: function(array, from, to) {
    if (AnimationUtils.isTypedArray(array)) {
      return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));
    }
    return array.slice(from, to);
  },
  convertArray: function(array, type, forceClone) {
    if (!array || !forceClone && array.constructor === type)
      return array;
    if (typeof type.BYTES_PER_ELEMENT === "number") {
      return new type(array);
    }
    return Array.prototype.slice.call(array);
  },
  isTypedArray: function(object) {
    return ArrayBuffer.isView(object) && !(object instanceof DataView);
  },
  getKeyframeOrder: function(times) {
    function compareTime(i, j) {
      return times[i] - times[j];
    }
    const n = times.length;
    const result = new Array(n);
    for (let i = 0; i !== n; ++i)
      result[i] = i;
    result.sort(compareTime);
    return result;
  },
  sortedArray: function(values, stride, order) {
    const nValues = values.length;
    const result = new values.constructor(nValues);
    for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
      const srcOffset = order[i] * stride;
      for (let j = 0; j !== stride; ++j) {
        result[dstOffset++] = values[srcOffset + j];
      }
    }
    return result;
  },
  flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
    let i = 1, key = jsonKeys[0];
    while (key !== void 0 && key[valuePropertyName] === void 0) {
      key = jsonKeys[i++];
    }
    if (key === void 0)
      return;
    let value = key[valuePropertyName];
    if (value === void 0)
      return;
    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push.apply(values, value);
        }
        key = jsonKeys[i++];
      } while (key !== void 0);
    } else if (value.toArray !== void 0) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          value.toArray(values, values.length);
        }
        key = jsonKeys[i++];
      } while (key !== void 0);
    } else {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push(value);
        }
        key = jsonKeys[i++];
      } while (key !== void 0);
    }
  },
  subclip: function(sourceClip, name, startFrame, endFrame, fps = 30) {
    const clip = sourceClip.clone();
    clip.name = name;
    const tracks = [];
    for (let i = 0; i < clip.tracks.length; ++i) {
      const track = clip.tracks[i];
      const valueSize = track.getValueSize();
      const times = [];
      const values = [];
      for (let j = 0; j < track.times.length; ++j) {
        const frame = track.times[j] * fps;
        if (frame < startFrame || frame >= endFrame)
          continue;
        times.push(track.times[j]);
        for (let k = 0; k < valueSize; ++k) {
          values.push(track.values[j * valueSize + k]);
        }
      }
      if (times.length === 0)
        continue;
      track.times = AnimationUtils.convertArray(times, track.times.constructor);
      track.values = AnimationUtils.convertArray(values, track.values.constructor);
      tracks.push(track);
    }
    clip.tracks = tracks;
    let minStartTime = Infinity;
    for (let i = 0; i < clip.tracks.length; ++i) {
      if (minStartTime > clip.tracks[i].times[0]) {
        minStartTime = clip.tracks[i].times[0];
      }
    }
    for (let i = 0; i < clip.tracks.length; ++i) {
      clip.tracks[i].shift(-1 * minStartTime);
    }
    clip.resetDuration();
    return clip;
  },
  makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
    if (fps <= 0)
      fps = 30;
    const numTracks = referenceClip.tracks.length;
    const referenceTime = referenceFrame / fps;
    for (let i = 0; i < numTracks; ++i) {
      const referenceTrack = referenceClip.tracks[i];
      const referenceTrackType = referenceTrack.ValueTypeName;
      if (referenceTrackType === "bool" || referenceTrackType === "string")
        continue;
      const targetTrack = targetClip.tracks.find(function(track) {
        return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
      });
      if (targetTrack === void 0)
        continue;
      let referenceOffset = 0;
      const referenceValueSize = referenceTrack.getValueSize();
      if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        referenceOffset = referenceValueSize / 3;
      }
      let targetOffset = 0;
      const targetValueSize = targetTrack.getValueSize();
      if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        targetOffset = targetValueSize / 3;
      }
      const lastIndex = referenceTrack.times.length - 1;
      let referenceValue;
      if (referenceTime <= referenceTrack.times[0]) {
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else if (referenceTime >= referenceTrack.times[lastIndex]) {
        const startIndex = lastIndex * referenceValueSize + referenceOffset;
        const endIndex = startIndex + referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else {
        const interpolant = referenceTrack.createInterpolant();
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        interpolant.evaluate(referenceTime);
        referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
      }
      if (referenceTrackType === "quaternion") {
        const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
        referenceQuat.toArray(referenceValue);
      }
      const numTimes = targetTrack.times.length;
      for (let j = 0; j < numTimes; ++j) {
        const valueStart = j * targetValueSize + targetOffset;
        if (referenceTrackType === "quaternion") {
          Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
        } else {
          const valueEnd = targetValueSize - targetOffset * 2;
          for (let k = 0; k < valueEnd; ++k) {
            targetTrack.values[valueStart + k] -= referenceValue[k];
          }
        }
      }
    }
    targetClip.blendMode = AdditiveAnimationBlendMode;
    return targetClip;
  }
};
function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  this.parameterPositions = parameterPositions;
  this._cachedIndex = 0;
  this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
  this.sampleValues = sampleValues;
  this.valueSize = sampleSize;
}
Object.assign(Interpolant.prototype, {
  evaluate: function(t) {
    const pp = this.parameterPositions;
    let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
    validate_interval: {
      seek: {
        let right;
        linear_scan: {
          forward_scan:
            if (!(t < t1)) {
              for (let giveUpAt = i1 + 2; ; ) {
                if (t1 === void 0) {
                  if (t < t0)
                    break forward_scan;
                  i1 = pp.length;
                  this._cachedIndex = i1;
                  return this.afterEnd_(i1 - 1, t, t0);
                }
                if (i1 === giveUpAt)
                  break;
                t0 = t1;
                t1 = pp[++i1];
                if (t < t1) {
                  break seek;
                }
              }
              right = pp.length;
              break linear_scan;
            }
          if (!(t >= t0)) {
            const t1global = pp[1];
            if (t < t1global) {
              i1 = 2;
              t0 = t1global;
            }
            for (let giveUpAt = i1 - 2; ; ) {
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.beforeStart_(0, t, t1);
              }
              if (i1 === giveUpAt)
                break;
              t1 = t0;
              t0 = pp[--i1 - 1];
              if (t >= t0) {
                break seek;
              }
            }
            right = i1;
            i1 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i1 < right) {
          const mid = i1 + right >>> 1;
          if (t < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }
        t1 = pp[i1];
        t0 = pp[i1 - 1];
        if (t0 === void 0) {
          this._cachedIndex = 0;
          return this.beforeStart_(0, t, t1);
        }
        if (t1 === void 0) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.afterEnd_(i1 - 1, t0, t);
        }
      }
      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    }
    return this.interpolate_(i1, t0, t, t1);
  },
  settings: null,
  DefaultSettings_: {},
  getSettings_: function() {
    return this.settings || this.DefaultSettings_;
  },
  copySampleValue_: function(index) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset + i];
    }
    return result;
  },
  interpolate_: function() {
    throw new Error("call to abstract method");
  },
  intervalChanged_: function() {
  }
});
Object.assign(Interpolant.prototype, {
  beforeStart_: Interpolant.prototype.copySampleValue_,
  afterEnd_: Interpolant.prototype.copySampleValue_
});
function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  this._weightPrev = -0;
  this._offsetPrev = -0;
  this._weightNext = -0;
  this._offsetNext = -0;
}
CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: CubicInterpolant,
  DefaultSettings_: {
    endingStart: ZeroCurvatureEnding,
    endingEnd: ZeroCurvatureEnding
  },
  intervalChanged_: function(i1, t0, t1) {
    const pp = this.parameterPositions;
    let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;
        case WrapAroundEnding:
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;
        default:
          iPrev = i1;
          tPrev = t1;
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;
        default:
          iNext = i1 - 1;
          tNext = t0;
      }
    }
    const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  },
  interpolate_: function(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
    const sP = -wP * ppp + 2 * wP * pp - wP * p;
    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
    const sN = wN * ppp - wN * pp;
    for (let i = 0; i !== stride; ++i) {
      result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
    }
    return result;
  }
});
function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: LinearInterpolant,
  interpolate_: function(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
    }
    return result;
  }
});
function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: DiscreteInterpolant,
  interpolate_: function(i1) {
    return this.copySampleValue_(i1 - 1);
  }
});
class KeyframeTrack {
  constructor(name, times, values, interpolation) {
    if (name === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times === void 0 || times.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
    this.name = name;
    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }
  static toJSON(track) {
    const trackType = track.constructor;
    let json;
    if (trackType.toJSON !== this.toJSON) {
      json = trackType.toJSON(track);
    } else {
      json = {
        name: track.name,
        times: AnimationUtils.convertArray(track.times, Array),
        values: AnimationUtils.convertArray(track.values, Array)
      };
      const interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }
    json.type = track.ValueTypeName;
    return json;
  }
  InterpolantFactoryMethodDiscrete(result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodLinear(result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodSmooth(result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  setInterpolation(interpolation) {
    let factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === void 0) {
      const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      console.warn("THREE.KeyframeTrack:", message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(timeOffset) {
    if (timeOffset !== 0) {
      const times = this.times;
      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] += timeOffset;
      }
    }
    return this;
  }
  scale(timeScale) {
    if (timeScale !== 1) {
      const times = this.times;
      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] *= timeScale;
      }
    }
    return this;
  }
  trim(startTime, endTime) {
    const times = this.times, nKeys = times.length;
    let from = 0, to = nKeys - 1;
    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }
    while (to !== -1 && times[to] > endTime) {
      --to;
    }
    ++to;
    if (from !== 0 || to !== nKeys) {
      if (from >= to) {
        to = Math.max(to, 1);
        from = to - 1;
      }
      const stride = this.getValueSize();
      this.times = AnimationUtils.arraySlice(times, from, to);
      this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
    }
    return this;
  }
  validate() {
    let valid = true;
    const valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
      valid = false;
    }
    const times = this.times, values = this.values, nKeys = times.length;
    if (nKeys === 0) {
      console.error("THREE.KeyframeTrack: Track is empty.", this);
      valid = false;
    }
    let prevTime = null;
    for (let i = 0; i !== nKeys; i++) {
      const currTime = times[i];
      if (typeof currTime === "number" && isNaN(currTime)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, currTime);
        valid = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, i, currTime, prevTime);
        valid = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== void 0) {
      if (AnimationUtils.isTypedArray(values)) {
        for (let i = 0, n = values.length; i !== n; ++i) {
          const value = values[i];
          if (isNaN(value)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, value);
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  }
  optimize() {
    const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
    let writeIndex = 1;
    for (let i = 1; i < lastIndex; ++i) {
      let keep = false;
      const time = times[i];
      const timeNext = times[i + 1];
      if (time !== timeNext && (i !== 1 || time !== times[0])) {
        if (!smoothInterpolation) {
          const offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
          for (let j = 0; j !== stride; ++j) {
            const value = values[offset + j];
            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      }
      if (keep) {
        if (i !== writeIndex) {
          times[writeIndex] = times[i];
          const readOffset = i * stride, writeOffset = writeIndex * stride;
          for (let j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
        values[writeOffset + j] = values[readOffset + j];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }
    return this;
  }
  clone() {
    const times = AnimationUtils.arraySlice(this.times, 0);
    const values = AnimationUtils.arraySlice(this.values, 0);
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times, values);
    track.createInterpolant = this.createInterpolant;
    return track;
  }
}
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
class BooleanKeyframeTrack extends KeyframeTrack {
}
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class ColorKeyframeTrack extends KeyframeTrack {
}
ColorKeyframeTrack.prototype.ValueTypeName = "color";
class NumberKeyframeTrack extends KeyframeTrack {
}
NumberKeyframeTrack.prototype.ValueTypeName = "number";
function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: QuaternionLinearInterpolant,
  interpolate_: function(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);
    let offset = i1 * stride;
    for (let end = offset + stride; offset !== end; offset += 4) {
      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
    }
    return result;
  }
});
class QuaternionKeyframeTrack extends KeyframeTrack {
  InterpolantFactoryMethodLinear(result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
}
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class StringKeyframeTrack extends KeyframeTrack {
}
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class VectorKeyframeTrack extends KeyframeTrack {
}
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
class AnimationClip {
  constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
    this.name = name;
    this.tracks = tracks;
    this.duration = duration;
    this.blendMode = blendMode;
    this.uuid = MathUtils.generateUUID();
    if (this.duration < 0) {
      this.resetDuration();
    }
  }
  static parse(json) {
    const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
    for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
    }
    const clip = new this(json.name, json.duration, tracks, json.blendMode);
    clip.uuid = json.uuid;
    return clip;
  }
  static toJSON(clip) {
    const tracks = [], clipTracks = clip.tracks;
    const json = {
      name: clip.name,
      duration: clip.duration,
      tracks,
      uuid: clip.uuid,
      blendMode: clip.blendMode
    };
    for (let i = 0, n = clipTracks.length; i !== n; ++i) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
    }
    return json;
  }
  static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
    const numMorphTargets = morphTargetSequence.length;
    const tracks = [];
    for (let i = 0; i < numMorphTargets; i++) {
      let times = [];
      let values = [];
      times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
      values.push(0, 1, 0);
      const order = AnimationUtils.getKeyframeOrder(times);
      times = AnimationUtils.sortedArray(times, 1, order);
      values = AnimationUtils.sortedArray(values, 1, order);
      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }
      tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i].name + "]", times, values).scale(1 / fps));
    }
    return new this(name, -1, tracks);
  }
  static findByName(objectOrClipArray, name) {
    let clipArray = objectOrClipArray;
    if (!Array.isArray(objectOrClipArray)) {
      const o = objectOrClipArray;
      clipArray = o.geometry && o.geometry.animations || o.animations;
    }
    for (let i = 0; i < clipArray.length; i++) {
      if (clipArray[i].name === name) {
        return clipArray[i];
      }
    }
    return null;
  }
  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
    const animationToMorphTargets = {};
    const pattern = /^([\w-]*?)([\d]+)$/;
    for (let i = 0, il = morphTargets.length; i < il; i++) {
      const morphTarget = morphTargets[i];
      const parts = morphTarget.name.match(pattern);
      if (parts && parts.length > 1) {
        const name = parts[1];
        let animationMorphTargets = animationToMorphTargets[name];
        if (!animationMorphTargets) {
          animationToMorphTargets[name] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
      }
    }
    const clips = [];
    for (const name in animationToMorphTargets) {
      clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
    }
    return clips;
  }
  static parseAnimation(animation, bones) {
    if (!animation) {
      console.error("THREE.AnimationClip: No animation in JSONLoader data.");
      return null;
    }
    const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
      if (animationKeys.length !== 0) {
        const times = [];
        const values = [];
        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values));
        }
      }
    };
    const tracks = [];
    const clipName = animation.name || "default";
    const fps = animation.fps || 30;
    const blendMode = animation.blendMode;
    let duration = animation.length || -1;
    const hierarchyTracks = animation.hierarchy || [];
    for (let h = 0; h < hierarchyTracks.length; h++) {
      const animationKeys = hierarchyTracks[h].keys;
      if (!animationKeys || animationKeys.length === 0)
        continue;
      if (animationKeys[0].morphTargets) {
        const morphTargetNames = {};
        let k;
        for (k = 0; k < animationKeys.length; k++) {
          if (animationKeys[k].morphTargets) {
            for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
              morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
            }
          }
        }
        for (const morphTargetName in morphTargetNames) {
          const times = [];
          const values = [];
          for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
            const animationKey = animationKeys[k];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
        }
        duration = morphTargetNames.length * (fps || 1);
      } else {
        const boneName = ".bones[" + bones[h].name + "]";
        addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
        addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
        addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
      }
    }
    if (tracks.length === 0) {
      return null;
    }
    const clip = new this(clipName, duration, tracks, blendMode);
    return clip;
  }
  resetDuration() {
    const tracks = this.tracks;
    let duration = 0;
    for (let i = 0, n = tracks.length; i !== n; ++i) {
      const track = this.tracks[i];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }
    this.duration = duration;
    return this;
  }
  trim() {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].trim(0, this.duration);
    }
    return this;
  }
  validate() {
    let valid = true;
    for (let i = 0; i < this.tracks.length; i++) {
      valid = valid && this.tracks[i].validate();
    }
    return valid;
  }
  optimize() {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].optimize();
    }
    return this;
  }
  clone() {
    const tracks = [];
    for (let i = 0; i < this.tracks.length; i++) {
      tracks.push(this.tracks[i].clone());
    }
    return new this.constructor(this.name, this.duration, tracks, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json) {
  if (json.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  const trackType = getTrackTypeForValueTypeName(json.type);
  if (json.times === void 0) {
    const times = [], values = [];
    AnimationUtils.flattenJSON(json.keys, times, values, "value");
    json.times = times;
    json.values = values;
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json);
  } else {
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}
const Cache = {
  enabled: false,
  files: {},
  add: function(key, file) {
    if (this.enabled === false)
      return;
    this.files[key] = file;
  },
  get: function(key) {
    if (this.enabled === false)
      return;
    return this.files[key];
  },
  remove: function(key) {
    delete this.files[key];
  },
  clear: function() {
    this.files = {};
  }
};
function LoadingManager(onLoad, onProgress, onError) {
  const scope = this;
  let isLoading = false;
  let itemsLoaded = 0;
  let itemsTotal = 0;
  let urlModifier = void 0;
  const handlers = [];
  this.onStart = void 0;
  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;
  this.itemStart = function(url) {
    itemsTotal++;
    if (isLoading === false) {
      if (scope.onStart !== void 0) {
        scope.onStart(url, itemsLoaded, itemsTotal);
      }
    }
    isLoading = true;
  };
  this.itemEnd = function(url) {
    itemsLoaded++;
    if (scope.onProgress !== void 0) {
      scope.onProgress(url, itemsLoaded, itemsTotal);
    }
    if (itemsLoaded === itemsTotal) {
      isLoading = false;
      if (scope.onLoad !== void 0) {
        scope.onLoad();
      }
    }
  };
  this.itemError = function(url) {
    if (scope.onError !== void 0) {
      scope.onError(url);
    }
  };
  this.resolveURL = function(url) {
    if (urlModifier) {
      return urlModifier(url);
    }
    return url;
  };
  this.setURLModifier = function(transform) {
    urlModifier = transform;
    return this;
  };
  this.addHandler = function(regex, loader) {
    handlers.push(regex, loader);
    return this;
  };
  this.removeHandler = function(regex) {
    const index = handlers.indexOf(regex);
    if (index !== -1) {
      handlers.splice(index, 2);
    }
    return this;
  };
  this.getHandler = function(file) {
    for (let i = 0, l = handlers.length; i < l; i += 2) {
      const regex = handlers[i];
      const loader = handlers[i + 1];
      if (regex.global)
        regex.lastIndex = 0;
      if (regex.test(file)) {
        return loader;
      }
    }
    return null;
  };
}
const DefaultLoadingManager = new LoadingManager();
function Loader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  this.crossOrigin = "anonymous";
  this.withCredentials = false;
  this.path = "";
  this.resourcePath = "";
  this.requestHeader = {};
}
Object.assign(Loader.prototype, {
  load: function() {
  },
  loadAsync: function(url, onProgress) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.load(url, resolve, onProgress, reject);
    });
  },
  parse: function() {
  },
  setCrossOrigin: function(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  },
  setWithCredentials: function(value) {
    this.withCredentials = value;
    return this;
  },
  setPath: function(path) {
    this.path = path;
    return this;
  },
  setResourcePath: function(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  },
  setRequestHeader: function(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
});
const loading = {};
function FileLoader(manager) {
  Loader.call(this, manager);
}
FileLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: FileLoader,
  load: function(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    if (loading[url] !== void 0) {
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      return;
    }
    const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
    const dataUriRegexResult = url.match(dataUriRegex);
    let request;
    if (dataUriRegexResult) {
      const mimeType = dataUriRegexResult[1];
      const isBase64 = !!dataUriRegexResult[2];
      let data = dataUriRegexResult[3];
      data = decodeURIComponent(data);
      if (isBase64)
        data = atob(data);
      try {
        let response;
        const responseType = (this.responseType || "").toLowerCase();
        switch (responseType) {
          case "arraybuffer":
          case "blob":
            const view = new Uint8Array(data.length);
            for (let i = 0; i < data.length; i++) {
              view[i] = data.charCodeAt(i);
            }
            if (responseType === "blob") {
              response = new Blob([view.buffer], {type: mimeType});
            } else {
              response = view.buffer;
            }
            break;
          case "document":
            const parser = new DOMParser();
            response = parser.parseFromString(data, mimeType);
            break;
          case "json":
            response = JSON.parse(data);
            break;
          default:
            response = data;
            break;
        }
        setTimeout(function() {
          if (onLoad)
            onLoad(response);
          scope.manager.itemEnd(url);
        }, 0);
      } catch (error) {
        setTimeout(function() {
          if (onError)
            onError(error);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }, 0);
      }
    } else {
      loading[url] = [];
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      request = new XMLHttpRequest();
      request.open("GET", url, true);
      request.addEventListener("load", function(event) {
        const response = this.response;
        const callbacks = loading[url];
        delete loading[url];
        if (this.status === 200 || this.status === 0) {
          if (this.status === 0)
            console.warn("THREE.FileLoader: HTTP Status 0 received.");
          Cache.add(url, response);
          for (let i = 0, il = callbacks.length; i < il; i++) {
            const callback = callbacks[i];
            if (callback.onLoad)
              callback.onLoad(response);
          }
          scope.manager.itemEnd(url);
        } else {
          for (let i = 0, il = callbacks.length; i < il; i++) {
            const callback = callbacks[i];
            if (callback.onError)
              callback.onError(event);
          }
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }
      }, false);
      request.addEventListener("progress", function(event) {
        const callbacks = loading[url];
        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i];
          if (callback.onProgress)
            callback.onProgress(event);
        }
      }, false);
      request.addEventListener("error", function(event) {
        const callbacks = loading[url];
        delete loading[url];
        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i];
          if (callback.onError)
            callback.onError(event);
        }
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      request.addEventListener("abort", function(event) {
        const callbacks = loading[url];
        delete loading[url];
        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i];
          if (callback.onError)
            callback.onError(event);
        }
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      if (this.responseType !== void 0)
        request.responseType = this.responseType;
      if (this.withCredentials !== void 0)
        request.withCredentials = this.withCredentials;
      if (request.overrideMimeType)
        request.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
      for (const header in this.requestHeader) {
        request.setRequestHeader(header, this.requestHeader[header]);
      }
      request.send(null);
    }
    scope.manager.itemStart(url);
    return request;
  },
  setResponseType: function(value) {
    this.responseType = value;
    return this;
  },
  setMimeType: function(value) {
    this.mimeType = value;
    return this;
  }
});
function CompressedTextureLoader(manager) {
  Loader.call(this, manager);
}
CompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: CompressedTextureLoader,
  load: function(url, onLoad, onProgress, onError) {
    const scope = this;
    const images = [];
    const texture = new CompressedTexture();
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    let loaded = 0;
    function loadTexture(i) {
      loader.load(url[i], function(buffer) {
        const texDatas = scope.parse(buffer, true);
        images[i] = {
          width: texDatas.width,
          height: texDatas.height,
          format: texDatas.format,
          mipmaps: texDatas.mipmaps
        };
        loaded += 1;
        if (loaded === 6) {
          if (texDatas.mipmapCount === 1)
            texture.minFilter = LinearFilter;
          texture.image = images;
          texture.format = texDatas.format;
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }
      }, onProgress, onError);
    }
    if (Array.isArray(url)) {
      for (let i = 0, il = url.length; i < il; ++i) {
        loadTexture(i);
      }
    } else {
      loader.load(url, function(buffer) {
        const texDatas = scope.parse(buffer, true);
        if (texDatas.isCubemap) {
          const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
          for (let f = 0; f < faces; f++) {
            images[f] = {mipmaps: []};
            for (let i = 0; i < texDatas.mipmapCount; i++) {
              images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
              images[f].format = texDatas.format;
              images[f].width = texDatas.width;
              images[f].height = texDatas.height;
            }
          }
          texture.image = images;
        } else {
          texture.image.width = texDatas.width;
          texture.image.height = texDatas.height;
          texture.mipmaps = texDatas.mipmaps;
        }
        if (texDatas.mipmapCount === 1) {
          texture.minFilter = LinearFilter;
        }
        texture.format = texDatas.format;
        texture.needsUpdate = true;
        if (onLoad)
          onLoad(texture);
      }, onProgress, onError);
    }
    return texture;
  }
});
class ImageLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
    function onImageLoad() {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
      Cache.add(url, this);
      if (onLoad)
        onLoad(this);
      scope.manager.itemEnd(url);
    }
    function onImageError(event) {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
      if (onError)
        onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }
    image.addEventListener("load", onImageLoad, false);
    image.addEventListener("error", onImageError, false);
    if (url.substr(0, 5) !== "data:") {
      if (this.crossOrigin !== void 0)
        image.crossOrigin = this.crossOrigin;
    }
    scope.manager.itemStart(url);
    image.src = url;
    return image;
  }
}
class CubeTextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(urls, onLoad, onProgress, onError) {
    const texture = new CubeTexture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    let loaded = 0;
    function loadTexture(i) {
      loader.load(urls[i], function(image) {
        texture.images[i] = image;
        loaded++;
        if (loaded === 6) {
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }
      }, void 0, onError);
    }
    for (let i = 0; i < urls.length; ++i) {
      loadTexture(i);
    }
    return texture;
  }
}
function DataTextureLoader(manager) {
  Loader.call(this, manager);
}
DataTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: DataTextureLoader,
  load: function(url, onLoad, onProgress, onError) {
    const scope = this;
    const texture = new DataTexture();
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setPath(this.path);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(buffer) {
      const texData = scope.parse(buffer);
      if (!texData)
        return;
      if (texData.image !== void 0) {
        texture.image = texData.image;
      } else if (texData.data !== void 0) {
        texture.image.width = texData.width;
        texture.image.height = texData.height;
        texture.image.data = texData.data;
      }
      texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping;
      texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping;
      texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter;
      texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearFilter;
      texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
      if (texData.encoding !== void 0) {
        texture.encoding = texData.encoding;
      }
      if (texData.flipY !== void 0) {
        texture.flipY = texData.flipY;
      }
      if (texData.format !== void 0) {
        texture.format = texData.format;
      }
      if (texData.type !== void 0) {
        texture.type = texData.type;
      }
      if (texData.mipmaps !== void 0) {
        texture.mipmaps = texData.mipmaps;
        texture.minFilter = LinearMipmapLinearFilter;
      }
      if (texData.mipmapCount === 1) {
        texture.minFilter = LinearFilter;
      }
      if (texData.generateMipmaps !== void 0) {
        texture.generateMipmaps = texData.generateMipmaps;
      }
      texture.needsUpdate = true;
      if (onLoad)
        onLoad(texture, texData);
    }, onProgress, onError);
    return texture;
  }
});
function TextureLoader(manager) {
  Loader.call(this, manager);
}
TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: TextureLoader,
  load: function(url, onLoad, onProgress, onError) {
    const texture = new Texture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function(image) {
      texture.image = image;
      const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
      texture.format = isJPEG ? RGBFormat : RGBAFormat;
      texture.needsUpdate = true;
      if (onLoad !== void 0) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  }
});
function Curve() {
  this.type = "Curve";
  this.arcLengthDivisions = 200;
}
Object.assign(Curve.prototype, {
  getPoint: function() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  },
  getPointAt: function(u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getPoint(t, optionalTarget);
  },
  getPoints: function(divisions = 5) {
    const points = [];
    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPoint(d / divisions));
    }
    return points;
  },
  getSpacedPoints: function(divisions = 5) {
    const points = [];
    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPointAt(d / divisions));
    }
    return points;
  },
  getLength: function() {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  },
  getLengths: function(divisions) {
    if (divisions === void 0)
      divisions = this.arcLengthDivisions;
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = false;
    const cache = [];
    let current, last = this.getPoint(0);
    let sum = 0;
    cache.push(0);
    for (let p = 1; p <= divisions; p++) {
      current = this.getPoint(p / divisions);
      sum += current.distanceTo(last);
      cache.push(sum);
      last = current;
    }
    this.cacheArcLengths = cache;
    return cache;
  },
  updateArcLengths: function() {
    this.needsUpdate = true;
    this.getLengths();
  },
  getUtoTmapping: function(u, distance) {
    const arcLengths = this.getLengths();
    let i = 0;
    const il = arcLengths.length;
    let targetArcLength;
    if (distance) {
      targetArcLength = distance;
    } else {
      targetArcLength = u * arcLengths[il - 1];
    }
    let low = 0, high = il - 1, comparison;
    while (low <= high) {
      i = Math.floor(low + (high - low) / 2);
      comparison = arcLengths[i] - targetArcLength;
      if (comparison < 0) {
        low = i + 1;
      } else if (comparison > 0) {
        high = i - 1;
      } else {
        high = i;
        break;
      }
    }
    i = high;
    if (arcLengths[i] === targetArcLength) {
      return i / (il - 1);
    }
    const lengthBefore = arcLengths[i];
    const lengthAfter = arcLengths[i + 1];
    const segmentLength = lengthAfter - lengthBefore;
    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
    const t = (i + segmentFraction) / (il - 1);
    return t;
  },
  getTangent: function(t, optionalTarget) {
    const delta = 1e-4;
    let t1 = t - delta;
    let t2 = t + delta;
    if (t1 < 0)
      t1 = 0;
    if (t2 > 1)
      t2 = 1;
    const pt1 = this.getPoint(t1);
    const pt2 = this.getPoint(t2);
    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  },
  getTangentAt: function(u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getTangent(t, optionalTarget);
  },
  computeFrenetFrames: function(segments, closed) {
    const normal = new Vector3();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new Vector3();
    const mat = new Matrix4();
    for (let i = 0; i <= segments; i++) {
      const u = i / segments;
      tangents[i] = this.getTangentAt(u, new Vector3());
      tangents[i].normalize();
    }
    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    let min = Number.MAX_VALUE;
    const tx = Math.abs(tangents[0].x);
    const ty = Math.abs(tangents[0].y);
    const tz = Math.abs(tangents[0].z);
    if (tx <= min) {
      min = tx;
      normal.set(1, 0, 0);
    }
    if (ty <= min) {
      min = ty;
      normal.set(0, 1, 0);
    }
    if (tz <= min) {
      normal.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
    for (let i = 1; i <= segments; i++) {
      normals[i] = normals[i - 1].clone();
      binormals[i] = binormals[i - 1].clone();
      vec.crossVectors(tangents[i - 1], tangents[i]);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(MathUtils.clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }
      binormals[i].crossVectors(tangents[i], normals[i]);
    }
    if (closed === true) {
      let theta = Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;
      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }
      for (let i = 1; i <= segments; i++) {
        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
    }
    return {
      tangents,
      normals,
      binormals
    };
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  },
  toJSON: function() {
    const data = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  },
  fromJSON: function(json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }
});
class Light extends Object3D {
  constructor(color, intensity = 1) {
    super();
    this.type = "Light";
    this.color = new Color(color);
    this.intensity = intensity;
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== void 0)
      data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== void 0)
      data.object.distance = this.distance;
    if (this.angle !== void 0)
      data.object.angle = this.angle;
    if (this.decay !== void 0)
      data.object.decay = this.decay;
    if (this.penumbra !== void 0)
      data.object.penumbra = this.penumbra;
    if (this.shadow !== void 0)
      data.object.shadow = this.shadow.toJSON();
    return data;
  }
}
Light.prototype.isLight = true;
const _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
const _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
const _lookTarget$1 = /* @__PURE__ */ new Vector3();
class LightShadow {
  constructor(camera) {
    this.camera = camera;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [
      new Vector4(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(light) {
    const shadowCamera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
    shadowCamera.position.copy(_lightPositionWorld$1);
    _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
    shadowCamera.lookAt(_lookTarget$1);
    shadowCamera.updateMatrixWorld();
    _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
    shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
    shadowMatrix.multiply(shadowCamera.projectionMatrix);
    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
  }
  getViewport(viewportIndex) {
    return this._viewports[viewportIndex];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  copy(source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const object = {};
    if (this.bias !== 0)
      object.bias = this.bias;
    if (this.normalBias !== 0)
      object.normalBias = this.normalBias;
    if (this.radius !== 1)
      object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
      object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
}
class SpotLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500));
    this.focus = 1;
  }
  updateMatrices(light) {
    const camera = this.camera;
    const fov2 = MathUtils.RAD2DEG * 2 * light.angle * this.focus;
    const aspect2 = this.mapSize.width / this.mapSize.height;
    const far = light.distance || camera.far;
    if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
      camera.fov = fov2;
      camera.aspect = aspect2;
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    super.updateMatrices(light);
  }
  copy(source) {
    super.copy(source);
    this.focus = source.focus;
    return this;
  }
}
SpotLightShadow.prototype.isSpotLightShadow = true;
class SpotLight extends Light {
  constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
    super(color, intensity);
    this.type = "SpotLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.distance = distance;
    this.angle = angle;
    this.penumbra = penumbra;
    this.decay = decay;
    this.shadow = new SpotLightShadow();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(power) {
    this.intensity = power / Math.PI;
  }
  copy(source) {
    super.copy(source);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
}
SpotLight.prototype.isSpotLight = true;
const _projScreenMatrix = /* @__PURE__ */ new Matrix4();
const _lightPositionWorld = /* @__PURE__ */ new Vector3();
const _lookTarget = /* @__PURE__ */ new Vector3();
class PointLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500));
    this._frameExtents = new Vector2(4, 2);
    this._viewportCount = 6;
    this._viewports = [
      new Vector4(2, 1, 1, 1),
      new Vector4(0, 1, 1, 1),
      new Vector4(3, 1, 1, 1),
      new Vector4(1, 1, 1, 1),
      new Vector4(3, 0, 1, 1),
      new Vector4(1, 0, 1, 1)
    ];
    this._cubeDirections = [
      new Vector3(1, 0, 0),
      new Vector3(-1, 0, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1),
      new Vector3(0, 1, 0),
      new Vector3(0, -1, 0)
    ];
    this._cubeUps = [
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1)
    ];
  }
  updateMatrices(light, viewportIndex = 0) {
    const camera = this.camera;
    const shadowMatrix = this.matrix;
    const far = light.distance || camera.far;
    if (far !== camera.far) {
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    camera.position.copy(_lightPositionWorld);
    _lookTarget.copy(camera.position);
    _lookTarget.add(this._cubeDirections[viewportIndex]);
    camera.up.copy(this._cubeUps[viewportIndex]);
    camera.lookAt(_lookTarget);
    camera.updateMatrixWorld();
    shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix);
  }
}
PointLightShadow.prototype.isPointLightShadow = true;
class PointLight extends Light {
  constructor(color, intensity, distance = 0, decay = 1) {
    super(color, intensity);
    this.type = "PointLight";
    this.distance = distance;
    this.decay = decay;
    this.shadow = new PointLightShadow();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(power) {
    this.intensity = power / (4 * Math.PI);
  }
  copy(source) {
    super.copy(source);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
}
PointLight.prototype.isPointLight = true;
class OrthographicCamera extends Camera {
  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
    super();
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  }
  setViewOffset(fullWidth, fullHeight, x, y, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = Object3D.prototype.toJSON.call(this, meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    return data;
  }
}
OrthographicCamera.prototype.isOrthographicCamera = true;
class DirectionalLightShadow extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
  }
}
DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
class DirectionalLight extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
  }
  copy(source) {
    super.copy(source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
}
DirectionalLight.prototype.isDirectionalLight = true;
const LoaderUtils = {
  decodeText: function(array) {
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array);
    }
    let s = "";
    for (let i = 0, il = array.length; i < il; i++) {
      s += String.fromCharCode(array[i]);
    }
    try {
      return decodeURIComponent(escape(s));
    } catch (e) {
      return s;
    }
  },
  extractUrlBase: function(url) {
    const index = url.lastIndexOf("/");
    if (index === -1)
      return "./";
    return url.substr(0, index + 1);
  }
};
function InstancedBufferGeometry() {
  BufferGeometry.call(this);
  this.type = "InstancedBufferGeometry";
  this.instanceCount = Infinity;
}
InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
  constructor: InstancedBufferGeometry,
  isInstancedBufferGeometry: true,
  copy: function(source) {
    BufferGeometry.prototype.copy.call(this, source);
    this.instanceCount = source.instanceCount;
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  toJSON: function() {
    const data = BufferGeometry.prototype.toJSON.call(this);
    data.instanceCount = this.instanceCount;
    data.isInstancedBufferGeometry = true;
    return data;
  }
});
function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
  if (typeof normalized === "number") {
    meshPerAttribute = normalized;
    normalized = false;
    console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
  }
  BufferAttribute.call(this, array, itemSize, normalized);
  this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
  constructor: InstancedBufferAttribute,
  isInstancedBufferAttribute: true,
  copy: function(source) {
    BufferAttribute.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  },
  toJSON: function() {
    const data = BufferAttribute.prototype.toJSON.call(this);
    data.meshPerAttribute = this.meshPerAttribute;
    data.isInstancedBufferAttribute = true;
    return data;
  }
});
function ImageBitmapLoader(manager) {
  if (typeof createImageBitmap === "undefined") {
    console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
  }
  if (typeof fetch === "undefined") {
    console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
  }
  Loader.call(this, manager);
  this.options = {premultiplyAlpha: "none"};
}
ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: ImageBitmapLoader,
  isImageBitmapLoader: true,
  setOptions: function setOptions(options) {
    this.options = options;
    return this;
  },
  load: function(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const fetchOptions = {};
    fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
    fetchOptions.headers = this.requestHeader;
    fetch(url, fetchOptions).then(function(res) {
      return res.blob();
    }).then(function(blob) {
      return createImageBitmap(blob, Object.assign(scope.options, {colorSpaceConversion: "none"}));
    }).then(function(imageBitmap) {
      Cache.add(url, imageBitmap);
      if (onLoad)
        onLoad(imageBitmap);
      scope.manager.itemEnd(url);
    }).catch(function(e) {
      if (onError)
        onError(e);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    });
    scope.manager.itemStart(url);
  }
});
new Matrix4();
new Matrix4();
class Clock {
  constructor(autoStart) {
    this.autoStart = autoStart !== void 0 ? autoStart : true;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
  }
  start() {
    this.startTime = now();
    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
  }
  stop() {
    this.getElapsedTime();
    this.running = false;
    this.autoStart = false;
  }
  getElapsedTime() {
    this.getDelta();
    return this.elapsedTime;
  }
  getDelta() {
    let diff2 = 0;
    if (this.autoStart && !this.running) {
      this.start();
      return 0;
    }
    if (this.running) {
      const newTime = now();
      diff2 = (newTime - this.oldTime) / 1e3;
      this.oldTime = newTime;
      this.elapsedTime += diff2;
    }
    return diff2;
  }
}
function now() {
  return (typeof performance === "undefined" ? Date : performance).now();
}
class PropertyMixer {
  constructor(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    let mixFunction, mixFunctionAdditive, setIdentity;
    switch (typeName) {
      case "quaternion":
        mixFunction = this._slerp;
        mixFunctionAdditive = this._slerpAdditive;
        setIdentity = this._setAdditiveIdentityQuaternion;
        this.buffer = new Float64Array(valueSize * 6);
        this._workIndex = 5;
        break;
      case "string":
      case "bool":
        mixFunction = this._select;
        mixFunctionAdditive = this._select;
        setIdentity = this._setAdditiveIdentityOther;
        this.buffer = new Array(valueSize * 5);
        break;
      default:
        mixFunction = this._lerp;
        mixFunctionAdditive = this._lerpAdditive;
        setIdentity = this._setAdditiveIdentityNumeric;
        this.buffer = new Float64Array(valueSize * 5);
    }
    this._mixBufferRegion = mixFunction;
    this._mixBufferRegionAdditive = mixFunctionAdditive;
    this._setIdentity = setIdentity;
    this._origIndex = 3;
    this._addIndex = 4;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    this.useCount = 0;
    this.referenceCount = 0;
  }
  accumulate(accuIndex, weight) {
    const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
    let currentWeight = this.cumulativeWeight;
    if (currentWeight === 0) {
      for (let i = 0; i !== stride; ++i) {
        buffer[offset + i] = buffer[i];
      }
      currentWeight = weight;
    } else {
      currentWeight += weight;
      const mix = weight / currentWeight;
      this._mixBufferRegion(buffer, offset, 0, mix, stride);
    }
    this.cumulativeWeight = currentWeight;
  }
  accumulateAdditive(weight) {
    const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
    if (this.cumulativeWeightAdditive === 0) {
      this._setIdentity();
    }
    this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
    this.cumulativeWeightAdditive += weight;
  }
  apply(accuIndex) {
    const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    if (weight < 1) {
      const originalValueOffset = stride * this._origIndex;
      this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
    }
    if (weightAdditive > 0) {
      this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
    }
    for (let i = stride, e = stride + stride; i !== e; ++i) {
      if (buffer[i] !== buffer[i + stride]) {
        binding.setValue(buffer, offset);
        break;
      }
    }
  }
  saveOriginalState() {
    const binding = this.binding;
    const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
    binding.getValue(buffer, originalValueOffset);
    for (let i = stride, e = originalValueOffset; i !== e; ++i) {
      buffer[i] = buffer[originalValueOffset + i % stride];
    }
    this._setIdentity();
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
  }
  restoreOriginalState() {
    const originalValueOffset = this.valueSize * 3;
    this.binding.setValue(this.buffer, originalValueOffset);
  }
  _setAdditiveIdentityNumeric() {
    const startIndex = this._addIndex * this.valueSize;
    const endIndex = startIndex + this.valueSize;
    for (let i = startIndex; i < endIndex; i++) {
      this.buffer[i] = 0;
    }
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric();
    this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const startIndex = this._origIndex * this.valueSize;
    const targetIndex = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++) {
      this.buffer[targetIndex + i] = this.buffer[startIndex + i];
    }
  }
  _select(buffer, dstOffset, srcOffset, t, stride) {
    if (t >= 0.5) {
      for (let i = 0; i !== stride; ++i) {
        buffer[dstOffset + i] = buffer[srcOffset + i];
      }
    }
  }
  _slerp(buffer, dstOffset, srcOffset, t) {
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
  }
  _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
    const workOffset = this._workIndex * stride;
    Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
  }
  _lerp(buffer, dstOffset, srcOffset, t, stride) {
    const s = 1 - t;
    for (let i = 0; i !== stride; ++i) {
      const j = dstOffset + i;
      buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
    }
  }
  _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
    for (let i = 0; i !== stride; ++i) {
      const j = dstOffset + i;
      buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
    }
  }
}
const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
const _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
const _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
const _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
const _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
const _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
const _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
const _supportedObjectNames = ["material", "materials", "bones"];
function Composite(targetGroup, path, optionalParsedPath) {
  const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
  this._targetGroup = targetGroup;
  this._bindings = targetGroup.subscribe_(path, parsedPath);
}
Object.assign(Composite.prototype, {
  getValue: function(array, offset) {
    this.bind();
    const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
    if (binding !== void 0)
      binding.getValue(array, offset);
  },
  setValue: function(array, offset) {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].setValue(array, offset);
    }
  },
  bind: function() {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].bind();
    }
  },
  unbind: function() {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].unbind();
    }
  }
});
function PropertyBinding(rootNode, path, parsedPath) {
  this.path = path;
  this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
  this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
  this.rootNode = rootNode;
}
Object.assign(PropertyBinding, {
  Composite,
  create: function(root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path, parsedPath);
    } else {
      return new PropertyBinding.Composite(root, path, parsedPath);
    }
  },
  sanitizeNodeName: function(name) {
    return name.replace(/\s/g, "_").replace(_reservedRe, "");
  },
  parseTrackName: function(trackName) {
    const matches = _trackRe.exec(trackName);
    if (!matches) {
      throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
    }
    const results = {
      nodeName: matches[2],
      objectName: matches[3],
      objectIndex: matches[4],
      propertyName: matches[5],
      propertyIndex: matches[6]
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
    if (lastDot !== void 0 && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1);
      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }
    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
    }
    return results;
  },
  findNode: function(root, nodeName) {
    if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    }
    if (root.skeleton) {
      const bone = root.skeleton.getBoneByName(nodeName);
      if (bone !== void 0) {
        return bone;
      }
    }
    if (root.children) {
      const searchNodeSubtree = function(children) {
        for (let i = 0; i < children.length; i++) {
          const childNode = children[i];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          const result = searchNodeSubtree(childNode.children);
          if (result)
            return result;
        }
        return null;
      };
      const subTreeNode = searchNodeSubtree(root.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
});
Object.assign(PropertyBinding.prototype, {
  _getValue_unavailable: function() {
  },
  _setValue_unavailable: function() {
  },
  BindingType: {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  },
  Versioning: {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  },
  GetterByBindingType: [
    function getValue_direct(buffer, offset) {
      buffer[offset] = this.node[this.propertyName];
    },
    function getValue_array(buffer, offset) {
      const source = this.resolvedProperty;
      for (let i = 0, n = source.length; i !== n; ++i) {
        buffer[offset++] = source[i];
      }
    },
    function getValue_arrayElement(buffer, offset) {
      buffer[offset] = this.resolvedProperty[this.propertyIndex];
    },
    function getValue_toArray(buffer, offset) {
      this.resolvedProperty.toArray(buffer, offset);
    }
  ],
  SetterByBindingTypeAndVersioning: [
    [
      function setValue_direct(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
      },
      function setValue_direct_setNeedsUpdate(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
        this.targetObject.needsUpdate = true;
      },
      function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ],
    [
      function setValue_array(buffer, offset) {
        const dest = this.resolvedProperty;
        for (let i = 0, n = dest.length; i !== n; ++i) {
          dest[i] = buffer[offset++];
        }
      },
      function setValue_array_setNeedsUpdate(buffer, offset) {
        const dest = this.resolvedProperty;
        for (let i = 0, n = dest.length; i !== n; ++i) {
          dest[i] = buffer[offset++];
        }
        this.targetObject.needsUpdate = true;
      },
      function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
        const dest = this.resolvedProperty;
        for (let i = 0, n = dest.length; i !== n; ++i) {
          dest[i] = buffer[offset++];
        }
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ],
    [
      function setValue_arrayElement(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
      },
      function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.needsUpdate = true;
      },
      function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ],
    [
      function setValue_fromArray(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
      },
      function setValue_fromArray_setNeedsUpdate(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.needsUpdate = true;
      },
      function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ]
  ],
  getValue: function getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset);
  },
  setValue: function getValue_unbound2(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  },
  bind: function() {
    let targetObject = this.node;
    const parsedPath = this.parsedPath;
    const objectName = parsedPath.objectName;
    const propertyName = parsedPath.propertyName;
    let propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
      this.node = targetObject;
    }
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (!targetObject) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (objectName) {
      let objectIndex = parsedPath.objectIndex;
      switch (objectName) {
        case "materials":
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case "bones":
          if (!targetObject.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (let i = 0; i < targetObject.length; i++) {
            if (targetObject[i].name === objectIndex) {
              objectIndex = i;
              break;
            }
          }
          break;
        default:
          if (targetObject[objectName] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== void 0) {
        if (targetObject[objectIndex] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }
    const nodeProperty = targetObject[propertyName];
    if (nodeProperty === void 0) {
      const nodeName = parsedPath.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
      return;
    }
    let versioning = this.Versioning.None;
    this.targetObject = targetObject;
    if (targetObject.needsUpdate !== void 0) {
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    }
    let bindingType = this.BindingType.Direct;
    if (propertyIndex !== void 0) {
      if (propertyName === "morphTargetInfluences") {
        if (!targetObject.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (targetObject.geometry.isBufferGeometry) {
          if (!targetObject.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
          }
        } else {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
          return;
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  },
  unbind: function() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
});
Object.assign(PropertyBinding.prototype, {
  _getValue_unbound: PropertyBinding.prototype.getValue,
  _setValue_unbound: PropertyBinding.prototype.setValue
});
class AnimationAction {
  constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot;
    this.blendMode = blendMode;
    const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
    const interpolantSettings = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
    for (let i = 0; i !== nTracks; ++i) {
      const interpolant = tracks[i].createInterpolant(null);
      interpolants[i] = interpolant;
      interpolant.settings = interpolantSettings;
    }
    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants;
    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null;
    this._byClipCacheIndex = null;
    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1;
    this._startTime = null;
    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity;
    this.paused = false;
    this.enabled = true;
    this.clampWhenFinished = false;
    this.zeroSlopeAtStart = true;
    this.zeroSlopeAtEnd = true;
  }
  play() {
    this._mixer._activateAction(this);
    return this;
  }
  stop() {
    this._mixer._deactivateAction(this);
    return this.reset();
  }
  reset() {
    this.paused = false;
    this.enabled = true;
    this.time = 0;
    this._loopCount = -1;
    this._startTime = null;
    return this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(time) {
    this._startTime = time;
    return this;
  }
  setLoop(mode, repetitions) {
    this.loop = mode;
    this.repetitions = repetitions;
    return this;
  }
  setEffectiveWeight(weight) {
    this.weight = weight;
    this._effectiveWeight = this.enabled ? weight : 0;
    return this.stopFading();
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(duration) {
    return this._scheduleFading(duration, 0, 1);
  }
  fadeOut(duration) {
    return this._scheduleFading(duration, 1, 0);
  }
  crossFadeFrom(fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration);
    this.fadeIn(duration);
    if (warp) {
      const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
      fadeOutAction.warp(1, startEndRatio, duration);
      this.warp(endStartRatio, 1, duration);
    }
    return this;
  }
  crossFadeTo(fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp);
  }
  stopFading() {
    const weightInterpolant = this._weightInterpolant;
    if (weightInterpolant !== null) {
      this._weightInterpolant = null;
      this._mixer._takeBackControlInterpolant(weightInterpolant);
    }
    return this;
  }
  setEffectiveTimeScale(timeScale) {
    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 : timeScale;
    return this.stopWarping();
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(duration) {
    this.timeScale = this._clip.duration / duration;
    return this.stopWarping();
  }
  syncWith(action) {
    this.time = action.time;
    this.timeScale = action.timeScale;
    return this.stopWarping();
  }
  halt(duration) {
    return this.warp(this._effectiveTimeScale, 0, duration);
  }
  warp(startTimeScale, endTimeScale, duration) {
    const mixer = this._mixer, now2 = mixer.time, timeScale = this.timeScale;
    let interpolant = this._timeScaleInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._timeScaleInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now2;
    times[1] = now2 + duration;
    values[0] = startTimeScale / timeScale;
    values[1] = endTimeScale / timeScale;
    return this;
  }
  stopWarping() {
    const timeScaleInterpolant = this._timeScaleInterpolant;
    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null;
      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
    }
    return this;
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(time, deltaTime, timeDirection, accuIndex) {
    if (!this.enabled) {
      this._updateWeight(time);
      return;
    }
    const startTime = this._startTime;
    if (startTime !== null) {
      const timeRunning = (time - startTime) * timeDirection;
      if (timeRunning < 0 || timeDirection === 0) {
        return;
      }
      this._startTime = null;
      deltaTime = timeDirection * timeRunning;
    }
    deltaTime *= this._updateTimeScale(time);
    const clipTime = this._updateTime(deltaTime);
    const weight = this._updateWeight(time);
    if (weight > 0) {
      const interpolants = this._interpolants;
      const propertyMixers = this._propertyBindings;
      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let j = 0, m = interpolants.length; j !== m; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulateAdditive(weight);
          }
          break;
        case NormalAnimationBlendMode:
        default:
          for (let j = 0, m = interpolants.length; j !== m; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulate(accuIndex, weight);
          }
      }
    }
  }
  _updateWeight(time) {
    let weight = 0;
    if (this.enabled) {
      weight = this.weight;
      const interpolant = this._weightInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        weight *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopFading();
          if (interpolantValue === 0) {
            this.enabled = false;
          }
        }
      }
    }
    this._effectiveWeight = weight;
    return weight;
  }
  _updateTimeScale(time) {
    let timeScale = 0;
    if (!this.paused) {
      timeScale = this.timeScale;
      const interpolant = this._timeScaleInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        timeScale *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopWarping();
          if (timeScale === 0) {
            this.paused = true;
          } else {
            this.timeScale = timeScale;
          }
        }
      }
    }
    this._effectiveTimeScale = timeScale;
    return timeScale;
  }
  _updateTime(deltaTime) {
    const duration = this._clip.duration;
    const loop = this.loop;
    let time = this.time + deltaTime;
    let loopCount = this._loopCount;
    const pingPong = loop === LoopPingPong;
    if (deltaTime === 0) {
      if (loopCount === -1)
        return time;
      return pingPong && (loopCount & 1) === 1 ? duration - time : time;
    }
    if (loop === LoopOnce) {
      if (loopCount === -1) {
        this._loopCount = 0;
        this._setEndings(true, true, false);
      }
      handle_stop: {
        if (time >= duration) {
          time = duration;
        } else if (time < 0) {
          time = 0;
        } else {
          this.time = time;
          break handle_stop;
        }
        if (this.clampWhenFinished)
          this.paused = true;
        else
          this.enabled = false;
        this.time = time;
        this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: deltaTime < 0 ? -1 : 1
        });
      }
    } else {
      if (loopCount === -1) {
        if (deltaTime >= 0) {
          loopCount = 0;
          this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
          this._setEndings(this.repetitions === 0, true, pingPong);
        }
      }
      if (time >= duration || time < 0) {
        const loopDelta = Math.floor(time / duration);
        time -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        const pending = this.repetitions - loopCount;
        if (pending <= 0) {
          if (this.clampWhenFinished)
            this.paused = true;
          else
            this.enabled = false;
          time = deltaTime > 0 ? duration : 0;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: deltaTime > 0 ? 1 : -1
          });
        } else {
          if (pending === 1) {
            const atStart = deltaTime < 0;
            this._setEndings(atStart, !atStart, pingPong);
          } else {
            this._setEndings(false, false, pingPong);
          }
          this._loopCount = loopCount;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta
          });
        }
      } else {
        this.time = time;
      }
      if (pingPong && (loopCount & 1) === 1) {
        return duration - time;
      }
    }
    return time;
  }
  _setEndings(atStart, atEnd, pingPong) {
    const settings = this._interpolantSettings;
    if (pingPong) {
      settings.endingStart = ZeroSlopeEnding;
      settings.endingEnd = ZeroSlopeEnding;
    } else {
      if (atStart) {
        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingStart = WrapAroundEnding;
      }
      if (atEnd) {
        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingEnd = WrapAroundEnding;
      }
    }
  }
  _scheduleFading(duration, weightNow, weightThen) {
    const mixer = this._mixer, now2 = mixer.time;
    let interpolant = this._weightInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._weightInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now2;
    values[0] = weightNow;
    times[1] = now2 + duration;
    values[1] = weightThen;
    return this;
  }
}
class AnimationMixer extends EventDispatcher {
  constructor(root) {
    super();
    this._root = root;
    this._initMemoryManager();
    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1;
  }
  _bindAction(action, prototypeAction) {
    const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
    let bindingsByName = bindingsByRoot[rootUuid];
    if (bindingsByName === void 0) {
      bindingsByName = {};
      bindingsByRoot[rootUuid] = bindingsByName;
    }
    for (let i = 0; i !== nTracks; ++i) {
      const track = tracks[i], trackName = track.name;
      let binding = bindingsByName[trackName];
      if (binding !== void 0) {
        bindings[i] = binding;
      } else {
        binding = bindings[i];
        if (binding !== void 0) {
          if (binding._cacheIndex === null) {
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
          }
          continue;
        }
        const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
        ++binding.referenceCount;
        this._addInactiveBinding(binding, rootUuid, trackName);
        bindings[i] = binding;
      }
      interpolants[i].resultBuffer = binding.buffer;
    }
  }
  _activateAction(action) {
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
        this._addInactiveAction(action, clipUuid, rootUuid);
      }
      const bindings = action._propertyBindings;
      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i];
        if (binding.useCount++ === 0) {
          this._lendBinding(binding);
          binding.saveOriginalState();
        }
      }
      this._lendAction(action);
    }
  }
  _deactivateAction(action) {
    if (this._isActiveAction(action)) {
      const bindings = action._propertyBindings;
      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i];
        if (--binding.useCount === 0) {
          binding.restoreOriginalState();
          this._takeBackBinding(binding);
        }
      }
      this._takeBackAction(action);
    }
  }
  _initMemoryManager() {
    this._actions = [];
    this._nActiveActions = 0;
    this._actionsByClip = {};
    this._bindings = [];
    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {};
    this._controlInterpolants = [];
    this._nActiveControlInterpolants = 0;
    const scope = this;
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length;
        },
        get inUse() {
          return scope._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return scope._bindings.length;
        },
        get inUse() {
          return scope._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length;
        },
        get inUse() {
          return scope._nActiveControlInterpolants;
        }
      }
    };
  }
  _isActiveAction(action) {
    const index = action._cacheIndex;
    return index !== null && index < this._nActiveActions;
  }
  _addInactiveAction(action, clipUuid, rootUuid) {
    const actions = this._actions, actionsByClip = this._actionsByClip;
    let actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip === void 0) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {}
      };
      action._byClipCacheIndex = 0;
      actionsByClip[clipUuid] = actionsForClip;
    } else {
      const knownActions = actionsForClip.knownActions;
      action._byClipCacheIndex = knownActions.length;
      knownActions.push(action);
    }
    action._cacheIndex = actions.length;
    actions.push(action);
    actionsForClip.actionByRoot[rootUuid] = action;
  }
  _removeInactiveAction(action) {
    const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
    lastInactiveAction._cacheIndex = cacheIndex;
    actions[cacheIndex] = lastInactiveAction;
    actions.pop();
    action._cacheIndex = null;
    const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
    knownActionsForClip.pop();
    action._byClipCacheIndex = null;
    const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
    delete actionByRoot[rootUuid];
    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid];
    }
    this._removeInactiveBindingsForAction(action);
  }
  _removeInactiveBindingsForAction(action) {
    const bindings = action._propertyBindings;
    for (let i = 0, n = bindings.length; i !== n; ++i) {
      const binding = bindings[i];
      if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding);
      }
    }
  }
  _lendAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
    action._cacheIndex = lastActiveIndex;
    actions[lastActiveIndex] = action;
    firstInactiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = firstInactiveAction;
  }
  _takeBackAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
    action._cacheIndex = firstInactiveIndex;
    actions[firstInactiveIndex] = action;
    lastActiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = lastActiveAction;
  }
  _addInactiveBinding(binding, rootUuid, trackName) {
    const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
    let bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName === void 0) {
      bindingByName = {};
      bindingsByRoot[rootUuid] = bindingByName;
    }
    bindingByName[trackName] = binding;
    binding._cacheIndex = bindings.length;
    bindings.push(binding);
  }
  _removeInactiveBinding(binding) {
    const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[cacheIndex] = lastInactiveBinding;
    bindings.pop();
    delete bindingByName[trackName];
    if (Object.keys(bindingByName).length === 0) {
      delete bindingsByRoot[rootUuid];
    }
  }
  _lendBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
    binding._cacheIndex = lastActiveIndex;
    bindings[lastActiveIndex] = binding;
    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = firstInactiveBinding;
  }
  _takeBackBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
    binding._cacheIndex = firstInactiveIndex;
    bindings[firstInactiveIndex] = binding;
    lastActiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = lastActiveBinding;
  }
  _lendControlInterpolant() {
    const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
    let interpolant = interpolants[lastActiveIndex];
    if (interpolant === void 0) {
      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[lastActiveIndex] = interpolant;
    }
    return interpolant;
  }
  _takeBackControlInterpolant(interpolant) {
    const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[firstInactiveIndex] = interpolant;
    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[prevIndex] = lastActiveInterpolant;
  }
  clipAction(clip, optionalRoot, blendMode) {
    const root = optionalRoot || this._root, rootUuid = root.uuid;
    let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
    const clipUuid = clipObject !== null ? clipObject.uuid : clip;
    const actionsForClip = this._actionsByClip[clipUuid];
    let prototypeAction = null;
    if (blendMode === void 0) {
      if (clipObject !== null) {
        blendMode = clipObject.blendMode;
      } else {
        blendMode = NormalAnimationBlendMode;
      }
    }
    if (actionsForClip !== void 0) {
      const existingAction = actionsForClip.actionByRoot[rootUuid];
      if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
        return existingAction;
      }
      prototypeAction = actionsForClip.knownActions[0];
      if (clipObject === null)
        clipObject = prototypeAction._clip;
    }
    if (clipObject === null)
      return null;
    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
    this._bindAction(newAction, prototypeAction);
    this._addInactiveAction(newAction, clipUuid, rootUuid);
    return newAction;
  }
  existingAction(clip, optionalRoot) {
    const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      return actionsForClip.actionByRoot[rootUuid] || null;
    }
    return null;
  }
  stopAllAction() {
    const actions = this._actions, nActions = this._nActiveActions;
    for (let i = nActions - 1; i >= 0; --i) {
      actions[i].stop();
    }
    return this;
  }
  update(deltaTime) {
    deltaTime *= this.timeScale;
    const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
    for (let i = 0; i !== nActions; ++i) {
      const action = actions[i];
      action._update(time, deltaTime, timeDirection, accuIndex);
    }
    const bindings = this._bindings, nBindings = this._nActiveBindings;
    for (let i = 0; i !== nBindings; ++i) {
      bindings[i].apply(accuIndex);
    }
    return this;
  }
  setTime(timeInSeconds) {
    this.time = 0;
    for (let i = 0; i < this._actions.length; i++) {
      this._actions[i].time = 0;
    }
    return this.update(timeInSeconds);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(clip) {
    const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      const actionsToRemove = actionsForClip.knownActions;
      for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
        const action = actionsToRemove[i];
        this._deactivateAction(action);
        const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        this._removeInactiveBindingsForAction(action);
      }
      delete actionsByClip[clipUuid];
    }
  }
  uncacheRoot(root) {
    const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
    for (const clipUuid in actionsByClip) {
      const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
      if (action !== void 0) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
    const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName !== void 0) {
      for (const trackName in bindingByName) {
        const binding = bindingByName[trackName];
        binding.restoreOriginalState();
        this._removeInactiveBinding(binding);
      }
    }
  }
  uncacheAction(clip, optionalRoot) {
    const action = this.existingAction(clip, optionalRoot);
    if (action !== null) {
      this._deactivateAction(action);
      this._removeInactiveAction(action);
    }
  }
}
AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
  InterleavedBuffer.call(this, array, stride);
  this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
  constructor: InstancedInterleavedBuffer,
  isInstancedInterleavedBuffer: true,
  copy: function(source) {
    InterleavedBuffer.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  },
  clone: function(data) {
    const ib = InterleavedBuffer.prototype.clone.call(this, data);
    ib.meshPerAttribute = this.meshPerAttribute;
    return ib;
  },
  toJSON: function(data) {
    const json = InterleavedBuffer.prototype.toJSON.call(this, data);
    json.isInstancedInterleavedBuffer = true;
    json.meshPerAttribute = this.meshPerAttribute;
    return json;
  }
});
function GLBufferAttribute(buffer, type, itemSize, elementSize, count) {
  this.buffer = buffer;
  this.type = type;
  this.itemSize = itemSize;
  this.elementSize = elementSize;
  this.count = count;
  this.version = 0;
}
Object.defineProperty(GLBufferAttribute.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
Object.assign(GLBufferAttribute.prototype, {
  isGLBufferAttribute: true,
  setBuffer: function(buffer) {
    this.buffer = buffer;
    return this;
  },
  setType: function(type, elementSize) {
    this.type = type;
    this.elementSize = elementSize;
    return this;
  },
  setItemSize: function(itemSize) {
    this.itemSize = itemSize;
    return this;
  },
  setCount: function(count) {
    this.count = count;
    return this;
  }
});
function Raycaster(origin, direction, near = 0, far = Infinity) {
  this.ray = new Ray(origin, direction);
  this.near = near;
  this.far = far;
  this.camera = null;
  this.layers = new Layers();
  this.params = {
    Mesh: {},
    Line: {threshold: 1},
    LOD: {},
    Points: {threshold: 1},
    Sprite: {}
  };
  Object.defineProperties(this.params, {
    PointCloud: {
      get: function() {
        console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
        return this.Points;
      }
    }
  });
}
function ascSort(a, b) {
  return a.distance - b.distance;
}
function intersectObject(object, raycaster, intersects, recursive) {
  if (object.layers.test(raycaster.layers)) {
    object.raycast(raycaster, intersects);
  }
  if (recursive === true) {
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      intersectObject(children[i], raycaster, intersects, true);
    }
  }
}
Object.assign(Raycaster.prototype, {
  set: function(origin, direction) {
    this.ray.set(origin, direction);
  },
  setFromCamera: function(coords, camera) {
    if (camera && camera.isPerspectiveCamera) {
      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
      this.camera = camera;
    } else if (camera && camera.isOrthographicCamera) {
      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
      this.camera = camera;
    } else {
      console.error("THREE.Raycaster: Unsupported camera type: " + camera.type);
    }
  },
  intersectObject: function(object, recursive = false, intersects = []) {
    intersectObject(object, this, intersects, recursive);
    intersects.sort(ascSort);
    return intersects;
  },
  intersectObjects: function(objects, recursive = false, intersects = []) {
    for (let i = 0, l = objects.length; i < l; i++) {
      intersectObject(objects[i], this, intersects, recursive);
    }
    intersects.sort(ascSort);
    return intersects;
  }
});
function ImmediateRenderObject(material) {
  Object3D.call(this);
  this.material = material;
  this.render = function() {
  };
  this.hasPositions = false;
  this.hasNormals = false;
  this.hasColors = false;
  this.hasUvs = false;
  this.positionArray = null;
  this.normalArray = null;
  this.colorArray = null;
  this.uvArray = null;
  this.count = 0;
}
ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
ImmediateRenderObject.prototype.isImmediateRenderObject = true;
const _axis = /* @__PURE__ */ new Vector3();
let _lineGeometry, _coneGeometry;
class ArrowHelper extends Object3D {
  constructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 16776960, headLength = length * 0.2, headWidth = headLength * 0.2) {
    super();
    this.type = "ArrowHelper";
    if (_lineGeometry === void 0) {
      _lineGeometry = new BufferGeometry();
      _lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
      _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
      _coneGeometry.translate(0, -0.5, 0);
    }
    this.position.copy(origin);
    this.line = new Line(_lineGeometry, new LineBasicMaterial({color, toneMapped: false}));
    this.line.matrixAutoUpdate = false;
    this.add(this.line);
    this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({color, toneMapped: false}));
    this.cone.matrixAutoUpdate = false;
    this.add(this.cone);
    this.setDirection(dir);
    this.setLength(length, headLength, headWidth);
  }
  setDirection(dir) {
    if (dir.y > 0.99999) {
      this.quaternion.set(0, 0, 0, 1);
    } else if (dir.y < -0.99999) {
      this.quaternion.set(1, 0, 0, 0);
    } else {
      _axis.set(dir.z, 0, -dir.x).normalize();
      const radians = Math.acos(dir.y);
      this.quaternion.setFromAxisAngle(_axis, radians);
    }
  }
  setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, length - headLength), 1);
    this.line.updateMatrix();
    this.cone.scale.set(headWidth, headLength, headWidth);
    this.cone.position.y = length;
    this.cone.updateMatrix();
  }
  setColor(color) {
    this.line.material.color.set(color);
    this.cone.material.color.set(color);
  }
  copy(source) {
    super.copy(source, false);
    this.line.copy(source.line);
    this.cone.copy(source.cone);
    return this;
  }
}
const backgroundMaterial = new MeshBasicMaterial({
  side: BackSide,
  depthWrite: false,
  depthTest: false
});
new Mesh(new BoxGeometry(), backgroundMaterial);
Curve.create = function(construct, getPoint) {
  console.log("THREE.Curve.create() has been deprecated");
  construct.prototype = Object.create(Curve.prototype);
  construct.prototype.constructor = construct;
  construct.prototype.getPoint = getPoint;
  return construct;
};
Loader.prototype.extractUrlBase = function(url) {
  console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
  return LoaderUtils.extractUrlBase(url);
};
Loader.Handlers = {
  add: function() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  },
  get: function() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  }
};
Box3.prototype.center = function(optionalTarget) {
  console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Box3.prototype.empty = function() {
  console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Box3.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Box3.prototype.isIntersectionSphere = function(sphere) {
  console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
  return this.intersectsSphere(sphere);
};
Box3.prototype.size = function(optionalTarget) {
  console.warn("THREE.Box3: .size() has been renamed to .getSize().");
  return this.getSize(optionalTarget);
};
Sphere.prototype.empty = function() {
  console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Frustum.prototype.setFromMatrix = function(m) {
  console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
  return this.setFromProjectionMatrix(m);
};
MathUtils.random16 = function() {
  console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");
  return Math.random();
};
MathUtils.nearestPowerOfTwo = function(value) {
  console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");
  return MathUtils.floorPowerOfTwo(value);
};
MathUtils.nextPowerOfTwo = function(value) {
  console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
  return MathUtils.ceilPowerOfTwo(value);
};
Matrix3.prototype.flattenToArrayOffset = function(array, offset) {
  console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
  return this.toArray(array, offset);
};
Matrix3.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
  return vector.applyMatrix3(this);
};
Matrix3.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
};
Matrix3.prototype.applyToBufferAttribute = function(attribute) {
  console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
  return attribute.applyMatrix3(this);
};
Matrix3.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
};
Matrix3.prototype.getInverse = function(matrix) {
  console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
  return this.copy(matrix).invert();
};
Matrix4.prototype.extractPosition = function(m) {
  console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
  return this.copyPosition(m);
};
Matrix4.prototype.flattenToArrayOffset = function(array, offset) {
  console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
  return this.toArray(array, offset);
};
Matrix4.prototype.getPosition = function() {
  console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
  return new Vector3().setFromMatrixColumn(this, 3);
};
Matrix4.prototype.setRotationFromQuaternion = function(q) {
  console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
  return this.makeRotationFromQuaternion(q);
};
Matrix4.prototype.multiplyToArray = function() {
  console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
};
Matrix4.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector4 = function(vector) {
  console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
};
Matrix4.prototype.rotateAxis = function(v) {
  console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
  v.transformDirection(this);
};
Matrix4.prototype.crossVector = function(vector) {
  console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.translate = function() {
  console.error("THREE.Matrix4: .translate() has been removed.");
};
Matrix4.prototype.rotateX = function() {
  console.error("THREE.Matrix4: .rotateX() has been removed.");
};
Matrix4.prototype.rotateY = function() {
  console.error("THREE.Matrix4: .rotateY() has been removed.");
};
Matrix4.prototype.rotateZ = function() {
  console.error("THREE.Matrix4: .rotateZ() has been removed.");
};
Matrix4.prototype.rotateByAxis = function() {
  console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
};
Matrix4.prototype.applyToBufferAttribute = function(attribute) {
  console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
  return attribute.applyMatrix4(this);
};
Matrix4.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
};
Matrix4.prototype.makeFrustum = function(left, right, bottom, top, near, far) {
  console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
  return this.makePerspective(left, right, top, bottom, near, far);
};
Matrix4.prototype.getInverse = function(matrix) {
  console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
  return this.copy(matrix).invert();
};
Plane.prototype.isIntersectionLine = function(line) {
  console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
  return this.intersectsLine(line);
};
Quaternion.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
  return vector.applyQuaternion(this);
};
Quaternion.prototype.inverse = function() {
  console.warn("THREE.Quaternion: .inverse() has been renamed to invert().");
  return this.invert();
};
Ray.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Ray.prototype.isIntersectionPlane = function(plane) {
  console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
  return this.intersectsPlane(plane);
};
Ray.prototype.isIntersectionSphere = function(sphere) {
  console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
  return this.intersectsSphere(sphere);
};
Triangle.prototype.area = function() {
  console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
  return this.getArea();
};
Triangle.prototype.barycoordFromPoint = function(point, target) {
  console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
  return this.getBarycoord(point, target);
};
Triangle.prototype.midpoint = function(target) {
  console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
  return this.getMidpoint(target);
};
Triangle.prototypenormal = function(target) {
  console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
  return this.getNormal(target);
};
Triangle.prototype.plane = function(target) {
  console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
  return this.getPlane(target);
};
Triangle.barycoordFromPoint = function(point, a, b, c, target) {
  console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
  return Triangle.getBarycoord(point, a, b, c, target);
};
Triangle.normal = function(a, b, c, target) {
  console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
  return Triangle.getNormal(a, b, c, target);
};
Vector2.prototype.fromAttribute = function(attribute, index, offset) {
  console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset);
};
Vector2.prototype.distanceToManhattan = function(v) {
  console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
  return this.manhattanDistanceTo(v);
};
Vector2.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Vector3.prototype.setEulerFromRotationMatrix = function() {
  console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
};
Vector3.prototype.setEulerFromQuaternion = function() {
  console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
};
Vector3.prototype.getPositionFromMatrix = function(m) {
  console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
  return this.setFromMatrixPosition(m);
};
Vector3.prototype.getScaleFromMatrix = function(m) {
  console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
  return this.setFromMatrixScale(m);
};
Vector3.prototype.getColumnFromMatrix = function(index, matrix) {
  console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
  return this.setFromMatrixColumn(matrix, index);
};
Vector3.prototype.applyProjection = function(m) {
  console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
  return this.applyMatrix4(m);
};
Vector3.prototype.fromAttribute = function(attribute, index, offset) {
  console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset);
};
Vector3.prototype.distanceToManhattan = function(v) {
  console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
  return this.manhattanDistanceTo(v);
};
Vector3.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Vector4.prototype.fromAttribute = function(attribute, index, offset) {
  console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset);
};
Vector4.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Object3D.prototype.getChildByName = function(name) {
  console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
  return this.getObjectByName(name);
};
Object3D.prototype.renderDepth = function() {
  console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
};
Object3D.prototype.translate = function(distance, axis) {
  console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
  return this.translateOnAxis(axis, distance);
};
Object3D.prototype.getWorldRotation = function() {
  console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
};
Object3D.prototype.applyMatrix = function(matrix) {
  console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
  return this.applyMatrix4(matrix);
};
Object.defineProperties(Object3D.prototype, {
  eulerOrder: {
    get: function() {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      return this.rotation.order;
    },
    set: function(value) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      this.rotation.order = value;
    }
  },
  useQuaternion: {
    get: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }
  }
});
Mesh.prototype.setDrawMode = function() {
  console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
};
Object.defineProperties(Mesh.prototype, {
  drawMode: {
    get: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
      return TrianglesDrawMode;
    },
    set: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }
  }
});
SkinnedMesh.prototype.initBones = function() {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
Object.defineProperty(Curve.prototype, "__arcLengthDivisions", {
  get: function() {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
    return this.arcLengthDivisions;
  },
  set: function(value) {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
    this.arcLengthDivisions = value;
  }
});
PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
  if (filmGauge !== void 0)
    this.filmGauge = filmGauge;
  this.setFocalLength(focalLength);
};
Object.defineProperties(Light.prototype, {
  onlyShadow: {
    set: function() {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }
  },
  shadowCameraFov: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
      this.shadow.camera.fov = value;
    }
  },
  shadowCameraLeft: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
      this.shadow.camera.left = value;
    }
  },
  shadowCameraRight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
      this.shadow.camera.right = value;
    }
  },
  shadowCameraTop: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
      this.shadow.camera.top = value;
    }
  },
  shadowCameraBottom: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
      this.shadow.camera.bottom = value;
    }
  },
  shadowCameraNear: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
      this.shadow.camera.near = value;
    }
  },
  shadowCameraFar: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
      this.shadow.camera.far = value;
    }
  },
  shadowCameraVisible: {
    set: function() {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }
  },
  shadowBias: {
    set: function(value) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
      this.shadow.bias = value;
    }
  },
  shadowDarkness: {
    set: function() {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }
  },
  shadowMapWidth: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
      this.shadow.mapSize.width = value;
    }
  },
  shadowMapHeight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
      this.shadow.mapSize.height = value;
    }
  }
});
Object.defineProperties(BufferAttribute.prototype, {
  length: {
    get: function() {
      console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
      return this.array.length;
    }
  },
  dynamic: {
    get: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
      return this.usage === DynamicDrawUsage;
    },
    set: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
      this.setUsage(DynamicDrawUsage);
    }
  }
});
BufferAttribute.prototype.setDynamic = function(value) {
  console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};
BufferAttribute.prototype.copyIndicesArray = function() {
  console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
}, BufferAttribute.prototype.setArray = function() {
  console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
BufferGeometry.prototype.addIndex = function(index) {
  console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
  this.setIndex(index);
};
BufferGeometry.prototype.addAttribute = function(name, attribute) {
  console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
  if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
    console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
    return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
  }
  if (name === "index") {
    console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
    this.setIndex(attribute);
    return this;
  }
  return this.setAttribute(name, attribute);
};
BufferGeometry.prototype.addDrawCall = function(start, count, indexOffset) {
  if (indexOffset !== void 0) {
    console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
  }
  console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
  this.addGroup(start, count);
};
BufferGeometry.prototype.clearDrawCalls = function() {
  console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
  this.clearGroups();
};
BufferGeometry.prototype.computeOffsets = function() {
  console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
};
BufferGeometry.prototype.removeAttribute = function(name) {
  console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
  return this.deleteAttribute(name);
};
BufferGeometry.prototype.applyMatrix = function(matrix) {
  console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
  return this.applyMatrix4(matrix);
};
Object.defineProperties(BufferGeometry.prototype, {
  drawcalls: {
    get: function() {
      console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
      return this.groups;
    }
  },
  offsets: {
    get: function() {
      console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
      return this.groups;
    }
  }
});
Object.defineProperties(InstancedBufferGeometry.prototype, {
  maxInstancedCount: {
    get: function() {
      console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.");
      return this.instanceCount;
    },
    set: function(value) {
      console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.");
      this.instanceCount = value;
    }
  }
});
Object.defineProperties(Raycaster.prototype, {
  linePrecision: {
    get: function() {
      console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.");
      return this.params.Line.threshold;
    },
    set: function(value) {
      console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.");
      this.params.Line.threshold = value;
    }
  }
});
Object.defineProperties(InterleavedBuffer.prototype, {
  dynamic: {
    get: function() {
      console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
      return this.usage === DynamicDrawUsage;
    },
    set: function(value) {
      console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
      this.setUsage(value);
    }
  }
});
InterleavedBuffer.prototype.setDynamic = function(value) {
  console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};
InterleavedBuffer.prototype.setArray = function() {
  console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
Scene.prototype.dispose = function() {
  console.error("THREE.Scene: .dispose() has been removed.");
};
Object.defineProperties(Material.prototype, {
  wrapAround: {
    get: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }
  },
  overdraw: {
    get: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    }
  },
  wrapRGB: {
    get: function() {
      console.warn("THREE.Material: .wrapRGB has been removed.");
      return new Color();
    }
  },
  shading: {
    get: function() {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
      this.flatShading = value === FlatShading;
    }
  },
  stencilMask: {
    get: function() {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
      return this.stencilFuncMask;
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
      this.stencilFuncMask = value;
    }
  }
});
Object.defineProperties(MeshPhysicalMaterial.prototype, {
  transparency: {
    get: function() {
      console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.");
      return this.transmission;
    },
    set: function(value) {
      console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.");
      this.transmission = value;
    }
  }
});
Object.defineProperties(ShaderMaterial.prototype, {
  derivatives: {
    get: function() {
      console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      return this.extensions.derivatives;
    },
    set: function(value) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      this.extensions.derivatives = value;
    }
  }
});
WebGLRenderer.prototype.clearTarget = function(renderTarget, color, depth, stencil) {
  console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
  this.setRenderTarget(renderTarget);
  this.clear(color, depth, stencil);
};
WebGLRenderer.prototype.animate = function(callback) {
  console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
  this.setAnimationLoop(callback);
};
WebGLRenderer.prototype.getCurrentRenderTarget = function() {
  console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
  return this.getRenderTarget();
};
WebGLRenderer.prototype.getMaxAnisotropy = function() {
  console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
  return this.capabilities.getMaxAnisotropy();
};
WebGLRenderer.prototype.getPrecision = function() {
  console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
  return this.capabilities.precision;
};
WebGLRenderer.prototype.resetGLState = function() {
  console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
  return this.state.reset();
};
WebGLRenderer.prototype.supportsFloatTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
  return this.extensions.get("OES_texture_float");
};
WebGLRenderer.prototype.supportsHalfFloatTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
  return this.extensions.get("OES_texture_half_float");
};
WebGLRenderer.prototype.supportsStandardDerivatives = function() {
  console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
  return this.extensions.get("OES_standard_derivatives");
};
WebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {
  console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
  return this.extensions.get("WEBGL_compressed_texture_s3tc");
};
WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {
  console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
  return this.extensions.get("WEBGL_compressed_texture_pvrtc");
};
WebGLRenderer.prototype.supportsBlendMinMax = function() {
  console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
  return this.extensions.get("EXT_blend_minmax");
};
WebGLRenderer.prototype.supportsVertexTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
  return this.capabilities.vertexTextures;
};
WebGLRenderer.prototype.supportsInstancedArrays = function() {
  console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
  return this.extensions.get("ANGLE_instanced_arrays");
};
WebGLRenderer.prototype.enableScissorTest = function(boolean) {
  console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
  this.setScissorTest(boolean);
};
WebGLRenderer.prototype.initMaterial = function() {
  console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
};
WebGLRenderer.prototype.addPrePlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
};
WebGLRenderer.prototype.addPostPlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
};
WebGLRenderer.prototype.updateShadowMap = function() {
  console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
};
WebGLRenderer.prototype.setFaceCulling = function() {
  console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
};
WebGLRenderer.prototype.allocTextureUnit = function() {
  console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
};
WebGLRenderer.prototype.setTexture = function() {
  console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
};
WebGLRenderer.prototype.setTexture2D = function() {
  console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
};
WebGLRenderer.prototype.setTextureCube = function() {
  console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
};
WebGLRenderer.prototype.getActiveMipMapLevel = function() {
  console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
  return this.getActiveMipmapLevel();
};
Object.defineProperties(WebGLRenderer.prototype, {
  shadowMapEnabled: {
    get: function() {
      return this.shadowMap.enabled;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
      this.shadowMap.enabled = value;
    }
  },
  shadowMapType: {
    get: function() {
      return this.shadowMap.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
      this.shadowMap.type = value;
    }
  },
  shadowMapCullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  context: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
      return this.getContext();
    }
  },
  vr: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
      return this.xr;
    }
  },
  gammaInput: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
      return false;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
    }
  },
  gammaOutput: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      return false;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
    }
  },
  toneMappingWhitePoint: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
      return 1;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
    }
  }
});
Object.defineProperties(WebGLShadowMap.prototype, {
  cullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  renderReverseSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }
  },
  renderSingleSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }
  }
});
Object.defineProperties(WebGLRenderTarget.prototype, {
  wrapS: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      return this.texture.wrapS;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      this.texture.wrapS = value;
    }
  },
  wrapT: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      return this.texture.wrapT;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      this.texture.wrapT = value;
    }
  },
  magFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      return this.texture.magFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      this.texture.magFilter = value;
    }
  },
  minFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      return this.texture.minFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      this.texture.minFilter = value;
    }
  },
  anisotropy: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      return this.texture.anisotropy;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      this.texture.anisotropy = value;
    }
  },
  offset: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      return this.texture.offset;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      this.texture.offset = value;
    }
  },
  repeat: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      return this.texture.repeat;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      this.texture.repeat = value;
    }
  },
  format: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      return this.texture.format;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      this.texture.format = value;
    }
  },
  type: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      return this.texture.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      this.texture.type = value;
    }
  },
  generateMipmaps: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      return this.texture.generateMipmaps;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      this.texture.generateMipmaps = value;
    }
  }
});
CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
  console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
  return this.update(renderer, scene);
};
CubeCamera.prototype.clear = function(renderer, color, depth, stencil) {
  console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear().");
  return this.renderTarget.clear(renderer, color, depth, stencil);
};
ImageUtils.crossOrigin = void 0;
ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
  const loader = new TextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(url, onLoad, void 0, onError);
  if (mapping)
    texture.mapping = mapping;
  return texture;
};
ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
  const loader = new CubeTextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(urls, onLoad, void 0, onError);
  if (mapping)
    texture.mapping = mapping;
  return texture;
};
ImageUtils.loadCompressedTexture = function() {
  console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
};
ImageUtils.loadCompressedTextureCube = function() {
  console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
};
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {detail: {
    revision: REVISION
  }}));
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    console.warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}
var GLTFLoader = function() {
  function GLTFLoader2(manager) {
    Loader.call(this, manager);
    this.dracoLoader = null;
    this.ktx2Loader = null;
    this.meshoptDecoder = null;
    this.pluginCallbacks = [];
    this.register(function(parser) {
      return new GLTFMaterialsClearcoatExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureBasisUExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureWebPExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsTransmissionExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFLightsExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshoptCompression(parser);
    });
  }
  GLTFLoader2.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: GLTFLoader2,
    load: function(url, onLoad, onProgress, onError) {
      var scope = this;
      var resourcePath;
      if (this.resourcePath !== "") {
        resourcePath = this.resourcePath;
      } else if (this.path !== "") {
        resourcePath = this.path;
      } else {
        resourcePath = LoaderUtils.extractUrlBase(url);
      }
      this.manager.itemStart(url);
      var _onError = function(e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      };
      var loader = new FileLoader(this.manager);
      loader.setPath(this.path);
      loader.setResponseType("arraybuffer");
      loader.setRequestHeader(this.requestHeader);
      loader.setWithCredentials(this.withCredentials);
      loader.load(url, function(data) {
        try {
          scope.parse(data, resourcePath, function(gltf) {
            onLoad(gltf);
            scope.manager.itemEnd(url);
          }, _onError);
        } catch (e) {
          _onError(e);
        }
      }, onProgress, _onError);
    },
    setDRACOLoader: function(dracoLoader) {
      this.dracoLoader = dracoLoader;
      return this;
    },
    setDDSLoader: function() {
      throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
    },
    setKTX2Loader: function(ktx2Loader) {
      this.ktx2Loader = ktx2Loader;
      return this;
    },
    setMeshoptDecoder: function(meshoptDecoder) {
      this.meshoptDecoder = meshoptDecoder;
      return this;
    },
    register: function(callback) {
      if (this.pluginCallbacks.indexOf(callback) === -1) {
        this.pluginCallbacks.push(callback);
      }
      return this;
    },
    unregister: function(callback) {
      if (this.pluginCallbacks.indexOf(callback) !== -1) {
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
      }
      return this;
    },
    parse: function(data, path, onLoad, onError) {
      var content;
      var extensions = {};
      var plugins = {};
      if (typeof data === "string") {
        content = data;
      } else {
        var magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));
        if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
          try {
            extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
          } catch (error) {
            if (onError)
              onError(error);
            return;
          }
          content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;
        } else {
          content = LoaderUtils.decodeText(new Uint8Array(data));
        }
      }
      var json = JSON.parse(content);
      if (json.asset === void 0 || json.asset.version[0] < 2) {
        if (onError)
          onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
        return;
      }
      var parser = new GLTFParser(json, {
        path: path || this.resourcePath || "",
        crossOrigin: this.crossOrigin,
        requestHeader: this.requestHeader,
        manager: this.manager,
        ktx2Loader: this.ktx2Loader,
        meshoptDecoder: this.meshoptDecoder
      });
      parser.fileLoader.setRequestHeader(this.requestHeader);
      for (var i = 0; i < this.pluginCallbacks.length; i++) {
        var plugin = this.pluginCallbacks[i](parser);
        plugins[plugin.name] = plugin;
        extensions[plugin.name] = true;
      }
      if (json.extensionsUsed) {
        for (var i = 0; i < json.extensionsUsed.length; ++i) {
          var extensionName = json.extensionsUsed[i];
          var extensionsRequired = json.extensionsRequired || [];
          switch (extensionName) {
            case EXTENSIONS.KHR_MATERIALS_UNLIT:
              extensions[extensionName] = new GLTFMaterialsUnlitExtension();
              break;
            case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
              extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();
              break;
            case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
              extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
              break;
            case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
              extensions[extensionName] = new GLTFTextureTransformExtension();
              break;
            case EXTENSIONS.KHR_MESH_QUANTIZATION:
              extensions[extensionName] = new GLTFMeshQuantizationExtension();
              break;
            default:
              if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
                console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
              }
          }
        }
      }
      parser.setExtensions(extensions);
      parser.setPlugins(plugins);
      parser.parse(onLoad, onError);
    }
  });
  function GLTFRegistry() {
    var objects = {};
    return {
      get: function(key) {
        return objects[key];
      },
      add: function(key, object) {
        objects[key] = object;
      },
      remove: function(key) {
        delete objects[key];
      },
      removeAll: function() {
        objects = {};
      }
    };
  }
  var EXTENSIONS = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
  };
  function GLTFLightsExtension(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
    this.cache = {refs: {}, uses: {}};
  }
  GLTFLightsExtension.prototype._markDefs = function() {
    var parser = this.parser;
    var nodeDefs = this.parser.json.nodes || [];
    for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      var nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
      }
    }
  };
  GLTFLightsExtension.prototype._loadLight = function(lightIndex) {
    var parser = this.parser;
    var cacheKey = "light:" + lightIndex;
    var dependency = parser.cache.get(cacheKey);
    if (dependency)
      return dependency;
    var json = parser.json;
    var extensions = json.extensions && json.extensions[this.name] || {};
    var lightDefs = extensions.lights || [];
    var lightDef = lightDefs[lightIndex];
    var lightNode;
    var color = new Color(16777215);
    if (lightDef.color !== void 0)
      color.fromArray(lightDef.color);
    var range = lightDef.range !== void 0 ? lightDef.range : 0;
    switch (lightDef.type) {
      case "directional":
        lightNode = new DirectionalLight(color);
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      case "point":
        lightNode = new PointLight(color);
        lightNode.distance = range;
        break;
      case "spot":
        lightNode = new SpotLight(color);
        lightNode.distance = range;
        lightDef.spot = lightDef.spot || {};
        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
        lightNode.angle = lightDef.spot.outerConeAngle;
        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
    }
    lightNode.position.set(0, 0, 0);
    lightNode.decay = 2;
    if (lightDef.intensity !== void 0)
      lightNode.intensity = lightDef.intensity;
    lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
    dependency = Promise.resolve(lightNode);
    parser.cache.add(cacheKey, dependency);
    return dependency;
  };
  GLTFLightsExtension.prototype.createNodeAttachment = function(nodeIndex) {
    var self2 = this;
    var parser = this.parser;
    var json = parser.json;
    var nodeDef = json.nodes[nodeIndex];
    var lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
    var lightIndex = lightDef.light;
    if (lightIndex === void 0)
      return null;
    return this._loadLight(lightIndex).then(function(light) {
      return parser._getNodeRef(self2.cache, lightIndex, light);
    });
  };
  function GLTFMaterialsUnlitExtension() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  GLTFMaterialsUnlitExtension.prototype.getMaterialType = function() {
    return MeshBasicMaterial;
  };
  GLTFMaterialsUnlitExtension.prototype.extendParams = function(materialParams, materialDef, parser) {
    var pending = [];
    materialParams.color = new Color(1, 1, 1);
    materialParams.opacity = 1;
    var metallicRoughness = materialDef.pbrMetallicRoughness;
    if (metallicRoughness) {
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        var array = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture));
      }
    }
    return Promise.all(pending);
  };
  function GLTFMaterialsClearcoatExtension(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
  }
  GLTFMaterialsClearcoatExtension.prototype.getMaterialType = function(materialIndex) {
    var parser = this.parser;
    var materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  };
  GLTFMaterialsClearcoatExtension.prototype.extendMaterialParams = function(materialIndex, materialParams) {
    var parser = this.parser;
    var materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    var pending = [];
    var extension = materialDef.extensions[this.name];
    if (extension.clearcoatFactor !== void 0) {
      materialParams.clearcoat = extension.clearcoatFactor;
    }
    if (extension.clearcoatTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
    }
    if (extension.clearcoatRoughnessFactor !== void 0) {
      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
    }
    if (extension.clearcoatRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
    }
    if (extension.clearcoatNormalTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
      if (extension.clearcoatNormalTexture.scale !== void 0) {
        var scale = extension.clearcoatNormalTexture.scale;
        materialParams.clearcoatNormalScale = new Vector2(scale, -scale);
      }
    }
    return Promise.all(pending);
  };
  function GLTFMaterialsTransmissionExtension(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
  }
  GLTFMaterialsTransmissionExtension.prototype.getMaterialType = function(materialIndex) {
    var parser = this.parser;
    var materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  };
  GLTFMaterialsTransmissionExtension.prototype.extendMaterialParams = function(materialIndex, materialParams) {
    var parser = this.parser;
    var materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    var pending = [];
    var extension = materialDef.extensions[this.name];
    if (extension.transmissionFactor !== void 0) {
      materialParams.transmission = extension.transmissionFactor;
    }
    if (extension.transmissionTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
    }
    return Promise.all(pending);
  };
  function GLTFTextureBasisUExtension(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
  }
  GLTFTextureBasisUExtension.prototype.loadTexture = function(textureIndex) {
    var parser = this.parser;
    var json = parser.json;
    var textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[this.name]) {
      return null;
    }
    var extension = textureDef.extensions[this.name];
    var source = json.images[extension.source];
    var loader = parser.options.ktx2Loader;
    if (!loader) {
      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      } else {
        return null;
      }
    }
    return parser.loadTextureImage(textureIndex, source, loader);
  };
  function GLTFTextureWebPExtension(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
    this.isSupported = null;
  }
  GLTFTextureWebPExtension.prototype.loadTexture = function(textureIndex) {
    var name = this.name;
    var parser = this.parser;
    var json = parser.json;
    var textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    var extension = textureDef.extensions[name];
    var source = json.images[extension.source];
    var loader = parser.textureLoader;
    if (source.uri) {
      var handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null)
        loader = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported)
        return parser.loadTextureImage(textureIndex, source, loader);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  };
  GLTFTextureWebPExtension.prototype.detectSupport = function() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve) {
        var image = new Image();
        image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
        image.onload = image.onerror = function() {
          resolve(image.height === 1);
        };
      });
    }
    return this.isSupported;
  };
  function GLTFMeshoptCompression(parser) {
    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
    this.parser = parser;
  }
  GLTFMeshoptCompression.prototype.loadBufferView = function(index) {
    var json = this.parser.json;
    var bufferView = json.bufferViews[index];
    if (bufferView.extensions && bufferView.extensions[this.name]) {
      var extensionDef = bufferView.extensions[this.name];
      var buffer = this.parser.getDependency("buffer", extensionDef.buffer);
      var decoder = this.parser.options.meshoptDecoder;
      if (!decoder || !decoder.supported) {
        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        } else {
          return null;
        }
      }
      return Promise.all([buffer, decoder.ready]).then(function(res) {
        var byteOffset = extensionDef.byteOffset || 0;
        var byteLength = extensionDef.byteLength || 0;
        var count = extensionDef.count;
        var stride = extensionDef.byteStride;
        var result = new ArrayBuffer(count * stride);
        var source = new Uint8Array(res[0], byteOffset, byteLength);
        decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
        return result;
      });
    } else {
      return null;
    }
  };
  var BINARY_EXTENSION_HEADER_MAGIC = "glTF";
  var BINARY_EXTENSION_HEADER_LENGTH = 12;
  var BINARY_EXTENSION_CHUNK_TYPES = {JSON: 1313821514, BIN: 5130562};
  function GLTFBinaryExtension(data) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF;
    this.content = null;
    this.body = null;
    var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
    this.header = {
      magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
      version: headerView.getUint32(4, true),
      length: headerView.getUint32(8, true)
    };
    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    } else if (this.header.version < 2) {
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    }
    var chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
    var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
    var chunkIndex = 0;
    while (chunkIndex < chunkContentsLength) {
      var chunkLength = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      var chunkType = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
        this.content = LoaderUtils.decodeText(contentArray);
      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
        this.body = data.slice(byteOffset, byteOffset + chunkLength);
      }
      chunkIndex += chunkLength;
    }
    if (this.content === null) {
      throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
  function GLTFDracoMeshCompressionExtension(json, dracoLoader) {
    if (!dracoLoader) {
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    }
    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
    this.json = json;
    this.dracoLoader = dracoLoader;
    this.dracoLoader.preload();
  }
  GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function(primitive, parser) {
    var json = this.json;
    var dracoLoader = this.dracoLoader;
    var bufferViewIndex = primitive.extensions[this.name].bufferView;
    var gltfAttributeMap = primitive.extensions[this.name].attributes;
    var threeAttributeMap = {};
    var attributeNormalizedMap = {};
    var attributeTypeMap = {};
    for (var attributeName in gltfAttributeMap) {
      var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
    }
    for (attributeName in primitive.attributes) {
      var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      if (gltfAttributeMap[attributeName] !== void 0) {
        var accessorDef = json.accessors[primitive.attributes[attributeName]];
        var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        attributeTypeMap[threeAttributeName] = componentType;
        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
      }
    }
    return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
      return new Promise(function(resolve) {
        dracoLoader.decodeDracoFile(bufferView, function(geometry) {
          for (var attributeName2 in geometry.attributes) {
            var attribute = geometry.attributes[attributeName2];
            var normalized = attributeNormalizedMap[attributeName2];
            if (normalized !== void 0)
              attribute.normalized = normalized;
          }
          resolve(geometry);
        }, threeAttributeMap, attributeTypeMap);
      });
    });
  };
  function GLTFTextureTransformExtension() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }
  GLTFTextureTransformExtension.prototype.extendTexture = function(texture, transform) {
    texture = texture.clone();
    if (transform.offset !== void 0) {
      texture.offset.fromArray(transform.offset);
    }
    if (transform.rotation !== void 0) {
      texture.rotation = transform.rotation;
    }
    if (transform.scale !== void 0) {
      texture.repeat.fromArray(transform.scale);
    }
    if (transform.texCoord !== void 0) {
      console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.');
    }
    texture.needsUpdate = true;
    return texture;
  };
  function GLTFMeshStandardSGMaterial(params) {
    MeshStandardMaterial.call(this);
    this.isGLTFSpecularGlossinessMaterial = true;
    var specularMapParsFragmentChunk = [
      "#ifdef USE_SPECULARMAP",
      "	uniform sampler2D specularMap;",
      "#endif"
    ].join("\n");
    var glossinessMapParsFragmentChunk = [
      "#ifdef USE_GLOSSINESSMAP",
      "	uniform sampler2D glossinessMap;",
      "#endif"
    ].join("\n");
    var specularMapFragmentChunk = [
      "vec3 specularFactor = specular;",
      "#ifdef USE_SPECULARMAP",
      "	vec4 texelSpecular = texture2D( specularMap, vUv );",
      "	texelSpecular = sRGBToLinear( texelSpecular );",
      "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
      "	specularFactor *= texelSpecular.rgb;",
      "#endif"
    ].join("\n");
    var glossinessMapFragmentChunk = [
      "float glossinessFactor = glossiness;",
      "#ifdef USE_GLOSSINESSMAP",
      "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );",
      "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
      "	glossinessFactor *= texelGlossiness.a;",
      "#endif"
    ].join("\n");
    var lightPhysicalFragmentChunk = [
      "PhysicalMaterial material;",
      "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
      "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
      "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
      "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
      "material.specularRoughness += geometryRoughness;",
      "material.specularRoughness = min( material.specularRoughness, 1.0 );",
      "material.specularColor = specularFactor;"
    ].join("\n");
    var uniforms = {
      specular: {value: new Color().setHex(16777215)},
      glossiness: {value: 1},
      specularMap: {value: null},
      glossinessMap: {value: null}
    };
    this._extraUniforms = uniforms;
    this.onBeforeCompile = function(shader) {
      for (var uniformName in uniforms) {
        shader.uniforms[uniformName] = uniforms[uniformName];
      }
      shader.fragmentShader = shader.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", specularMapParsFragmentChunk).replace("#include <metalnessmap_pars_fragment>", glossinessMapParsFragmentChunk).replace("#include <roughnessmap_fragment>", specularMapFragmentChunk).replace("#include <metalnessmap_fragment>", glossinessMapFragmentChunk).replace("#include <lights_physical_fragment>", lightPhysicalFragmentChunk);
    };
    Object.defineProperties(this, {
      specular: {
        get: function() {
          return uniforms.specular.value;
        },
        set: function(v) {
          uniforms.specular.value = v;
        }
      },
      specularMap: {
        get: function() {
          return uniforms.specularMap.value;
        },
        set: function(v) {
          uniforms.specularMap.value = v;
          if (v) {
            this.defines.USE_SPECULARMAP = "";
          } else {
            delete this.defines.USE_SPECULARMAP;
          }
        }
      },
      glossiness: {
        get: function() {
          return uniforms.glossiness.value;
        },
        set: function(v) {
          uniforms.glossiness.value = v;
        }
      },
      glossinessMap: {
        get: function() {
          return uniforms.glossinessMap.value;
        },
        set: function(v) {
          uniforms.glossinessMap.value = v;
          if (v) {
            this.defines.USE_GLOSSINESSMAP = "";
            this.defines.USE_UV = "";
          } else {
            delete this.defines.USE_GLOSSINESSMAP;
            delete this.defines.USE_UV;
          }
        }
      }
    });
    delete this.metalness;
    delete this.roughness;
    delete this.metalnessMap;
    delete this.roughnessMap;
    this.setValues(params);
  }
  GLTFMeshStandardSGMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
  GLTFMeshStandardSGMaterial.prototype.constructor = GLTFMeshStandardSGMaterial;
  GLTFMeshStandardSGMaterial.prototype.copy = function(source) {
    MeshStandardMaterial.prototype.copy.call(this, source);
    this.specularMap = source.specularMap;
    this.specular.copy(source.specular);
    this.glossinessMap = source.glossinessMap;
    this.glossiness = source.glossiness;
    delete this.metalness;
    delete this.roughness;
    delete this.metalnessMap;
    delete this.roughnessMap;
    return this;
  };
  function GLTFMaterialsPbrSpecularGlossinessExtension() {
    return {
      name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
      specularGlossinessParams: [
        "color",
        "map",
        "lightMap",
        "lightMapIntensity",
        "aoMap",
        "aoMapIntensity",
        "emissive",
        "emissiveIntensity",
        "emissiveMap",
        "bumpMap",
        "bumpScale",
        "normalMap",
        "normalMapType",
        "displacementMap",
        "displacementScale",
        "displacementBias",
        "specularMap",
        "specular",
        "glossinessMap",
        "glossiness",
        "alphaMap",
        "envMap",
        "envMapIntensity",
        "refractionRatio"
      ],
      getMaterialType: function() {
        return GLTFMeshStandardSGMaterial;
      },
      extendParams: function(materialParams, materialDef, parser) {
        var pbrSpecularGlossiness = materialDef.extensions[this.name];
        materialParams.color = new Color(1, 1, 1);
        materialParams.opacity = 1;
        var pending = [];
        if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {
          var array = pbrSpecularGlossiness.diffuseFactor;
          materialParams.color.fromArray(array);
          materialParams.opacity = array[3];
        }
        if (pbrSpecularGlossiness.diffuseTexture !== void 0) {
          pending.push(parser.assignTexture(materialParams, "map", pbrSpecularGlossiness.diffuseTexture));
        }
        materialParams.emissive = new Color(0, 0, 0);
        materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== void 0 ? pbrSpecularGlossiness.glossinessFactor : 1;
        materialParams.specular = new Color(1, 1, 1);
        if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {
          materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);
        }
        if (pbrSpecularGlossiness.specularGlossinessTexture !== void 0) {
          var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
          pending.push(parser.assignTexture(materialParams, "glossinessMap", specGlossMapDef));
          pending.push(parser.assignTexture(materialParams, "specularMap", specGlossMapDef));
        }
        return Promise.all(pending);
      },
      createMaterial: function(materialParams) {
        var material = new GLTFMeshStandardSGMaterial(materialParams);
        material.fog = true;
        material.color = materialParams.color;
        material.map = materialParams.map === void 0 ? null : materialParams.map;
        material.lightMap = null;
        material.lightMapIntensity = 1;
        material.aoMap = materialParams.aoMap === void 0 ? null : materialParams.aoMap;
        material.aoMapIntensity = 1;
        material.emissive = materialParams.emissive;
        material.emissiveIntensity = 1;
        material.emissiveMap = materialParams.emissiveMap === void 0 ? null : materialParams.emissiveMap;
        material.bumpMap = materialParams.bumpMap === void 0 ? null : materialParams.bumpMap;
        material.bumpScale = 1;
        material.normalMap = materialParams.normalMap === void 0 ? null : materialParams.normalMap;
        material.normalMapType = TangentSpaceNormalMap;
        if (materialParams.normalScale)
          material.normalScale = materialParams.normalScale;
        material.displacementMap = null;
        material.displacementScale = 1;
        material.displacementBias = 0;
        material.specularMap = materialParams.specularMap === void 0 ? null : materialParams.specularMap;
        material.specular = materialParams.specular;
        material.glossinessMap = materialParams.glossinessMap === void 0 ? null : materialParams.glossinessMap;
        material.glossiness = materialParams.glossiness;
        material.alphaMap = null;
        material.envMap = materialParams.envMap === void 0 ? null : materialParams.envMap;
        material.envMapIntensity = 1;
        material.refractionRatio = 0.98;
        return material;
      }
    };
  }
  function GLTFMeshQuantizationExtension() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
  function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  GLTFCubicSplineInterpolant.prototype = Object.create(Interpolant.prototype);
  GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;
  GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function(index) {
    var result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
    for (var i = 0; i !== valueSize; i++) {
      result[i] = values[offset + i];
    }
    return result;
  };
  GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
  GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
  GLTFCubicSplineInterpolant.prototype.interpolate_ = function(i1, t0, t, t1) {
    var result = this.resultBuffer;
    var values = this.sampleValues;
    var stride = this.valueSize;
    var stride2 = stride * 2;
    var stride3 = stride * 3;
    var td = t1 - t0;
    var p = (t - t0) / td;
    var pp = p * p;
    var ppp = pp * p;
    var offset1 = i1 * stride3;
    var offset0 = offset1 - stride3;
    var s2 = -2 * ppp + 3 * pp;
    var s3 = ppp - pp;
    var s0 = 1 - s2;
    var s1 = s3 - pp + p;
    for (var i = 0; i !== stride; i++) {
      var p0 = values[offset0 + i + stride];
      var m0 = values[offset0 + i + stride2] * td;
      var p1 = values[offset1 + i + stride];
      var m1 = values[offset1 + i] * td;
      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
    }
    return result;
  };
  var WEBGL_CONSTANTS = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123
  };
  var WEBGL_COMPONENT_TYPES = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  };
  var WEBGL_FILTERS = {
    9728: NearestFilter,
    9729: LinearFilter,
    9984: NearestMipmapNearestFilter,
    9985: LinearMipmapNearestFilter,
    9986: NearestMipmapLinearFilter,
    9987: LinearMipmapLinearFilter
  };
  var WEBGL_WRAPPINGS = {
    33071: ClampToEdgeWrapping,
    33648: MirroredRepeatWrapping,
    10497: RepeatWrapping
  };
  var WEBGL_TYPE_SIZES = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var ATTRIBUTES = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
  };
  var PATH_PROPERTIES = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
  };
  var INTERPOLATION = {
    CUBICSPLINE: void 0,
    LINEAR: InterpolateLinear,
    STEP: InterpolateDiscrete
  };
  var ALPHA_MODES = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
  };
  function resolveURL(url, path) {
    if (typeof url !== "string" || url === "")
      return "";
    if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
      path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
    }
    if (/^(https?:)?\/\//i.test(url))
      return url;
    if (/^data:.*,.*$/i.test(url))
      return url;
    if (/^blob:.*$/i.test(url))
      return url;
    return path + url;
  }
  function createDefaultMaterial(cache) {
    if (cache["DefaultMaterial"] === void 0) {
      cache["DefaultMaterial"] = new MeshStandardMaterial({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: false,
        depthTest: true,
        side: FrontSide
      });
    }
    return cache["DefaultMaterial"];
  }
  function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
    for (var name in objectDef.extensions) {
      if (knownExtensions[name] === void 0) {
        object.userData.gltfExtensions = object.userData.gltfExtensions || {};
        object.userData.gltfExtensions[name] = objectDef.extensions[name];
      }
    }
  }
  function assignExtrasToUserData(object, gltfDef) {
    if (gltfDef.extras !== void 0) {
      if (typeof gltfDef.extras === "object") {
        Object.assign(object.userData, gltfDef.extras);
      } else {
        console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
      }
    }
  }
  function addMorphTargets(geometry, targets, parser) {
    var hasMorphPosition = false;
    var hasMorphNormal = false;
    for (var i = 0, il = targets.length; i < il; i++) {
      var target = targets[i];
      if (target.POSITION !== void 0)
        hasMorphPosition = true;
      if (target.NORMAL !== void 0)
        hasMorphNormal = true;
      if (hasMorphPosition && hasMorphNormal)
        break;
    }
    if (!hasMorphPosition && !hasMorphNormal)
      return Promise.resolve(geometry);
    var pendingPositionAccessors = [];
    var pendingNormalAccessors = [];
    for (var i = 0, il = targets.length; i < il; i++) {
      var target = targets[i];
      if (hasMorphPosition) {
        var pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
        pendingPositionAccessors.push(pendingAccessor);
      }
      if (hasMorphNormal) {
        var pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
        pendingNormalAccessors.push(pendingAccessor);
      }
    }
    return Promise.all([
      Promise.all(pendingPositionAccessors),
      Promise.all(pendingNormalAccessors)
    ]).then(function(accessors) {
      var morphPositions = accessors[0];
      var morphNormals = accessors[1];
      if (hasMorphPosition)
        geometry.morphAttributes.position = morphPositions;
      if (hasMorphNormal)
        geometry.morphAttributes.normal = morphNormals;
      geometry.morphTargetsRelative = true;
      return geometry;
    });
  }
  function updateMorphTargets(mesh, meshDef) {
    mesh.updateMorphTargets();
    if (meshDef.weights !== void 0) {
      for (var i = 0, il = meshDef.weights.length; i < il; i++) {
        mesh.morphTargetInfluences[i] = meshDef.weights[i];
      }
    }
    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
      var targetNames = meshDef.extras.targetNames;
      if (mesh.morphTargetInfluences.length === targetNames.length) {
        mesh.morphTargetDictionary = {};
        for (var i = 0, il = targetNames.length; i < il; i++) {
          mesh.morphTargetDictionary[targetNames[i]] = i;
        }
      } else {
        console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
      }
    }
  }
  function createPrimitiveKey(primitiveDef) {
    var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
    var geometryKey;
    if (dracoExtension) {
      geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
    } else {
      geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
    }
    return geometryKey;
  }
  function createAttributesKey(attributes) {
    var attributesKey = "";
    var keys = Object.keys(attributes).sort();
    for (var i = 0, il = keys.length; i < il; i++) {
      attributesKey += keys[i] + ":" + attributes[keys[i]] + ";";
    }
    return attributesKey;
  }
  function GLTFParser(json, options) {
    this.json = json || {};
    this.extensions = {};
    this.plugins = {};
    this.options = options || {};
    this.cache = new GLTFRegistry();
    this.associations = new Map();
    this.primitiveCache = {};
    this.meshCache = {refs: {}, uses: {}};
    this.cameraCache = {refs: {}, uses: {}};
    this.lightCache = {refs: {}, uses: {}};
    this.nodeNamesUsed = {};
    if (typeof createImageBitmap !== "undefined" && /Firefox/.test(navigator.userAgent) === false) {
      this.textureLoader = new ImageBitmapLoader(this.options.manager);
    } else {
      this.textureLoader = new TextureLoader(this.options.manager);
    }
    this.textureLoader.setCrossOrigin(this.options.crossOrigin);
    this.textureLoader.setRequestHeader(this.options.requestHeader);
    this.fileLoader = new FileLoader(this.options.manager);
    this.fileLoader.setResponseType("arraybuffer");
    if (this.options.crossOrigin === "use-credentials") {
      this.fileLoader.setWithCredentials(true);
    }
  }
  GLTFParser.prototype.setExtensions = function(extensions) {
    this.extensions = extensions;
  };
  GLTFParser.prototype.setPlugins = function(plugins) {
    this.plugins = plugins;
  };
  GLTFParser.prototype.parse = function(onLoad, onError) {
    var parser = this;
    var json = this.json;
    var extensions = this.extensions;
    this.cache.removeAll();
    this._invokeAll(function(ext) {
      return ext._markDefs && ext._markDefs();
    });
    Promise.all(this._invokeAll(function(ext) {
      return ext.beforeRoot && ext.beforeRoot();
    })).then(function() {
      return Promise.all([
        parser.getDependencies("scene"),
        parser.getDependencies("animation"),
        parser.getDependencies("camera")
      ]);
    }).then(function(dependencies) {
      var result = {
        scene: dependencies[0][json.scene || 0],
        scenes: dependencies[0],
        animations: dependencies[1],
        cameras: dependencies[2],
        asset: json.asset,
        parser,
        userData: {}
      };
      addUnknownExtensionsToUserData(extensions, result, json);
      assignExtrasToUserData(result, json);
      Promise.all(parser._invokeAll(function(ext) {
        return ext.afterRoot && ext.afterRoot(result);
      })).then(function() {
        onLoad(result);
      });
    }).catch(onError);
  };
  GLTFParser.prototype._markDefs = function() {
    var nodeDefs = this.json.nodes || [];
    var skinDefs = this.json.skins || [];
    var meshDefs = this.json.meshes || [];
    for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
      var joints = skinDefs[skinIndex].joints;
      for (var i = 0, il = joints.length; i < il; i++) {
        nodeDefs[joints[i]].isBone = true;
      }
    }
    for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      var nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.mesh !== void 0) {
        this._addNodeRef(this.meshCache, nodeDef.mesh);
        if (nodeDef.skin !== void 0) {
          meshDefs[nodeDef.mesh].isSkinnedMesh = true;
        }
      }
      if (nodeDef.camera !== void 0) {
        this._addNodeRef(this.cameraCache, nodeDef.camera);
      }
    }
  };
  GLTFParser.prototype._addNodeRef = function(cache, index) {
    if (index === void 0)
      return;
    if (cache.refs[index] === void 0) {
      cache.refs[index] = cache.uses[index] = 0;
    }
    cache.refs[index]++;
  };
  GLTFParser.prototype._getNodeRef = function(cache, index, object) {
    if (cache.refs[index] <= 1)
      return object;
    var ref = object.clone();
    ref.name += "_instance_" + cache.uses[index]++;
    return ref;
  };
  GLTFParser.prototype._invokeOne = function(func) {
    var extensions = Object.values(this.plugins);
    extensions.push(this);
    for (var i = 0; i < extensions.length; i++) {
      var result = func(extensions[i]);
      if (result)
        return result;
    }
  };
  GLTFParser.prototype._invokeAll = function(func) {
    var extensions = Object.values(this.plugins);
    extensions.unshift(this);
    var pending = [];
    for (var i = 0; i < extensions.length; i++) {
      var result = func(extensions[i]);
      if (result)
        pending.push(result);
    }
    return pending;
  };
  GLTFParser.prototype.getDependency = function(type, index) {
    var cacheKey = type + ":" + index;
    var dependency = this.cache.get(cacheKey);
    if (!dependency) {
      switch (type) {
        case "scene":
          dependency = this.loadScene(index);
          break;
        case "node":
          dependency = this.loadNode(index);
          break;
        case "mesh":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMesh && ext.loadMesh(index);
          });
          break;
        case "accessor":
          dependency = this.loadAccessor(index);
          break;
        case "bufferView":
          dependency = this._invokeOne(function(ext) {
            return ext.loadBufferView && ext.loadBufferView(index);
          });
          break;
        case "buffer":
          dependency = this.loadBuffer(index);
          break;
        case "material":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMaterial && ext.loadMaterial(index);
          });
          break;
        case "texture":
          dependency = this._invokeOne(function(ext) {
            return ext.loadTexture && ext.loadTexture(index);
          });
          break;
        case "skin":
          dependency = this.loadSkin(index);
          break;
        case "animation":
          dependency = this.loadAnimation(index);
          break;
        case "camera":
          dependency = this.loadCamera(index);
          break;
        default:
          throw new Error("Unknown type: " + type);
      }
      this.cache.add(cacheKey, dependency);
    }
    return dependency;
  };
  GLTFParser.prototype.getDependencies = function(type) {
    var dependencies = this.cache.get(type);
    if (!dependencies) {
      var parser = this;
      var defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
      dependencies = Promise.all(defs.map(function(def, index) {
        return parser.getDependency(type, index);
      }));
      this.cache.add(type, dependencies);
    }
    return dependencies;
  };
  GLTFParser.prototype.loadBuffer = function(bufferIndex) {
    var bufferDef = this.json.buffers[bufferIndex];
    var loader = this.fileLoader;
    if (bufferDef.type && bufferDef.type !== "arraybuffer") {
      throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
    }
    if (bufferDef.uri === void 0 && bufferIndex === 0) {
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    }
    var options = this.options;
    return new Promise(function(resolve, reject) {
      loader.load(resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {
        reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
      });
    });
  };
  GLTFParser.prototype.loadBufferView = function(bufferViewIndex) {
    var bufferViewDef = this.json.bufferViews[bufferViewIndex];
    return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer) {
      var byteLength = bufferViewDef.byteLength || 0;
      var byteOffset = bufferViewDef.byteOffset || 0;
      return buffer.slice(byteOffset, byteOffset + byteLength);
    });
  };
  GLTFParser.prototype.loadAccessor = function(accessorIndex) {
    var parser = this;
    var json = this.json;
    var accessorDef = this.json.accessors[accessorIndex];
    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
      return Promise.resolve(null);
    }
    var pendingBufferViews = [];
    if (accessorDef.bufferView !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
    } else {
      pendingBufferViews.push(null);
    }
    if (accessorDef.sparse !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
    }
    return Promise.all(pendingBufferViews).then(function(bufferViews) {
      var bufferView = bufferViews[0];
      var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      var elementBytes = TypedArray.BYTES_PER_ELEMENT;
      var itemBytes = elementBytes * itemSize;
      var byteOffset = accessorDef.byteOffset || 0;
      var byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
      var normalized = accessorDef.normalized === true;
      var array, bufferAttribute;
      if (byteStride && byteStride !== itemBytes) {
        var ibSlice = Math.floor(byteOffset / byteStride);
        var ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
        var ib = parser.cache.get(ibCacheKey);
        if (!ib) {
          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
          ib = new InterleavedBuffer(array, byteStride / elementBytes);
          parser.cache.add(ibCacheKey, ib);
        }
        bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
      } else {
        if (bufferView === null) {
          array = new TypedArray(accessorDef.count * itemSize);
        } else {
          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
        }
        bufferAttribute = new BufferAttribute(array, itemSize, normalized);
      }
      if (accessorDef.sparse !== void 0) {
        var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
        var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
        var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
        var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
        var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
        var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
        if (bufferView !== null) {
          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
        }
        for (var i = 0, il = sparseIndices.length; i < il; i++) {
          var index = sparseIndices[i];
          bufferAttribute.setX(index, sparseValues[i * itemSize]);
          if (itemSize >= 2)
            bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
          if (itemSize >= 3)
            bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
          if (itemSize >= 4)
            bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
          if (itemSize >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return bufferAttribute;
    });
  };
  GLTFParser.prototype.loadTexture = function(textureIndex) {
    var json = this.json;
    var options = this.options;
    var textureDef = json.textures[textureIndex];
    var source = json.images[textureDef.source];
    var loader = this.textureLoader;
    if (source.uri) {
      var handler = options.manager.getHandler(source.uri);
      if (handler !== null)
        loader = handler;
    }
    return this.loadTextureImage(textureIndex, source, loader);
  };
  GLTFParser.prototype.loadTextureImage = function(textureIndex, source, loader) {
    var parser = this;
    var json = this.json;
    var options = this.options;
    var textureDef = json.textures[textureIndex];
    var URL2 = self.URL || self.webkitURL;
    var sourceURI = source.uri;
    var isObjectURL = false;
    var hasAlpha = true;
    if (source.mimeType === "image/jpeg")
      hasAlpha = false;
    if (source.bufferView !== void 0) {
      sourceURI = parser.getDependency("bufferView", source.bufferView).then(function(bufferView) {
        if (source.mimeType === "image/png") {
          var colorType = new DataView(bufferView, 25, 1).getUint8(0, false);
          hasAlpha = colorType === 6 || colorType === 4 || colorType === 3;
        }
        isObjectURL = true;
        var blob = new Blob([bufferView], {type: source.mimeType});
        sourceURI = URL2.createObjectURL(blob);
        return sourceURI;
      });
    } else if (source.uri === void 0) {
      throw new Error("THREE.GLTFLoader: Image " + textureIndex + " is missing URI and bufferView");
    }
    return Promise.resolve(sourceURI).then(function(sourceURI2) {
      return new Promise(function(resolve, reject) {
        var onLoad = resolve;
        if (loader.isImageBitmapLoader === true) {
          onLoad = function(imageBitmap) {
            resolve(new CanvasTexture(imageBitmap));
          };
        }
        loader.load(resolveURL(sourceURI2, options.path), onLoad, void 0, reject);
      });
    }).then(function(texture) {
      if (isObjectURL === true) {
        URL2.revokeObjectURL(sourceURI);
      }
      texture.flipY = false;
      if (textureDef.name)
        texture.name = textureDef.name;
      if (!hasAlpha)
        texture.format = RGBFormat;
      var samplers = json.samplers || {};
      var sampler = samplers[textureDef.sampler] || {};
      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
      parser.associations.set(texture, {
        type: "textures",
        index: textureIndex
      });
      return texture;
    });
  };
  GLTFParser.prototype.assignTexture = function(materialParams, mapName, mapDef) {
    var parser = this;
    return this.getDependency("texture", mapDef.index).then(function(texture) {
      if (mapDef.texCoord !== void 0 && mapDef.texCoord != 0 && !(mapName === "aoMap" && mapDef.texCoord == 1)) {
        console.warn("THREE.GLTFLoader: Custom UV set " + mapDef.texCoord + " for texture " + mapName + " not yet supported.");
      }
      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
        var transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
        if (transform) {
          var gltfReference = parser.associations.get(texture);
          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
          parser.associations.set(texture, gltfReference);
        }
      }
      materialParams[mapName] = texture;
    });
  };
  GLTFParser.prototype.assignFinalMaterial = function(mesh) {
    var geometry = mesh.geometry;
    var material = mesh.material;
    var useVertexTangents = geometry.attributes.tangent !== void 0;
    var useVertexColors = geometry.attributes.color !== void 0;
    var useFlatShading = geometry.attributes.normal === void 0;
    var useSkinning = mesh.isSkinnedMesh === true;
    var useMorphTargets = Object.keys(geometry.morphAttributes).length > 0;
    var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== void 0;
    if (mesh.isPoints) {
      var cacheKey = "PointsMaterial:" + material.uuid;
      var pointsMaterial = this.cache.get(cacheKey);
      if (!pointsMaterial) {
        pointsMaterial = new PointsMaterial();
        Material.prototype.copy.call(pointsMaterial, material);
        pointsMaterial.color.copy(material.color);
        pointsMaterial.map = material.map;
        pointsMaterial.sizeAttenuation = false;
        this.cache.add(cacheKey, pointsMaterial);
      }
      material = pointsMaterial;
    } else if (mesh.isLine) {
      var cacheKey = "LineBasicMaterial:" + material.uuid;
      var lineMaterial = this.cache.get(cacheKey);
      if (!lineMaterial) {
        lineMaterial = new LineBasicMaterial();
        Material.prototype.copy.call(lineMaterial, material);
        lineMaterial.color.copy(material.color);
        this.cache.add(cacheKey, lineMaterial);
      }
      material = lineMaterial;
    }
    if (useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets) {
      var cacheKey = "ClonedMaterial:" + material.uuid + ":";
      if (material.isGLTFSpecularGlossinessMaterial)
        cacheKey += "specular-glossiness:";
      if (useSkinning)
        cacheKey += "skinning:";
      if (useVertexTangents)
        cacheKey += "vertex-tangents:";
      if (useVertexColors)
        cacheKey += "vertex-colors:";
      if (useFlatShading)
        cacheKey += "flat-shading:";
      if (useMorphTargets)
        cacheKey += "morph-targets:";
      if (useMorphNormals)
        cacheKey += "morph-normals:";
      var cachedMaterial = this.cache.get(cacheKey);
      if (!cachedMaterial) {
        cachedMaterial = material.clone();
        if (useSkinning)
          cachedMaterial.skinning = true;
        if (useVertexColors)
          cachedMaterial.vertexColors = true;
        if (useFlatShading)
          cachedMaterial.flatShading = true;
        if (useMorphTargets)
          cachedMaterial.morphTargets = true;
        if (useMorphNormals)
          cachedMaterial.morphNormals = true;
        if (useVertexTangents) {
          cachedMaterial.vertexTangents = true;
          if (cachedMaterial.normalScale)
            cachedMaterial.normalScale.y *= -1;
          if (cachedMaterial.clearcoatNormalScale)
            cachedMaterial.clearcoatNormalScale.y *= -1;
        }
        this.cache.add(cacheKey, cachedMaterial);
        this.associations.set(cachedMaterial, this.associations.get(material));
      }
      material = cachedMaterial;
    }
    if (material.aoMap && geometry.attributes.uv2 === void 0 && geometry.attributes.uv !== void 0) {
      geometry.setAttribute("uv2", geometry.attributes.uv);
    }
    mesh.material = material;
  };
  GLTFParser.prototype.getMaterialType = function() {
    return MeshStandardMaterial;
  };
  GLTFParser.prototype.loadMaterial = function(materialIndex) {
    var parser = this;
    var json = this.json;
    var extensions = this.extensions;
    var materialDef = json.materials[materialIndex];
    var materialType;
    var materialParams = {};
    var materialExtensions = materialDef.extensions || {};
    var pending = [];
    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
      var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
      materialType = sgExtension.getMaterialType();
      pending.push(sgExtension.extendParams(materialParams, materialDef, parser));
    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
      materialType = kmuExtension.getMaterialType();
      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
    } else {
      var metallicRoughness = materialDef.pbrMetallicRoughness || {};
      materialParams.color = new Color(1, 1, 1);
      materialParams.opacity = 1;
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        var array = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture));
      }
      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
      if (metallicRoughness.metallicRoughnessTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
        pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
      }
      materialType = this._invokeOne(function(ext) {
        return ext.getMaterialType && ext.getMaterialType(materialIndex);
      });
      pending.push(Promise.all(this._invokeAll(function(ext) {
        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
      })));
    }
    if (materialDef.doubleSided === true) {
      materialParams.side = DoubleSide;
    }
    var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
    if (alphaMode === ALPHA_MODES.BLEND) {
      materialParams.transparent = true;
      materialParams.depthWrite = false;
    } else {
      materialParams.transparent = false;
      if (alphaMode === ALPHA_MODES.MASK) {
        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
      }
    }
    if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
      materialParams.normalScale = new Vector2(1, -1);
      if (materialDef.normalTexture.scale !== void 0) {
        materialParams.normalScale.set(materialDef.normalTexture.scale, -materialDef.normalTexture.scale);
      }
    }
    if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
      if (materialDef.occlusionTexture.strength !== void 0) {
        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
      }
    }
    if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {
      materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);
    }
    if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture));
    }
    return Promise.all(pending).then(function() {
      var material;
      if (materialType === GLTFMeshStandardSGMaterial) {
        material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);
      } else {
        material = new materialType(materialParams);
      }
      if (materialDef.name)
        material.name = materialDef.name;
      if (material.map)
        material.map.encoding = sRGBEncoding;
      if (material.emissiveMap)
        material.emissiveMap.encoding = sRGBEncoding;
      assignExtrasToUserData(material, materialDef);
      parser.associations.set(material, {type: "materials", index: materialIndex});
      if (materialDef.extensions)
        addUnknownExtensionsToUserData(extensions, material, materialDef);
      return material;
    });
  };
  GLTFParser.prototype.createUniqueName = function(originalName) {
    var sanitizedName = PropertyBinding.sanitizeNodeName(originalName || "");
    var name = sanitizedName;
    for (var i = 1; this.nodeNamesUsed[name]; ++i) {
      name = sanitizedName + "_" + i;
    }
    this.nodeNamesUsed[name] = true;
    return name;
  };
  function computeBounds(geometry, primitiveDef, parser) {
    var attributes = primitiveDef.attributes;
    var box = new Box3();
    if (attributes.POSITION !== void 0) {
      var accessor = parser.json.accessors[attributes.POSITION];
      var min = accessor.min;
      var max = accessor.max;
      if (min !== void 0 && max !== void 0) {
        box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]));
      } else {
        console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        return;
      }
    } else {
      return;
    }
    var targets = primitiveDef.targets;
    if (targets !== void 0) {
      var maxDisplacement = new Vector3();
      var vector = new Vector3();
      for (var i = 0, il = targets.length; i < il; i++) {
        var target = targets[i];
        if (target.POSITION !== void 0) {
          var accessor = parser.json.accessors[target.POSITION];
          var min = accessor.min;
          var max = accessor.max;
          if (min !== void 0 && max !== void 0) {
            vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
            vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
            vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));
            maxDisplacement.max(vector);
          } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
          }
        }
      }
      box.expandByVector(maxDisplacement);
    }
    geometry.boundingBox = box;
    var sphere = new Sphere();
    box.getCenter(sphere.center);
    sphere.radius = box.min.distanceTo(box.max) / 2;
    geometry.boundingSphere = sphere;
  }
  function addPrimitiveAttributes(geometry, primitiveDef, parser) {
    var attributes = primitiveDef.attributes;
    var pending = [];
    function assignAttributeAccessor(accessorIndex, attributeName) {
      return parser.getDependency("accessor", accessorIndex).then(function(accessor2) {
        geometry.setAttribute(attributeName, accessor2);
      });
    }
    for (var gltfAttributeName in attributes) {
      var threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
      if (threeAttributeName in geometry.attributes)
        continue;
      pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
    }
    if (primitiveDef.indices !== void 0 && !geometry.index) {
      var accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
        geometry.setIndex(accessor2);
      });
      pending.push(accessor);
    }
    assignExtrasToUserData(geometry, primitiveDef);
    computeBounds(geometry, primitiveDef, parser);
    return Promise.all(pending).then(function() {
      return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
    });
  }
  function toTrianglesDrawMode(geometry, drawMode) {
    var index = geometry.getIndex();
    if (index === null) {
      var indices = [];
      var position = geometry.getAttribute("position");
      if (position !== void 0) {
        for (var i = 0; i < position.count; i++) {
          indices.push(i);
        }
        geometry.setIndex(indices);
        index = geometry.getIndex();
      } else {
        console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
        return geometry;
      }
    }
    var numberOfTriangles = index.count - 2;
    var newIndices = [];
    if (drawMode === TriangleFanDrawMode) {
      for (var i = 1; i <= numberOfTriangles; i++) {
        newIndices.push(index.getX(0));
        newIndices.push(index.getX(i));
        newIndices.push(index.getX(i + 1));
      }
    } else {
      for (var i = 0; i < numberOfTriangles; i++) {
        if (i % 2 === 0) {
          newIndices.push(index.getX(i));
          newIndices.push(index.getX(i + 1));
          newIndices.push(index.getX(i + 2));
        } else {
          newIndices.push(index.getX(i + 2));
          newIndices.push(index.getX(i + 1));
          newIndices.push(index.getX(i));
        }
      }
    }
    if (newIndices.length / 3 !== numberOfTriangles) {
      console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    }
    var newGeometry = geometry.clone();
    newGeometry.setIndex(newIndices);
    return newGeometry;
  }
  GLTFParser.prototype.loadGeometries = function(primitives) {
    var parser = this;
    var extensions = this.extensions;
    var cache = this.primitiveCache;
    function createDracoPrimitive(primitive2) {
      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive2, parser).then(function(geometry) {
        return addPrimitiveAttributes(geometry, primitive2, parser);
      });
    }
    var pending = [];
    for (var i = 0, il = primitives.length; i < il; i++) {
      var primitive = primitives[i];
      var cacheKey = createPrimitiveKey(primitive);
      var cached = cache[cacheKey];
      if (cached) {
        pending.push(cached.promise);
      } else {
        var geometryPromise;
        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
          geometryPromise = createDracoPrimitive(primitive);
        } else {
          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
        }
        cache[cacheKey] = {primitive, promise: geometryPromise};
        pending.push(geometryPromise);
      }
    }
    return Promise.all(pending);
  };
  GLTFParser.prototype.loadMesh = function(meshIndex) {
    var parser = this;
    var json = this.json;
    var extensions = this.extensions;
    var meshDef = json.meshes[meshIndex];
    var primitives = meshDef.primitives;
    var pending = [];
    for (var i = 0, il = primitives.length; i < il; i++) {
      var material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i].material);
      pending.push(material);
    }
    pending.push(parser.loadGeometries(primitives));
    return Promise.all(pending).then(function(results) {
      var materials = results.slice(0, results.length - 1);
      var geometries = results[results.length - 1];
      var meshes = [];
      for (var i2 = 0, il2 = geometries.length; i2 < il2; i2++) {
        var geometry = geometries[i2];
        var primitive = primitives[i2];
        var mesh;
        var material2 = materials[i2];
        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {
          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material2) : new Mesh(geometry, material2);
          if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {
            mesh.normalizeSkinWeights();
          }
          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
          }
        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
          mesh = new LineSegments(geometry, material2);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
          mesh = new Line(geometry, material2);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
          mesh = new LineLoop(geometry, material2);
        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
          mesh = new Points(geometry, material2);
        } else {
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
        }
        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
          updateMorphTargets(mesh, meshDef);
        }
        mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
        assignExtrasToUserData(mesh, meshDef);
        if (primitive.extensions)
          addUnknownExtensionsToUserData(extensions, mesh, primitive);
        parser.assignFinalMaterial(mesh);
        meshes.push(mesh);
      }
      if (meshes.length === 1) {
        return meshes[0];
      }
      var group = new Group();
      for (var i2 = 0, il2 = meshes.length; i2 < il2; i2++) {
        group.add(meshes[i2]);
      }
      return group;
    });
  };
  GLTFParser.prototype.loadCamera = function(cameraIndex) {
    var camera;
    var cameraDef = this.json.cameras[cameraIndex];
    var params = cameraDef[cameraDef.type];
    if (!params) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    if (cameraDef.type === "perspective") {
      camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
    } else if (cameraDef.type === "orthographic") {
      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
    }
    if (cameraDef.name)
      camera.name = this.createUniqueName(cameraDef.name);
    assignExtrasToUserData(camera, cameraDef);
    return Promise.resolve(camera);
  };
  GLTFParser.prototype.loadSkin = function(skinIndex) {
    var skinDef = this.json.skins[skinIndex];
    var skinEntry = {joints: skinDef.joints};
    if (skinDef.inverseBindMatrices === void 0) {
      return Promise.resolve(skinEntry);
    }
    return this.getDependency("accessor", skinDef.inverseBindMatrices).then(function(accessor) {
      skinEntry.inverseBindMatrices = accessor;
      return skinEntry;
    });
  };
  GLTFParser.prototype.loadAnimation = function(animationIndex) {
    var json = this.json;
    var animationDef = json.animations[animationIndex];
    var pendingNodes = [];
    var pendingInputAccessors = [];
    var pendingOutputAccessors = [];
    var pendingSamplers = [];
    var pendingTargets = [];
    for (var i = 0, il = animationDef.channels.length; i < il; i++) {
      var channel = animationDef.channels[i];
      var sampler = animationDef.samplers[channel.sampler];
      var target = channel.target;
      var name = target.node !== void 0 ? target.node : target.id;
      var input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
      var output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
      pendingNodes.push(this.getDependency("node", name));
      pendingInputAccessors.push(this.getDependency("accessor", input));
      pendingOutputAccessors.push(this.getDependency("accessor", output));
      pendingSamplers.push(sampler);
      pendingTargets.push(target);
    }
    return Promise.all([
      Promise.all(pendingNodes),
      Promise.all(pendingInputAccessors),
      Promise.all(pendingOutputAccessors),
      Promise.all(pendingSamplers),
      Promise.all(pendingTargets)
    ]).then(function(dependencies) {
      var nodes = dependencies[0];
      var inputAccessors = dependencies[1];
      var outputAccessors = dependencies[2];
      var samplers = dependencies[3];
      var targets = dependencies[4];
      var tracks = [];
      for (var i2 = 0, il2 = nodes.length; i2 < il2; i2++) {
        var node = nodes[i2];
        var inputAccessor = inputAccessors[i2];
        var outputAccessor = outputAccessors[i2];
        var sampler2 = samplers[i2];
        var target2 = targets[i2];
        if (node === void 0)
          continue;
        node.updateMatrix();
        node.matrixAutoUpdate = true;
        var TypedKeyframeTrack;
        switch (PATH_PROPERTIES[target2.path]) {
          case PATH_PROPERTIES.weights:
            TypedKeyframeTrack = NumberKeyframeTrack;
            break;
          case PATH_PROPERTIES.rotation:
            TypedKeyframeTrack = QuaternionKeyframeTrack;
            break;
          case PATH_PROPERTIES.position:
          case PATH_PROPERTIES.scale:
          default:
            TypedKeyframeTrack = VectorKeyframeTrack;
            break;
        }
        var targetName = node.name ? node.name : node.uuid;
        var interpolation = sampler2.interpolation !== void 0 ? INTERPOLATION[sampler2.interpolation] : InterpolateLinear;
        var targetNames = [];
        if (PATH_PROPERTIES[target2.path] === PATH_PROPERTIES.weights) {
          node.traverse(function(object) {
            if (object.isMesh === true && object.morphTargetInfluences) {
              targetNames.push(object.name ? object.name : object.uuid);
            }
          });
        } else {
          targetNames.push(targetName);
        }
        var outputArray = outputAccessor.array;
        if (outputAccessor.normalized) {
          var scale;
          if (outputArray.constructor === Int8Array) {
            scale = 1 / 127;
          } else if (outputArray.constructor === Uint8Array) {
            scale = 1 / 255;
          } else if (outputArray.constructor == Int16Array) {
            scale = 1 / 32767;
          } else if (outputArray.constructor === Uint16Array) {
            scale = 1 / 65535;
          } else {
            throw new Error("THREE.GLTFLoader: Unsupported output accessor component type.");
          }
          var scaled = new Float32Array(outputArray.length);
          for (var j = 0, jl = outputArray.length; j < jl; j++) {
            scaled[j] = outputArray[j] * scale;
          }
          outputArray = scaled;
        }
        for (var j = 0, jl = targetNames.length; j < jl; j++) {
          var track = new TypedKeyframeTrack(targetNames[j] + "." + PATH_PROPERTIES[target2.path], inputAccessor.array, outputArray, interpolation);
          if (sampler2.interpolation === "CUBICSPLINE") {
            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
              return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);
            };
            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
          }
          tracks.push(track);
        }
      }
      var name2 = animationDef.name ? animationDef.name : "animation_" + animationIndex;
      return new AnimationClip(name2, void 0, tracks);
    });
  };
  GLTFParser.prototype.loadNode = function(nodeIndex) {
    var json = this.json;
    var extensions = this.extensions;
    var parser = this;
    var nodeDef = json.nodes[nodeIndex];
    var nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
    return function() {
      var pending = [];
      if (nodeDef.mesh !== void 0) {
        pending.push(parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
          var node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
          if (nodeDef.weights !== void 0) {
            node.traverse(function(o) {
              if (!o.isMesh)
                return;
              for (var i = 0, il = nodeDef.weights.length; i < il; i++) {
                o.morphTargetInfluences[i] = nodeDef.weights[i];
              }
            });
          }
          return node;
        }));
      }
      if (nodeDef.camera !== void 0) {
        pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera) {
          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
        }));
      }
      parser._invokeAll(function(ext) {
        return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
      }).forEach(function(promise) {
        pending.push(promise);
      });
      return Promise.all(pending);
    }().then(function(objects) {
      var node;
      if (nodeDef.isBone === true) {
        node = new Bone();
      } else if (objects.length > 1) {
        node = new Group();
      } else if (objects.length === 1) {
        node = objects[0];
      } else {
        node = new Object3D();
      }
      if (node !== objects[0]) {
        for (var i = 0, il = objects.length; i < il; i++) {
          node.add(objects[i]);
        }
      }
      if (nodeDef.name) {
        node.userData.name = nodeDef.name;
        node.name = nodeName;
      }
      assignExtrasToUserData(node, nodeDef);
      if (nodeDef.extensions)
        addUnknownExtensionsToUserData(extensions, node, nodeDef);
      if (nodeDef.matrix !== void 0) {
        var matrix = new Matrix4();
        matrix.fromArray(nodeDef.matrix);
        node.applyMatrix4(matrix);
      } else {
        if (nodeDef.translation !== void 0) {
          node.position.fromArray(nodeDef.translation);
        }
        if (nodeDef.rotation !== void 0) {
          node.quaternion.fromArray(nodeDef.rotation);
        }
        if (nodeDef.scale !== void 0) {
          node.scale.fromArray(nodeDef.scale);
        }
      }
      parser.associations.set(node, {type: "nodes", index: nodeIndex});
      return node;
    });
  };
  GLTFParser.prototype.loadScene = function() {
    function buildNodeHierachy(nodeId, parentObject, json, parser) {
      var nodeDef = json.nodes[nodeId];
      return parser.getDependency("node", nodeId).then(function(node) {
        if (nodeDef.skin === void 0)
          return node;
        var skinEntry;
        return parser.getDependency("skin", nodeDef.skin).then(function(skin) {
          skinEntry = skin;
          var pendingJoints = [];
          for (var i = 0, il = skinEntry.joints.length; i < il; i++) {
            pendingJoints.push(parser.getDependency("node", skinEntry.joints[i]));
          }
          return Promise.all(pendingJoints);
        }).then(function(jointNodes) {
          node.traverse(function(mesh) {
            if (!mesh.isMesh)
              return;
            var bones = [];
            var boneInverses = [];
            for (var j = 0, jl = jointNodes.length; j < jl; j++) {
              var jointNode = jointNodes[j];
              if (jointNode) {
                bones.push(jointNode);
                var mat = new Matrix4();
                if (skinEntry.inverseBindMatrices !== void 0) {
                  mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);
                }
                boneInverses.push(mat);
              } else {
                console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[j]);
              }
            }
            mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld);
          });
          return node;
        });
      }).then(function(node) {
        parentObject.add(node);
        var pending = [];
        if (nodeDef.children) {
          var children = nodeDef.children;
          for (var i = 0, il = children.length; i < il; i++) {
            var child = children[i];
            pending.push(buildNodeHierachy(child, node, json, parser));
          }
        }
        return Promise.all(pending);
      });
    }
    return function loadScene(sceneIndex) {
      var json = this.json;
      var extensions = this.extensions;
      var sceneDef = this.json.scenes[sceneIndex];
      var parser = this;
      var scene = new Group();
      if (sceneDef.name)
        scene.name = parser.createUniqueName(sceneDef.name);
      assignExtrasToUserData(scene, sceneDef);
      if (sceneDef.extensions)
        addUnknownExtensionsToUserData(extensions, scene, sceneDef);
      var nodeIds = sceneDef.nodes || [];
      var pending = [];
      for (var i = 0, il = nodeIds.length; i < il; i++) {
        pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));
      }
      return Promise.all(pending).then(function() {
        return scene;
      });
    };
  }();
  return GLTFLoader2;
}();
const TYPES_ENUM = {
  i8: "i8",
  ui8: "ui8",
  ui8c: "ui8c",
  i16: "i16",
  ui16: "ui16",
  i32: "i32",
  ui32: "ui32",
  f32: "f32",
  f64: "f64"
};
const TYPES_NAMES = {
  i8: "Int8",
  ui8: "Uint8",
  ui8c: "Uint8Clamped",
  i16: "Int16",
  ui16: "Uint16",
  i32: "Int32",
  ui32: "Uint32",
  f32: "Float32",
  f64: "Float64"
};
const TYPES = {
  i8: Int8Array,
  ui8: Uint8Array,
  ui8c: Uint8ClampedArray,
  i16: Int16Array,
  ui16: Uint16Array,
  i32: Int32Array,
  ui32: Uint32Array,
  f32: Float32Array,
  f64: Float64Array
};
const UNSIGNED_MAX = {
  uint8: 2 ** 8,
  uint16: 2 ** 16,
  uint32: 2 ** 32
};
const $storeRef = Symbol("storeRef");
const $storeSize = Symbol("storeSize");
const $storeMaps = Symbol("storeMaps");
const $storeFlattened = Symbol("storeFlattened");
const $storeBase = Symbol("storeBase");
const $storeType = Symbol("storeType");
const $storeArrayCounts = Symbol("storeArrayCount");
const $storeSubarrays = Symbol("storeSubarrays");
const $storeCursor = Symbol("storeCursor");
const $subarrayCursors = Symbol("subarrayCursors");
const $subarray = Symbol("subarray");
const $queryShadow = Symbol("queryShadow");
const $serializeShadow = Symbol("serializeShadow");
const $indexType = Symbol("indexType");
const $indexBytes = Symbol("indexBytes");
const stores = {};
const resize = (ta, size) => {
  const newBuffer = new ArrayBuffer(size * ta.BYTES_PER_ELEMENT);
  const newTa = new ta.constructor(newBuffer);
  newTa.set(ta, 0);
  return newTa;
};
const resizeRecursive = (store, size) => {
  Object.keys(store).forEach((key) => {
    const ta = store[key];
    if (ta[$subarray])
      return;
    else if (ArrayBuffer.isView(ta)) {
      store[key] = resize(ta, size);
      store[key][$queryShadow] = resize(ta[$queryShadow], size);
      store[key][$serializeShadow] = resize(ta[$serializeShadow], size);
    } else if (typeof ta === "object") {
      resizeRecursive(store[key], size);
    }
  });
};
const resizeSubarrays = (metadata, size) => {
  Object.keys(metadata[$subarrayCursors]).forEach((k) => {
    metadata[$subarrayCursors][k] = 0;
  });
  const cursors = metadata[$subarrayCursors];
  metadata[$storeFlattened].filter((store) => !ArrayBuffer.isView(store)).forEach((store) => {
    const type = store[$storeType];
    const length = store[0].length;
    const arrayCount = metadata[$storeArrayCounts][type];
    const summedLength = Array(arrayCount).fill(0).reduce((a, p) => a + length, 0);
    const array = new TYPES[type](summedLength * size);
    array.set(metadata[$storeSubarrays][type]);
    metadata[$storeSubarrays][type] = array;
    metadata[$storeSubarrays][type][$queryShadow] = array.slice(0);
    metadata[$storeSubarrays][type][$serializeShadow] = array.slice(0);
    for (let eid = 0; eid < size; eid++) {
      const from = cursors[type] + eid * length;
      const to = from + length;
      store[eid] = metadata[$storeSubarrays][type].subarray(from, to);
      store[eid].from = from;
      store[eid].to = to;
      store[eid][$queryShadow] = metadata[$storeSubarrays][type][$queryShadow].subarray(from, to);
      store[eid][$serializeShadow] = metadata[$storeSubarrays][type][$serializeShadow].subarray(from, to);
      store[eid][$subarray] = true;
      store[eid][$indexType] = array[$indexType];
      store[eid][$indexBytes] = array[$indexBytes];
    }
  });
};
const resizeStore = (store, size) => {
  store[$storeSize] = size;
  resizeRecursive(store, size);
  resizeSubarrays(store, size);
};
const resetStoreFor = (store, eid) => {
  store[$storeFlattened].forEach((ta) => {
    if (ArrayBuffer.isView(ta))
      ta[eid] = 0;
    else
      ta[eid].fill(0);
  });
};
const createTypeStore = (type, length) => {
  const totalBytes = length * TYPES[type].BYTES_PER_ELEMENT;
  const buffer = new ArrayBuffer(totalBytes);
  return new TYPES[type](buffer);
};
const createArrayStore = (metadata, type, length) => {
  const size = metadata[$storeSize];
  const store = Array(size).fill(0);
  store[$storeType] = type;
  const cursors = metadata[$subarrayCursors];
  const indexType = length < UNSIGNED_MAX.uint8 ? "ui8" : length < UNSIGNED_MAX.uint16 ? "ui16" : "ui32";
  if (!length)
    throw new Error("\u274C Must define a length for component array.");
  if (!TYPES[type])
    throw new Error(`\u274C Invalid component array property type ${type}.`);
  if (!metadata[$storeSubarrays][type]) {
    const arrayCount = metadata[$storeArrayCounts][type];
    const summedLength = Array(arrayCount).fill(0).reduce((a, p) => a + length, 0);
    const array = new TYPES[type](summedLength * size);
    metadata[$storeSubarrays][type] = array;
    metadata[$storeSubarrays][type][$queryShadow] = array.slice(0);
    metadata[$storeSubarrays][type][$serializeShadow] = array.slice(0);
    array[$indexType] = TYPES_NAMES[indexType];
    array[$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT;
  }
  let end = 0;
  for (let eid = 0; eid < size; eid++) {
    const from = cursors[type] + eid * length;
    const to = from + length;
    store[eid] = metadata[$storeSubarrays][type].subarray(from, to);
    store[eid].from = from;
    store[eid].to = to;
    store[eid][$queryShadow] = metadata[$storeSubarrays][type][$queryShadow].subarray(from, to);
    store[eid][$serializeShadow] = metadata[$storeSubarrays][type][$serializeShadow].subarray(from, to);
    store[eid][$subarray] = true;
    store[eid][$indexType] = TYPES_NAMES[indexType];
    store[eid][$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT;
    end = to;
  }
  cursors[type] = end;
  return store;
};
const createShadows = (store) => {
  store[$queryShadow] = store.slice(0);
  store[$serializeShadow] = store.slice(0);
};
const isArrayType = (x) => Array.isArray(x) && typeof x[0] === "string" && typeof x[1] === "number";
const createStore = (schema, size = 1e4) => {
  const $store = Symbol("store");
  if (!schema)
    return {};
  schema = JSON.parse(JSON.stringify(schema));
  const arrayCounts = {};
  const collectArrayCounts = (s) => {
    const keys = Object.keys(s);
    for (const k of keys) {
      if (isArrayType(s[k])) {
        if (!arrayCounts[s[k][0]])
          arrayCounts[s[k][0]] = 0;
        arrayCounts[s[k][0]]++;
      } else if (s[k] instanceof Object) {
        collectArrayCounts(s[k]);
      }
    }
  };
  collectArrayCounts(schema);
  const metadata = {
    [$storeSize]: size,
    [$storeMaps]: {},
    [$storeSubarrays]: {},
    [$storeRef]: $store,
    [$storeCursor]: 0,
    [$subarrayCursors]: Object.keys(TYPES).reduce((a, type) => __assign(__assign({}, a), {
      [type]: 0
    }), {}),
    [$storeArrayCounts]: arrayCounts,
    [$storeFlattened]: []
  };
  if (schema instanceof Object && Object.keys(schema).length) {
    const recursiveTransform = (a, k) => {
      if (typeof a[k] === "string") {
        a[k] = createTypeStore(a[k], size);
        a[k][$storeBase] = () => stores[$store];
        metadata[$storeFlattened].push(a[k]);
        createShadows(a[k]);
      } else if (isArrayType(a[k])) {
        const [type, length] = a[k];
        a[k] = createArrayStore(metadata, type, length);
        a[k][$storeBase] = () => stores[$store];
        metadata[$storeFlattened].push(a[k]);
      } else if (a[k] instanceof Object) {
        a[k] = Object.keys(a[k]).reduce(recursiveTransform, a[k]);
      }
      return a;
    };
    stores[$store] = Object.assign(Object.keys(schema).reduce(recursiveTransform, schema), metadata);
    stores[$store][$storeBase] = () => stores[$store];
    return stores[$store];
  }
  stores[$store] = metadata;
  stores[$store][$storeBase] = () => stores[$store];
  return stores[$store];
};
const $entityMasks = Symbol("entityMasks");
const $entityEnabled = Symbol("entityEnabled");
const $entityArray = Symbol("entityArray");
const $entityIndices = Symbol("entityIndices");
const NONE$1 = 2 ** 32;
let globalEntityCursor = 0;
const removed = [];
const getEntityCursor = () => globalEntityCursor;
const resizeWorld = (world, size) => {
  world[$size] = size;
  world[$componentMap].forEach((c) => {
    resizeStore(c.store, size);
  });
  world[$queryMap].forEach((q) => {
    q.indices = resize(q.indices, size);
    q.enabled = resize(q.enabled, size);
  });
  world[$entityEnabled] = resize(world[$entityEnabled], size);
  world[$entityIndices] = resize(world[$entityIndices], size);
  for (let i = 0; i < world[$entityMasks].length; i++) {
    const masks = world[$entityMasks][i];
    world[$entityMasks][i] = resize(masks, size);
  }
};
const addEntity = (world) => {
  const enabled = world[$entityEnabled];
  const eid = removed.length > 0 ? removed.shift() : globalEntityCursor++;
  enabled[eid] = 1;
  world[$entityIndices][eid] = world[$entityArray].push(eid) - 1;
  if (globalEntityCursor >= world[$warningSize]) {
    const size = world[$size];
    const amount = Math.ceil(size / 2 / 4) * 4;
    resizeWorld(world, size + amount);
    world[$warningSize] = world[$size] - world[$size] / 5;
    console.info(`\u{1F47E} bitECS - resizing world from ${size} to ${size + amount}`);
  }
  return eid;
};
const removeEntity = (world, eid) => {
  const enabled = world[$entityEnabled];
  if (enabled[eid] === 0)
    return;
  world[$queries].forEach((query) => {
    queryRemoveEntity(world, query, eid);
  });
  removed.push(eid);
  enabled[eid] = 0;
  const index = world[$entityIndices][eid];
  const swapped = world[$entityArray].pop();
  if (swapped !== eid) {
    world[$entityArray][index] = swapped;
    world[$entityIndices][swapped] = index;
  }
  world[$entityIndices][eid] = NONE$1;
  for (let i = 0; i < world[$entityMasks].length; i++)
    world[$entityMasks][i][eid] = 0;
};
const $queries = Symbol("queries");
const $queryMap = Symbol("queryMap");
const $dirtyQueries = Symbol("$dirtyQueries");
const $queryComponents = Symbol("queryComponents");
const NONE = 2 ** 32;
const enterQuery = (query) => (world) => {
  if (!world[$queryMap].has(query))
    registerQuery(world, query);
  const q = world[$queryMap].get(query);
  return q.entered.splice(0);
};
const registerQuery = (world, query) => {
  let components = [];
  let notComponents = [];
  let changedComponents = [];
  query[$queryComponents].forEach((c) => {
    if (typeof c === "function") {
      if (c.name === "QueryNot") {
        notComponents.push(c());
      }
      if (c.name === "QueryChanged") {
        changedComponents.push(c());
        components.push(c());
      }
    } else {
      components.push(c);
    }
  });
  const mapComponents = (c) => world[$componentMap].get(c);
  const size = components.concat(notComponents).reduce((a, c) => c[$storeSize] > a ? c[$storeSize] : a, 0);
  const entities = [];
  const changed = [];
  const indices = new Uint32Array(size).fill(NONE);
  const enabled = new Uint8Array(size);
  const generations = components.concat(notComponents).map((c) => {
    if (!world[$componentMap].has(c))
      registerComponent(world, c);
    return c;
  }).map(mapComponents).map((c) => c.generationId).reduce((a, v) => {
    if (a.includes(v))
      return a;
    a.push(v);
    return a;
  }, []);
  const reduceBitmasks = (a, c) => {
    if (!a[c.generationId])
      a[c.generationId] = 0;
    a[c.generationId] |= c.bitflag;
    return a;
  };
  const masks = components.map(mapComponents).reduce(reduceBitmasks, {});
  const notMasks = notComponents.map(mapComponents).reduce((a, c) => {
    if (!a[c.generationId]) {
      a[c.generationId] = 0;
      a[c.generationId] |= c.bitflag;
    }
    return a;
  }, {});
  const flatProps = components.map((c) => Object.getOwnPropertySymbols(c).includes($storeFlattened) ? c[$storeFlattened] : [c]).reduce((a, v) => a.concat(v), []);
  const toRemove = [];
  const entered = [];
  const exited = [];
  world[$queryMap].set(query, {
    entities,
    changed,
    enabled,
    components,
    notComponents,
    changedComponents,
    masks,
    notMasks,
    generations,
    indices,
    flatProps,
    toRemove,
    entered,
    exited
  });
  world[$queries].add(query);
  for (let eid = 0; eid < getEntityCursor(); eid++) {
    if (!world[$entityEnabled][eid])
      continue;
    if (queryCheckEntity(world, query, eid)) {
      queryAddEntity(world, query, eid);
    }
  }
};
const diff = (q) => {
  q.changed.length = 0;
  const flat = q.flatProps;
  for (let i = 0; i < q.entities.length; i++) {
    const eid = q.entities[i];
    let dirty = false;
    for (let pid = 0; pid < flat.length; pid++) {
      const prop = flat[pid];
      if (ArrayBuffer.isView(prop[eid])) {
        for (let i2 = 0; i2 < prop[eid].length; i2++) {
          if (prop[eid][i2] !== prop[eid][$queryShadow][i2]) {
            dirty = true;
            prop[eid][$queryShadow][i2] = prop[eid][i2];
          }
        }
      } else {
        if (prop[eid] !== prop[$queryShadow][eid]) {
          dirty = true;
          prop[$queryShadow][eid] = prop[eid];
        }
      }
    }
    if (dirty)
      q.changed.push(eid);
  }
  return q.changed;
};
const defineQuery = (components) => {
  const query = function(world) {
    if (!world[$queryMap].has(query))
      registerQuery(world, query);
    const q = world[$queryMap].get(query);
    queryCommitRemovals(world, q);
    if (q.changedComponents.length)
      return diff(q);
    return q.entities;
  };
  query[$queryComponents] = components;
  return query;
};
const queryCheckEntity = (world, query, eid) => {
  const {
    masks,
    notMasks,
    generations
  } = world[$queryMap].get(query);
  for (let i = 0; i < generations.length; i++) {
    const generationId = generations[i];
    const qMask = masks[generationId];
    const qNotMask = notMasks[generationId];
    const eMask = world[$entityMasks][generationId][eid];
    if (qNotMask && (eMask & qNotMask) !== 0) {
      return false;
    }
    if (qMask && (eMask & qMask) !== qMask) {
      return false;
    }
  }
  return true;
};
const queryCheckComponent = (world, query, component) => {
  const {
    generationId,
    bitflag
  } = world[$componentMap].get(component);
  const {
    masks
  } = world[$queryMap].get(query);
  const mask = masks[generationId];
  return (mask & bitflag) === bitflag;
};
const queryAddEntity = (world, query, eid) => {
  const q = world[$queryMap].get(query);
  if (q.enabled[eid])
    return;
  q.enabled[eid] = true;
  q.entities.push(eid);
  q.indices[eid] = q.entities.length - 1;
  q.entered.push(eid);
};
const queryCommitRemovals = (world, q) => {
  while (q.toRemove.length) {
    const eid = q.toRemove.pop();
    const index = q.indices[eid];
    if (index === NONE)
      continue;
    const swapped = q.entities.pop();
    if (swapped !== eid) {
      q.entities[index] = swapped;
      q.indices[swapped] = index;
    }
    q.indices[eid] = NONE;
  }
  world[$dirtyQueries].delete(q);
};
const commitRemovals = (world) => {
  world[$dirtyQueries].forEach((q) => {
    queryCommitRemovals(world, q);
  });
};
const queryRemoveEntity = (world, query, eid) => {
  const q = world[$queryMap].get(query);
  if (!q.enabled[eid])
    return;
  q.enabled[eid] = false;
  q.toRemove.push(eid);
  world[$dirtyQueries].add(q);
  q.exited.push(eid);
};
const $componentMap = Symbol("componentMap");
const defineComponent = (schema) => createStore(schema);
const incrementBitflag = (world) => {
  world[$bitflag] *= 2;
  if (world[$bitflag] >= 2 ** 32) {
    world[$bitflag] = 1;
    world[$entityMasks].push(new Uint32Array(world[$size]));
  }
};
const registerComponent = (world, component) => {
  world[$componentMap].set(component, {
    generationId: world[$entityMasks].length - 1,
    bitflag: world[$bitflag],
    store: component
  });
  if (component[$storeSize] < world[$size]) {
    resizeStore(component, world[$size]);
  }
  incrementBitflag(world);
};
const hasComponent = (world, component, eid) => {
  const registeredComponent = world[$componentMap].get(component);
  if (!registeredComponent)
    return;
  const {
    generationId,
    bitflag
  } = registeredComponent;
  const mask = world[$entityMasks][generationId][eid];
  return (mask & bitflag) === bitflag;
};
const addComponent = (world, component, eid, reset = false) => {
  if (!world[$componentMap].has(component))
    registerComponent(world, component);
  if (hasComponent(world, component, eid))
    return;
  const {
    generationId,
    bitflag
  } = world[$componentMap].get(component);
  world[$entityMasks][generationId][eid] |= bitflag;
  world[$queries].forEach((query) => {
    if (!queryCheckComponent(world, query, component))
      return;
    const match = queryCheckEntity(world, query, eid);
    if (match)
      queryAddEntity(world, query, eid);
  });
  if (reset)
    resetStoreFor(component, eid);
};
const removeComponent = (world, component, eid, reset = false) => {
  const {
    generationId,
    bitflag
  } = world[$componentMap].get(component);
  if (!(world[$entityMasks][generationId][eid] & bitflag))
    return;
  world[$queries].forEach((query) => {
    if (!queryCheckComponent(world, query, component))
      return;
    const match = queryCheckEntity(world, query, eid);
    if (match)
      queryRemoveEntity(world, query, eid);
  });
  world[$entityMasks][generationId][eid] &= ~bitflag;
  if (reset)
    resetStoreFor(component, eid);
};
const $size = Symbol("size");
const $warningSize = Symbol("warningSize");
const $bitflag = Symbol("bitflag");
const createWorld = (size = 1e4) => {
  const world = {};
  world[$size] = size;
  world[$entityEnabled] = new Uint8Array(size);
  world[$entityMasks] = [new Uint32Array(size)];
  world[$entityArray] = [];
  world[$entityIndices] = new Uint32Array(size);
  world[$bitflag] = 1;
  world[$componentMap] = new Map();
  world[$queryMap] = new Map();
  world[$queries] = new Set();
  world[$dirtyQueries] = new Set();
  world[$warningSize] = size - size / 5;
  return world;
};
const defineSystem = (update) => {
  const system = (world) => {
    update(world);
    commitRemovals(world);
    return world;
  };
  Object.defineProperty(system, "name", {
    value: (update.name || "AnonymousSystem") + "_internal",
    configurable: true
  });
  return system;
};
const pipe = (...fns) => (input) => {
  fns = Array.isArray(fns[0]) ? fns[0] : fns;
  let tmp = input;
  for (let i = 0; i < fns.length; i++) {
    const fn = fns[i];
    tmp = fn(tmp);
  }
  return tmp;
};
const Types = TYPES_ENUM;
function createCommonjsModule(fn) {
  var module = {exports: {}};
  return fn(module, module.exports), module.exports;
}
var rapier = createCommonjsModule(function(module, exports) {
  !function(A, I) {
    module.exports = I();
  }(self, function() {
    return (() => {
      var A = {384: (A2, I2, g2) => {
        let C;
        g2.r(I2), g2.d(I2, {Ball: () => JA, BodyStatus: () => _, BroadPhase: () => UA, CCDSolver: () => kA, Capsule: () => yA, CoefficientCombineRule: () => DA, Collider: () => TA, ColliderDesc: () => tA, ColliderSet: () => OA, Cone: () => HA, ConvexPolyhedron: () => YA, Cuboid: () => FA, Cylinder: () => LA, EventQueue: () => fA, Heightfield: () => cA, IntegrationParameters: () => iA, Joint: () => oA, JointParams: () => SA, JointSet: () => GA, JointType: () => CA, NarrowPhase: () => MA, PhysicsPipeline: () => WA, PointColliderProjection: () => eA, Polyline: () => qA, Quaternion: () => IA, Ray: () => dA, RayColliderIntersection: () => ZA, RayColliderToi: () => nA, RigidBody: () => BA, RigidBodyDesc: () => QA, RigidBodySet: () => EA, RotationOps: () => gA, RoundCone: () => pA, RoundConvexPolyhedron: () => sA, RoundCuboid: () => KA, RoundCylinder: () => lA, RoundTriangle: () => aA, Segment: () => hA, SerializationPipeline: () => bA, ShapeColliderTOI: () => rA, ShapeType: () => wA, TriMesh: () => RA, Triangle: () => NA, Vector3: () => $, VectorOps: () => AA, World: () => jA, init: () => XA, version: () => VA});
        const B = new Array(32).fill(void 0);
        B.push(void 0, null, true, false);
        let Q = B.length;
        function E(A3) {
          Q === B.length && B.push(B.length + 1);
          const I3 = Q;
          return Q = B[I3], B[I3] = A3, I3;
        }
        function i(A3) {
          return B[A3];
        }
        function D(A3) {
          const I3 = i(A3);
          return function(A4) {
            A4 < 36 || (B[A4] = Q, Q = A4);
          }(A3), I3;
        }
        let o = new TextDecoder("utf-8", {ignoreBOM: true, fatal: true});
        o.decode();
        let S = null;
        function G() {
          return S !== null && S.buffer === C.memory.buffer || (S = new Uint8Array(C.memory.buffer)), S;
        }
        function w(A3, I3) {
          return o.decode(G().subarray(A3, A3 + I3));
        }
        function k(A3) {
          const I3 = typeof A3;
          if (I3 == "number" || I3 == "boolean" || A3 == null)
            return `${A3}`;
          if (I3 == "string")
            return `"${A3}"`;
          if (I3 == "symbol") {
            const I4 = A3.description;
            return I4 == null ? "Symbol" : `Symbol(${I4})`;
          }
          if (I3 == "function") {
            const I4 = A3.name;
            return typeof I4 == "string" && I4.length > 0 ? `Function(${I4})` : "Function";
          }
          if (Array.isArray(A3)) {
            const I4 = A3.length;
            let g4 = "[";
            I4 > 0 && (g4 += k(A3[0]));
            for (let C3 = 1; C3 < I4; C3++)
              g4 += ", " + k(A3[C3]);
            return g4 += "]", g4;
          }
          const g3 = /\[object ([^\]]+)\]/.exec(toString.call(A3));
          let C2;
          if (!(g3.length > 1))
            return toString.call(A3);
          if (C2 = g3[1], C2 == "Object")
            try {
              return "Object(" + JSON.stringify(A3) + ")";
            } catch (A4) {
              return "Object";
            }
          return A3 instanceof Error ? `${A3.name}: ${A3.message}
${A3.stack}` : C2;
        }
        let U = 0, M = new TextEncoder("utf-8");
        const J = typeof M.encodeInto == "function" ? function(A3, I3) {
          return M.encodeInto(A3, I3);
        } : function(A3, I3) {
          const g3 = M.encode(A3);
          return I3.set(g3), {read: A3.length, written: g3.length};
        };
        let F = null;
        function K() {
          return F !== null && F.buffer === C.memory.buffer || (F = new Int32Array(C.memory.buffer)), F;
        }
        function y(A3, I3) {
          if (!(A3 instanceof I3))
            throw new Error(`expected instance of ${I3.name}`);
          return A3.ptr;
        }
        let h = 32;
        function N(A3) {
          if (h == 1)
            throw new Error("out of js stack");
          return B[--h] = A3, h;
        }
        let a = null;
        function q() {
          return a !== null && a.buffer === C.memory.buffer || (a = new Float32Array(C.memory.buffer)), a;
        }
        function R(A3, I3) {
          return q().subarray(A3 / 4, A3 / 4 + I3);
        }
        let Y = null;
        function s() {
          return Y !== null && Y.buffer === C.memory.buffer || (Y = new Uint32Array(C.memory.buffer)), Y;
        }
        function c(A3) {
          return A3 == null;
        }
        function L(A3, I3) {
          const g3 = I3(4 * A3.length);
          return q().set(A3, g3 / 4), U = A3.length, g3;
        }
        function l(A3, I3) {
          const g3 = I3(4 * A3.length);
          return s().set(A3, g3 / 4), U = A3.length, g3;
        }
        function H(A3) {
          return function() {
            try {
              return A3.apply(this, arguments);
            } catch (A4) {
              C.__wbindgen_exn_store(E(A4));
            }
          };
        }
        Object.freeze({Ball: 0, 0: "Ball", Fixed: 1, 1: "Fixed", Prismatic: 2, 2: "Prismatic", Revolute: 3, 3: "Revolute"}), Object.freeze({Dynamic: 0, 0: "Dynamic", Static: 1, 1: "Static", Kinematic: 2, 2: "Kinematic"}), Object.freeze({Ball: 0, 0: "Ball", Cuboid: 1, 1: "Cuboid", Capsule: 2, 2: "Capsule", Segment: 3, 3: "Segment", Polyline: 4, 4: "Polyline", Triangle: 5, 5: "Triangle", TriMesh: 6, 6: "TriMesh", HeightField: 7, 7: "HeightField", Compound: 8, 8: "Compound", ConvexPolyhedron: 9, 9: "ConvexPolyhedron", Cylinder: 10, 10: "Cylinder", Cone: 11, 11: "Cone", RoundCuboid: 12, 12: "RoundCuboid", RoundTriangle: 13, 13: "RoundTriangle", RoundCylinder: 14, 14: "RoundCylinder", RoundCone: 15, 15: "RoundCone", RoundConvexPolyhedron: 16, 16: "RoundConvexPolyhedron"});
        class p {
          static __wrap(A3) {
            const I3 = Object.create(p.prototype);
            return I3.ptr = A3, I3;
          }
          __destroy_into_raw() {
            const A3 = this.ptr;
            return this.ptr = 0, A3;
          }
          free() {
            const A3 = this.__destroy_into_raw();
            C.__wbg_rawbroadphase_free(A3);
          }
          constructor() {
            var A3 = C.rawbroadphase_new();
            return p.__wrap(A3);
          }
        }
        class T {
          static __wrap(A3) {
            const I3 = Object.create(T.prototype);
            return I3.ptr = A3, I3;
          }
          __destroy_into_raw() {
            const A3 = this.ptr;
            return this.ptr = 0, A3;
          }
          free() {
            const A3 = this.__destroy_into_raw();
            C.__wbg_rawccdsolver_free(A3);
          }
          constructor() {
            var A3 = C.rawccdsolver_new();
            return T.__wrap(A3);
          }
        }
        class t {
          static __wrap(A3) {
            const I3 = Object.create(t.prototype);
            return I3.ptr = A3, I3;
          }
          __destroy_into_raw() {
            const A3 = this.ptr;
            return this.ptr = 0, A3;
          }
          free() {
            const A3 = this.__destroy_into_raw();
            C.__wbg_rawcolliderset_free(A3);
          }
          coTranslation(A3) {
            var I3 = C.rawcolliderset_coTranslation(this.ptr, A3);
            return z.__wrap(I3);
          }
          coRotation(A3) {
            var I3 = C.rawcolliderset_coRotation(this.ptr, A3);
            return X.__wrap(I3);
          }
          coIsSensor(A3) {
            return C.rawcolliderset_coIsSensor(this.ptr, A3) !== 0;
          }
          coShapeType(A3) {
            return C.rawcolliderset_coShapeType(this.ptr, A3) >>> 0;
          }
          coHalfExtents(A3) {
            var I3 = C.rawcolliderset_coHalfExtents(this.ptr, A3);
            return I3 === 0 ? void 0 : z.__wrap(I3);
          }
          coRadius(A3) {
            try {
              const B2 = C.__wbindgen_add_to_stack_pointer(-16);
              C.rawcolliderset_coRadius(B2, this.ptr, A3);
              var I3 = K()[B2 / 4 + 0], g3 = q()[B2 / 4 + 1];
              return I3 === 0 ? void 0 : g3;
            } finally {
              C.__wbindgen_add_to_stack_pointer(16);
            }
          }
          coHalfHeight(A3) {
            try {
              const B2 = C.__wbindgen_add_to_stack_pointer(-16);
              C.rawcolliderset_coHalfHeight(B2, this.ptr, A3);
              var I3 = K()[B2 / 4 + 0], g3 = q()[B2 / 4 + 1];
              return I3 === 0 ? void 0 : g3;
            } finally {
              C.__wbindgen_add_to_stack_pointer(16);
            }
          }
          coRoundRadius(A3) {
            try {
              const B2 = C.__wbindgen_add_to_stack_pointer(-16);
              C.rawcolliderset_coRoundRadius(B2, this.ptr, A3);
              var I3 = K()[B2 / 4 + 0], g3 = q()[B2 / 4 + 1];
              return I3 === 0 ? void 0 : g3;
            } finally {
              C.__wbindgen_add_to_stack_pointer(16);
            }
          }
          coVertices(A3) {
            try {
              const B2 = C.__wbindgen_add_to_stack_pointer(-16);
              C.rawcolliderset_coVertices(B2, this.ptr, A3);
              var I3 = K()[B2 / 4 + 0], g3 = K()[B2 / 4 + 1];
              let Q2;
              return I3 !== 0 && (Q2 = R(I3, g3).slice(), C.__wbindgen_free(I3, 4 * g3)), Q2;
            } finally {
              C.__wbindgen_add_to_stack_pointer(16);
            }
          }
          coIndices(A3) {
            try {
              const E2 = C.__wbindgen_add_to_stack_pointer(-16);
              C.rawcolliderset_coIndices(E2, this.ptr, A3);
              var I3 = K()[E2 / 4 + 0], g3 = K()[E2 / 4 + 1];
              let i2;
              return I3 !== 0 && (i2 = (B2 = I3, Q2 = g3, s().subarray(B2 / 4, B2 / 4 + Q2)).slice(), C.__wbindgen_free(I3, 4 * g3)), i2;
            } finally {
              C.__wbindgen_add_to_stack_pointer(16);
            }
            var B2, Q2;
          }
          coHeightfieldHeights(A3) {
            try {
              const B2 = C.__wbindgen_add_to_stack_pointer(-16);
              C.rawcolliderset_coHeightfieldHeights(B2, this.ptr, A3);
              var I3 = K()[B2 / 4 + 0], g3 = K()[B2 / 4 + 1];
              let Q2;
              return I3 !== 0 && (Q2 = R(I3, g3).slice(), C.__wbindgen_free(I3, 4 * g3)), Q2;
            } finally {
              C.__wbindgen_add_to_stack_pointer(16);
            }
          }
          coHeightfieldScale(A3) {
            var I3 = C.rawcolliderset_coHeightfieldScale(this.ptr, A3);
            return I3 === 0 ? void 0 : z.__wrap(I3);
          }
          coHeightfieldNRows(A3) {
            try {
              const B2 = C.__wbindgen_add_to_stack_pointer(-16);
              C.rawcolliderset_coHeightfieldNRows(B2, this.ptr, A3);
              var I3 = K()[B2 / 4 + 0], g3 = K()[B2 / 4 + 1];
              return I3 === 0 ? void 0 : g3 >>> 0;
            } finally {
              C.__wbindgen_add_to_stack_pointer(16);
            }
          }
          coHeightfieldNCols(A3) {
            try {
              const B2 = C.__wbindgen_add_to_stack_pointer(-16);
              C.rawcolliderset_coHeightfieldNCols(B2, this.ptr, A3);
              var I3 = K()[B2 / 4 + 0], g3 = K()[B2 / 4 + 1];
              return I3 === 0 ? void 0 : g3 >>> 0;
            } finally {
              C.__wbindgen_add_to_stack_pointer(16);
            }
          }
          coParent(A3) {
            return C.rawcolliderset_coParent(this.ptr, A3) >>> 0;
          }
          coFriction(A3) {
            return C.rawcolliderset_coFriction(this.ptr, A3);
          }
          coDensity(A3) {
            try {
              const B2 = C.__wbindgen_add_to_stack_pointer(-16);
              C.rawcolliderset_coDensity(B2, this.ptr, A3);
              var I3 = K()[B2 / 4 + 0], g3 = q()[B2 / 4 + 1];
              return I3 === 0 ? void 0 : g3;
            } finally {
              C.__wbindgen_add_to_stack_pointer(16);
            }
          }
          coCollisionGroups(A3) {
            return C.rawcolliderset_coCollisionGroups(this.ptr, A3) >>> 0;
          }
          coSolverGroups(A3) {
            return C.rawcolliderset_coSolverGroups(this.ptr, A3) >>> 0;
          }
          constructor() {
            var A3 = C.rawcolliderset_new();
            return t.__wrap(A3);
          }
          len() {
            return C.rawcolliderset_len(this.ptr) >>> 0;
          }
          contains(A3) {
            return C.rawcolliderset_contains(this.ptr, A3) !== 0;
          }
          createCollider(A3, I3, g3, B2, Q2, E2, i2, D2, o2, S2, G2, w2, k2) {
            try {
              const J2 = C.__wbindgen_add_to_stack_pointer(-16);
              y(A3, m), y(I3, z), y(g3, X), y(k2, V), C.rawcolliderset_createCollider(J2, this.ptr, A3.ptr, I3.ptr, g3.ptr, !c(B2), c(B2) ? 0 : B2, Q2, E2, i2, D2, o2, S2, G2, w2, k2.ptr);
              var U2 = K()[J2 / 4 + 0], M2 = K()[J2 / 4 + 1];
              return U2 === 0 ? void 0 : M2 >>> 0;
            } finally {
              C.__wbindgen_add_to_stack_pointer(16);
            }
          }
          remove(A3, I3, g3) {
            y(I3, V), C.rawcolliderset_remove(this.ptr, A3, I3.ptr, g3);
          }
          isHandleValid(A3) {
            return C.rawcolliderset_contains(this.ptr, A3) !== 0;
          }
          forEachColliderHandle(A3) {
            try {
              C.rawcolliderset_forEachColliderHandle(this.ptr, N(A3));
            } finally {
              B[h++] = void 0;
            }
          }
        }
        class O {
          static __wrap(A3) {
            const I3 = Object.create(O.prototype);
            return I3.ptr = A3, I3;
          }
          __destroy_into_raw() {
            const A3 = this.ptr;
            return this.ptr = 0, A3;
          }
          free() {
            const A3 = this.__destroy_into_raw();
            C.__wbg_rawdeserializedworld_free(A3);
          }
          takeGravity() {
            var A3 = C.rawdeserializedworld_takeGravity(this.ptr);
            return A3 === 0 ? void 0 : z.__wrap(A3);
          }
          takeIntegrationParameters() {
            var A3 = C.rawdeserializedworld_takeIntegrationParameters(this.ptr);
            return A3 === 0 ? void 0 : Z.__wrap(A3);
          }
          takeBroadPhase() {
            var A3 = C.rawdeserializedworld_takeBroadPhase(this.ptr);
            return A3 === 0 ? void 0 : p.__wrap(A3);
          }
          takeNarrowPhase() {
            var A3 = C.rawdeserializedworld_takeNarrowPhase(this.ptr);
            return A3 === 0 ? void 0 : r.__wrap(A3);
          }
          takeBodies() {
            var A3 = C.rawdeserializedworld_takeBodies(this.ptr);
            return A3 === 0 ? void 0 : V.__wrap(A3);
          }
          takeColliders() {
            var A3 = C.rawdeserializedworld_takeColliders(this.ptr);
            return A3 === 0 ? void 0 : t.__wrap(A3);
          }
          takeJoints() {
            var A3 = C.rawdeserializedworld_takeJoints(this.ptr);
            return A3 === 0 ? void 0 : e.__wrap(A3);
          }
        }
        class d {
          static __wrap(A3) {
            const I3 = Object.create(d.prototype);
            return I3.ptr = A3, I3;
          }
          __destroy_into_raw() {
            const A3 = this.ptr;
            return this.ptr = 0, A3;
          }
          free() {
            const A3 = this.__destroy_into_raw();
            C.__wbg_raweventqueue_free(A3);
          }
          constructor(A3) {
            var I3 = C.raweventqueue_new(A3);
            return d.__wrap(I3);
          }
          drainContactEvents(A3) {
            try {
              C.raweventqueue_drainContactEvents(this.ptr, N(A3));
            } finally {
              B[h++] = void 0;
            }
          }
          drainIntersectionEvents(A3) {
            try {
              C.raweventqueue_drainIntersectionEvents(this.ptr, N(A3));
            } finally {
              B[h++] = void 0;
            }
          }
          clear() {
            C.raweventqueue_clear(this.ptr);
          }
        }
        class Z {
          static __wrap(A3) {
            const I3 = Object.create(Z.prototype);
            return I3.ptr = A3, I3;
          }
          __destroy_into_raw() {
            const A3 = this.ptr;
            return this.ptr = 0, A3;
          }
          free() {
            const A3 = this.__destroy_into_raw();
            C.__wbg_rawintegrationparameters_free(A3);
          }
          constructor() {
            var A3 = C.rawintegrationparameters_new();
            return Z.__wrap(A3);
          }
          get dt() {
            return C.rawintegrationparameters_dt(this.ptr);
          }
          get erp() {
            return C.rawintegrationparameters_erp(this.ptr);
          }
          get jointErp() {
            return C.rawintegrationparameters_jointErp(this.ptr);
          }
          get warmstartCoeff() {
            return C.rawintegrationparameters_warmstartCoeff(this.ptr);
          }
          get allowedLinearError() {
            return C.rawintegrationparameters_allowedLinearError(this.ptr);
          }
          get predictionDistance() {
            return C.rawintegrationparameters_predictionDistance(this.ptr);
          }
          get allowedAngularError() {
            return C.rawintegrationparameters_allowedAngularError(this.ptr);
          }
          get maxLinearCorrection() {
            return C.rawintegrationparameters_maxLinearCorrection(this.ptr);
          }
          get maxAngularCorrection() {
            return C.rawintegrationparameters_maxAngularCorrection(this.ptr);
          }
          get maxVelocityIterations() {
            return C.rawintegrationparameters_maxVelocityIterations(this.ptr) >>> 0;
          }
          get maxPositionIterations() {
            return C.rawintegrationparameters_maxPositionIterations(this.ptr) >>> 0;
          }
          get minIslandSize() {
            return C.rawintegrationparameters_minIslandSize(this.ptr) >>> 0;
          }
          get maxCcdSubsteps() {
            return C.rawintegrationparameters_maxCcdSubsteps(this.ptr) >>> 0;
          }
          set dt(A3) {
            C.rawintegrationparameters_set_dt(this.ptr, A3);
          }
          set erp(A3) {
            C.rawintegrationparameters_set_erp(this.ptr, A3);
          }
          set jointErp(A3) {
            C.rawintegrationparameters_set_jointErp(this.ptr, A3);
          }
          set warmstartCoeff(A3) {
            C.rawintegrationparameters_set_warmstartCoeff(this.ptr, A3);
          }
          set allowedLinearError(A3) {
            C.rawintegrationparameters_set_allowedLinearError(this.ptr, A3);
          }
          set predictionDistance(A3) {
            C.rawintegrationparameters_set_predictionDistance(this.ptr, A3);
          }
          set allowedAngularError(A3) {
            C.rawintegrationparameters_set_allowedAngularError(this.ptr, A3);
          }
          set maxLinearCorrection(A3) {
            C.rawintegrationparameters_set_maxLinearCorrection(this.ptr, A3);
          }
          set maxAngularCorrection(A3) {
            C.rawintegrationparameters_set_maxAngularCorrection(this.ptr, A3);
          }
          set maxVelocityIterations(A3) {
            C.rawintegrationparameters_set_maxVelocityIterations(this.ptr, A3);
          }
          set maxPositionIterations(A3) {
            C.rawintegrationparameters_set_maxPositionIterations(this.ptr, A3);
          }
          set minIslandSize(A3) {
            C.rawintegrationparameters_set_minIslandSize(this.ptr, A3);
          }
          set maxCcdSubsteps(A3) {
            C.rawintegrationparameters_set_maxCcdSubsteps(this.ptr, A3);
          }
        }
        class n {
          static __wrap(A3) {
            const I3 = Object.create(n.prototype);
            return I3.ptr = A3, I3;
          }
          __destroy_into_raw() {
            const A3 = this.ptr;
            return this.ptr = 0, A3;
          }
          free() {
            const A3 = this.__destroy_into_raw();
            C.__wbg_rawjointparams_free(A3);
          }
          static ball(A3, I3) {
            y(A3, z), y(I3, z);
            var g3 = C.rawjointparams_ball(A3.ptr, I3.ptr);
            return n.__wrap(g3);
          }
          static prismatic(A3, I3, g3, B2, Q2, E2, i2, D2, o2) {
            y(A3, z), y(I3, z), y(g3, z), y(B2, z), y(Q2, z), y(E2, z);
            var S2 = C.rawjointparams_prismatic(A3.ptr, I3.ptr, g3.ptr, B2.ptr, Q2.ptr, E2.ptr, i2, D2, o2);
            return S2 === 0 ? void 0 : n.__wrap(S2);
          }
          static fixed(A3, I3, g3, B2) {
            y(A3, z), y(I3, X), y(g3, z), y(B2, X);
            var Q2 = C.rawjointparams_fixed(A3.ptr, I3.ptr, g3.ptr, B2.ptr);
            return n.__wrap(Q2);
          }
          static revolute(A3, I3, g3, B2) {
            y(A3, z), y(I3, z), y(g3, z), y(B2, z);
            var Q2 = C.rawjointparams_revolute(A3.ptr, I3.ptr, g3.ptr, B2.ptr);
            return Q2 === 0 ? void 0 : n.__wrap(Q2);
          }
        }
        class e {
          static __wrap(A3) {
            const I3 = Object.create(e.prototype);
            return I3.ptr = A3, I3;
          }
          __destroy_into_raw() {
            const A3 = this.ptr;
            return this.ptr = 0, A3;
          }
          free() {
            const A3 = this.__destroy_into_raw();
            C.__wbg_rawjointset_free(A3);
          }
          jointBodyHandle1(A3) {
            return C.rawjointset_jointBodyHandle1(this.ptr, A3) >>> 0;
          }
          jointBodyHandle2(A3) {
            return C.rawjointset_jointBodyHandle2(this.ptr, A3) >>> 0;
          }
          jointType(A3) {
            return C.rawjointset_jointType(this.ptr, A3) >>> 0;
          }
          jointFrameX1(A3) {
            var I3 = C.rawjointset_jointFrameX1(this.ptr, A3);
            return X.__wrap(I3);
          }
          jointFrameX2(A3) {
            var I3 = C.rawjointset_jointFrameX2(this.ptr, A3);
            return X.__wrap(I3);
          }
          jointAnchor1(A3) {
            var I3 = C.rawjointset_jointAnchor1(this.ptr, A3);
            return z.__wrap(I3);
          }
          jointAnchor2(A3) {
            var I3 = C.rawjointset_jointAnchor2(this.ptr, A3);
            return z.__wrap(I3);
          }
          jointAxis1(A3) {
            var I3 = C.rawjointset_jointAxis1(this.ptr, A3);
            return I3 === 0 ? void 0 : z.__wrap(I3);
          }
          jointAxis2(A3) {
            var I3 = C.rawjointset_jointAxis2(this.ptr, A3);
            return I3 === 0 ? void 0 : z.__wrap(I3);
          }
          jointLimitsEnabled(A3) {
            return C.rawjointset_jointLimitsEnabled(this.ptr, A3) !== 0;
          }
          jointLimitsMin(A3) {
            return C.rawjointset_jointLimitsMin(this.ptr, A3);
          }
          jointLimitsMax(A3) {
            return C.rawjointset_jointLimitsMax(this.ptr, A3);
          }
          constructor() {
            var A3 = C.rawjointset_new();
            return e.__wrap(A3);
          }
          createJoint(A3, I3, g3, B2) {
            return y(A3, V), y(I3, n), C.rawjointset_createJoint(this.ptr, A3.ptr, I3.ptr, g3, B2) >>> 0;
          }
          remove(A3, I3, g3) {
            y(I3, V), C.rawjointset_remove(this.ptr, A3, I3.ptr, g3);
          }
          len() {
            return C.rawjointset_len(this.ptr) >>> 0;
          }
          contains(A3) {
            return C.rawjointset_contains(this.ptr, A3) !== 0;
          }
          forEachJointHandle(A3) {
            try {
              C.rawjointset_forEachJointHandle(this.ptr, N(A3));
            } finally {
              B[h++] = void 0;
            }
          }
        }
        class r {
          static __wrap(A3) {
            const I3 = Object.create(r.prototype);
            return I3.ptr = A3, I3;
          }
          __destroy_into_raw() {
            const A3 = this.ptr;
            return this.ptr = 0, A3;
          }
          free() {
            const A3 = this.__destroy_into_raw();
            C.__wbg_rawnarrowphase_free(A3);
          }
          constructor() {
            var A3 = C.rawnarrowphase_new();
            return r.__wrap(A3);
          }
        }
        class W {
          static __wrap(A3) {
            const I3 = Object.create(W.prototype);
            return I3.ptr = A3, I3;
          }
          __destroy_into_raw() {
            const A3 = this.ptr;
            return this.ptr = 0, A3;
          }
          free() {
            const A3 = this.__destroy_into_raw();
            C.__wbg_rawphysicspipeline_free(A3);
          }
          constructor() {
            var A3 = C.rawphysicspipeline_new();
            return W.__wrap(A3);
          }
          step(A3, I3, g3, B2, Q2, E2, i2, D2) {
            y(A3, z), y(I3, Z), y(g3, p), y(B2, r), y(Q2, V), y(E2, t), y(i2, e), y(D2, T), C.rawphysicspipeline_step(this.ptr, A3.ptr, I3.ptr, g3.ptr, B2.ptr, Q2.ptr, E2.ptr, i2.ptr, D2.ptr);
          }
          stepWithEvents(A3, I3, g3, B2, Q2, E2, i2, D2, o2) {
            y(A3, z), y(I3, Z), y(g3, p), y(B2, r), y(Q2, V), y(E2, t), y(i2, e), y(D2, T), y(o2, d), C.rawphysicspipeline_stepWithEvents(this.ptr, A3.ptr, I3.ptr, g3.ptr, B2.ptr, Q2.ptr, E2.ptr, i2.ptr, D2.ptr, o2.ptr);
          }
          removeRigidBody(A3, I3, g3, B2) {
            y(I3, V), y(g3, t), y(B2, e), C.rawphysicspipeline_removeRigidBody(this.ptr, A3, I3.ptr, g3.ptr, B2.ptr);
          }
          removeCollider(A3, I3, g3) {
            y(I3, V), y(g3, t), C.rawphysicspipeline_removeCollider(this.ptr, A3, I3.ptr, g3.ptr);
          }
        }
        class x {
          static __wrap(A3) {
            const I3 = Object.create(x.prototype);
            return I3.ptr = A3, I3;
          }
          __destroy_into_raw() {
            const A3 = this.ptr;
            return this.ptr = 0, A3;
          }
          free() {
            const A3 = this.__destroy_into_raw();
            C.__wbg_rawpointcolliderprojection_free(A3);
          }
          colliderHandle() {
            return C.rawpointcolliderprojection_colliderHandle(this.ptr) >>> 0;
          }
          point() {
            var A3 = C.rawpointcolliderprojection_point(this.ptr);
            return z.__wrap(A3);
          }
          isInside() {
            return C.rawpointcolliderprojection_isInside(this.ptr) !== 0;
          }
        }
        class b {
          static __wrap(A3) {
            const I3 = Object.create(b.prototype);
            return I3.ptr = A3, I3;
          }
          __destroy_into_raw() {
            const A3 = this.ptr;
            return this.ptr = 0, A3;
          }
          free() {
            const A3 = this.__destroy_into_raw();
            C.__wbg_rawquerypipeline_free(A3);
          }
          constructor() {
            var A3 = C.rawquerypipeline_new();
            return b.__wrap(A3);
          }
          update(A3, I3) {
            y(A3, V), y(I3, t), C.rawquerypipeline_update(this.ptr, A3.ptr, I3.ptr);
          }
          castRay(A3, I3, g3, B2, Q2, E2) {
            y(A3, t), y(I3, z), y(g3, z);
            var i2 = C.rawquerypipeline_castRay(this.ptr, A3.ptr, I3.ptr, g3.ptr, B2, Q2, E2);
            return i2 === 0 ? void 0 : f.__wrap(i2);
          }
          castRayAndGetNormal(A3, I3, g3, B2, Q2, E2) {
            y(A3, t), y(I3, z), y(g3, z);
            var i2 = C.rawquerypipeline_castRayAndGetNormal(this.ptr, A3.ptr, I3.ptr, g3.ptr, B2, Q2, E2);
            return i2 === 0 ? void 0 : j.__wrap(i2);
          }
          intersectionsWithRay(A3, I3, g3, Q2, E2, i2, D2) {
            try {
              y(A3, t), y(I3, z), y(g3, z), C.rawquerypipeline_intersectionsWithRay(this.ptr, A3.ptr, I3.ptr, g3.ptr, Q2, E2, i2, N(D2));
            } finally {
              B[h++] = void 0;
            }
          }
          intersectionWithShape(A3, I3, g3, B2, Q2) {
            try {
              const D2 = C.__wbindgen_add_to_stack_pointer(-16);
              y(A3, t), y(I3, z), y(g3, X), y(B2, m), C.rawquerypipeline_intersectionWithShape(D2, this.ptr, A3.ptr, I3.ptr, g3.ptr, B2.ptr, Q2);
              var E2 = K()[D2 / 4 + 0], i2 = K()[D2 / 4 + 1];
              return E2 === 0 ? void 0 : i2 >>> 0;
            } finally {
              C.__wbindgen_add_to_stack_pointer(16);
            }
          }
          projectPoint(A3, I3, g3, B2) {
            y(A3, t), y(I3, z);
            var Q2 = C.rawquerypipeline_projectPoint(this.ptr, A3.ptr, I3.ptr, g3, B2);
            return Q2 === 0 ? void 0 : x.__wrap(Q2);
          }
          intersectionsWithPoint(A3, I3, g3, Q2) {
            try {
              y(A3, t), y(I3, z), C.rawquerypipeline_intersectionsWithPoint(this.ptr, A3.ptr, I3.ptr, g3, N(Q2));
            } finally {
              B[h++] = void 0;
            }
          }
          castShape(A3, I3, g3, B2, Q2, E2, i2) {
            y(A3, t), y(I3, z), y(g3, X), y(B2, z), y(Q2, m);
            var D2 = C.rawquerypipeline_castShape(this.ptr, A3.ptr, I3.ptr, g3.ptr, B2.ptr, Q2.ptr, E2, i2);
            return D2 === 0 ? void 0 : u.__wrap(D2);
          }
          intersectionsWithShape(A3, I3, g3, Q2, E2, i2) {
            try {
              y(A3, t), y(I3, z), y(g3, X), y(Q2, m), C.rawquerypipeline_intersectionsWithShape(this.ptr, A3.ptr, I3.ptr, g3.ptr, Q2.ptr, E2, N(i2));
            } finally {
              B[h++] = void 0;
            }
          }
        }
        class j {
          static __wrap(A3) {
            const I3 = Object.create(j.prototype);
            return I3.ptr = A3, I3;
          }
          __destroy_into_raw() {
            const A3 = this.ptr;
            return this.ptr = 0, A3;
          }
          free() {
            const A3 = this.__destroy_into_raw();
            C.__wbg_rawraycolliderintersection_free(A3);
          }
          colliderHandle() {
            return C.rawpointcolliderprojection_colliderHandle(this.ptr) >>> 0;
          }
          normal() {
            var A3 = C.rawraycolliderintersection_normal(this.ptr);
            return z.__wrap(A3);
          }
          toi() {
            return C.rawraycolliderintersection_toi(this.ptr);
          }
        }
        class f {
          static __wrap(A3) {
            const I3 = Object.create(f.prototype);
            return I3.ptr = A3, I3;
          }
          __destroy_into_raw() {
            const A3 = this.ptr;
            return this.ptr = 0, A3;
          }
          free() {
            const A3 = this.__destroy_into_raw();
            C.__wbg_rawraycollidertoi_free(A3);
          }
          colliderHandle() {
            return C.rawpointcolliderprojection_colliderHandle(this.ptr) >>> 0;
          }
          toi() {
            return C.rawraycolliderintersection_toi(this.ptr);
          }
        }
        class V {
          static __wrap(A3) {
            const I3 = Object.create(V.prototype);
            return I3.ptr = A3, I3;
          }
          __destroy_into_raw() {
            const A3 = this.ptr;
            return this.ptr = 0, A3;
          }
          free() {
            const A3 = this.__destroy_into_raw();
            C.__wbg_rawrigidbodyset_free(A3);
          }
          rbTranslation(A3) {
            var I3 = C.rawrigidbodyset_rbTranslation(this.ptr, A3);
            return z.__wrap(I3);
          }
          rbRotation(A3) {
            var I3 = C.rawrigidbodyset_rbRotation(this.ptr, A3);
            return X.__wrap(I3);
          }
          rbSleep(A3) {
            C.rawrigidbodyset_rbSleep(this.ptr, A3);
          }
          rbIsSleeping(A3) {
            return C.rawrigidbodyset_rbIsSleeping(this.ptr, A3) !== 0;
          }
          rbIsMoving(A3) {
            return C.rawrigidbodyset_rbIsMoving(this.ptr, A3) !== 0;
          }
          rbNextTranslation(A3) {
            var I3 = C.rawrigidbodyset_rbNextTranslation(this.ptr, A3);
            return z.__wrap(I3);
          }
          rbNextRotation(A3) {
            var I3 = C.rawrigidbodyset_rbNextRotation(this.ptr, A3);
            return X.__wrap(I3);
          }
          rbSetTranslation(A3, I3, g3, B2, Q2) {
            C.rawrigidbodyset_rbSetTranslation(this.ptr, A3, I3, g3, B2, Q2);
          }
          rbSetRotation(A3, I3, g3, B2, Q2, E2) {
            C.rawrigidbodyset_rbSetRotation(this.ptr, A3, I3, g3, B2, Q2, E2);
          }
          rbSetLinvel(A3, I3, g3) {
            y(I3, z), C.rawrigidbodyset_rbSetLinvel(this.ptr, A3, I3.ptr, g3);
          }
          rbSetAngvel(A3, I3, g3) {
            y(I3, z), C.rawrigidbodyset_rbSetAngvel(this.ptr, A3, I3.ptr, g3);
          }
          rbSetNextKinematicTranslation(A3, I3, g3, B2) {
            C.rawrigidbodyset_rbSetNextKinematicTranslation(this.ptr, A3, I3, g3, B2);
          }
          rbSetNextKinematicRotation(A3, I3, g3, B2, Q2) {
            C.rawrigidbodyset_rbSetNextKinematicRotation(this.ptr, A3, I3, g3, B2, Q2);
          }
          rbLinvel(A3) {
            var I3 = C.rawrigidbodyset_rbLinvel(this.ptr, A3);
            return z.__wrap(I3);
          }
          rbAngvel(A3) {
            var I3 = C.rawrigidbodyset_rbAngvel(this.ptr, A3);
            return z.__wrap(I3);
          }
          rbMass(A3) {
            return C.rawrigidbodyset_rbMass(this.ptr, A3);
          }
          rbWakeUp(A3) {
            C.rawrigidbodyset_rbWakeUp(this.ptr, A3);
          }
          rbIsCcdEnabled(A3) {
            return C.rawrigidbodyset_rbIsCcdEnabled(this.ptr, A3) !== 0;
          }
          rbNumColliders(A3) {
            return C.rawrigidbodyset_rbNumColliders(this.ptr, A3) >>> 0;
          }
          rbCollider(A3, I3) {
            return C.rawrigidbodyset_rbCollider(this.ptr, A3, I3) >>> 0;
          }
          rbBodyStatus(A3) {
            return C.rawrigidbodyset_rbBodyStatus(this.ptr, A3) >>> 0;
          }
          rbIsStatic(A3) {
            return C.rawrigidbodyset_rbIsStatic(this.ptr, A3) !== 0;
          }
          rbIsKinematic(A3) {
            return C.rawrigidbodyset_rbIsKinematic(this.ptr, A3) !== 0;
          }
          rbIsDynamic(A3) {
            return C.rawrigidbodyset_rbIsDynamic(this.ptr, A3) !== 0;
          }
          rbLinearDamping(A3) {
            return C.rawrigidbodyset_rbLinearDamping(this.ptr, A3);
          }
          rbAngularDamping(A3) {
            return C.rawrigidbodyset_rbAngularDamping(this.ptr, A3);
          }
          rbSetLinearDamping(A3, I3) {
            C.rawrigidbodyset_rbSetLinearDamping(this.ptr, A3, I3);
          }
          rbSetAngularDamping(A3, I3) {
            C.rawrigidbodyset_rbSetAngularDamping(this.ptr, A3, I3);
          }
          rbGravityScale(A3) {
            return C.rawrigidbodyset_rbGravityScale(this.ptr, A3);
          }
          rbSetGravityScale(A3, I3, g3) {
            C.rawrigidbodyset_rbSetGravityScale(this.ptr, A3, I3, g3);
          }
          rbApplyForce(A3, I3, g3) {
            y(I3, z), C.rawrigidbodyset_rbApplyForce(this.ptr, A3, I3.ptr, g3);
          }
          rbApplyImpulse(A3, I3, g3) {
            y(I3, z), C.rawrigidbodyset_rbApplyImpulse(this.ptr, A3, I3.ptr, g3);
          }
          rbApplyTorque(A3, I3, g3) {
            y(I3, z), C.rawrigidbodyset_rbApplyTorque(this.ptr, A3, I3.ptr, g3);
          }
          rbApplyTorqueImpulse(A3, I3, g3) {
            y(I3, z), C.rawrigidbodyset_rbApplyTorqueImpulse(this.ptr, A3, I3.ptr, g3);
          }
          rbApplyForceAtPoint(A3, I3, g3, B2) {
            y(I3, z), y(g3, z), C.rawrigidbodyset_rbApplyForceAtPoint(this.ptr, A3, I3.ptr, g3.ptr, B2);
          }
          rbApplyImpulseAtPoint(A3, I3, g3, B2) {
            y(I3, z), y(g3, z), C.rawrigidbodyset_rbApplyImpulseAtPoint(this.ptr, A3, I3.ptr, g3.ptr, B2);
          }
          constructor() {
            var A3 = C.rawrigidbodyset_new();
            return V.__wrap(A3);
          }
          createRigidBody(A3, I3, g3, B2, Q2, E2, i2, D2, o2, S2, G2, w2, k2, U2, M2, J2, F2, K2) {
            return y(A3, z), y(I3, X), y(E2, z), y(i2, z), y(D2, z), y(o2, z), y(S2, X), C.rawrigidbodyset_createRigidBody(this.ptr, A3.ptr, I3.ptr, g3, B2, Q2, E2.ptr, i2.ptr, D2.ptr, o2.ptr, S2.ptr, G2, w2, k2, U2, M2, J2, F2, K2) >>> 0;
          }
          remove(A3, I3, g3) {
            y(I3, t), y(g3, e), C.rawrigidbodyset_remove(this.ptr, A3, I3.ptr, g3.ptr);
          }
          len() {
            return C.rawrigidbodyset_len(this.ptr) >>> 0;
          }
          contains(A3) {
            return C.rawrigidbodyset_contains(this.ptr, A3) !== 0;
          }
          forEachRigidBodyHandle(A3) {
            try {
              C.rawrigidbodyset_forEachRigidBodyHandle(this.ptr, N(A3));
            } finally {
              B[h++] = void 0;
            }
          }
          forEachActiveRigidBodyHandle(A3) {
            try {
              C.rawrigidbodyset_forEachActiveRigidBodyHandle(this.ptr, N(A3));
            } finally {
              B[h++] = void 0;
            }
          }
        }
        class X {
          static __wrap(A3) {
            const I3 = Object.create(X.prototype);
            return I3.ptr = A3, I3;
          }
          __destroy_into_raw() {
            const A3 = this.ptr;
            return this.ptr = 0, A3;
          }
          free() {
            const A3 = this.__destroy_into_raw();
            C.__wbg_rawrotation_free(A3);
          }
          constructor(A3, I3, g3, B2) {
            var Q2 = C.rawrotation_new(A3, I3, g3, B2);
            return X.__wrap(Q2);
          }
          static identity() {
            var A3 = C.rawrotation_identity();
            return X.__wrap(A3);
          }
          get x() {
            return C.rawintegrationparameters_dt(this.ptr);
          }
          get y() {
            return C.rawrotation_y(this.ptr);
          }
          get z() {
            return C.rawintegrationparameters_erp(this.ptr);
          }
          get w() {
            return C.rawintegrationparameters_jointErp(this.ptr);
          }
        }
        class P {
          static __wrap(A3) {
            const I3 = Object.create(P.prototype);
            return I3.ptr = A3, I3;
          }
          __destroy_into_raw() {
            const A3 = this.ptr;
            return this.ptr = 0, A3;
          }
          free() {
            const A3 = this.__destroy_into_raw();
            C.__wbg_rawserializationpipeline_free(A3);
          }
          constructor() {
            var A3 = C.rawserializationpipeline_new();
            return P.__wrap(A3);
          }
          serializeAll(A3, I3, g3, B2, Q2, E2, i2) {
            return y(A3, z), y(I3, Z), y(g3, p), y(B2, r), y(Q2, V), y(E2, t), y(i2, e), D(C.rawserializationpipeline_serializeAll(this.ptr, A3.ptr, I3.ptr, g3.ptr, B2.ptr, Q2.ptr, E2.ptr, i2.ptr));
          }
          deserializeAll(A3) {
            var I3 = C.rawserializationpipeline_deserializeAll(this.ptr, E(A3));
            return I3 === 0 ? void 0 : O.__wrap(I3);
          }
        }
        class m {
          static __wrap(A3) {
            const I3 = Object.create(m.prototype);
            return I3.ptr = A3, I3;
          }
          __destroy_into_raw() {
            const A3 = this.ptr;
            return this.ptr = 0, A3;
          }
          free() {
            const A3 = this.__destroy_into_raw();
            C.__wbg_rawshape_free(A3);
          }
          static cuboid(A3, I3, g3) {
            var B2 = C.rawshape_cuboid(A3, I3, g3);
            return m.__wrap(B2);
          }
          static roundCuboid(A3, I3, g3, B2) {
            var Q2 = C.rawshape_roundCuboid(A3, I3, g3, B2);
            return m.__wrap(Q2);
          }
          static ball(A3) {
            var I3 = C.rawshape_ball(A3);
            return m.__wrap(I3);
          }
          static capsule(A3, I3) {
            var g3 = C.rawshape_capsule(A3, I3);
            return m.__wrap(g3);
          }
          static cylinder(A3, I3) {
            var g3 = C.rawshape_cylinder(A3, I3);
            return m.__wrap(g3);
          }
          static roundCylinder(A3, I3, g3) {
            var B2 = C.rawshape_roundCylinder(A3, I3, g3);
            return m.__wrap(B2);
          }
          static cone(A3, I3) {
            var g3 = C.rawshape_cone(A3, I3);
            return m.__wrap(g3);
          }
          static roundCone(A3, I3, g3) {
            var B2 = C.rawshape_roundCone(A3, I3, g3);
            return m.__wrap(B2);
          }
          static polyline(A3, I3) {
            var g3 = L(A3, C.__wbindgen_malloc), B2 = U, Q2 = l(I3, C.__wbindgen_malloc), E2 = U, i2 = C.rawshape_polyline(g3, B2, Q2, E2);
            return m.__wrap(i2);
          }
          static trimesh(A3, I3) {
            var g3 = L(A3, C.__wbindgen_malloc), B2 = U, Q2 = l(I3, C.__wbindgen_malloc), E2 = U, i2 = C.rawshape_trimesh(g3, B2, Q2, E2);
            return m.__wrap(i2);
          }
          static heightfield(A3, I3, g3, B2) {
            var Q2 = L(g3, C.__wbindgen_malloc), E2 = U;
            y(B2, z);
            var i2 = C.rawshape_heightfield(A3, I3, Q2, E2, B2.ptr);
            return m.__wrap(i2);
          }
          static segment(A3, I3) {
            y(A3, z), y(I3, z);
            var g3 = C.rawshape_segment(A3.ptr, I3.ptr);
            return m.__wrap(g3);
          }
          static triangle(A3, I3, g3) {
            y(A3, z), y(I3, z), y(g3, z);
            var B2 = C.rawshape_triangle(A3.ptr, I3.ptr, g3.ptr);
            return m.__wrap(B2);
          }
          static roundTriangle(A3, I3, g3, B2) {
            y(A3, z), y(I3, z), y(g3, z);
            var Q2 = C.rawshape_roundTriangle(A3.ptr, I3.ptr, g3.ptr, B2);
            return m.__wrap(Q2);
          }
          static convexHull(A3) {
            var I3 = L(A3, C.__wbindgen_malloc), g3 = U, B2 = C.rawshape_convexHull(I3, g3);
            return B2 === 0 ? void 0 : m.__wrap(B2);
          }
          static roundConvexHull(A3, I3) {
            var g3 = L(A3, C.__wbindgen_malloc), B2 = U, Q2 = C.rawshape_roundConvexHull(g3, B2, I3);
            return Q2 === 0 ? void 0 : m.__wrap(Q2);
          }
          static convexMesh(A3, I3) {
            var g3 = L(A3, C.__wbindgen_malloc), B2 = U, Q2 = l(I3, C.__wbindgen_malloc), E2 = U, i2 = C.rawshape_convexMesh(g3, B2, Q2, E2);
            return i2 === 0 ? void 0 : m.__wrap(i2);
          }
          static roundConvexMesh(A3, I3, g3) {
            var B2 = L(A3, C.__wbindgen_malloc), Q2 = U, E2 = l(I3, C.__wbindgen_malloc), i2 = U, D2 = C.rawshape_roundConvexMesh(B2, Q2, E2, i2, g3);
            return D2 === 0 ? void 0 : m.__wrap(D2);
          }
        }
        class u {
          static __wrap(A3) {
            const I3 = Object.create(u.prototype);
            return I3.ptr = A3, I3;
          }
          __destroy_into_raw() {
            const A3 = this.ptr;
            return this.ptr = 0, A3;
          }
          free() {
            const A3 = this.__destroy_into_raw();
            C.__wbg_rawshapecollidertoi_free(A3);
          }
          colliderHandle() {
            return C.rawpointcolliderprojection_colliderHandle(this.ptr) >>> 0;
          }
          toi() {
            return C.rawraycolliderintersection_toi(this.ptr);
          }
          witness1() {
            var A3 = C.rawraycolliderintersection_normal(this.ptr);
            return z.__wrap(A3);
          }
          witness2() {
            var A3 = C.rawraycolliderintersection_normal(this.ptr);
            return z.__wrap(A3);
          }
          normal1() {
            var A3 = C.rawshapecollidertoi_normal1(this.ptr);
            return z.__wrap(A3);
          }
          normal2() {
            var A3 = C.rawshapecollidertoi_normal1(this.ptr);
            return z.__wrap(A3);
          }
        }
        class z {
          static __wrap(A3) {
            const I3 = Object.create(z.prototype);
            return I3.ptr = A3, I3;
          }
          __destroy_into_raw() {
            const A3 = this.ptr;
            return this.ptr = 0, A3;
          }
          free() {
            const A3 = this.__destroy_into_raw();
            C.__wbg_rawvector_free(A3);
          }
          static zero() {
            var A3 = C.rawvector_zero();
            return z.__wrap(A3);
          }
          constructor(A3, I3, g3) {
            var B2 = C.rawvector_new(A3, I3, g3);
            return z.__wrap(B2);
          }
          get x() {
            return C.rawintegrationparameters_dt(this.ptr);
          }
          set x(A3) {
            C.rawintegrationparameters_set_dt(this.ptr, A3);
          }
          get y() {
            return C.rawrotation_y(this.ptr);
          }
          set y(A3) {
            C.rawvector_set_y(this.ptr, A3);
          }
          get z() {
            return C.rawintegrationparameters_erp(this.ptr);
          }
          set z(A3) {
            C.rawintegrationparameters_set_erp(this.ptr, A3);
          }
          xyz() {
            var A3 = C.rawvector_xyz(this.ptr);
            return z.__wrap(A3);
          }
          yxz() {
            var A3 = C.rawvector_yxz(this.ptr);
            return z.__wrap(A3);
          }
          zxy() {
            var A3 = C.rawvector_zxy(this.ptr);
            return z.__wrap(A3);
          }
          xzy() {
            var A3 = C.rawvector_xzy(this.ptr);
            return z.__wrap(A3);
          }
          yzx() {
            var A3 = C.rawvector_yzx(this.ptr);
            return z.__wrap(A3);
          }
          zyx() {
            var A3 = C.rawvector_zyx(this.ptr);
            return z.__wrap(A3);
          }
        }
        const v = async function A3(I3) {
          I3 === void 0 && (I3 = new URL(g2(271), g2.b));
          const B2 = {wbg: {}};
          B2.wbg.__wbindgen_number_new = function(A4) {
            return E(A4);
          }, B2.wbg.__wbindgen_object_drop_ref = function(A4) {
            D(A4);
          }, B2.wbg.__wbg_rawraycolliderintersection_new = function(A4) {
            return E(j.__wrap(A4));
          }, B2.wbg.__wbindgen_string_new = function(A4, I4) {
            return E(w(A4, I4));
          }, B2.wbg.__wbg_now_4abbca4ef2aba8d6 = function(A4) {
            return i(A4).now();
          }, B2.wbg.__wbg_get_0c6963cbab34fbb6 = H(function(A4, I4) {
            return E(Reflect.get(i(A4), i(I4)));
          }), B2.wbg.__wbg_call_cb478d88f3068c91 = H(function(A4, I4) {
            return E(i(A4).call(i(I4)));
          }), B2.wbg.__wbindgen_object_clone_ref = function(A4) {
            return E(i(A4));
          }, B2.wbg.__wbg_newnoargs_3efc7bfa69a681f9 = function(A4, I4) {
            return E(new Function(w(A4, I4)));
          }, B2.wbg.__wbg_call_f5e0576f61ee7461 = H(function(A4, I4, g3) {
            return E(i(A4).call(i(I4), i(g3)));
          }), B2.wbg.__wbg_call_7dd8829654c7999c = H(function(A4, I4, g3, C2, B3) {
            return E(i(A4).call(i(I4), i(g3), i(C2), i(B3)));
          }), B2.wbg.__wbg_bind_b2e4bc5c326869a0 = function(A4, I4, g3, C2) {
            return E(i(A4).bind(i(I4), i(g3), i(C2)));
          }, B2.wbg.__wbg_buffer_ebc6c8e75510eae3 = function(A4) {
            return E(i(A4).buffer);
          }, B2.wbg.__wbg_self_05c54dcacb623b9a = H(function() {
            return E(self.self);
          }), B2.wbg.__wbg_window_9777ce446d12989f = H(function() {
            return E(window.window);
          }), B2.wbg.__wbg_globalThis_f0ca0bbb0149cf3d = H(function() {
            return E(globalThis.globalThis);
          }), B2.wbg.__wbg_global_c3c8325ae8c7f1a9 = H(function() {
            return E(g2.g.global);
          }), B2.wbg.__wbindgen_is_undefined = function(A4) {
            return i(A4) === void 0;
          }, B2.wbg.__wbg_newwithbyteoffsetandlength_ca3d3d8811ecb569 = function(A4, I4, g3) {
            return E(new Uint8Array(i(A4), I4 >>> 0, g3 >>> 0));
          }, B2.wbg.__wbg_length_317f0dd77f7a6673 = function(A4) {
            return i(A4).length;
          }, B2.wbg.__wbg_new_135e963dedf67b22 = function(A4) {
            return E(new Uint8Array(i(A4)));
          }, B2.wbg.__wbg_set_4a5072a31008e0cb = function(A4, I4, g3) {
            i(A4).set(i(I4), g3 >>> 0);
          }, B2.wbg.__wbindgen_boolean_get = function(A4) {
            const I4 = i(A4);
            return typeof I4 == "boolean" ? I4 ? 1 : 0 : 2;
          }, B2.wbg.__wbindgen_debug_string = function(A4, I4) {
            var g3 = function(A5, I5, g4) {
              if (g4 === void 0) {
                const g5 = M.encode(A5), C3 = I5(g5.length);
                return G().subarray(C3, C3 + g5.length).set(g5), U = g5.length, C3;
              }
              let C2 = A5.length, B4 = I5(C2);
              const Q3 = G();
              let E2 = 0;
              for (; E2 < C2; E2++) {
                const I6 = A5.charCodeAt(E2);
                if (I6 > 127)
                  break;
                Q3[B4 + E2] = I6;
              }
              if (E2 !== C2) {
                E2 !== 0 && (A5 = A5.slice(E2)), B4 = g4(B4, C2, C2 = E2 + 3 * A5.length);
                const I6 = G().subarray(B4 + E2, B4 + C2);
                E2 += J(A5, I6).written;
              }
              return U = E2, B4;
            }(k(i(I4)), C.__wbindgen_malloc, C.__wbindgen_realloc), B3 = U;
            K()[A4 / 4 + 1] = B3, K()[A4 / 4 + 0] = g3;
          }, B2.wbg.__wbindgen_throw = function(A4, I4) {
            throw new Error(w(A4, I4));
          }, B2.wbg.__wbindgen_memory = function() {
            return E(C.memory);
          }, (typeof I3 == "string" || typeof Request == "function" && I3 instanceof Request || typeof URL == "function" && I3 instanceof URL) && (I3 = fetch(I3));
          const {instance: Q2, module: o2} = await async function(A4, I4) {
            if (typeof Response == "function" && A4 instanceof Response) {
              if (typeof WebAssembly.instantiateStreaming == "function")
                try {
                  return await WebAssembly.instantiateStreaming(A4, I4);
                } catch (I5) {
                  if (A4.headers.get("Content-Type") == "application/wasm")
                    throw I5;
                  console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", I5);
                }
              const g3 = await A4.arrayBuffer();
              return await WebAssembly.instantiate(g3, I4);
            }
            {
              const g3 = await WebAssembly.instantiate(A4, I4);
              return g3 instanceof WebAssembly.Instance ? {instance: g3, module: A4} : g3;
            }
          }(await I3, B2);
          return C = Q2.exports, A3.__wbindgen_wasm_module = o2, C;
        };
        var _, $ = function(A3, I3, g3) {
          this.x = A3, this.y = I3, this.z = g3;
        }, AA = function() {
          function A3() {
          }
          return A3.new = function(A4, I3, g3) {
            return new $(A4, I3, g3);
          }, A3.intoRaw = function(A4) {
            return new z(A4.x, A4.y, A4.z);
          }, A3.zeros = function() {
            return A3.new(0, 0, 0);
          }, A3.fromRaw = function(I3) {
            if (!I3)
              return null;
            var g3 = A3.new(I3.x, I3.y, I3.z);
            return I3.free(), g3;
          }, A3;
        }(), IA = function(A3, I3, g3, C2) {
          this.x = A3, this.y = I3, this.z = g3, this.w = C2;
        }, gA = function() {
          function A3() {
          }
          return A3.identity = function() {
            return new IA(0, 0, 0, 1);
          }, A3.fromRaw = function(A4) {
            if (!A4)
              return null;
            var I3 = new IA(A4.x, A4.y, A4.z, A4.w);
            return A4.free(), I3;
          }, A3.intoRaw = function(A4) {
            return new X(A4.x, A4.y, A4.z, A4.w);
          }, A3;
        }();
        !function(A3) {
          A3[A3.Dynamic = 0] = "Dynamic", A3[A3.Static = 1] = "Static", A3[A3.Kinematic = 2] = "Kinematic";
        }(_ || (_ = {}));
        var CA, BA = function() {
          function A3(A4, I3) {
            this.rawSet = A4, this.handle = I3;
          }
          return A3.prototype.isValid = function() {
            return this.rawSet.contains(this.handle);
          }, A3.prototype.translation = function() {
            var A4 = this.rawSet.rbTranslation(this.handle);
            return AA.fromRaw(A4);
          }, A3.prototype.rotation = function() {
            var A4 = this.rawSet.rbRotation(this.handle);
            return gA.fromRaw(A4);
          }, A3.prototype.nextTranslation = function() {
            var A4 = this.rawSet.rbNextTranslation(this.handle);
            return AA.fromRaw(A4);
          }, A3.prototype.nextRotation = function() {
            var A4 = this.rawSet.rbNextRotation(this.handle);
            return gA.fromRaw(A4);
          }, A3.prototype.setTranslation = function(A4, I3) {
            this.rawSet.rbSetTranslation(this.handle, A4.x, A4.y, A4.z, I3);
          }, A3.prototype.setLinvel = function(A4, I3) {
            var g3 = AA.intoRaw(A4);
            this.rawSet.rbSetLinvel(this.handle, g3, I3), g3.free();
          }, A3.prototype.gravityScale = function() {
            return this.rawSet.rbGravityScale(this.handle);
          }, A3.prototype.setGravityScale = function(A4, I3) {
            this.rawSet.rbSetGravityScale(this.handle, A4, I3);
          }, A3.prototype.setRotation = function(A4, I3) {
            this.rawSet.rbSetRotation(this.handle, A4.x, A4.y, A4.z, A4.w, I3);
          }, A3.prototype.setAngvel = function(A4, I3) {
            var g3 = AA.intoRaw(A4);
            this.rawSet.rbSetAngvel(this.handle, g3, I3), g3.free();
          }, A3.prototype.setNextKinematicTranslation = function(A4) {
            this.rawSet.rbSetNextKinematicTranslation(this.handle, A4.x, A4.y, A4.z);
          }, A3.prototype.setNextKinematicRotation = function(A4) {
            this.rawSet.rbSetNextKinematicRotation(this.handle, A4.x, A4.y, A4.z, A4.w);
          }, A3.prototype.linvel = function() {
            return AA.fromRaw(this.rawSet.rbLinvel(this.handle));
          }, A3.prototype.angvel = function() {
            return AA.fromRaw(this.rawSet.rbAngvel(this.handle));
          }, A3.prototype.mass = function() {
            return this.rawSet.rbMass(this.handle);
          }, A3.prototype.sleep = function() {
            this.rawSet.rbSleep(this.handle);
          }, A3.prototype.wakeUp = function() {
            this.rawSet.rbWakeUp(this.handle);
          }, A3.prototype.isCcdEnabled = function() {
            this.rawSet.rbIsCcdEnabled(this.handle);
          }, A3.prototype.numColliders = function() {
            return this.rawSet.rbNumColliders(this.handle);
          }, A3.prototype.collider = function(A4) {
            return this.rawSet.rbCollider(this.handle, A4);
          }, A3.prototype.bodyStatus = function() {
            return this.rawSet.rbBodyStatus(this.handle);
          }, A3.prototype.isSleeping = function() {
            return this.rawSet.rbIsSleeping(this.handle);
          }, A3.prototype.isMoving = function() {
            return this.rawSet.rbIsMoving(this.handle);
          }, A3.prototype.isStatic = function() {
            return this.rawSet.rbIsStatic(this.handle);
          }, A3.prototype.isKinematic = function() {
            return this.rawSet.rbIsKinematic(this.handle);
          }, A3.prototype.isDynamic = function() {
            return this.rawSet.rbIsDynamic(this.handle);
          }, A3.prototype.linearDamping = function() {
            return this.rawSet.rbLinearDamping(this.handle);
          }, A3.prototype.angularDamping = function() {
            return this.rawSet.rbAngularDamping(this.handle);
          }, A3.prototype.setLinearDamping = function(A4) {
            this.rawSet.rbSetLinearDamping(this.handle, A4);
          }, A3.prototype.setAngularDamping = function(A4) {
            this.rawSet.rbSetAngularDamping(this.handle, A4);
          }, A3.prototype.applyForce = function(A4, I3) {
            var g3 = AA.intoRaw(A4);
            this.rawSet.rbApplyForce(this.handle, g3, I3), g3.free();
          }, A3.prototype.applyImpulse = function(A4, I3) {
            var g3 = AA.intoRaw(A4);
            this.rawSet.rbApplyImpulse(this.handle, g3, I3), g3.free();
          }, A3.prototype.applyTorque = function(A4, I3) {
            var g3 = AA.intoRaw(A4);
            this.rawSet.rbApplyTorque(this.handle, g3, I3), g3.free();
          }, A3.prototype.applyTorqueImpulse = function(A4, I3) {
            var g3 = AA.intoRaw(A4);
            this.rawSet.rbApplyTorqueImpulse(this.handle, g3, I3), g3.free();
          }, A3.prototype.applyForceAtPoint = function(A4, I3, g3) {
            var C2 = AA.intoRaw(A4), B2 = AA.intoRaw(I3);
            this.rawSet.rbApplyForceAtPoint(this.handle, C2, B2, g3), C2.free(), B2.free();
          }, A3.prototype.applyImpulseAtPoint = function(A4, I3, g3) {
            var C2 = AA.intoRaw(A4), B2 = AA.intoRaw(I3);
            this.rawSet.rbApplyImpulseAtPoint(this.handle, C2, B2, g3), C2.free(), B2.free();
          }, A3;
        }(), QA = function() {
          function A3(A4) {
            this.status = A4, this.translation = AA.zeros(), this.rotation = gA.identity(), this.gravityScale = 1, this.linvel = AA.zeros(), this.mass = 0, this.translationsEnabled = true, this.centerOfMass = AA.zeros(), this.angvel = AA.zeros(), this.principalAngularInertia = AA.zeros(), this.angularInertiaLocalFrame = gA.identity(), this.rotationsEnabledX = true, this.rotationsEnabledY = true, this.rotationsEnabledZ = true, this.linearDamping = 0, this.angularDamping = 0, this.canSleep = true, this.ccdEnabled = false;
          }
          return A3.newDynamic = function() {
            return new A3(_.Dynamic);
          }, A3.newKinematic = function() {
            return new A3(_.Kinematic);
          }, A3.newStatic = function() {
            return new A3(_.Static);
          }, A3.prototype.setTranslation = function(A4, I3, g3) {
            if (typeof A4 != "number" || typeof I3 != "number" || typeof g3 != "number")
              throw TypeError("The translation components must be numbers.");
            return this.translation = {x: A4, y: I3, z: g3}, this;
          }, A3.prototype.setRotation = function(A4) {
            return this.rotation = A4, this;
          }, A3.prototype.setGravityScale = function(A4) {
            return this.gravityScale = A4, this;
          }, A3.prototype.setMass = function(A4) {
            return this.mass = A4, this;
          }, A3.prototype.lockTranslations = function() {
            return this.translationsEnabled = false, this;
          }, A3.prototype.setLinvel = function(A4, I3, g3) {
            if (typeof A4 != "number" || typeof I3 != "number" || typeof g3 != "number")
              throw TypeError("The linvel components must be numbers.");
            return this.linvel = {x: A4, y: I3, z: g3}, this;
          }, A3.prototype.setAngvel = function(A4) {
            return this.angvel = A4, this;
          }, A3.prototype.setMassProperties = function(A4, I3, g3, C2) {
            return this.mass = A4, this.centerOfMass = I3, this.principalAngularInertia = g3, this.angularInertiaLocalFrame = C2, this;
          }, A3.prototype.setPrincipalAngularInertia = function(A4) {
            return this.principalAngularInertia = A4, this;
          }, A3.prototype.restrictRotations = function(A4, I3, g3) {
            return this.rotationsEnabledX = A4, this.rotationsEnabledY = I3, this.rotationsEnabledZ = g3, this;
          }, A3.prototype.lockRotations = function() {
            return this.restrictRotations(false, false, false);
          }, A3.prototype.setLinearDamping = function(A4) {
            return this.linearDamping = A4, this;
          }, A3.prototype.setAngularDamping = function(A4) {
            return this.angularDamping = A4, this;
          }, A3.prototype.setCanSleep = function(A4) {
            return this.canSleep = A4, this;
          }, A3.prototype.setCcdEnabled = function(A4) {
            return this.ccdEnabled = A4, this;
          }, A3;
        }(), EA = function() {
          function A3(A4) {
            this.raw = A4 || new V();
          }
          return A3.prototype.free = function() {
            this.raw.free(), this.raw = void 0;
          }, A3.prototype.createRigidBody = function(A4) {
            var I3 = AA.intoRaw(A4.translation), g3 = gA.intoRaw(A4.rotation), C2 = AA.intoRaw(A4.linvel), B2 = AA.intoRaw(A4.centerOfMass), Q2 = AA.intoRaw(A4.angvel), E2 = AA.intoRaw(A4.principalAngularInertia), i2 = gA.intoRaw(A4.angularInertiaLocalFrame), D2 = this.raw.createRigidBody(I3, g3, A4.gravityScale, A4.mass, A4.translationsEnabled, B2, C2, Q2, E2, i2, A4.rotationsEnabledX, A4.rotationsEnabledY, A4.rotationsEnabledZ, A4.linearDamping, A4.angularDamping, A4.status, A4.canSleep, A4.ccdEnabled);
            return I3.free(), g3.free(), C2.free(), B2.free(), Q2.free(), E2.free(), i2.free(), D2;
          }, A3.prototype.remove = function(A4, I3, g3) {
            this.raw.remove(A4, I3.raw, g3.raw);
          }, A3.prototype.len = function() {
            return this.raw.len();
          }, A3.prototype.contains = function(A4) {
            return this.raw.contains(A4);
          }, A3.prototype.get = function(A4) {
            return this.raw.contains(A4) ? new BA(this.raw, A4) : null;
          }, A3.prototype.forEachRigidBody = function(A4) {
            var I3 = this;
            this.forEachRigidBodyHandle(function(g3) {
              A4(new BA(I3.raw, g3));
            });
          }, A3.prototype.forEachRigidBodyHandle = function(A4) {
            this.raw.forEachRigidBodyHandle(A4);
          }, A3.prototype.forEachActiveRigidBody = function(A4) {
            var I3 = this;
            this.forEachActiveRigidBodyHandle(function(g3) {
              A4(new BA(I3.raw, g3));
            });
          }, A3.prototype.forEachActiveRigidBodyHandle = function(A4) {
            this.raw.forEachActiveRigidBodyHandle(A4);
          }, A3;
        }(), iA = function() {
          function A3(A4) {
            this.raw = A4 || new Z();
          }
          return A3.prototype.free = function() {
            this.raw.free(), this.raw = void 0;
          }, Object.defineProperty(A3.prototype, "dt", {get: function() {
            return this.raw.dt;
          }, set: function(A4) {
            this.raw.dt = A4;
          }, enumerable: false, configurable: true}), Object.defineProperty(A3.prototype, "erp", {get: function() {
            return this.raw.erp;
          }, set: function(A4) {
            this.raw.erp = A4;
          }, enumerable: false, configurable: true}), Object.defineProperty(A3.prototype, "jointErp", {get: function() {
            return this.raw.jointErp;
          }, set: function(A4) {
            this.raw.jointErp = A4;
          }, enumerable: false, configurable: true}), Object.defineProperty(A3.prototype, "warmstartCoeff", {get: function() {
            return this.raw.warmstartCoeff;
          }, set: function(A4) {
            this.raw.warmstartCoeff = A4;
          }, enumerable: false, configurable: true}), Object.defineProperty(A3.prototype, "allowedLinearError", {get: function() {
            return this.raw.allowedLinearError;
          }, set: function(A4) {
            this.raw.allowedLinearError = A4;
          }, enumerable: false, configurable: true}), Object.defineProperty(A3.prototype, "predictionDistance", {get: function() {
            return this.raw.predictionDistance;
          }, set: function(A4) {
            this.raw.predictionDistance = A4;
          }, enumerable: false, configurable: true}), Object.defineProperty(A3.prototype, "allowedAngularError", {get: function() {
            return this.raw.allowedAngularError;
          }, set: function(A4) {
            this.raw.allowedAngularError = A4;
          }, enumerable: false, configurable: true}), Object.defineProperty(A3.prototype, "maxLinearCorrection", {get: function() {
            return this.raw.maxLinearCorrection;
          }, set: function(A4) {
            this.raw.maxLinearCorrection = A4;
          }, enumerable: false, configurable: true}), Object.defineProperty(A3.prototype, "maxAngularCorrection", {get: function() {
            return this.raw.maxAngularCorrection;
          }, set: function(A4) {
            this.raw.maxAngularCorrection = A4;
          }, enumerable: false, configurable: true}), Object.defineProperty(A3.prototype, "maxVelocityIterations", {get: function() {
            return this.raw.maxVelocityIterations;
          }, set: function(A4) {
            this.raw.maxVelocityIterations = A4;
          }, enumerable: false, configurable: true}), Object.defineProperty(A3.prototype, "maxPositionIterations", {get: function() {
            return this.raw.maxPositionIterations;
          }, set: function(A4) {
            this.raw.maxPositionIterations = A4;
          }, enumerable: false, configurable: true}), Object.defineProperty(A3.prototype, "minIslandSize", {get: function() {
            return this.raw.minIslandSize;
          }, set: function(A4) {
            this.raw.minIslandSize = A4;
          }, enumerable: false, configurable: true}), Object.defineProperty(A3.prototype, "maxCcdSubsteps", {get: function() {
            return this.raw.maxCcdSubsteps;
          }, set: function(A4) {
            this.raw.maxCcdSubsteps = A4;
          }, enumerable: false, configurable: true}), A3;
        }();
        !function(A3) {
          A3[A3.Ball = 0] = "Ball", A3[A3.Fixed = 1] = "Fixed", A3[A3.Prismatic = 2] = "Prismatic", A3[A3.Revolute = 3] = "Revolute";
        }(CA || (CA = {}));
        var DA, oA = function() {
          function A3(A4, I3) {
            this.rawSet = A4, this.handle = I3;
          }
          return A3.prototype.isValid = function() {
            return this.rawSet.contains(this.handle);
          }, A3.prototype.bodyHandle1 = function() {
            return this.rawSet.jointBodyHandle1(this.handle);
          }, A3.prototype.bodyHandle2 = function() {
            return this.rawSet.jointBodyHandle2(this.handle);
          }, A3.prototype.type = function() {
            return this.rawSet.jointType(this.handle);
          }, A3.prototype.frameX1 = function() {
            return gA.fromRaw(this.rawSet.jointFrameX1(this.handle));
          }, A3.prototype.frameX2 = function() {
            return gA.fromRaw(this.rawSet.jointFrameX2(this.handle));
          }, A3.prototype.anchor1 = function() {
            return AA.fromRaw(this.rawSet.jointAnchor1(this.handle));
          }, A3.prototype.anchor2 = function() {
            return AA.fromRaw(this.rawSet.jointAnchor2(this.handle));
          }, A3.prototype.axis1 = function() {
            return AA.fromRaw(this.rawSet.jointAxis1(this.handle));
          }, A3.prototype.axis2 = function() {
            return AA.fromRaw(this.rawSet.jointAxis2(this.handle));
          }, A3.prototype.limitsEnabled = function() {
            return this.rawSet.jointLimitsEnabled(this.handle);
          }, A3.prototype.limitsMin = function() {
            return this.rawSet.jointLimitsMin(this.handle);
          }, A3.prototype.limitsMax = function() {
            return this.rawSet.jointLimitsMax(this.handle);
          }, A3;
        }(), SA = function() {
          function A3() {
          }
          return A3.ball = function(I3, g3) {
            var C2 = new A3();
            return C2.anchor1 = I3, C2.anchor2 = g3, C2.jointType = CA.Ball, C2;
          }, A3.fixed = function(I3, g3, C2, B2) {
            var Q2 = new A3();
            return Q2.anchor1 = I3, Q2.anchor2 = C2, Q2.frame1 = g3, Q2.frame2 = B2, Q2.jointType = CA.Fixed, Q2;
          }, A3.prismatic = function(I3, g3, C2, B2, Q2, E2) {
            var i2 = new A3();
            return i2.anchor1 = I3, i2.axis1 = g3, i2.tangent1 = C2, i2.anchor2 = B2, i2.axis2 = Q2, i2.tangent2 = E2, i2.jointType = CA.Prismatic, i2;
          }, A3.revolute = function(I3, g3, C2, B2) {
            var Q2 = new A3();
            return Q2.anchor1 = I3, Q2.anchor2 = C2, Q2.axis1 = g3, Q2.axis2 = B2, Q2.jointType = CA.Revolute, Q2;
          }, A3.prototype.intoRaw = function() {
            var A4, I3, g3, C2 = AA.intoRaw(this.anchor1), B2 = AA.intoRaw(this.anchor2), Q2 = false, E2 = 0, i2 = 0;
            switch (this.jointType) {
              case CA.Ball:
                g3 = n.ball(C2, B2);
                break;
              case CA.Fixed:
                var D2 = gA.intoRaw(this.frame1), o2 = gA.intoRaw(this.frame2);
                g3 = n.fixed(C2, D2, B2, o2), D2.free(), o2.free();
                break;
              case CA.Prismatic:
                A4 = AA.intoRaw(this.axis1), I3 = AA.intoRaw(this.axis2), this.limitsEnabled && (Q2 = true, E2 = this.limits[0], i2 = this.limits[1]);
                var S2 = AA.intoRaw(this.tangent1), G2 = AA.intoRaw(this.tangent2);
                g3 = n.prismatic(C2, A4, S2, B2, I3, G2, Q2, E2, i2), S2.free(), G2.free(), A4.free(), I3.free();
                break;
              case CA.Revolute:
                A4 = AA.intoRaw(this.axis1), I3 = AA.intoRaw(this.axis2), g3 = n.revolute(C2, A4, B2, I3), A4.free(), I3.free();
            }
            return C2.free(), B2.free(), g3;
          }, A3;
        }(), GA = function() {
          function A3(A4) {
            this.raw = A4 || new e();
          }
          return A3.prototype.free = function() {
            this.raw.free(), this.raw = void 0;
          }, A3.prototype.createJoint = function(A4, I3, g3, C2) {
            var B2 = I3.intoRaw(), Q2 = this.raw.createJoint(A4.raw, B2, g3, C2);
            return B2.free(), Q2;
          }, A3.prototype.remove = function(A4, I3, g3) {
            this.raw.remove(A4, I3.raw, g3);
          }, A3.prototype.len = function() {
            return this.raw.len();
          }, A3.prototype.contains = function(A4) {
            return this.raw.contains(A4);
          }, A3.prototype.get = function(A4) {
            return this.raw.contains(A4) ? new oA(this.raw, A4) : null;
          }, A3.prototype.forEachJoint = function(A4) {
            var I3 = this;
            this.raw.forEachJointHandle(function(g3) {
              A4(new oA(I3.raw, g3));
            });
          }, A3.prototype.forEachJointHandle = function(A4) {
            this.raw.forEachJointHandle(A4);
          }, A3;
        }();
        !function(A3) {
          A3[A3.Average = 0] = "Average", A3[A3.Min = 1] = "Min", A3[A3.Multiply = 2] = "Multiply", A3[A3.Max = 3] = "Max";
        }(DA || (DA = {}));
        var wA, kA = function() {
          function A3(A4) {
            this.raw = A4 || new T();
          }
          return A3.prototype.free = function() {
            this.raw.free(), this.raw = void 0;
          }, A3;
        }(), UA = function() {
          function A3(A4) {
            this.raw = A4 || new p();
          }
          return A3.prototype.free = function() {
            this.raw.free(), this.raw = void 0;
          }, A3;
        }(), MA = function() {
          function A3(A4) {
            this.raw = A4 || new r();
          }
          return A3.prototype.free = function() {
            this.raw.free(), this.raw = void 0;
          }, A3;
        }();
        !function(A3) {
          A3[A3.Ball = 0] = "Ball", A3[A3.Cuboid = 1] = "Cuboid", A3[A3.Capsule = 2] = "Capsule", A3[A3.Segment = 3] = "Segment", A3[A3.Polyline = 4] = "Polyline", A3[A3.Triangle = 5] = "Triangle", A3[A3.TriMesh = 6] = "TriMesh", A3[A3.HeightField = 7] = "HeightField", A3[A3.ConvexPolyhedron = 9] = "ConvexPolyhedron", A3[A3.Cylinder = 10] = "Cylinder", A3[A3.Cone = 11] = "Cone", A3[A3.RoundCuboid = 12] = "RoundCuboid", A3[A3.RoundTriangle = 13] = "RoundTriangle", A3[A3.RoundCylinder = 14] = "RoundCylinder", A3[A3.RoundCone = 15] = "RoundCone", A3[A3.RoundConvexPolyhedron = 16] = "RoundConvexPolyhedron";
        }(wA || (wA = {}));
        var JA = function() {
          function A3(A4) {
            this.radius = A4;
          }
          return A3.prototype.intoRaw = function() {
            return m.ball(this.radius);
          }, A3;
        }(), FA = function() {
          function A3(A4, I3, g3) {
            this.halfExtents = AA.new(A4, I3, g3);
          }
          return A3.prototype.intoRaw = function() {
            return m.cuboid(this.halfExtents.x, this.halfExtents.y, this.halfExtents.z);
          }, A3;
        }(), KA = function() {
          function A3(A4, I3, g3, C2) {
            this.halfExtents = AA.new(A4, I3, g3), this.borderRadius = C2;
          }
          return A3.prototype.intoRaw = function() {
            return m.roundCuboid(this.halfExtents.x, this.halfExtents.y, this.halfExtents.z, this.borderRadius);
          }, A3;
        }(), yA = function() {
          function A3(A4, I3) {
            this.halfHeight = A4, this.radius = I3;
          }
          return A3.prototype.intoRaw = function() {
            return m.capsule(this.halfHeight, this.radius);
          }, A3;
        }(), hA = function() {
          function A3(A4, I3) {
            this.a = A4, this.b = I3;
          }
          return A3.prototype.intoRaw = function() {
            var A4 = AA.intoRaw(this.a), I3 = AA.intoRaw(this.b), g3 = m.segment(A4, I3);
            return A4.free(), I3.free(), g3;
          }, A3;
        }(), NA = function() {
          function A3(A4, I3, g3) {
            this.a = A4, this.b = I3, this.c = g3;
          }
          return A3.prototype.intoRaw = function() {
            var A4 = AA.intoRaw(this.a), I3 = AA.intoRaw(this.b), g3 = AA.intoRaw(this.c), C2 = m.triangle(A4, I3, g3);
            return A4.free(), I3.free(), g3.free(), C2;
          }, A3;
        }(), aA = function() {
          function A3(A4, I3, g3, C2) {
            this.a = A4, this.b = I3, this.c = g3, this.borderRadius = C2;
          }
          return A3.prototype.intoRaw = function() {
            var A4 = AA.intoRaw(this.a), I3 = AA.intoRaw(this.b), g3 = AA.intoRaw(this.c), C2 = m.roundTriangle(A4, I3, g3, this.borderRadius);
            return A4.free(), I3.free(), g3.free(), C2;
          }, A3;
        }(), qA = function() {
          function A3(A4, I3) {
            this.vertices = A4, this.indices = I3 || new Uint32Array();
          }
          return A3.prototype.intoRaw = function() {
            return m.polyline(this.vertices, this.indices);
          }, A3;
        }(), RA = function() {
          function A3(A4, I3) {
            this.vertices = A4, this.indices = I3;
          }
          return A3.prototype.intoRaw = function() {
            return m.trimesh(this.vertices, this.indices);
          }, A3;
        }(), YA = function() {
          function A3(A4, I3) {
            this.vertices = A4, this.indices = I3;
          }
          return A3.prototype.intoRaw = function() {
            return this.indices ? m.convexMesh(this.vertices, this.indices) : m.convexHull(this.vertices);
          }, A3;
        }(), sA = function() {
          function A3(A4, I3, g3) {
            this.vertices = A4, this.indices = I3, this.borderRadius = g3;
          }
          return A3.prototype.intoRaw = function() {
            return this.indices ? m.roundConvexMesh(this.vertices, this.indices, this.borderRadius) : m.roundConvexHull(this.vertices, this.borderRadius);
          }, A3;
        }(), cA = function() {
          function A3(A4, I3, g3, C2) {
            this.nrows = A4, this.ncols = I3, this.heights = g3, this.scale = C2;
          }
          return A3.prototype.intoRaw = function() {
            var A4 = AA.intoRaw(this.scale), I3 = m.heightfield(this.nrows, this.ncols, this.heights, A4);
            return A4.free(), I3;
          }, A3;
        }(), LA = function() {
          function A3(A4, I3) {
            this.halfHeight = A4, this.radius = I3;
          }
          return A3.prototype.intoRaw = function() {
            return m.cylinder(this.halfHeight, this.radius);
          }, A3;
        }(), lA = function() {
          function A3(A4, I3, g3) {
            this.borderRadius = g3, this.halfHeight = A4, this.radius = I3;
          }
          return A3.prototype.intoRaw = function() {
            return m.roundCylinder(this.halfHeight, this.radius, this.borderRadius);
          }, A3;
        }(), HA = function() {
          function A3(A4, I3) {
            this.halfHeight = A4, this.radius = I3;
          }
          return A3.prototype.intoRaw = function() {
            return m.cone(this.halfHeight, this.radius);
          }, A3;
        }(), pA = function() {
          function A3(A4, I3, g3) {
            this.halfHeight = A4, this.radius = I3, this.borderRadius = g3;
          }
          return A3.prototype.intoRaw = function() {
            return m.roundCone(this.halfHeight, this.radius, this.borderRadius);
          }, A3;
        }(), TA = function() {
          function A3(A4, I3) {
            this.rawSet = A4, this.handle = I3;
          }
          return A3.prototype.isValid = function() {
            return this.rawSet.contains(this.handle);
          }, A3.prototype.translation = function() {
            return AA.fromRaw(this.rawSet.coTranslation(this.handle));
          }, A3.prototype.rotation = function() {
            return gA.fromRaw(this.rawSet.coRotation(this.handle));
          }, A3.prototype.isSensor = function() {
            return this.rawSet.coIsSensor(this.handle);
          }, A3.prototype.shapeType = function() {
            return this.rawSet.coShapeType(this.handle);
          }, A3.prototype.halfExtents = function() {
            return AA.fromRaw(this.rawSet.coHalfExtents(this.handle));
          }, A3.prototype.radius = function() {
            return this.rawSet.coRadius(this.handle);
          }, A3.prototype.roundRadius = function() {
            return this.rawSet.coRoundRadius(this.handle);
          }, A3.prototype.halfHeight = function() {
            return this.rawSet.coHalfHeight(this.handle);
          }, A3.prototype.vertices = function() {
            return this.rawSet.coVertices(this.handle);
          }, A3.prototype.indices = function() {
            return this.rawSet.coIndices(this.handle);
          }, A3.prototype.heightfieldHeights = function() {
            return this.rawSet.coHeightfieldHeights(this.handle);
          }, A3.prototype.heightfieldScale = function() {
            var A4 = this.rawSet.coHeightfieldScale(this.handle);
            return AA.fromRaw(A4);
          }, A3.prototype.heightfieldNRows = function() {
            return this.rawSet.coHeightfieldNRows(this.handle);
          }, A3.prototype.heightfieldNCols = function() {
            return this.rawSet.coHeightfieldNCols(this.handle);
          }, A3.prototype.parent = function() {
            return this.rawSet.coParent(this.handle);
          }, A3.prototype.friction = function() {
            return this.rawSet.coFriction(this.handle);
          }, A3.prototype.density = function() {
            return this.rawSet.coDensity(this.handle);
          }, A3.prototype.collisionGroups = function() {
            return this.rawSet.coCollisionGroups(this.handle);
          }, A3.prototype.solverGroups = function() {
            return this.rawSet.coSolverGroups(this.handle);
          }, A3;
        }(), tA = function() {
          function A3(A4) {
            this.shape = A4, this.density = null, this.friction = 0.5, this.restitution = 0, this.rotation = gA.identity(), this.translation = AA.zeros(), this.isSensor = false, this.collisionGroups = 4294967295, this.solverGroups = 4294967295, this.frictionCombineRule = DA.Average, this.restitutionCombineRule = DA.Average;
          }
          return A3.ball = function(I3) {
            return new A3(new JA(I3));
          }, A3.capsule = function(I3, g3) {
            return new A3(new yA(I3, g3));
          }, A3.segment = function(I3, g3) {
            return new A3(new hA(I3, g3));
          }, A3.triangle = function(I3, g3, C2) {
            return new A3(new NA(I3, g3, C2));
          }, A3.roundTriangle = function(I3, g3, C2, B2) {
            return new A3(new aA(I3, g3, C2, B2));
          }, A3.polyline = function(I3, g3) {
            return new A3(new qA(I3, g3));
          }, A3.trimesh = function(I3, g3) {
            return new A3(new RA(I3, g3));
          }, A3.cuboid = function(I3, g3, C2) {
            return new A3(new FA(I3, g3, C2));
          }, A3.roundCuboid = function(I3, g3, C2, B2) {
            return new A3(new KA(I3, g3, C2, B2));
          }, A3.heightfield = function(I3, g3, C2, B2) {
            return new A3(new cA(I3, g3, C2, B2));
          }, A3.cylinder = function(I3, g3) {
            return new A3(new LA(I3, g3));
          }, A3.roundCylinder = function(I3, g3, C2) {
            return new A3(new lA(I3, g3, C2));
          }, A3.cone = function(I3, g3) {
            return new A3(new HA(I3, g3));
          }, A3.roundCone = function(I3, g3, C2) {
            return new A3(new pA(I3, g3, C2));
          }, A3.convexHull = function(I3) {
            return new A3(new YA(I3, null));
          }, A3.convexMesh = function(I3, g3) {
            return new A3(new YA(I3, g3));
          }, A3.roundConvexHull = function(I3, g3) {
            return new A3(new sA(I3, null, g3));
          }, A3.roundConvexMesh = function(I3, g3, C2) {
            return new A3(new sA(I3, g3, C2));
          }, A3.prototype.setTranslation = function(A4, I3, g3) {
            if (typeof A4 != "number" || typeof I3 != "number" || typeof g3 != "number")
              throw TypeError("The translation components must be numbers.");
            return this.translation = {x: A4, y: I3, z: g3}, this;
          }, A3.prototype.setRotation = function(A4) {
            return this.rotation = A4, this;
          }, A3.prototype.setIsSensor = function(A4) {
            return this.isSensor = A4, this;
          }, A3.prototype.setDensity = function(A4) {
            return this.density = A4, this;
          }, A3.prototype.setRestitution = function(A4) {
            return this.restitution = A4, this;
          }, A3.prototype.setFriction = function(A4) {
            return this.friction = A4, this;
          }, A3.prototype.setFrictionCombineRule = function(A4) {
            return this.frictionCombineRule = A4, this;
          }, A3.prototype.setRestitutionCombineRule = function(A4) {
            return this.restitutionCombineRule = A4, this;
          }, A3.prototype.setCollisionGroups = function(A4) {
            return this.collisionGroups = A4, this;
          }, A3.prototype.setSolverGroups = function(A4) {
            return this.solverGroups = A4, this;
          }, A3;
        }(), OA = function() {
          function A3(A4) {
            this.raw = A4 || new t();
          }
          return A3.prototype.free = function() {
            this.raw.free(), this.raw = void 0;
          }, A3.prototype.createCollider = function(A4, I3, g3) {
            if (isNaN(g3))
              throw Error("Cannot create a collider with a parent rigid-body handle that is not a number.");
            var C2 = I3.shape.intoRaw(), B2 = AA.intoRaw(I3.translation), Q2 = gA.intoRaw(I3.rotation), E2 = this.raw.createCollider(C2, B2, Q2, I3.density, I3.friction, I3.restitution, I3.frictionCombineRule, I3.restitutionCombineRule, I3.isSensor, I3.collisionGroups, I3.solverGroups, g3, A4.raw);
            return C2.free(), B2.free(), Q2.free(), E2;
          }, A3.prototype.remove = function(A4, I3, g3) {
            this.raw.remove(A4, I3.raw, g3);
          }, A3.prototype.get = function(A4) {
            return this.raw.contains(A4) ? new TA(this.raw, A4) : null;
          }, A3.prototype.len = function() {
            return this.raw.len();
          }, A3.prototype.contains = function(A4) {
            return this.raw.contains(A4);
          }, A3.prototype.forEachCollider = function(A4) {
            var I3 = this;
            this.forEachColliderHandle(function(g3) {
              A4(new TA(I3.raw, g3));
            });
          }, A3.prototype.forEachColliderHandle = function(A4) {
            this.raw.forEachColliderHandle(A4);
          }, A3;
        }(), dA = function(A3, I3) {
          this.origin = A3, this.dir = I3;
        }, ZA = function() {
          function A3(A4, I3, g3) {
            this.colliderHandle = A4, this.toi = I3, this.normal = g3;
          }
          return A3.fromRaw = function(I3) {
            if (!I3)
              return null;
            var g3 = new A3(I3.colliderHandle(), I3.toi(), AA.fromRaw(I3.normal()));
            return I3.free(), g3;
          }, A3;
        }(), nA = function() {
          function A3(A4, I3) {
            this.colliderHandle = A4, this.toi = I3;
          }
          return A3.fromRaw = function(I3) {
            if (!I3)
              return null;
            var g3 = new A3(I3.colliderHandle(), I3.toi());
            return I3.free(), g3;
          }, A3;
        }(), eA = function() {
          function A3(A4, I3, g3) {
            this.colliderHandle = A4, this.point = I3, this.isInside = g3;
          }
          return A3.fromRaw = function(I3) {
            if (!I3)
              return null;
            var g3 = new A3(I3.colliderHandle(), AA.fromRaw(I3.point()), I3.isInside());
            return I3.free(), g3;
          }, A3;
        }(), rA = function() {
          function A3(A4, I3, g3, C2, B2, Q2) {
            this.colliderHandle = A4, this.toi = I3, this.witness1 = g3, this.witness2 = C2, this.normal1 = B2, this.normal2 = Q2;
          }
          return A3.fromRaw = function(I3) {
            if (!I3)
              return null;
            var g3 = new A3(I3.colliderHandle(), I3.toi(), AA.fromRaw(I3.witness1()), AA.fromRaw(I3.witness2()), AA.fromRaw(I3.normal1()), AA.fromRaw(I3.normal2()));
            return I3.free(), g3;
          }, A3;
        }(), WA = function() {
          function A3(A4) {
            this.raw = A4 || new W();
          }
          return A3.prototype.free = function() {
            this.raw.free(), this.raw = void 0;
          }, A3.prototype.step = function(A4, I3, g3, C2, B2, Q2, E2, i2, D2) {
            var o2 = AA.intoRaw(A4);
            D2 ? this.raw.stepWithEvents(o2, I3.raw, g3.raw, C2.raw, B2.raw, Q2.raw, E2.raw, i2.raw, D2.raw) : this.raw.step(o2, I3.raw, g3.raw, C2.raw, B2.raw, Q2.raw, E2.raw, i2.raw), o2.free();
          }, A3.prototype.removeRigidBody = function(A4, I3, g3, C2) {
            this.raw.removeRigidBody(A4, I3.raw, g3.raw, C2.raw);
          }, A3.prototype.removeCollider = function(A4, I3, g3) {
            this.raw.removeCollider(A4, I3.raw, g3.raw);
          }, A3;
        }(), xA = function() {
          function A3(A4) {
            this.raw = A4 || new b();
          }
          return A3.prototype.free = function() {
            this.raw.free(), this.raw = void 0;
          }, A3.prototype.update = function(A4, I3) {
            this.raw.update(A4.raw, I3.raw);
          }, A3.prototype.castRay = function(A4, I3, g3, C2, B2) {
            var Q2 = AA.intoRaw(I3.origin), E2 = AA.intoRaw(I3.dir), i2 = nA.fromRaw(this.raw.castRay(A4.raw, Q2, E2, g3, C2, B2));
            return Q2.free(), E2.free(), i2;
          }, A3.prototype.castRayAndGetNormal = function(A4, I3, g3, C2, B2) {
            var Q2 = AA.intoRaw(I3.origin), E2 = AA.intoRaw(I3.dir), i2 = ZA.fromRaw(this.raw.castRayAndGetNormal(A4.raw, Q2, E2, g3, C2, B2));
            return Q2.free(), E2.free(), i2;
          }, A3.prototype.intersectionsWithRay = function(A4, I3, g3, C2, B2, Q2) {
            var E2 = AA.intoRaw(I3.origin), i2 = AA.intoRaw(I3.dir);
            this.raw.intersectionsWithRay(A4.raw, E2, i2, g3, C2, B2, function(A5) {
              return Q2(ZA.fromRaw(A5));
            }), E2.free(), i2.free();
          }, A3.prototype.intersectionWithShape = function(A4, I3, g3, C2, B2) {
            var Q2 = AA.intoRaw(I3), E2 = gA.intoRaw(g3), i2 = C2.intoRaw(), D2 = this.raw.intersectionWithShape(A4.raw, Q2, E2, i2, B2);
            return Q2.free(), E2.free(), i2.free(), D2;
          }, A3.prototype.projectPoint = function(A4, I3, g3, C2) {
            var B2 = AA.intoRaw(I3), Q2 = eA.fromRaw(this.raw.projectPoint(A4.raw, B2, g3, C2));
            return B2.free(), Q2;
          }, A3.prototype.intersectionsWithPoint = function(A4, I3, g3, C2) {
            var B2 = AA.intoRaw(I3);
            this.raw.intersectionsWithPoint(A4.raw, B2, g3, C2), B2.free();
          }, A3.prototype.castShape = function(A4, I3, g3, C2, B2, Q2, E2) {
            var i2 = AA.intoRaw(I3), D2 = gA.intoRaw(g3), o2 = AA.intoRaw(C2), S2 = B2.intoRaw(), G2 = rA.fromRaw(this.raw.castShape(A4.raw, i2, D2, o2, S2, Q2, E2));
            return i2.free(), D2.free(), o2.free(), S2.free(), G2;
          }, A3.prototype.intersectionsWithShape = function(A4, I3, g3, C2, B2, Q2) {
            var E2 = AA.intoRaw(I3), i2 = gA.intoRaw(g3), D2 = C2.intoRaw();
            this.raw.intersectionsWithShape(A4.raw, E2, i2, D2, B2, Q2), E2.free(), i2.free(), D2.free();
          }, A3;
        }(), bA = function() {
          function A3(A4) {
            this.raw = A4 || new P();
          }
          return A3.prototype.free = function() {
            this.raw.free(), this.raw = void 0;
          }, A3.prototype.serializeAll = function(A4, I3, g3, C2, B2, Q2, E2) {
            var i2 = AA.intoRaw(A4), D2 = this.raw.serializeAll(i2, I3.raw, g3.raw, C2.raw, B2.raw, Q2.raw, E2.raw);
            return i2.free(), D2;
          }, A3.prototype.deserializeAll = function(A4) {
            return jA.fromRaw(this.raw.deserializeAll(A4));
          }, A3;
        }(), jA = function() {
          function A3(A4, I3, g3, C2, B2, Q2, E2, i2, D2, o2, S2) {
            this.gravity = A4, this.integrationParameters = new iA(I3), this.broadPhase = new UA(g3), this.narrowPhase = new MA(C2), this.bodies = new EA(B2), this.colliders = new OA(Q2), this.joints = new GA(E2), this.ccdSolver = new kA(i2), this.queryPipeline = new xA(D2), this.physicsPipeline = new WA(o2), this.serializationPipeline = new bA(S2);
          }
          return A3.prototype.free = function() {
            this.integrationParameters.free(), this.broadPhase.free(), this.narrowPhase.free(), this.bodies.free(), this.colliders.free(), this.joints.free(), this.ccdSolver.free(), this.queryPipeline.free(), this.physicsPipeline.free(), this.serializationPipeline.free(), this.integrationParameters = void 0, this.broadPhase = void 0, this.narrowPhase = void 0, this.bodies = void 0, this.colliders = void 0, this.ccdSolver = void 0, this.joints = void 0, this.queryPipeline = void 0, this.physicsPipeline = void 0, this.serializationPipeline = void 0;
          }, A3.fromRaw = function(I3) {
            return I3 ? new A3(AA.fromRaw(I3.takeGravity()), I3.takeIntegrationParameters(), I3.takeBroadPhase(), I3.takeNarrowPhase(), I3.takeBodies(), I3.takeColliders(), I3.takeJoints()) : null;
          }, A3.prototype.takeSnapshot = function() {
            return this.serializationPipeline.serializeAll(this.gravity, this.integrationParameters, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.joints);
          }, A3.restoreSnapshot = function(A4) {
            return new bA().deserializeAll(A4);
          }, A3.prototype.step = function(A4) {
            this.physicsPipeline.step(this.gravity, this.integrationParameters, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.joints, this.ccdSolver, A4), this.queryPipeline.update(this.bodies, this.colliders);
          }, Object.defineProperty(A3.prototype, "timestep", {get: function() {
            return this.integrationParameters.dt;
          }, set: function(A4) {
            this.integrationParameters.dt = A4;
          }, enumerable: false, configurable: true}), Object.defineProperty(A3.prototype, "maxVelocityIterations", {get: function() {
            return this.integrationParameters.maxVelocityIterations;
          }, set: function(A4) {
            this.integrationParameters.maxVelocityIterations = A4;
          }, enumerable: false, configurable: true}), Object.defineProperty(A3.prototype, "maxPositionIterations", {get: function() {
            return this.integrationParameters.maxPositionIterations;
          }, set: function(A4) {
            this.integrationParameters.maxPositionIterations = A4;
          }, enumerable: false, configurable: true}), A3.prototype.createRigidBody = function(A4) {
            return this.bodies.get(this.bodies.createRigidBody(A4));
          }, A3.prototype.createCollider = function(A4, I3) {
            return this.colliders.get(this.colliders.createCollider(this.bodies, A4, I3));
          }, A3.prototype.createJoint = function(A4, I3, g3) {
            return this.joints.get(this.joints.createJoint(this.bodies, A4, I3.handle, g3.handle));
          }, A3.prototype.getRigidBody = function(A4) {
            return this.bodies.get(A4);
          }, A3.prototype.getCollider = function(A4) {
            return this.colliders.get(A4);
          }, A3.prototype.getJoint = function(A4) {
            return this.joints.get(A4);
          }, A3.prototype.removeRigidBody = function(A4) {
            this.physicsPipeline.removeRigidBody(A4.handle, this.bodies, this.colliders, this.joints);
          }, A3.prototype.removeCollider = function(A4) {
            this.physicsPipeline.removeCollider(A4.handle, this.bodies, this.colliders);
          }, A3.prototype.forEachCollider = function(A4) {
            this.colliders.forEachCollider(A4);
          }, A3.prototype.forEachColliderHandle = function(A4) {
            this.colliders.forEachColliderHandle(A4);
          }, A3.prototype.forEachRigidBody = function(A4) {
            this.bodies.forEachRigidBody(A4);
          }, A3.prototype.forEachRigidBodyHandle = function(A4) {
            this.bodies.forEachRigidBodyHandle(A4);
          }, A3.prototype.forEachActiveRigidBody = function(A4) {
            this.bodies.forEachActiveRigidBody(A4);
          }, A3.prototype.forEachActiveRigidBodyHandle = function(A4) {
            this.bodies.forEachActiveRigidBodyHandle(A4);
          }, A3.prototype.castRay = function(A4, I3) {
            return this.queryPipeline.castRay(this.colliders, A4, I3, true, 4294967295);
          }, A3.prototype.castRayAndGetNormal = function(A4, I3) {
            return this.queryPipeline.castRayAndGetNormal(this.colliders, A4, I3, true, 4294967295);
          }, A3.prototype.intersectionsWithRay = function(A4, I3, g3, C2, B2, Q2) {
            this.queryPipeline.intersectionsWithRay(this.colliders, I3, g3, C2, B2, Q2);
          }, A3.prototype.intersectionWithShape = function(A4, I3, g3, C2, B2) {
            return this.queryPipeline.intersectionWithShape(this.colliders, I3, g3, C2, B2);
          }, A3.prototype.projectPoint = function(A4, I3, g3, C2) {
            return this.queryPipeline.projectPoint(this.colliders, I3, g3, C2);
          }, A3.prototype.intersectionsWithPoint = function(A4, I3, g3, C2) {
            this.queryPipeline.intersectionsWithPoint(this.colliders, I3, g3, C2);
          }, A3.prototype.castShape = function(A4, I3, g3, C2, B2, Q2, E2) {
            return this.queryPipeline.castShape(this.colliders, I3, g3, C2, B2, Q2, E2);
          }, A3.prototype.intersectionsWithShape = function(A4, I3, g3, C2, B2, Q2) {
            this.queryPipeline.intersectionsWithShape(this.colliders, I3, g3, C2, B2, Q2);
          }, A3;
        }(), fA = function() {
          function A3(A4, I3) {
            this.raw = I3 || new d(A4);
          }
          return A3.prototype.free = function() {
            this.raw.free(), this.raw = void 0;
          }, A3.prototype.drainContactEvents = function(A4) {
            this.raw.drainContactEvents(A4);
          }, A3.prototype.drainIntersectionEvents = function(A4) {
            this.raw.drainIntersectionEvents(A4);
          }, A3.prototype.clear = function() {
            this.raw.clear();
          }, A3;
        }();
        function VA() {
          return function() {
            try {
              const g3 = C.__wbindgen_add_to_stack_pointer(-16);
              C.version(g3);
              var A3 = K()[g3 / 4 + 0], I3 = K()[g3 / 4 + 1];
              return w(A3, I3);
            } finally {
              C.__wbindgen_add_to_stack_pointer(16), C.__wbindgen_free(A3, I3);
            }
          }();
        }
        function XA() {
          return A3 = this, I3 = void 0, C2 = function() {
            var A4, I4;
            return function(A5, I5) {
              var g4, C3, B2, Q2, E2 = {label: 0, sent: function() {
                if (1 & B2[0])
                  throw B2[1];
                return B2[1];
              }, trys: [], ops: []};
              return Q2 = {next: i2(0), throw: i2(1), return: i2(2)}, typeof Symbol == "function" && (Q2[Symbol.iterator] = function() {
                return this;
              }), Q2;
              function i2(Q3) {
                return function(i3) {
                  return function(Q4) {
                    if (g4)
                      throw new TypeError("Generator is already executing.");
                    for (; E2; )
                      try {
                        if (g4 = 1, C3 && (B2 = 2 & Q4[0] ? C3.return : Q4[0] ? C3.throw || ((B2 = C3.return) && B2.call(C3), 0) : C3.next) && !(B2 = B2.call(C3, Q4[1])).done)
                          return B2;
                        switch (C3 = 0, B2 && (Q4 = [2 & Q4[0], B2.value]), Q4[0]) {
                          case 0:
                          case 1:
                            B2 = Q4;
                            break;
                          case 4:
                            return E2.label++, {value: Q4[1], done: false};
                          case 5:
                            E2.label++, C3 = Q4[1], Q4 = [0];
                            continue;
                          case 7:
                            Q4 = E2.ops.pop(), E2.trys.pop();
                            continue;
                          default:
                            if (!((B2 = (B2 = E2.trys).length > 0 && B2[B2.length - 1]) || Q4[0] !== 6 && Q4[0] !== 2)) {
                              E2 = 0;
                              continue;
                            }
                            if (Q4[0] === 3 && (!B2 || Q4[1] > B2[0] && Q4[1] < B2[3])) {
                              E2.label = Q4[1];
                              break;
                            }
                            if (Q4[0] === 6 && E2.label < B2[1]) {
                              E2.label = B2[1], B2 = Q4;
                              break;
                            }
                            if (B2 && E2.label < B2[2]) {
                              E2.label = B2[2], E2.ops.push(Q4);
                              break;
                            }
                            B2[2] && E2.ops.pop(), E2.trys.pop();
                            continue;
                        }
                        Q4 = I5.call(A5, E2);
                      } catch (A6) {
                        Q4 = [6, A6], C3 = 0;
                      } finally {
                        g4 = B2 = 0;
                      }
                    if (5 & Q4[0])
                      throw Q4[1];
                    return {value: Q4[0] ? Q4[1] : void 0, done: true};
                  }([Q3, i3]);
                };
              }
            }(this, function(g4) {
              switch (g4.label) {
                case 0:
                  return A4 = "data:application/wasm;base64,AGFzbQEAAAABjQhzYAJ/fwBgA39/fwBgAn9/AX9gBH9/f38AYAF/AGABfwF+YAN/f38Bf2ABfwF/YAV/f39/fwBgBn9/f399fwBgAX8BfWAFf39/fX8AYAABf2AEf39/fQF/YAN/f38BfWADf399AGADf399AX9gBH9/f38BfWACf30AYAd/f39/f39/AGAFf39/f30AYAR/f39/AX9gCH9/f39/f31/AX9gBn9/f39/fwF/YAJ/fwF9YAAAYAV/f39/fwF/YAR/fn9/AX9gAX0BfWAGf39/f39/AGAJf39/f39/f399AGAIf39/f39/f30AYAh/f39/fX9/fwBgBH99f38AYAN9fX0Bf2ALf39/f39/f399fX8AYAZ/f39/f30AYAd/f39/fX9/AGAEf39/fQBgBn9/fn9/fwBgA399fQBgBH99fX0AYAJ9fQF/YAh/f39/f39/fwBgCX9/f39/f39/fwBgCn9/f39/f31/f38AYBB/f39/f399fX1/f39/f39/AGAJf39/f399f39/AGAEf399fwBgBX9/fX9/AGAFf399fX0AYAN/fn8AYAV/fn9+fwBgBn99f39/fwBgBn99fX9/fQBgBX5/f39/AGAJf39/f39/fX9/AX9gB39/f399f38Bf2ATf39/fX1/f39/f39/f399fX9/fwF/YAR/fX9/AX9gA319fwF/YAR9fX19AX9gA39/fwF+YAJ9fQF9YAp/f39/f39/f39/AGALf39/f39/f39/f38AYAx/f39/f39/f39/f38AYA1/f39/f39/f39/f39/AGAPf39/f39/f39/f39/fX1/AGAKf39/f39/f399fQBgCn9/f39/f399f38AYA1/f39/f39/fX19fX19AGAJf39/f39/fn5+AGAHf39/f39/fQBgCX9/f39/f31/fwBgCH9/f399fX9/AGAGf39/fn9/AGASf39/fn9+f39/f39/fX99fX19AGALf39/fX9/fX99fX8AYAZ/f35/fn8AYAZ/f31/f38AYAh/f31/f39/fwBgBn9/fX19fwBgBn9/fX19fQBgB39/fX19fX8AYAV/f3x/fwBgBH9+f38AYAR/fn99AGADf31/AGAIf31/f39/f38AYAl/fX9/f39/f38AYAp/fX9/f39/f39/AGAFf31/f30AYAh/fX99f31/fwBgBX99fX19AGAEf3x/fwBgAn5/AGADfX9/AGAIf39/f39/f38Bf2AJf39/f39/f319AX9gBX9/f399AX9gBH9/fX0Bf2ACf34Bf2ADf35/AX9gA399fwF/YAN/fH8Bf2AEf3x/fwF/YAN+f38Bf2ABfQF/YAF8AX9gAX4BfmAEfn5+fwF+YAZ/f39/f38BfWAAAXxgAX8BfAL0BhoDd2JnFV9fd2JpbmRnZW5fbnVtYmVyX25ldwBtA3diZxpfX3diaW5kZ2VuX29iamVjdF9kcm9wX3JlZgAEA3diZyRfX3diZ19yYXdyYXljb2xsaWRlcmludGVyc2VjdGlvbl9uZXcABwN3YmcVX193YmluZGdlbl9zdHJpbmdfbmV3AAIDd2JnGl9fd2JnX25vd180YWJiY2E0ZWYyYWJhOGQ2AHIDd2JnGl9fd2JnX2dldF8wYzY5NjNjYmFiMzRmYmI2AAIDd2JnG19fd2JnX2NhbGxfY2I0NzhkODhmMzA2OGM5MQACA3diZxtfX3diaW5kZ2VuX29iamVjdF9jbG9uZV9yZWYABwN3YmcgX193YmdfbmV3bm9hcmdzXzNlZmM3YmZhNjlhNjgxZjkAAgN3YmcbX193YmdfY2FsbF9mNWUwNTc2ZjYxZWU3NDYxAAYDd2JnG19fd2JnX2NhbGxfN2RkODgyOTY1NGM3OTk5YwAaA3diZxtfX3diZ19iaW5kX2IyZTRiYzVjMzI2ODY5YTAAFQN3YmcdX193YmdfYnVmZmVyX2ViYzZjOGU3NTUxMGVhZTMABwN3YmcbX193Ymdfc2VsZl8wNWM1NGRjYWNiNjIzYjlhAAwDd2JnHV9fd2JnX3dpbmRvd185Nzc3Y2U0NDZkMTI5ODlmAAwDd2JnIV9fd2JnX2dsb2JhbFRoaXNfZjBjYTBiYmIwMTQ5Y2YzZAAMA3diZx1fX3diZ19nbG9iYWxfYzNjODMyNWFlOGM3ZjFhOQAMA3diZxdfX3diaW5kZ2VuX2lzX3VuZGVmaW5lZAAHA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9jYTNkM2Q4ODExZWNiNTY5AAYDd2JnHV9fd2JnX2xlbmd0aF8zMTdmMGRkNzdmN2E2NjczAAcDd2JnGl9fd2JnX25ld18xMzVlOTYzZGVkZjY3YjIyAAcDd2JnGl9fd2JnX3NldF80YTUwNzJhMzEwMDhlMGNiAAEDd2JnFl9fd2JpbmRnZW5fYm9vbGVhbl9nZXQABwN3YmcXX193YmluZGdlbl9kZWJ1Z19zdHJpbmcAAAN3YmcQX193YmluZGdlbl90aHJvdwAAA3diZxFfX3diaW5kZ2VuX21lbW9yeQAMA9YL1AsAAkJDCAgWASFRAB8UAgMDAwMDA0EhBh8lADgTAy8eHggjRgEdCCUBAwADAwADRABQAAMDK04tCDUHHyAABicEARcDHisAARMECwMgAQBwAhMACwMLCwEVAiABCwABSi0fAAYDAUwvCAETFwsCIQIBARQLJwIAAzAAARQUFBQaEhRLNhwUTQIAFBQ2CAIDags7AwMAAWYDAwMDAwMDAQMDAwEABAtWAQALJgEPAQsBAwFpBAICHDtZHAgIFlcGBlsLCxMSAQA/Bi4CBAMLIwETCyUDAAAdCwAHAw4CCwIACRUBARMBAjUAAAABARcAXQQIB0kJAQADAQ8DAAM6ASwBAQgBDQEBAwkAAAIkAAAAZQECAQABAAQIAQkDBgEECQYBA1oJCQkJCQkJCQkJCQkJCQkBCAkDAAAYEQAkAU8AAAEBAQM5AwIBDwIADQMIA2gAAAABAQAACAIDAwIDAQECAQEAAAAAAEcVADMCAwABAAABXAADCAMDDgAEAQMAAwQJAwkGAwAAAAkDAQ0IADNvAAgBAw0CAQsBGgADAQAIAwADDQEDAwMDAwMDAwcABAMEKEAHAwkJCQAJCQkJCQkJCQkJCSQDDQ0NDwEnDwNIAQEBCAMDAwMBDQ0NDQ0NDQ0NDQ0BCAUHAAMBBjoICAgICAgICAgICAhFAwQBCwFiAQICEzkEAGAAAQAAAwMZAQABAB0MEwYEEwECYwECAQIAAwETHAcGAQAEBAQEAQELPgQAAgAHDD4BAgAAAAIAAwIREQMNERERERERERERERERBhEBAWssAQEAAQAcAAMCAQEAP2E3NwQuAQgBCwQAFQIDAQMCAgMMCAcKAAIBAAEEAQITBwoAAQYBBAEBAQEDAAYGBgYBBAEEAgYBBBEGBgYGBgYGARAICAERAQIHAwEBBBEBAAACAgQAAAYGBgEMAgICBhwgAAAEFAYCAggAAgAaC1QBAAEEAAAPUwIDAQEBJm4HDwABBAEDAwEBAQQEBAQEAwEAAQ8AAAEDBAEEAQACAgICAgICAgQDBAIDCAEPJgIEAQEGBAQDAwMDAwMBBwsBABwEMQMDC3EdAwcDAAEGUgIAAgYyBwcHAwMBAAEBAQEBBAQHAAEBAgICAgJkAQECAwIVAAICAioQAgICGBgBAQEUAQAABwcBAwQaAQEPCBUVAQIEAAIYGAEBAQEYDAsFEAEBAQICGAICAgIYAgICAgAMBgAADgEOEAMACAcBAg4ODg4ODg4ODg4ODg4GBwcHBwcHEg4BBDABBAQABgQEBAQCAAoKAgIADw8CAgsEAgABAQEEAgAAAQEBAQICBwgACAAEAwICAAABAQIMDAwEBAECAgICAgAAAAABAgICCgEBDAEADykBBD0QATw0IiIiAQEEADQEKio8KAAEAWwEAgIAAB0AAAAAAAQMAgcOAA8AAAMKBBUAZw4ABwcBAQEDAQAMDAwMBAADAF4BAgMDAgICAgICAgICAgICAgAAAgICBAILCwsLCwsLCwsLCwQCAA8AKSkABAwCAAQ9BAgAAAAEAwEBKAYCAgIHAQIiAhAQEBAQEBAQEBAQEBAQCgwCWAIAAAoSAgMSEhISEhISEgAAAAASAgIABAQEBAAEAwEKAAAABAQABgoKCgoKCgoKBwcHBxIHCgoMBAIEBAQBAQQyBAECAgICAgICAgABBAIKDAEGBAQXAgwaMQhVDAIDAAAGBwAAAAAAAAAZGQAAAAAAAAABAAIAAgICBBUBAQABAQEBAQEBAQEADwICAgACBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQUFBQAAAAAABQAFAAUABQUABQAFAAAFBQAFAAUABQAFAAICAgACAwMDAwMDAwoCGQICAQYCBwICAgICABkZAgUBAQEKAgICBgICAAgBBwQKCgoZBQUHBwIFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBgoHBwoHCgcHBwcKBwcHBwoHBwcHBwcFBQQABAcBcAHqBuoGBQMBABEGCQF/AUGAgMAACwfyN+UBBm1lbW9yeQIAB3ZlcnNpb24AlgkXX193YmdfcmF3Y2Nkc29sdmVyX2ZyZWUA2QcQcmF3Y2Nkc29sdmVyX25ldwDeCCNfX3diZ19yYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfZnJlZQDWCRxyYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfbmV3AMYIG3Jhd2ludGVncmF0aW9ucGFyYW1ldGVyc19kdACMChxyYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfZXJwAOQJIXJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19qb2ludEVycADlCSdyYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfd2FybXN0YXJ0Q29lZmYA5gkrcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX2FsbG93ZWRMaW5lYXJFcnJvcgDnCStyYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfcHJlZGljdGlvbkRpc3RhbmNlAOgJLHJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19hbGxvd2VkQW5ndWxhckVycm9yAOkJLHJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19tYXhMaW5lYXJDb3JyZWN0aW9uAOoJLXJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19tYXhBbmd1bGFyQ29ycmVjdGlvbgDrCS5yYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfbWF4VmVsb2NpdHlJdGVyYXRpb25zAOwJLnJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19tYXhQb3NpdGlvbkl0ZXJhdGlvbnMA7QkmcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX21pbklzbGFuZFNpemUA7gkncmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX21heENjZFN1YnN0ZXBzAO8JH3Jhd2ludGVncmF0aW9ucGFyYW1ldGVyc19zZXRfZHQA8AkgcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3NldF9lcnAAxAklcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3NldF9qb2ludEVycADFCStyYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfc2V0X3dhcm1zdGFydENvZWZmAMYJL3Jhd2ludGVncmF0aW9ucGFyYW1ldGVyc19zZXRfYWxsb3dlZExpbmVhckVycm9yAMcJL3Jhd2ludGVncmF0aW9ucGFyYW1ldGVyc19zZXRfcHJlZGljdGlvbkRpc3RhbmNlAMgJMHJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19zZXRfYWxsb3dlZEFuZ3VsYXJFcnJvcgDJCTByYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfc2V0X21heExpbmVhckNvcnJlY3Rpb24AygkxcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3NldF9tYXhBbmd1bGFyQ29ycmVjdGlvbgDLCTJyYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfc2V0X21heFZlbG9jaXR5SXRlcmF0aW9ucwDMCTJyYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfc2V0X21heFBvc2l0aW9uSXRlcmF0aW9ucwDNCSpyYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfc2V0X21pbklzbGFuZFNpemUAzgkrcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3NldF9tYXhDY2RTdWJzdGVwcwDPCRxyYXdqb2ludHNldF9qb2ludEJvZHlIYW5kbGUxAPUGHHJhd2pvaW50c2V0X2pvaW50Qm9keUhhbmRsZTIA6wYVcmF3am9pbnRzZXRfam9pbnRUeXBlAJEHGHJhd2pvaW50c2V0X2pvaW50RnJhbWVYMQD2BhhyYXdqb2ludHNldF9qb2ludEZyYW1lWDIA9wYYcmF3am9pbnRzZXRfam9pbnRBbmNob3IxAM8FGHJhd2pvaW50c2V0X2pvaW50QW5jaG9yMgDQBRZyYXdqb2ludHNldF9qb2ludEF4aXMxANoFFnJhd2pvaW50c2V0X2pvaW50QXhpczIA2wUecmF3am9pbnRzZXRfam9pbnRMaW1pdHNFbmFibGVkAPIGGnJhd2pvaW50c2V0X2pvaW50TGltaXRzTWluAPgGGnJhd2pvaW50c2V0X2pvaW50TGltaXRzTWF4APkGGV9fd2JnX3Jhd2pvaW50cGFyYW1zX2ZyZWUA1gkTcmF3am9pbnRwYXJhbXNfYmFsbACyBRhyYXdqb2ludHBhcmFtc19wcmlzbWF0aWMAtAQUcmF3am9pbnRwYXJhbXNfZml4ZWQAggMXcmF3am9pbnRwYXJhbXNfcmV2b2x1dGUAiAUWX193YmdfcmF3am9pbnRzZXRfZnJlZQCsBg9yYXdqb2ludHNldF9uZXcAzwQXcmF3am9pbnRzZXRfY3JlYXRlSm9pbnQAhgcScmF3am9pbnRzZXRfcmVtb3ZlAOwGD3Jhd2pvaW50c2V0X2xlbgDWCBRyYXdqb2ludHNldF9jb250YWlucwDiBx5yYXdqb2ludHNldF9mb3JFYWNoSm9pbnRIYW5kbGUAkggdcmF3cmlnaWRib2R5c2V0X3JiVHJhbnNsYXRpb24AmgYacmF3cmlnaWRib2R5c2V0X3JiUm90YXRpb24AmwYXcmF3cmlnaWRib2R5c2V0X3JiU2xlZXAA6wcccmF3cmlnaWRib2R5c2V0X3JiSXNTbGVlcGluZwCgBxpyYXdyaWdpZGJvZHlzZXRfcmJJc01vdmluZwChByFyYXdyaWdpZGJvZHlzZXRfcmJOZXh0VHJhbnNsYXRpb24AnAYecmF3cmlnaWRib2R5c2V0X3JiTmV4dFJvdGF0aW9uAJ0GIHJhd3JpZ2lkYm9keXNldF9yYlNldFRyYW5zbGF0aW9uAMsGHXJhd3JpZ2lkYm9keXNldF9yYlNldFJvdGF0aW9uAOwFG3Jhd3JpZ2lkYm9keXNldF9yYlNldExpbnZlbACyBhtyYXdyaWdpZGJvZHlzZXRfcmJTZXRBbmd2ZWwAswYtcmF3cmlnaWRib2R5c2V0X3JiU2V0TmV4dEtpbmVtYXRpY1RyYW5zbGF0aW9uANAGKnJhd3JpZ2lkYm9keXNldF9yYlNldE5leHRLaW5lbWF0aWNSb3RhdGlvbgD0BRhyYXdyaWdpZGJvZHlzZXRfcmJMaW52ZWwAngYYcmF3cmlnaWRib2R5c2V0X3JiQW5ndmVsAJ8GFnJhd3JpZ2lkYm9keXNldF9yYk1hc3MAogcYcmF3cmlnaWRib2R5c2V0X3JiV2FrZVVwAOMHHnJhd3JpZ2lkYm9keXNldF9yYklzQ2NkRW5hYmxlZACjBx5yYXdyaWdpZGJvZHlzZXRfcmJOdW1Db2xsaWRlcnMAjgcacmF3cmlnaWRib2R5c2V0X3JiQ29sbGlkZXIArwYccmF3cmlnaWRib2R5c2V0X3JiQm9keVN0YXR1cwDtBhpyYXdyaWdpZGJvZHlzZXRfcmJJc1N0YXRpYwCkBx1yYXdyaWdpZGJvZHlzZXRfcmJJc0tpbmVtYXRpYwClBxtyYXdyaWdpZGJvZHlzZXRfcmJJc0R5bmFtaWMApgcfcmF3cmlnaWRib2R5c2V0X3JiTGluZWFyRGFtcGluZwCSByByYXdyaWdpZGJvZHlzZXRfcmJBbmd1bGFyRGFtcGluZwCTByJyYXdyaWdpZGJvZHlzZXRfcmJTZXRMaW5lYXJEYW1waW5nAOQHI3Jhd3JpZ2lkYm9keXNldF9yYlNldEFuZ3VsYXJEYW1waW5nAOUHHnJhd3JpZ2lkYm9keXNldF9yYkdyYXZpdHlTY2FsZQCnByFyYXdyaWdpZGJvZHlzZXRfcmJTZXRHcmF2aXR5U2NhbGUA0wcccmF3cmlnaWRib2R5c2V0X3JiQXBwbHlGb3JjZQC0Bh5yYXdyaWdpZGJvZHlzZXRfcmJBcHBseUltcHVsc2UAtQYdcmF3cmlnaWRib2R5c2V0X3JiQXBwbHlUb3JxdWUAtgYkcmF3cmlnaWRib2R5c2V0X3JiQXBwbHlUb3JxdWVJbXB1bHNlALcGI3Jhd3JpZ2lkYm9keXNldF9yYkFwcGx5Rm9yY2VBdFBvaW50AMAFJXJhd3JpZ2lkYm9keXNldF9yYkFwcGx5SW1wdWxzZUF0UG9pbnQAwQUaX193YmdfcmF3cmlnaWRib2R5c2V0X2ZyZWUA2gcTcmF3cmlnaWRib2R5c2V0X25ldwCHCB9yYXdyaWdpZGJvZHlzZXRfY3JlYXRlUmlnaWRCb2R5AIUEFnJhd3JpZ2lkYm9keXNldF9yZW1vdmUAggYTcmF3cmlnaWRib2R5c2V0X2xlbgDXCBhyYXdyaWdpZGJvZHlzZXRfY29udGFpbnMA5gcmcmF3cmlnaWRib2R5c2V0X2ZvckVhY2hSaWdpZEJvZHlIYW5kbGUAkwgscmF3cmlnaWRib2R5c2V0X2ZvckVhY2hBY3RpdmVSaWdpZEJvZHlIYW5kbGUAlAgYX193YmdfcmF3YnJvYWRwaGFzZV9mcmVlANsHEXJhd2Jyb2FkcGhhc2VfbmV3AN8IHHJhd2NvbGxpZGVyc2V0X2NvVHJhbnNsYXRpb24AoAYZcmF3Y29sbGlkZXJzZXRfY29Sb3RhdGlvbgChBhlyYXdjb2xsaWRlcnNldF9jb0lzU2Vuc29yAKgHGnJhd2NvbGxpZGVyc2V0X2NvU2hhcGVUeXBlAMcIHHJhd2NvbGxpZGVyc2V0X2NvSGFsZkV4dGVudHMA6AUXcmF3Y29sbGlkZXJzZXRfY29SYWRpdXMAlAcbcmF3Y29sbGlkZXJzZXRfY29IYWxmSGVpZ2h0AJUHHHJhd2NvbGxpZGVyc2V0X2NvUm91bmRSYWRpdXMAkwYZcmF3Y29sbGlkZXJzZXRfY29WZXJ0aWNlcwCEBhhyYXdjb2xsaWRlcnNldF9jb0luZGljZXMAhQYjcmF3Y29sbGlkZXJzZXRfY29IZWlnaHRmaWVsZEhlaWdodHMAhgYhcmF3Y29sbGlkZXJzZXRfY29IZWlnaHRmaWVsZFNjYWxlAIkFIXJhd2NvbGxpZGVyc2V0X2NvSGVpZ2h0ZmllbGROUm93cwCWByFyYXdjb2xsaWRlcnNldF9jb0hlaWdodGZpZWxkTkNvbHMAlwcXcmF3Y29sbGlkZXJzZXRfY29QYXJlbnQA5wYZcmF3Y29sbGlkZXJzZXRfY29GcmljdGlvbgCYBxhyYXdjb2xsaWRlcnNldF9jb0RlbnNpdHkA1gYgcmF3Y29sbGlkZXJzZXRfY29Db2xsaXNpb25Hcm91cHMAqQcdcmF3Y29sbGlkZXJzZXRfY29Tb2x2ZXJHcm91cHMAqgcZX193YmdfcmF3Y29sbGlkZXJzZXRfZnJlZQDcBxJyYXdjb2xsaWRlcnNldF9uZXcAiAgScmF3Y29sbGlkZXJzZXRfbGVuANcIF3Jhd2NvbGxpZGVyc2V0X2NvbnRhaW5zAOcHHXJhd2NvbGxpZGVyc2V0X2NyZWF0ZUNvbGxpZGVyAIEFFXJhd2NvbGxpZGVyc2V0X3JlbW92ZQCUBiRyYXdjb2xsaWRlcnNldF9mb3JFYWNoQ29sbGlkZXJIYW5kbGUAlQgZX193YmdfcmF3bmFycm93cGhhc2VfZnJlZQDKBBJyYXduYXJyb3dwaGFzZV9uZXcA4AglX193YmdfcmF3cG9pbnRjb2xsaWRlcnByb2plY3Rpb25fZnJlZQDWCSlyYXdwb2ludGNvbGxpZGVycHJvamVjdGlvbl9jb2xsaWRlckhhbmRsZQD5ByByYXdwb2ludGNvbGxpZGVycHJvamVjdGlvbl9wb2ludADRBiNyYXdwb2ludGNvbGxpZGVycHJvamVjdGlvbl9pc0luc2lkZQDxCSVfX3diZ19yYXdyYXljb2xsaWRlcmludGVyc2VjdGlvbl9mcmVlANYJIXJhd3JheWNvbGxpZGVyaW50ZXJzZWN0aW9uX25vcm1hbADSBh5yYXdyYXljb2xsaWRlcmludGVyc2VjdGlvbl90b2kA8gkcX193YmdfcmF3cmF5Y29sbGlkZXJ0b2lfZnJlZQDWCRNfX3diZ19yYXdzaGFwZV9mcmVlAKMID3Jhd3NoYXBlX2N1Ym9pZACpCBRyYXdzaGFwZV9yb3VuZEN1Ym9pZACkCA1yYXdzaGFwZV9iYWxsALkIEHJhd3NoYXBlX2NhcHN1bGUA8wYRcmF3c2hhcGVfY3lsaW5kZXIAsggWcmF3c2hhcGVfcm91bmRDeWxpbmRlcgCqCA1yYXdzaGFwZV9jb25lALMIEnJhd3NoYXBlX3JvdW5kQ29uZQCrCBFyYXdzaGFwZV9wb2x5bGluZQCLBxByYXdzaGFwZV90cmltZXNoAIwHFHJhd3NoYXBlX2hlaWdodGZpZWxkAOoFEHJhd3NoYXBlX3NlZ21lbnQAxQURcmF3c2hhcGVfdHJpYW5nbGUA6gQWcmF3c2hhcGVfcm91bmRUcmlhbmdsZQDdBBNyYXdzaGFwZV9jb252ZXhIdWxsAKsHGHJhd3NoYXBlX3JvdW5kQ29udmV4SHVsbACcBxNyYXdzaGFwZV9jb252ZXhNZXNoAO4GGHJhd3NoYXBlX3JvdW5kQ29udmV4TWVzaADoBh5fX3diZ19yYXdzaGFwZWNvbGxpZGVydG9pX2ZyZWUA1gkbcmF3c2hhcGVjb2xsaWRlcnRvaV9ub3JtYWwxANMGFl9fd2JnX3Jhd3JvdGF0aW9uX2ZyZWUA1gkPcmF3cm90YXRpb25fbmV3AJcJFHJhd3JvdGF0aW9uX2lkZW50aXR5ALoJDXJhd3JvdGF0aW9uX3kA8wkUX193YmdfcmF3dmVjdG9yX2ZyZWUA1gkOcmF3dmVjdG9yX3plcm8A9AkNcmF3dmVjdG9yX25ldwCpCQ9yYXd2ZWN0b3Jfc2V0X3kA0AkNcmF3dmVjdG9yX3h5egDJBw1yYXd2ZWN0b3JfeXh6AMoHDXJhd3ZlY3Rvcl96eHkAywcNcmF3dmVjdG9yX3h6eQDMBw1yYXd2ZWN0b3JfeXp4AM0HDXJhd3ZlY3Rvcl96eXgAzgcYX193YmdfcmF3ZXZlbnRxdWV1ZV9mcmVlAFkRcmF3ZXZlbnRxdWV1ZV9uZXcAggcgcmF3ZXZlbnRxdWV1ZV9kcmFpbkNvbnRhY3RFdmVudHMAwQglcmF3ZXZlbnRxdWV1ZV9kcmFpbkludGVyc2VjdGlvbkV2ZW50cwDCCBNyYXdldmVudHF1ZXVlX2NsZWFyAN4GHV9fd2JnX3Jhd3BoeXNpY3NwaXBlbGluZV9mcmVlAL0BFnJhd3BoeXNpY3NwaXBlbGluZV9uZXcAiQgXcmF3cGh5c2ljc3BpcGVsaW5lX3N0ZXAA7wQhcmF3cGh5c2ljc3BpcGVsaW5lX3N0ZXBXaXRoRXZlbnRzAMwDInJhd3BoeXNpY3NwaXBlbGluZV9yZW1vdmVSaWdpZEJvZHkA5gUhcmF3cGh5c2ljc3BpcGVsaW5lX3JlbW92ZUNvbGxpZGVyAPYFG19fd2JnX3Jhd3F1ZXJ5cGlwZWxpbmVfZnJlZQDZBxRyYXdxdWVyeXBpcGVsaW5lX25ldwDhCBdyYXdxdWVyeXBpcGVsaW5lX3VwZGF0ZQD6BhhyYXdxdWVyeXBpcGVsaW5lX2Nhc3RSYXkAnQQkcmF3cXVlcnlwaXBlbGluZV9jYXN0UmF5QW5kR2V0Tm9ybWFsAN4CJXJhd3F1ZXJ5cGlwZWxpbmVfaW50ZXJzZWN0aW9uc1dpdGhSYXkA3gUmcmF3cXVlcnlwaXBlbGluZV9pbnRlcnNlY3Rpb25XaXRoU2hhcGUArgQdcmF3cXVlcnlwaXBlbGluZV9wcm9qZWN0UG9pbnQAswMncmF3cXVlcnlwaXBlbGluZV9pbnRlcnNlY3Rpb25zV2l0aFBvaW50AKcGGnJhd3F1ZXJ5cGlwZWxpbmVfY2FzdFNoYXBlANUBJ3Jhd3F1ZXJ5cGlwZWxpbmVfaW50ZXJzZWN0aW9uc1dpdGhTaGFwZQCcBR9fX3diZ19yYXdkZXNlcmlhbGl6ZWR3b3JsZF9mcmVlALACIHJhd2Rlc2VyaWFsaXplZHdvcmxkX3Rha2VHcmF2aXR5AMYGLnJhd2Rlc2VyaWFsaXplZHdvcmxkX3Rha2VJbnRlZ3JhdGlvblBhcmFtZXRlcnMA3wYjcmF3ZGVzZXJpYWxpemVkd29ybGRfdGFrZUJyb2FkUGhhc2UAgAQkcmF3ZGVzZXJpYWxpemVkd29ybGRfdGFrZU5hcnJvd1BoYXNlALkGH3Jhd2Rlc2VyaWFsaXplZHdvcmxkX3Rha2VCb2RpZXMAkgUicmF3ZGVzZXJpYWxpemVkd29ybGRfdGFrZUNvbGxpZGVycwCdBR9yYXdkZXNlcmlhbGl6ZWR3b3JsZF90YWtlSm9pbnRzAL4EJXJhd3NlcmlhbGl6YXRpb25waXBlbGluZV9zZXJpYWxpemVBbGwAmAQncmF3c2VyaWFsaXphdGlvbnBpcGVsaW5lX2Rlc2VyaWFsaXplQWxsAKUGHHJhd3NlcmlhbGl6YXRpb25waXBlbGluZV9uZXcAlAopcmF3cmF5Y29sbGlkZXJpbnRlcnNlY3Rpb25fY29sbGlkZXJIYW5kbGUA+QcgcmF3cmF5Y29sbGlkZXJ0b2lfY29sbGlkZXJIYW5kbGUA+QcicmF3c2hhcGVjb2xsaWRlcnRvaV9jb2xsaWRlckhhbmRsZQD5BxxyYXdzaGFwZWNvbGxpZGVydG9pX3dpdG5lc3MxANIGHHJhd3NoYXBlY29sbGlkZXJ0b2lfd2l0bmVzczIA0gYbcmF3c2hhcGVjb2xsaWRlcnRvaV9ub3JtYWwyANMGI19fd2JnX3Jhd3NlcmlhbGl6YXRpb25waXBlbGluZV9mcmVlANYJD3Jhd3ZlY3Rvcl9zZXRfeADwCQ9yYXd2ZWN0b3Jfc2V0X3oAxAkccmF3Y29sbGlkZXJzZXRfaXNIYW5kbGVWYWxpZADnBxVyYXdyYXljb2xsaWRlcnRvaV90b2kA8gkXcmF3c2hhcGVjb2xsaWRlcnRvaV90b2kA8gkNcmF3cm90YXRpb25feACMCg1yYXdyb3RhdGlvbl96AOQJDXJhd3JvdGF0aW9uX3cA5QkLcmF3dmVjdG9yX3gAjAoLcmF3dmVjdG9yX3kA8wkLcmF3dmVjdG9yX3oA5AkRX193YmluZGdlbl9tYWxsb2MApgkSX193YmluZGdlbl9yZWFsbG9jAI8KH19fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIAmgsPX193YmluZGdlbl9mcmVlALsKFF9fd2JpbmRnZW5fZXhuX3N0b3JlAMwKCbkNAQBBAQvpBscKlguyCuMBngvsC5sLrQuuC4cLnAu9CJwKqwWkAoYItgq4C50LuwuxC7wL7QvtC2JDRpkL0QnsCzQgWzUlMTjnAb4InQq5C6UJ0gmfC6MJowmkCdcG+wTXB6ULvgWNCdgL5QrZC9cL1QvrCq8LqgqwC8oKygrKCsoK6QjpBrEHuwmDBdoEugSsBegHwgalCJoDswKlA0eNC0WOC32LC0SMC7gLtwrOBpUKkgrEBpcKlQqeCpsKlwqXCpYKmArsC8sKgQj6CIAIlQXsC8AIoAq+C7MLwwvHC9UHzgvIC8ELzQv+B78LsATSC8sLxAvCC9ALuQuVBr0LigjMC9YHygvPC4sIxQuuCNELyQvAC8YLowujCfwI3Qe4C8kBkQvkCusC3wrfCt8K3wrlCu8C3ArcCtwK3ArmCuwC4QrhCuEK4QrnCvAC3greCt4K3gqkC7cD1ArUCtQK1AqcCbMKvgmWCI8GqQa7C6QLtAvUC9UL6AqvC68LsAvYCtgK2ArYCtUGsgfJCP4IuAO2Bd8D3AWFBZYEvwXOAssC5QKMBY8F1AaRA7oBkAuQAdoJpwGPC6YG8wKfBY4GygjWArIEjQnaC+QK2QvXC9UL7AqvC6sKsAvNCs0KzQrNCp4JpgjQB/YJ/gPrBK0DswWJCeoBrgnbA74C8gOeCNsJtQfbCOUI4wiMCcYExAX9BdUL5wrcCdcL1QvpCq8LqQqwC9EK0QrRCtEKwAaOApIDzAaPA8sF7QO/BJoHyAS0B40C+QGdAtwI3AilBKAJyAbvBp8IlQPwBKAI1gvmCrUL1wvVC+oKrwuhCrAL1wrXCtcK1wr0ArwKvQerBowE5gTuA68EhwnHAbEJ2APBAvkDzAW4BuYClgO3BIgHiAe1A6QDrwuwC9oK2graCtoK6gjqBrMHvQnsA9sEmAOtBegHwgalCKIDuAKuA5oFmgX2Av0D3Qn/Bu0B2wLtBMYK2wvtCt8H4Ae7C68L7gqvC7AL2wrbCtsK2wpkvQq+B2mOBOcExAPWBYUBb7QJ0APFAuED5AiyC94JkAfYAqYL8wSNCdwL7wrZC94LuwuvC/AKrwuwC90K3QrdCt0KbXTFB3KNBOAE8APVBXVjrAnRA8AC4AOMBroL2QKmC90L8QryCtAK0ArQCtAKXHDDB4gBiQTjBO8D1AVsbrMJzwPKAuIDqAXfCYAH6gLcAuwEjQnfC/MK2QveC7sLrwuvC7AL4ArgCuAK4AqQAr8Kxwe8C4oE5ATDA9MLgwmMAbUJ3QPIAvcDqQWXBd0Ipwu9A4kH4Av0Cp4F3gvVC/UKrwusCrAL1QrVCtUK1QopogW/B4EKjwTfBM8CugWCCb4BtwnZA8YC9gO0BbQF3wLfAvoCmQa/CfgI+AXtBZAG4Qv2CrYL1wvVC/cKrwutCrAL0wrTCtMK0wqOA8AEwAe7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QCABIANBeGo2AgQgASABKAIAIgNBCGo2AgACfiADKQAAIl9C/////w9YBEAgX6chA0IADAELIAJBAToA0AIgAiBfNwPYAiACQdACaiACQbgIakGwgsAAENgHIQNCAQsgA61CIIaEDAELEI0KrUIghkIBhAsiX0IgiKchVyBfpwRAIFchGQwBCwJ+IBwoAgAiA0EITwRAIAEgA0F4ajYCBCABIAEoAgAiA0EIajYCAAJ+IAMpAAAiX0L/////D1gEQCBfpyEDQgAMAQsgAkEBOgDQAiACIF83A9gCIAJB0AJqIAJBuAhqQbCCwAAQ2AchA0IBCyADrUIghoQMAQsQjQqtQiCGQgGECyJfQiCIpyFYIF+nBEAgWCEZDAELAn4gHCgCACIDQQhPBEAgASADQXhqNgIEIAEgASgCACIDQQhqNgIAAn4gAykAACJfQv////8PWARAIF+nIQNCAAwBCyACQQE6ANACIAIgXzcD2AIgAkHQAmogAkG4CGpBsILAABDYByEDQgELIAOtQiCGhAwBCxCNCq1CIIZCAYQLIl9CIIinIVkgX6cEQCBZIRkMAQsCfiAcKAIAIgNBCE8EQCABIANBeGo2AgQgASABKAIAIgNBCGo2AgACfiADKQAAIl9C/////w9YBEAgX6chCEIADAELIAJBAToA0AIgAiBfNwPYAiACQdACaiACQbgIakGwgsAAENgHIQhCAQsgCK1CIIaEDAELEI0KrUIghkIBhAsiX0IgiKchWiBfp0UNASBaIRkLIABBATYCACAAIBk2AgQMAQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACfiAcKAIAIgNBB00EQBCNCiEDDCILIAEgA0F4ajYCBEEIISwgASABKAIAIgNBCGo2AgAgAykAABD7BSJnQiCIpyEEIGenBEAgBCEDDCILIARBgCAgBEGAIEkbIhMEQCATQThsIgNBCBDICiIsRQ0oC0HYnMAAKAIAIS8CQAJAAkACQAJAAn4gBARAIAJBsAdqQQRyISAgAkHQAmpBBHIhJiACQZwDaiEVIAJB8AFqIR1BACEIAkADQAJAAkACQAJAIBwoAgAiB0EETwRAIAEgB0F8aiIQNgIEIAEgASgCACIDQQRqIis2AgAg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mAcgAiACKQPoBjcDiAcgPiAmKQMANwMAIEMgCSkDADcDACA/IBQpAwA3AwAgICAGKQMANwMAIAIgAikDwAY3A9ACIAJBtAVqIhQgAy0AADoAACACIAIoArgGNgKwBSAKIA1GBEAgDUEBdCIGIA1BAWoiAyAGIANLGyIDQQQgA0EESxutQqgCfiJgQiCIp0VBA3QhBiBgpyEDAkAgDUUEQCACQQA2AuABDAELIAJBCDYC6AEgAiARNgLgASACIA1BqAJsNgLkAQsgAkHwBWogAyAGIAJB4AFqEMEGIAIoAvQFIREgAigC+AUhAyACKALwBUEBRg0DIANBqAJuIQ0LIA4gEWoiAyBcNgIAIANBIGogHTYCACADQQhqIFutIGWENwMAIANBBGogSTYCACADQRhqIGw3AwAgA0EQaiBkNwMAIAwoAgAhHSACKQOYByFkIANBPGogMTYCACADQTRqIGM3AgAgA0EwaiAPNgIAIANBJGogZDcCACADQSxqIB02AgAgCygCACEPIAIpA4gHIWQgA0HYAGogBTYCACADQdAAaiBhNwMAIANBzABqIBI2AgAgA0HIAGogDzYCACADQUBrIGQ3AwAgA0HcAGogAikD0AI3AgAgA0HkAGogPikDADcCACBDKQMAIWMgPykDACFhICApAwAhZCADQf8BakEAOgAAIANB/QFqQQA7AAAgA0H8AGogZDcCACADQfQAaiBhNwIAIANB7ABqIGM3AgAgA0H8AWogGzoAACADQaACaiBIOgAAIANBoQJqICg6AAAgA0GiAmogNToAACADQZwCaiAXNgIAIANBmAJqIB82AgAgA0GUAmogXTYCACADQZACaiAzNgIAIANBjAJqICQ2AgAgA0GIAmogIzYCACADQYQCaiAuNgIAIANBgAJqIDo2AgAgA0H4AWogXjYCACADQfQBaiAiNgIAIANB8AFqIAc2AgAgA0HsAWogX0IgiD4CACADQegBaiBfPgIAIANB5AFqICU2AgAgA0HcAWogYjcCACADQdgBaiAtNgIAIANB0AFqIGY3AwAgA0HMAWogNjYCACADQcgBaiAYNgIAIANBxAFqICo2AgAgA0G8AWogaDcCACADQbgBaiA3NgIAIANBsAFqIG03AwAgA0GsAWogODYCACADQagBaiA9NgIAIANBpAFqIDw2AgAgA0GgAWog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ahDBBiACQdgBaigCACEEIAIoAtQBIQggAigC0AFBAUcEQCADIAg2AgAgA0EEaiAENgIADAELIARFDQEMEQsgBiAIaiAHNgAAIANBCGogBTYCACANQSRqKAIAIQcCQCACKALMASgCACIDQQRqKAIAIgQgA0EIaigCACIGa0EETwRAIAZBBGohBSADKAIAIQgMAQsgBkEEaiIFIAZJDQEgBEEBdCIKIAUgCiAFSxsiCkEIIApBCEsbIQoCQCAERQRAIAJBADYC4AEMAQsgAkHoAWpBATYCACACIAQ2AuQBIAIgAygCADYC4AELIAJB0AFqIApBASACQeABahDBBiACQdgBaigCACEEIAIoAtQBIQggAigC0AFBAUcEQCADIAg2AgAgA0EEaiAENgIADAELIARFDQEMEQsgBiAIaiAHNgAAIANBCGogBTYCACANQTBqKAIAIQQgAkHQAGogAigCzAEgDUE0aigCAEF/aiIMIA1BLGooAgAiCyANQShqKAIAIgVrcRDxBCACKAJUIQMgAigCUA0EIAUgC0cEQANAIAVBGGwgBGoiBkEQaigCACEOIAMgBikDACAGQQhqKAIAEKgDAkAgAygCACIGQQRqIg8oAgAiByAGQQhqIhEoAgAiCmtBBE8EQCAKQQRqIQggBigCACEHDAELIApBBGoiCCAKSQ0DIAdBAXQiCSAIIAkgCEsbIglBCCAJQQhLGyEJAkAgB0UEQCACQQA2AuABDAELIAJBATYC6AEgAiAHNgLkASACIAYoAgA2AuABCyACQdABaiAJQQEgAkHgAWoQwQYgAigC1AEhByACKALYASEJIAIoAtABQQFHBEAgBiAHNgIAIA8gCTYCAAwBCyAJRQ0DIAcgCUGElMMAKAIAIgBBrQYgABsRAAAACyARIAg2AgAgByAKaiAONgAAIAsgBUEBaiAMcSIFRw0ACwsgAkHMAWogDUE4ahC2BCIDDQQgDUHIAGooAgAhBSACQcgAaiACKALMASANQdAAaigCACIEEPEEIAIoAkwhAyACKAJIDQQgBARAIARBA3QgBWohCyADKAIAIgNBCGoiCCgCACEGA0AgBSgCACEMAkAgA0EEaiIHKAIAIgogBmtBBE8EQCAGQQRqIQQgAygCACEJDAELIAZBBGoiBCAGSQ0DIApBAXQiCSAEIAkgBEsbIglBCCAJQQhL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AGogA0EkaikCADcCACAAQYABaiADQdQAaikCADcCACAAQYgBaiADQdwAaigCADYCAAwHCyAAIAdB4PjAABDzBwALIANBDGooAgAiACAHSQRAIABB8AFsIAZqIgAoAjBBAUcNBiAAQfwAaiADQSBqKQIANwIAIABB9ABqIANBGGopAgA3AgAgAEHsAGogA0EQaikCADcCAAwGCyAAIAdBwPzAABDzBwALIANBCGooAgAiACAHSQRAIABB8AFsIAZqIgAoAjBBAUcNBSAAQfwAaiADQRxqKQIANwIAIABB9ABqIANBFGopAgA3AgAgAEHsAGogA0EMaikCADcCAAwFCyAAIAdBgP3AABDzBwALIANBDGooAgAiACAHSQRAIABB8AFsIAZqIgAoAjBBAkcNBCAAQaQBaiADQbABaigCADYCACAAQZwBaiADQagBaikCADcCACAAQZQBaiADQaABaikCADcCACAAQcgBaiADQcwBaioCADgCACAAQbABaiADQdwBaioCADgCAAwECyAAIAdBoITBABDzBwALIANBCGooAgAiACAHSQRAIABB8AFsIAZqIgAoAjBBAkcNAyAAQaQBaiADQaABaigCADYCACAAQZwBaiADQZgBaikCADcCACAAQZQBaiADQZABaikCADcCACAAQcgBaiADQcwBaioCADgCACAAQbABaiADQbABaioCADgCAAwDCyAAIAdB0ITBABDzBwALIANBDGooAgAiACAHSQRAIABB8AFsIAZqIgIoAjBBA0cNAiACQaQBaiADQbABaiIAKAIANgIAIAJBnAFqIANBqAFqKQIANwIAIAJBlAFqIANBoAFqKQIANwIAIAJBzAFqIANBrAFqKgIAIiEgA0HoAWoqAgCUIAAqAgAiICADQfQBaioCAJSSOAIAIAJByAFqICEgA0HkAWoqAgCUICAgA0HwAWoqAgCUkjgCACACQcQBaiAhIANB4AFqKgIAlCAgIANB7AFqKgIAlJI4AgAgAkHYAWogA0HQAWooAgA2AgAgAkHQAWogA0HIAWopAgA3AgAgAkHAAWogA0HEAWoqAgA4AgAgAkG8AWogA0G8AWoqAgA4AgAMAgsgACAHQciIwQAQ8wcACyADQQhqKAIAIgAgB08NCiAAQfABbCAGaiIAKAIwQQNHDQAgAEGkAWogA0GgAWooAgA2AgAg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IAwpAwA3AwAgAkEQaiANKQMANwMAIAJBCGogAykDADcDACAIIAgpA8gBNwOgBCAEIAspAwA3AwAgBSAOKQMANwMAIAogDykDADcDACAJIBApAwA3AwAgDCASKQMANwMAIA0gFCkDADcDACADIBUpAwA3AwAgCCAIKQPgAzcDyAECQCAIQcACaigCACIEIAhBxAJqKAIAIgBHBEAgCCgCvAIhBQwBCyAAQQFqIgIgAEkNGSAAQQF0IgMgAiADIAJLGyICQQQgAkEESxsiAiACQf///x9xRkECdCEDIAJBBnQhAgJAIABFBEAgCEEANgKgAwwBCyAIQagDakEENgIAIAggCCgCvAI2AqADIAggAEEGdDYCpAMLIAhB4AJqIAIgAyAIQaADahDBBiAIQegCaigCACECIAgoAuQCIQUgCCgC4AJBAUcEQCAIIAU2ArwCIAggAkEGdiIENgLAAgwBCyACRQ0ZDBwLIABBBnQgBWoiAiAIKQPIATcCACACQShqIAhByAFqIgNBKGoiCikDADcCACACQSBqIANBIGoiCSkDADcCACACQRhqIANBGGoiDCkDADcCACACQRBqIANBEGoiDSkDADcCACACQQhqIANBCGoiCykDADcCACACQThqIANBOGoiDikDADcCACACQTBqIANBMGoiAykDADcCACAIIABBAWoiDzYCxAIgDiAIQaAEaiICQThqKQMANwMAIAMgAkEwaikDADcDACAKIAJBKGopAwA3AwAgCSACQSBqKQMANwMAIAwgAkEYaikDADcDACANIAJBEGopAwA3AwAgCyACQQhqKQMANwMAIAggCCkDoAQ3A8gBAkAgBCAPRgRAIARBAWoiAiAESQ0aIARBAXQiECACIBAgAksbIgJBBCACQQRLGyICIAJB////H3FGQQJ0IRAgAkEGdCECAkAgBEUEQCAIQQA2AqADDAELIAhBqANqQQQ2AgAgCCAFNgKgAyAIIARBBnQ2AqQDCyAIQeACaiACIBAgCEGgA2oQwQYgCEHoAmooAgAhAiAIKALkAiEFIAgoAuACQQFGDQEgCCAFNgK8AiAIIAJBBnY2AsACCyAPQQZ0IAVqIgIgCCkDyAE3AgAgAkEoaiAKKQMANwIAIAJBIGogCSkDADcCACACQRhqIAwpAwA3AgAgAkEQaiANKQMANwIAIAJBCGogCykD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NwLEBCADQSBqIgsgAUEsaigCADYCACADQRhqIgEgCCkCnAU3AwAgA0EsaiAEKAIANgIAIAggBSkDADcC3AQgCiADQShqKQMANwMAIAQgCykDADcDACAFIAEpAwA3AwAgBiADQRBqKQMANwMAIA0gCSkDADcDACAIIAgpA7gENwP4BAsgACACNgIAIAAgCCkD+AQ3AgQgAEE0aiAmOAIAIABBDGogCEH4BGoiAUEIaikDADcCACAAQRRqIAhBiAVqKQMANwIAIABBHGogAUEYaikDADcCACAAQSRqIAhBmAVqKQMANwIAIABBLGogCEGgBWopAwA3AgAMGAtBBEEEQcjowQAQ8wcAC0ECQQJBvOLBABDzBwALIANBJGwgAWoiASAnOAIYIAEgBzgCDCABICYgKpM4AgggASApICuTOAIEIAEgByAnkzgCACABQSBqICo4AgAgAUEcaiArOAIAIAFBFGogJjgCACABQRBqICk4AgAgCCADQQFqIgE2AtACCyAIKALIAiEEIAhBAjYCgAQgCEKAgICAEDcC+AMgCEEBNgLABCAIQoGAgIAQNwK4BCAIQfgEaiIDIAQgASAIQfgDaiIEIAhBuARqIgEQ5wIgBEE4aiIOIANBOGoiBSkDADcDACAEQTBqIg8gA0EwaiIGKQMANwMAIARBKGoiECADQShqIgspAwA3AwAgBEEgaiIRIANBIGoiCikDADcDACAEQRhqIhYgA0EYaiIJKQMANwMAIARBEGoiFyADQRBqIgwpAwA3AwAgBEEIaiISIANBCGoiBCkDADcDACAIIAgpA/gENwP4AyAIKALQAiEUIAgoAsgCIRUgCEEBNgLAAyAIQoCAgIAgNwK4AyAIQQA2AsAEIAhCADcCuAQgAyAVIBQgCEG4A2ogARDnAiABQThqIAUpAwA3AwAgAUEwaiAGKQMANwMAIAFBKGogCykDADcDACABQSBqIAopAwA3AwAgAUEYaiAJKQMANwMAIAFBEGogDCkDADcDACABQQhqIAQpAwA3AwAgCCAIKQP4BDcDuAQgBSAOKQMANwMAIAYgDykDADcDACALIBApAwA3AwAgCiARKQMANwMAIAkgFikDADcDACAMIBcpAwA3AwAgBCASKQMANwMAIAggCCkD+AM3A/gEAkAgCCgC2AIiAyAIKALcAiIBRwRAIAgoAtQCIQYM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QAJAIBMgBkEIaigCACIITQ0AIAhBqAJsIAtqIgkoAgBBAUcNACAJQQhqKQMAIAYpAwBRDQULIA0gBkEQaiIGRw0ACwsgA0EBaw4CAwEECyAKQRBqIQoMBAsgACgCLCIGIABBMGoiCSgCACIIRg0NIAAqAkghIyAAQThqIQ4gAEE0aiEQA0AgACAOKAIAQX9qIAZBAWpxIgs2AiwgACgCKCIRIBAoAgAgBkECdGooAgAiA0sEfyAAKAIgIQggBUL////7////v383A6gDIAVC////+/f//79/NwOgAyAFQv////v3//+//wA3A5gDIAVC////+////79/NwOQAyAFQv////v3//+/fzcDiAMgBUL////79///v/8ANwOAAyAFQv////v///+/fzcD+AIgBUL////79///v383A/ACIAVC////+/f//7//ADcD6AIgBUL////7////v383A+ACIAVC////+/f//79/NwPYAiAFQv////v3//+//wA3A9ACIANBB3QgCGoiDEHgAGohCiAMQfgAaiETIAEoAhAhEiABKAIIIRQgAigCECEVIAIoAgghFiAAKAI8IRkgACgCRCEaQQAhAwJAAkADQAJAIAooAgAhBiAFQdACaiADaiEHAkAgEy0AAEUEQCARIAZNDQEgBUHQA2oiDSAGQQd0IAhqELQDIAdBEGogDUEQaikDADcCACAHQQhqIA1BCGopAwA3AgAgByAFKQPQAzcCAAwBCyAaIAZNDQAgFSAGQRhsIBlqIg1BCGooAgAiBk0NASAGQZgBbCAWaiIGKAIAQQFHDQEgBkEIaikDACANKQMAUg0BIBIgBkEYaigCACINTQ0DIA1BqAJsIBRqIg0oAgBBAUcNAyANQQhqKQMAIAZBEGopAwBSDQMgBUHQA2oiFyANQRBqIAQQxQEgBSAFKgLcAyImIAZB1ABqKgIAIiKUIAUqAtADIiAgBkHIAGoqAgAiJZSTIAUqAtQDIiEgBkHMAGoqAgAiJ5STIAUqAtgDIiQgBkHQAGoqAgAiKJSTOALcASAFICQgIpQgICAnlCAmICiUkiAhICWUk5I4AtgBIAUgJCAllCAhICKUICYgJ5QgICAolJOSkjgC1AEgBSAhICiUICYgJZQgICAilJKSICQgJ5STOALQASAgIAZB3ABqKgIAIieUICEgBkHYAGoqAgAiKJSTIiIgIpIhIiAkICiUIAZB4ABqKgIAIikgIJSTIiUgJZIhJSAFIAUqAugDICkgJiAilCAgICWUICEgISAplCAkICeUkyIpICmSIimUk5KSkjgC6AEgBSAFKgLkAyAnICYgJZQgJCAplCAgICKUk5KSkjgC5AEgBSAFKgLgAyAoICkgJpQgISAilCAkICWUk5KSkjgC4AEgBUHIAWoiGCAGQTBqIg1BBGoiGygCACIcNgIEIBggDSgCACAcKAIIQQdqQXhxajYCACAFQbgDaiAFKALIASAGQeQAaiAFKALMASgCGBEBACAFQcABaiIGIBsoAgAiGDYCBCAGIA0oAgAgGCgCCEEHakF4cWo2AgAgFyAFKALAASAFQdABaiAFKALEASgCGBEBACAHQRRqIAUqAswDIiAgBSoC5AMiISAgICFgGzgCACAHQRBqIAUqAsgDIiAgBSoC4AMiISAgICFgGzgCACAHQQxqIAUqAsQDIiAgBSoC3AMiISAgICFgGzgCACAHQQhqIAUqAsADIiAgBSoC2AMiISAgICFfGzgCACAHQQRqIAUqArwDIiAgBSoC1AMiISAgICFfGzgCACAHIAUqArgDIiAgBSoC0AMiISAgICFfGzgCAAsgCkEEaiEKIANBGGoiA0HgAEcNAQwDCwtB9OHAAEETQZyxwQAQuAgAC0H04cAAQRNBrLHBABC4CAALIAVB0AFqIgMgBUHQAmpB4AAQogkaIAVB0ANqIgYgAxCfBCADIAwgBhDtAgJAAkAgBS0A0AFFDQAgBS0A0QFFDQAgBS0A0wFFDQAgBS0A0gFFDQAgCSgCACEIDAELIAwgBUHQA2pB4AAQyAchAyAFICM4AtwBIAUgIzgC2AEgBSAjOALUASAFICM4AtABIAMgBUHQAWoQjwIgAygCcCEDIA4oAgAiBkF/aiEIIAYgCSgCACIGIAtrIAhxa0EBRgRAIA8QwwQgDigCAEF/aiEIIAkoAgAhBgsgCSAGQQFqIAhxIgg2AgAgECgCACAGQQJ0aiADNgIACyAMQQA6AHkgDygCAAUgCwsiBiAIRw0ACwwNCyAGQRBqIQZBACEKDAILIAAoAiwiBiAAQTBqIgkoAgAiCEYNCyAAKgJIISYgAEE4aiEOIABBNGohEANAIAAgDigCAEF/aiAGQQFqcSILNgIsIAAoAigiESAQKAIAIAZBAnRqKAIAIgNLBH8gACgCICENIAVC////+////79/NwOoAyAFQv////v3//+/fzcDoAMgBUL////79///v/8ANwOYAyAFQv////v///+/fzcDkAMgBUL////79///v383A4gDIAVC////+/f//7//ADcDgAMgBUL////7////v383A/gCIAVC////+/f//79/NwPwAiAFQv////v3//+//wA3A+gCIAVC////+////79/NwPgAiAFQv////v3//+/fzcD2AIgBUL////79///v/8ANwPQAiADQQd0IA1qIgxB4ABqIQogDEH4AGohEyABKAIQIRIgASgCCCEUIAIoAhAhFSACKAIIIRYgACgCPCEZIAAoAkQhGkEAIQMCQAJAA0ACQCAKKAIAIQYgBUHQAmogA2ohBwJAIBMtAABFBEAgESAGTQ0BIAVB0ANqIgggBkEHdCANahC0AyAHQRBqIAhBEGopAwA3AgAgB0EIaiAIQQhqKQMANwIAIAcgBSkD0AM3AgAMAQsgGiAGTQ0AIBUgBkEYbCAZaiIIQQhqKAIAIgZNDQEgBkGYAWwgFmoiBigCAEEBRw0BIAZBCGopAwAgCCkDAFINASASIAZBGGooAgAiCE0NAyAIQagCbCAUaiIIKAIAQQFHDQMgCEEIaikDACAGQRBqKQMAUg0DIAhBzABqKgIAISkgCEHQAGoqAgAhKiAIQdQAaioCACErIAUgCEHIAGoqAgAiJCAGQdQAaioCACIjlCAIQTxqKgIAIgQgBkHIAGoqAgAiIpSTIAhBQGsqAgAiICAGQcwAaioCACIllJMgCEHEAGoqAgAiISAGQdAAaioCACInlJM4AtwDIAUgISAjlCAEICWUICQgJ5SSICAgIpSTkjgC2AMgBSAhICKUICAgI5QgJCAllCAEICeUk5KSOALUAyAFICAgJ5QgJCAilCAEICOUkpIgISAllJM4AtADIAQgBkHcAGoqAgAiJZQgICAGQdgAaioCACInlJMiIyAjkiEjICEgJ5QgBCAGQeAAaioCACIolJMiIiAikiEiIAUgKyAoICQgI5QgBCAilCAgICAgKJQgISAllJMiKCAokiIolJOSkpI4AugDIAUgKiAlICQgIpQgISAolCAEICOUk5KSkjgC5AMgBSApICcgJCAolCAgICOUICEgIpSTkpKSOALgAyAF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AAALIAggAUGElMMAKAIAIgBBrQYgABsRAAAACyADIAFBhJTDACgCACIAQa0GIAAbEQAAAAsQlAsACyADQQd0IAZqIAVB0ANqIgZB4AAQogkiAUH0AGogBzoAACABIAg2AnAgBUG/AmotAAAhByAFLwC9AiEIIAFBADsBeCABQfcAaiAHOgAAIAEgCDsAdSABIAUoAbYCNgF6IAFB/gBqIAVBugJqLwEAOwEAIAFB6ABqQn83AwAgAUKBgICAcDcDYCAAIANBAWo2AiggBUEwaiIBQQA6AAQgAUEANgIAIAYgDCACIAkgBSgCwAIgBSgCyAIgBSgCMCAFLQA0ICsQXSAFQbgDaiIBQRBqIAVB5ANqKQIAIh03AwAgAUEIaiAFQdwDaikCACIeNwMAIAUgBSkC1AMiHzcDuAMgDEEQaiAdNwIAIAxBCGogHjcCACAMIB83AgAgBUHQAWoiAUEQaiAdNwMAIAFBCGogHjcDACAFQagCakL////7////v383AwAgBUGgAmpC////+/f//79/NwMAIAVBkAJqQv////v///+/fzcDACAFQYgCakL////79///v383AwAgBUH4AWpC////+////79/NwMAIAVB8AFqQv////v3//+/fzcDACAFIB83A9ABIAVC////+/f//7//ADcDmAIgBUL////79///v/8ANwOAAiAFQv////v3//+//wA3A+gBIAYgARCfBCAAKAIoBEAgACgCICAFQdADakHgABCiCRoCQCAFKALEAiIARQ0AIAUoAsACIgFFDQAgAEEYbEUNACABEMwBCyALRQ0DIAtBAnRFDQMgAhDMAQwDCwwHCyADQQd0IAZqIAVB0ANqIgZB4AAQogkiAUH0AGogBzoAACABIAg2AnAgBUG/AmotAAAhByAFLwC9AiEIIAFBADsBeCABQfcAaiAHOgAAIAEgCDsAdSABIAUoAbYCNgF6IAFB/gBqIAVBugJqLwEAOwEAIAFB6ABqQn83AwAgAUKBgICAcDcDYCAAIANBAWo2AiggBUEIaiIBQQA6AAQgAUEANgIAIAYgDCACIAkgBSgCwAIgBSgCyAIgBSgCCCAFLQAMIAQQXSAFQbgDaiIBQRBqIAVB5ANqKQIAIh03AwAgAUEIaiAFQdwDaikCACIeNwMAIAUgBSkC1AMiHzcDuAMgDEEQaiAdNwIAIAxBCGogHjcCACAMIB83AgAgBUHQAWoiAUEQaiAdNwMAIAFBCGogHjcDACAFQagCakL////7////v383AwAgBUGgAmpC////+/f//79/NwMAIAVBkAJqQv////v///+/fzcDACAFQYgCakL////79///v383AwAgBUH4AWpC////+////79/NwMAIAVB8AFqQv////v3//+/fzcDACAFIB83A9ABIAVC////+/f//7//ADcDmAIgBUL////79///v/8ANwOAAiAFQv////v3//+//wA3A+gBIAYgARCfBCAAKAIoBEAgACgCICAFQdADakHgABCiCRoCQCAFKALEAiIARQ0AIAUoAsACIgFFDQAgAEEYbEUNACABEMwBCyALRQ0CIAtBAnRFDQIgAhDMAQwCCwwGCyADQQd0IAZqIAVB0ANqIgZB4AAQogkiAUH0AGogBzoAACABIAg2AnAgBUG/AmotAAAhByAFLwC9AiEIIAFBADsBeCABQfcAaiAHOgAAIAEgCDsAdSABIAUoAbYCNgF6IAFB/gBqIAVBugJqLwEAOwEAIAFB6ABqQn83AwAgAUKBgICAcDcDYCAAIANBAWo2AiggBUHgAGoiAUEAOgAEIAFBADYCACAGIAwgAiAJIAUoAsACIAUoAsgCIAUoAmAgBS0AZCAsEF0gBUG4A2oiAUEQaiAFQeQDaikCACIdNwMAIAFBCGogBUHcA2opAgAiHjcDACAFIAUpAtQDIh83A7gDIAxBEGogHTcCACAMQQhqIB43AgAgDCAfNwIAIAVB0AFqIgFBEGogHTcDACABQQhqIB43AwAgBUGoAmpC////+////79/NwMAIAVBoAJqQv////v3//+/fzcDACAFQZACakL////7////v383AwAgBUGIAmpC////+/f//79/NwMAIAVB+AFqQv////v///+/fzcDACAFQfABakL////79///v383AwAgBSAfNwPQASAFQv////v3//+//wA3A5gCIAVC////+/f//7//ADcDgAIgBUL////79///v/8ANwPoASAGIAEQnwQgACgCKEUNBSAAKAIgIAVB0ANqQeAAEKIJGgJAIAUoAsQCIgBFDQAgBSgCwAIiAUUNACAAQRhsRQ0AIAEQzAELIAtFDQAgC0ECdEUNACACEMwBCyAFQbAEaiQADwsgBiABQYSU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NwMAIARCADcCxAFBACEFIARBlL/BACgCACIINgLkASAEIAg2AtgBIAQgCDYCzAEgBCAINgLAASADQSRqIRkCQAJAAkACQCAEKAK8ASIKQX9GDQAgCkEBaiERIARBIGohEkEAIQdBACEDAkACQAJAA0AgB0GQAUYNDiADQQFqIQUgBEGIBGoiCUEgaiILIAcgEmoiEEEgaigCADYCACAJQRhqIhQgEEEYaikCADcDACAJQRBqIg0gEEEQaikCADcDACAJQQhqIg4gEEEIaikCADcDACAEIBApAgA3A4gEIAMgBkYEQCAGQQF0IgMgBSADIAVLGyIDQQQgA0EESxutQiR+IihCIIinRUECdCEJICinIQMCQCAGRQRAIARBADYCyAMMAQsgBEEENgLQAyAEIAg2AsgDIAQgBkEkbDYCzAMLIARBiANqIAMgCSAEQcgDahDFBiAEKAKMAyEIIAQoApADIQMgBCgCiANBAUYNAiAEIAg2AsABIAQgA0EkbiIGNgLEAQsgByAIaiIDIAQpA4gENwIAIANBIGogCygCADYCACADQRhqIBQpAwA3AgAgA0EQaiANKQMANwIAIANBCGogDikDADcCACAEIAU2AsgBIAxBAmohDCAHQSRqIQcgESAFIgNHDQALIAoOBAYCAwEDCyADRQ0hDCcLIAdByABGDQwgBCgCwAEiCioCACErIAoqAmwgK5MgCkEoaioCACAKKgIEIi2TIiogCkHQAGoqAgAgCioCCCIskyI1lCAKQSxqKgIAICyTIikgCkHMAGoqAgAgLZMiNJSTlCApIAoqAkggK5MiL5QgCioCJCArkyIpIDWUkyAKQfAAaioCACAtk5SSICkgNJQgKiAvlJMgCkH0AGoqAgAgLJOUkkMAAAAAXkEBc0UEQCAKQSRqIgYpAgAhKCAGIApByABqIgwpAgA3AgAgBEGIBGoiA0EgaiIRIAZBIGoiEigCADYCACADQRhqIgsgBkEYaiIUKQIANwMAIANBEGoiDSAGQRBqIgcpAgA3AwAgA0EIaiIOIAZBCGoiAykCADcDACADIAxBCGoiCSkCADcCACAHIAxBEGoiBikCADcCACAUIAxBGGoiBykCADcCACASIAxBIGoiAygCADYCACAEICg3A4gEIAwgBCkDiAQ3AgAgAyARKAIANgIAIAcgCykDADcCACAGIA0p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IAQgBUEGdDYC5AQLIARB0ARqIAMgBiAEQeAEahDFBiAEQdgEaigCACEDIAQoAtQEIQcgBCgC0ARBAUYNASAEIAc2AswBIAQgA0EGdiIFNgLQAQsgC0EGdCAHaiIDIAQpA4gENwIAIANBKGogEykDADcCACADQSBqIAgpAwA3AgAgA0EYaiAQKQMANwIAIANBEGogCikDADcCACADQQhqIAwpAwA3AgAgA0E4aiARKQMANwIAIANBMGogEikDADcCACAEIA9BAmoiCzYC1AEgESAEQYgDaiIDQThqKQMANwMAIBIgA0EwaikDADcDACATIANBKGopAwA3AwAgCCADQSBqKQMANwMAIBAgA0EYaikDADcDACAKIANBEGopAwA3AwAgDCADQQhqKQMANwMAIAQgBCkDiAM3A4gEIAUgC0cNAyAFQQFqIgYgBUkNGiAFQQF0IgMgBiADIAZLGyIDQQQgA0EESxsiAyADQf///x9xRkECdCEGIANBBnQhAyAFDQEgBEEANgLgBAwCCyADRQ0ZDB0LIARB6ARqQQQ2AgAgBCAHNgLgBCAEIAVBBnQ2AuQECyAEQdAEaiADIAYgBEHgBGoQxQYgBEHYBGooAgAhAyAEKALUBCEHIAQoAtAEQQFGDQEgBCAHNgLMASAEIANBBnYiBTYC0AELIAtBBnQgB2oiBiAEKQOIBDcCACAGQShqIARBiARqIgNBKGoiEykDADcCACAGQSBqIANBIGoiCCkDADcCACAGQRhqIANBGGoiECkDADcCACAGQRBqIANBEGoiCikDADcCACAGQQhqIANBCGoiDCkDADcCACAGQThqIANBOGoiESkDADcCACAGQTBqIANBMGoiEikDADcCACAEIA9BA2oiCzYC1AEgESAEQcgDaiIDQThqKQMANwMAIBIgA0EwaikDADcDACATIANBKGopAwA3AwAgCCADQSBqKQMANwMAIBAgA0EYaikDADcDACAKIANBEGopAwA3AwAgDCADQQhqKQMANwMAIAQgBCkDyAM3A4gEIAUgC0cNAyAFQQFqIgYgBUkNFiAFQQF0IgMgBiADIAZLGyIDQQQgA0EESxsiAyADQf///x9xRkECdCEGIANBBnQhAyAFDQEgBEEANgLgBAwCCyADRQ0VDBkLIARB6ARqQQQ2AgAgBCAHNgLgBCAEIAVBBnQ2AuQE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A0EoaikDADcDACAUIANBIGopAwA3AwAgFSADQRhqKQMANwMAIAsgA0EQaikDADcDACAMIANBCGopAwA3AwAgBCAEKQPIAzcDiAQCQCAHIAlGBEAgCUEBaiIFIAlJDRQgCUEBdCIDIAUgAyAFSxsiA0EEIANBBEsbIgMgA0H///8fcUZBAnQhBSADQQZ0IQMCQCAJRQRAIARBADYCyAIMAQsgBEHQAmpBBDYCACAEIAY2AsgCIAQgCUEGdDYCzAILIARBiAJqIAMgBSAEQcgCahDFBiAEQZACaigCACEDIAQoAowCIQYgBCgCiAJBAUYNASAEIAY2AswBIAQgA0EGdjYC0AELIAdBBnQgBmoiAyAEKQOIBDcCACADQShqIBIpAwA3AgAgA0EgaiAUKQMANwIAIANBGGogFSkDADcCACADQRBqIAspAwA3AgAgA0EIaiAMKQMANwIAIANBOGogDSkDADcCACADQTBqIA4pAwA3AgAgBCAPQQJqNgLUASAbQQBDAAAAABDmAyAbQQFDAAAAABDmAwwCCyADRQ0SDBgLIBNBBnQgCGoiBiAEKQOIBDcCACAGQShqIARBiARqIgNBKGoiCSkDADcCACAGQSBqIANBIGoiECkDADcCACAGQRhqIANBGGoiCikDADcCACAGQRBqIANBEGoiDykDADcCACAGQQhqIANBCGoiEikDADcCACAGQThqIANBOGoiFCkDADcCACAGQTBqIANBMGoiFSkDADcCACAEIBNBAWoiCzYC1AEgFCAEQcgCaiIDQThqKQMANwMAIBUgA0EwaikDADcDACAJIANBKGopAwA3AwAgECADQSBqKQMANwMAIAogA0EYaikDADcDACAPIANBEGopAwA3AwAgEiADQQhqKQMANwMAIAQgBCkDyAI3A4gEAkACQAJAAkACQAJAAkACQAJAIAUgC0YEQCAFQQFqIgYgBUkNGyAFQQF0IgMgBiADIAZLGyIDQQQgA0EESxsiAyADQf///x9xRkECdCEGIANBBnQhAwJAIAVFBEAgBEEANgLgBAwBCyAEQegEakEENgIAIAQgCDYC4AQgBCAFQQZ0NgLkBAsgBEHQBGogAyAGIARB4ARqEMUGIARB2ARqKAIAIQUgBCgC1AQhCCAEKALQBEEBRg0BIAQgCDYCzAEgBCAFQQZ2IgU2AtABCyALQQZ0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4sEAEPMHAAtBAEEAQdziwQAQ8wcAC0EAQQBBzOLBABDzBwALIAkgBUHM5MEAEPMHAAsgBCgC1AEiASARTQ0BIARByANqIgEgBCgCzAEgEUEGdGogBCgCwAEgBCgCyAEQkwQgBEGIBGoiA0EIaiICIAFBCGooAgA2AgAgA0EUaiABQRRqKAIANgIAIAQgBCkC1AM3ApQEIARB8AFqIgFBCGogAikDADcDACABQRBqIANBEGopAwA3AwAgBCAEKQPIAzcD8AELIAAgBCkD8AE3AgAgAEEIaiAEQfgBaigCADYCACAAQQE6AAwgBEHAAWoQogYMBAsgESABQdzjwQAQ8wcACxCUCwALQwAAAAAhIkMAAAAAISNDAAAAACEmCyAAICI4AgggACAjOAIEIAAgJjgCACAAQQA6AAwLIARB8ARqJAAPCyAIIAVBhJTDACgCACIAQa0GIAAbEQAAAAsgBEEANgKIBCADQQhqIARByANqIARBiARqQdzhwQAQ/wcACyAGIANBhJTDACgCACIAQa0GIAAbEQAAAAv7WQMcfwF+E30jAEHwBGsiBCQAIARBGGpBADYCACAEQbgBakEANgIAIARCADcDECAEQgA3A7ABIARCgoCAgDA3AwggBEKAgICAEDcDACAEQcQAakEAQewAEOMJGkMAAIA/IScgAioCACIsICyUIAIqAgQiKiAqlJIgAioCCCIoICiUkkMAAAAAkiIlQwAAgCheQQFzRQRAICggJRCdASIhlSErICwgIZUhJyAqICGVISELICEgKyArlCAhICGUICcgJ5SSkkMAAAAAkhCdASIhlSEjAkACfSArICGVIiIgIpQgJyAhlSIpICmUQwAAAACSkkMAAAAAkhCdASIlQwAAAABbBEAgASoCACIlICOYDAELICIgIiAllSABKgIEIiGUIiSUICkgKSAllSAhlCImlCAjIAEqAgAiJZQiIZOSICFdQQFzBEAgJYwhIQwCC0MAAAAAISQgJQshIUMAAAAAISYLIARBQGsgKDgCACAEQTxqICo4AgAgBEE4aiAsOAIAIARBNGogJCAiIAEqAggiLZSSIiI4AgAgBEEwaiAhICMgLZSSIiQ4AgAgBEEsaiAmICkgLZSSIiE4AgAgBEEoaiAiICiTOAIAIARBJGogJCAqkzgCACAEQQA2ArwBIARBADYCHCAEICEg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QcwBakIANwIAIAtBIGogC0E8aikCADcCACALQShqIAtBxABqKQIANwIAIAtBMGogC0HMAGopAgA3AgAgC0E4aiALQdQAaigCADYCACAGENQCCyATIAxBEGoiDEcNAAsLIAAgDioCLCADIAQgBSAGIAkgCkEAELwCIAVBADYCQCAaDQALIAAtAMgDBEAgACkDCEIBUQRAIABBEGorAwAhaxDDBiFsIAAgACsDACBsIGuhoDkDAAsgAEIANwMICyAOQZABaiQAC/5OAzF/A34IfSMAQfAAayIKJAAgACgCHEEBRwRAIABBIGogAkEgahDNAzYCACAAQQE2AhwLIAApAhwhNSAAQQA2AhwCQAJAAkACQAJAAkACQAJAIDWnBEAgAkHQAGooAgAiBCA1QiCIpyIPSwRAAkAgAkEwaigCACIRRQ0AIAJBNGooAgBBf2oiEiACQSxqKAIAIAJBKGooAgAiGmtxIhQgAkHIAGooAgAgD0EDdGooAgQgAkEgaigCAGsiDE0NACAAQRhqKAIAIQ0gACgCECEWIAAoAgAhFSAAKAIIIRgDQAJAIAwgGmogEnFBGGwgEWooAhAiBEF/Rg0AIBggBEsEQCANIARBOGwgFWoiBC0ANCIGSwRAIARBIGoqAgAgBEEcaiITKgIAIAZBBnQgFmoiGSoCACI5lSE7An8CQCAEKgIYIDmVjiI6QwAAAM9gIgZBAXMNACA6Q////05fQQFzDQAgOqgMAQtB/////wdBgICAgHggBhsiBSAFQQAgOkP///9OXxsgBhsLIQYgOZUhPAJ/IDuOIjpDAAAAz2AiBUEBc0VBACA6Q////05fG0UEQEH/////B0GAgICAeCAFGyIJIAlBACA6Q////05fGyAFGwwBCyA6qAshCQJ/IDyOIjpDAAAAz2AiBUEBc0VBACA6Q////05fG0UEQEH/////B0GAgICAeCAFGyILIAtBACA6Q////05fGyAFGwwBCyA6qAshCyAEQSxqKgIAIARBKGoiDioCACA5lSE7An8CQCAEQSRqIhsqAgAgOZWOIjpDAAAAz2AiBUEBcw0AIDpD////Tl9BAXMNACA6qAwBC0H/////B0GAgICAeCAFGyIQIBBBACA6Q////05fGyAFGwshECA5lSE6An8gO44iOUMAAADPYCIFQQFzRUEAIDlD////Tl8bRQRA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7ABqKAIAIBBNDQEgBEHoAGooAgAgB00NAUG6t8EAQbu3wQAgBCgCYCAHQQJ0aigCACAWcRstAABFDQMgBCAEKAKMAUF/aiIENgKMASAEDQMgCkHIAGoiICAIQQRqIgRBCGooAgA2AgAgCiAEKQIANwNAIBgoAgAiBCAZKAIARwRAIAkoAgAhCAwDCyAEQQFqIgsgBEkNDyAEQQF0IgggCyAIIAtLGyILQQQgC0EESxutQgx+IjVCIIinRUECdCELIDWnIQgCQCAERQRAIApBADYCCAwBCyAKQQQ2AhAgCiAEQQxsNgIMIAogCSgCADYCCAsgCkHQAGogCCALIApBCGoQwQYgCigCVCEIIAooAlghCyAKKAJQQQFHBEAgCSAINgIAIBkgC0EMbjYCAAwDCyALRQ0PIAggC0GElMMAKAIAIgBBrQYgABsRAAAACyAEIA9B9KLBABDzBwALQazawABBE0HEpsEAELgIAAsgBEEMbCAIaiILIAopA0A3AgAgC0EIaiAgKAIANgIAIBggBEEBajYCAAsgBiAGQRRqIAYgEUYiCxshBEEAIAYgCxsiCA0ACwsgACANEKABIQcgACgCCCIGIAUoAgAiBE0NASAAKAIAIARBOGxqIAc6ADQLIA4oAgAiBiAHQf8BcSIESwRAID0gACgCECAEQQZ0aiIRKgIAIj2VITggBSgCAAJ/AkAgPiA9lY4iPkMAAADPYCIGQQFzDQAgPkP///9OX0EBcw0AID6oDAELQf////8HQYCAgIB4IAYbIgUgBUEAID5D////Tl8bIAYbCyEGIDsgPZUhPgJ/IDiOIjtDAAAAz2AiBUEBc0VBACA7Q////05fG0UEQEH/////B0GAgICAeCAFGyIJIAlBACA7Q////05fGyAFGwwBCyA7qAshCQJ/ID6OIjtDAAAAz2AiBUEBc0VBACA7Q////05fG0UEQEH/////B0GAgICAeCAFGyILIAtBACA7Q////05fGyAFGwwBCyA7qAshCyA6ID2VITsCfwJAIDwgPZWOIjpDAAAAz2AiBUEBcw0AIDpD////Tl9BAXMNACA6qAwBC0H/////B0GAgICAeCAFGyIQIBBBACA6Q////05fGyAFGwshECA5ID2VIToCfyA7jiI5QwAAAM9gIgVBAXNFQQAgOUP///9OXxtFBEBB/////wdBgICA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BUsbIgRBCCAEQQhLGyEEAkAgAEUEQCADQQA2AlAMAQsgA0HYAGpBATYCACADIAA2AlQgAyABKAIANgJQCyADQUBrIARBASADQdAAahDBBiADQcgAaigCACEEIAMoAkQhACADKAJAQQFHBEAgASAANgIAIAFBBGogBDYCAAwhCyAERQ0iDCYLIAIoAgAiAUEEaigCACIAIAFBCGooAgAiBmtBBE8EQCAGQQRqIQUgASgCACEADB8LIAZBBGoiBSAGSQ0hIABBAXQiBCAFIAQgBUsbIgRBCCAEQQhLGyEEAkAgAEUEQCADQQA2AlAMAQsgA0HYAGpBATYCACADIAA2AlQgAyABKAIANgJQCyADQUBrIARBASADQdAAahDBBiADQcgAaigCACEEIAMoAkQhACADKAJAQQFHBEAgASAANgIAIAFBBGogBDYCAAwfCyAERQ0hDCULIAIoAgAiAUEEaigCACIAIAFBCGooAgAiBmtBBE8EQCAGQQRqIQUgASgCACEADBwLIAZBBGoiBSAGSQ0gIABBAXQiBCAFIAQgBUsbIgRBCCAEQQhLGyEEAkAgAEUEQCADQQA2AlAMAQsgA0HYAGpBATYCACADIAA2AlQgAyABKAIANgJQCyADQUBrIARBASADQdAAahDBBiADQcgAaigCACEEIAMoAkQhACADKAJAQQFHBEAgASAANgIAIAFBBGogBDYCAAwcCyAERQ0gDCQLIAIoAgAiAUEEaigCACIAIAFBCGooAgAiBmtBBE8EQCAGQQRqIQUgASgCACEADBoLIAZBBGoiBSAGSQ0fIABBAXQiBCAFIAQgBUsbIgRBCCAEQQhLGyEEAkAgAEUEQCADQQA2AlAMAQsgA0HYAGpBATYCACADIAA2AlQgAyABKAIANgJQCyADQUBrIARBASADQdAAahDBBiADQcgAaigCACEEIAMoAkQhACADKAJAQQFHBEAgASAANgIAIAFBBGogBDYCAAwaCyAERQ0fDCMLIAIoAgAiAUEEaigCACIAIAFBCGooAgAiBmtBBE8EQCAGQQRqIQUgASgCACEADBgLIAZBBGoiBSAGSQ0eIABBAXQiBCAFIAQgBUsbIgRBCCAEQQhLGyEEAkAgAEUEQCADQQA2AlAMAQsgA0HYAGpBATYCACADIAA2AlQgAyABKAIANgJQCyADQUBrIARBASADQdAAahDBBiADQcgAaigCACEEIAMoAkQhACADKAJAQQFHBEAgASAANgIAIAFBBGogBDYCAAwYCyAERQ0eDCILIAIoAgAiAUEEaigCACIAIAFBCGooAgAiBmtBBE8EQCAGQQRqIQUgASgCACEADBYLIAZBBGoiBSAGSQ0dIABBAXQiBCAFIAQgBUsbIgRBCCAEQQhLGyEEAkAgAEUEQCADQQA2AlAMAQsgA0HYAGpBATYCACADIAA2AlQgAyABKAIANgJQCyADQUBrIARBASADQdAAahDBBiADQcgAaigCACEEIAMoAkQhACADKAJAQQFHBEAgASAANgIAIAFBBGogBDYCAAwWCyAERQ0dDCELIAIoAgAiAUEEaigCACIAIAFBCGooAgAiBmtBBE8EQCAGQQRqIQUgASgCACEADBQLIAZBBGoiBSAGSQ0cIABBAXQiBCAFIAQgBUsbIgRBCCAEQQhLGyEEAkAgAEUEQCADQQA2AlAMAQsgA0HYAGpBATYCACADIAA2AlQgAyABKAIANgJQCyADQUBrIARBASADQdAAahDBBiADQcgAaigCACEEIAMoAkQhACADKAJAQQFHBEAgASAANgIAIAFBBGogBDYCAAwUCyAERQ0cDCALIAIoAgAiAUEEaigCACIAIAFBCGooAgAiBmtBBE8EQCAGQQRqIQUgASgCACEADBILIAZBBGoiBSAGSQ0bIABBAXQiBCAFIAQgBUsbIgRBCCAEQQhLGyEEAkAgAEUEQCADQQA2AlAMAQsgA0HYAGpBATYCACADIAA2AlQgAyABKAIANgJQCyADQUBrIARBASADQdAAahDBBiADQcgAaigCACEEIAMoAkQhACADKAJAQQFHBEAgASAANgIAIAFBBGogBDYCAAwSCyAERQ0bDB8LIAIoAgAiAEEEaigCACIFIABBCGooAgAiAWtBBE8EQCABQQRqIQYgACgCACEFDBALIAFBBGoiBiABSQ0aIAVBAXQiBCAGIAQgBksbIgRBCCAEQQhLGyEEAkAgBUUEQCADQQA2AlAMAQsgA0HYAGpBATYCACADIAU2AlQgAyAAKAIANgJQCyADQUBrIARBASADQdAAahDBBiADQcgAaigCACEEIAMoAkQhBSADKAJAQQFHBEAgACAFNgIAIABBBGogBDYCAAwQCyAERQ0aIAUgBEGElMMAKAIA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IAZFBEAgA0EANgJQDAELIANB2ABqQQE2AgAgAyAGNgJUIAMgASgCADYCUAsgA0FAayAFQQEgA0HQAGoQwQYgA0HIAGooAgAhBSADKAJEIQYgAygCQEEBRwRAIAEgBjYCACABQQRqIAU2AgAMAQsgBUUNEwwWCyABQQhqIAA2AgAgAiAGaiAOOAAADA4LIAFBCGogBTYCACAAIAZqQRA2AAAgByACEJcDIAcqAgghDgJAIAIoAgAiAUEEaigCACIGIAFBCGooAgAiAmtBBE8EQCACQQRqIQAgASgCACEGDAELIAJBBGoiACACSQ0SIAZBAXQiBSAAIAUgAEsbIgVBCCAFQQhLGyEFAkAgBkUEQCADQQA2AlAMAQsgA0HYAGpBATYCACADIAY2AlQgAyABKAIANgJQCyADQUBrIAVBASADQdAAahDBBiADQcgAaigCACEFIAMoAkQhBiADKAJAQQFHBEAgASAGNgIAIAFBBGogBTYCAAwBCyAFRQ0SDBULIAFBCGogADYCACACIAZqIA44AABBACEBDBMLIAFBCGogBTYCACAAIAZqQQ82AAAgByACEJcDIAcqAgghDgJAIAIoAgAiAUEEaigCACIGIAFBCGooAgAiAmtBBE8EQCACQQRqIQAgASgCACEGDAELIAJBBGoiACACSQ0RIAZBAXQiBSAAIAUgAEsbIgVBCCAFQQhLGyEFAkAgBkUEQCADQQA2AlAMAQsgA0HYAGpBATYCACADIAY2AlQgAyABKAIANgJQCyADQUBrIAVBASADQdAAahDBBiADQcgAaigCACEFIAMoAkQhBiADKAJAQQFHBEAgASAGNgIAIAFBBGogBTYCAAwBCyAFRQ0RDBQLIAFBCGogADYCACACIAZqIA44AABBACEBDBILIAFBCGogBTYCACAAIAZqQQ42AAAgByACEPcBIgENESAHQQxqIAIQ9wEiAQ0RIAdBGGogAhD3ASIBDREgByoCJCEOAkAgAigCACIBQQRqKAIAIgYgAUEIaigCACICa0EETwRAIAJBBGohACABKAIAIQYMAQsgAkEEaiIAIAJJDRAgBkEBdCIFIAAgBSAASxsiBUEIIAVBCEsbIQUCQCAGRQRAIANBADYCUAwBCyADQdgAakEBNgIAIAMgBjYCVCADIAEoAgA2AlALIANBQGsgBUEBIANB0ABqEMEGIANByABqKAIAIQUgAygCRCEGIAMoAkBBAUcEQCABIAY2AgAgAUEEaiAFNgIADAELIAVFDRAMEwsgAUEIaiAANgIAIAIgBmogDjgAAEEAIQEMEQsgAUEIaiAFNgIAIAAgBmpBDTYAACAHIAIQ9wEiAQ0QIAcqAgwhDgJAIAIoAgAiAUEEaigCACIGIAFBCGooAgAiAmtBBE8EQCACQQRqIQAgASgCACEGDAELIAJBBGoiACACSQ0PIAZBAXQiBSAAIAUgAEsbIgVBCCAFQQhLGyEFAkAgBkUEQCADQQA2AlAMAQsgA0HYAGpBATYCACADIAY2AlQgAyABKAIANgJQCyADQUBrIAVBASADQdAAahDBBiADQcgAaigCACEFIAMoAkQhBiADKAJAQQFHBEAgASAGNgIAIAFBBGogBTYCAAwBCyAFRQ0PDBILIAFBCGogADYCACACIAZqIA44AABBACEBDBALIAFBCGogBTYCACAAIAZqQQw2AAAgByACEJcDQQAhAQwPCyABQQhqIAU2AgAgACAGakELNgAAIAcgAhCXA0EAIQEMDgsgAUEIaiAFNgIAIAAgBmpBCjYAACAHIAIQjgEhAQwNCyABIAVqQQk2AAAgAEEIaiAGNgIAIAMoAjQgAhDWBCEBDAwLIAFBCGogBTYCACAAIAZqQQg2AAAgBygCACEAIANBKGogAiAHKAIIIgYQ8QQgAygCLCEBIAMoAigNCyAGBEAgBkECdCEIIAEoAgAiCUEEaiIKKAIAIQUgCUEIaiILKAIAIQEDQCAAKgIAIQ4CQCAFIAFrQQRPBEAgAUEEaiEGIAkoAgAhBAwBCyABQQRqIgYgAUkNDCAFQQF0IgQgBiAEIAZLGyIEQQggBEEISxshBAJAIAVFBEAgA0EANgJQDAELIANBATYCWCADIAU2AlQgAyAJKAIANgJQCyADQUBrIARBASADQdAAahDBBiADKAJEIQQgAygCSCEFIAMoAkBBAUcEQCAJIAQ2AgAgCiAFNgIADAELIAVFDQwgBCAFQYSUwwAoAgAiAEGtBiAAGxEAAAALIABBBGohACALIAY2AgAgASAEaiAOOAAAIAYhASAIQXxqIggNAAsLIAc1AgwhDQJAIAIoAgAiAUEEaigCACIAIAFBCGooAgAiBmtBCE8EQCAGQQhqIQUgASgCACEADAELIAZBCGoiBSAGSQ0KIABBAXQiBCAFIAQgBUsbIgRBCCAEQQhLGyEEAkAgAEUEQCADQQA2AlAMAQsgA0HYAGpBATYCACADIAA2AlQgAyABKAIANgJQCyADQUBrIARBASADQdAAahDBBiADQcgAaigCACEEIAMoAkQhACADKAJAQQFHBEAgASAANgIAIAFBBGogBDYCAAwBCyAERQ0KDA4LIAFBCGogBTYCACAAIAZqIA03AAAgBzUCECENAkAgAigCACIBQQRqKAIAIgAgAUEIaigCACIGa0EITwRAIAZBCGohBSABKAIAIQAMAQsgBkEIaiIFIAZJDQogAEEBdCIEIAUgBCAFSxsiBEEIIARBCEsbIQQCQCAARQRAIANBADYCUAwBCyADQdgAakEBNgIAIAMgADYCVCADIAEoAgA2AlALIANBQGsgBEEBIANB0ABqEMEGIANByABqKAIAIQQgAygCRCEAIAMoAkBBAUcEQCABIAA2AgAgAUEEaiAENgIADAELIARFDQoMDgsgAUEIaiAFNgIAIAAgBmogDTcAACAHQRRqIAIQ9wEiAQ0LIAdBIGogAhD3ASIBDQsgB0EsaiACEPcBIgENCyAHNQI4IQ0CQCACKAIAIgFBBGooAgAiACABQQhqKAIAIgZrQQhPBEAgBkEIaiEFIAEoAgAhAAwBCyAGQQhqIgUgBkkNCiAAQQF0IgQgBSAEIAVLGyIEQQggBEEISxshBAJAIABFBEAgA0EANgJQDAELIANB2ABqQQE2AgAgAyAANgJUIAMgASgCADYCUAsgA0FAayAEQQEgA0HQAGoQwQYgA0HIAGooAgAhBCADKAJEIQAgAygCQEEBRwRAIAEgADYCACABQQRqIAQ2AgAMAQsgBEUNCgwOCyABQQhqIAU2AgAgACAGaiANNwAAIAcoAjwhACADQSBqIAIgB0HEAGooAgAiCBDxBCADKAIkIQEgAygCIA0LIAgEQCABKAIAIglBBGoiCigCACEBIAlBCGoiCygCACEFA0AgAC0AACEMAkAgASAFRwRAIAVBAWohBiAJKAIAIQQMAQsgAUEBaiIGIAFJDQwgAUEBdCIEIAYgBCAGSxsiBEEIIARBCEsbIQQCQCABRQRAIANBADYCUAwBCyADQQE2AlggAyABNgJUIAMgCSgCADYCUAsgA0FAayAEQQEgA0HQAGoQwQYgAygCRCEEIAMoAkghASADKAJAQQFHBEAgCSAENgIAIAogATYCAAwBCyABRQ0MIAQgAUGElMMAKAIAIgBBrQYgABsRAAAACyALIAY2AgAgBCAFaiAMOgAAIABBAWohACAGIQUgCEF/aiIIDQALCyAHQcgAajUCACENAkAgAigCACIBQQRqKAIAIgAgAUEIaigCACIGa0EITwRAIAZBCGohBSABKAIAIQAMAQsgBkEIaiIFIAZJDQogAEEBdCIEIAUgBCAFSxsiBEEIIARBCEsbIQQCQCAARQRAIANBADYCUAwBCyADQdgAakEBNgIAIAMgADYCVCADIAEoAgA2AlALIANBQGsgBEEBIANB0ABqEMEGIANByABqKAIAIQQgAygCRCEAIAMoAkBBAUcEQCABIAA2AgAgAUEEaiAENgIADAELIARFDQoMDgsgAUEIaiAFNgIAIAAgBmogDTcAACAHQcwAajUCACENAkAgAigCACIBQQRqKAIAIgYgAUEIaigCACICa0EITwRAIAJBCGohACABKAIAIQYMAQsgAkEIaiIAIAJJDQogBkEBdCIFIAAgBSAASxsiBUEIIAVBCEsbIQUCQCAGRQRAIANBADYCUAwBCyADQdgAakEBNgIAIAMgBjYCVCADIAEoAgA2AlALIANBQGsgBUEBIANB0ABqEMEGIANByABqKAIAIQUgAygCRCEGIAMoAkBBAUcEQCABIAY2AgAgAUEEaiAFNgIADAELIAVFDQoMDQsgAUEIaiAANgIAIAIgBmogDTcAAEEAIQEMCwsgAUEIaiAFNgIAIAAgBmpBBzYAACAHIAIQ9wEhAQwKCyABQQhqIAU2AgAgACAGakEGNgAAIAMgAjYCPCADQTxqIAcQhgEiAQ0JIAcoAkAhBiADQRhqIAIgB0HIAGooAgAiABDxBCADKAIcIQEgAygCGA0JIABBDGwhBQJAA0AgBUUNASAFQXRqIQUgBiABEPcBIQAgBkEMaiEGIABFDQALIAAhAQwKCyAHKAJMIQYgA0EQaiACIAdB1ABqKAIAIgAQ8QQgAygCFCEBIAMoAhANCSAARQ0DIABBA3QgBmohCSABKAIAIgVBCGoiCCgCACECA0ACQCAGKAIAIQoCQCAFQQRqIgcoAgAiACACa0EETwRAIAJBBGohASAFKAIAIQAMAQsgAkEEaiIBIAJJDQogAEEBdCIEIAEgBCABSxsiBEEIIARBCEsbIQQCQCAARQRAIANBADYCUAwBCyADQQE2AlggAyAANgJUIAMgBSgCADYCUAsgA0FAayAEQQEgA0HQAGoQwQYgAygCRCEAIAMoAkghBCADKAJAQQFGDQEgBSAANgIAIAcgBDYCAAsgACACaiAKNgAAIAggATYCACAGQQRqKAIAIQoCQCAHKAIAIgAgAWtBBE8EQCABQQRqIQIgBSgCACEADAELIAFBBGoiAiABSQ0KIABBAXQiBCACIAQgAksbIgRBCCAEQQhLGyEEAkAgAARAIANBATYCWCADIAA2AlQgAyAFKAIANgJQDAELIANBADYCUAsgA0FAayAEQQEgA0HQAGoQwQYgAygCRCEAIAMoAkghBCADKAJAQQFGDQEgBSAANgIAIAcgBDYCAAsgCCACNgIAIAAgAWogCjYAACAJIAZBCGoiBkcNAQwFCwsgBEUNBwwLCyABQQhqIAU2AgAgACAGakEFNgAAIAMgAjYCPCADQTxqIAcQhgEiAQ0IIAcoAkAhBiADQQhqIAIgB0HIAGooAgAiABDxBCADKAIMIQEgAygCCA0IIABBDGwhBQJAA0AgBUUNASAFQXRqIQUgBiABEPcBIQAgBkEMaiEGIABFDQALIAAhAQwJCyAHKAJMIQUgAyACIAdB1ABqKAIAIgAQ8QQgAygCBCEBIAMoAgANCCAARQ0CIABBDGwgBWohCiABKAIAIgdBCGoiCSgCACEBA0ACQCAFKAIAIQYCQCAHQQRqIggoAgAiAiABa0EETwRAIAFBBGohACAHKAIAIQIMAQsgAUEEaiIAIAFJDQkgAkEBdCIEIAAgBCAASxsiBEEIIARBCEsbIQQCQCACRQRAIANBADYCUAwBCyADQQE2AlggAyACNgJUIAMgBygCADYCUAsgA0FAayAEQQEgA0HQAGoQwQYgAygCRCECIAMoAkghBCADKAJAQQFGDQEgByACNgIAIAggBDYCAAsgASACaiAGNgAAIAkgADYCACAFQQRqKAIAIQsCQCAIKAIAIgEgAGtBBE8EQCAAQQRqIQYgBygCACECDAELIABBBGoiBiAASQ0JIAFBAXQiAiAGIAIgBksbIgJBCCACQQhLGyECAkAgAQRAIANBATYCWCADIAE2AlQgAyAHKAIANgJQDAELIANBADYCUAsgA0FAayACQQEgA0HQAGoQwQYgAygCRCECIAMoAkghBCADKAJAQQFGDQEgByACNgIAIAggBDYCAAsgACACaiALNgAAIAkgBjYCACAFQQhqKAIAIQsCQCAIKAIAIgAgBmtBBE8EQCAGQQRqIQEgBygCACECDAELIAZBBGoiASAGSQ0JIABBAXQiAiABIAIgAUsbIgJBCCACQQhLGyECAkAgAARAIANBATYCWCADIAA2AlQgAyAHKAIANgJQDAELIANBADYCUAsgA0FAayACQQEgA0HQAGoQwQYgAygCRCECIAMoAkghBCADKAJAQQFGDQEgByACNgIAIAggBDYCAAsgCSABNgIAIAIgBmogCzYAACAKIAVBDGoiBUcNAQwECwsgBEUNBiACIARBhJTDACgCACIAQa0GIAAbEQAAAAsgAUEIaiAFNgIAIAAgBmpBBDYAACAHIAIQ9wEiAQ0HIAdBDGogAhD3ASIBDQcgB0EYaiACEPcBIgENBwwBCyABQQhqIAU2AgAgACAGakEDNgAAIAcgAhD3ASIBDQYgB0EMaiACEPcBIgENBgtBACEBDAULIAFBCGogBTYCACAAIAZqQQI2AAAgByACEPcBIgENBCAHQQxqIAIQ9wEiAQ0EIAcqAhghDgJAIAIoAgAiAUEEaigCACIGIAFBCGooAgAiAmtBBE8EQCACQQRqIQAgASgCACEGDAELIAJBBGoiACACSQ0DIAZBAXQiBSAAIAUgAEsbIgVBCCAFQQhLGyEFAkAgBkUEQCADQQA2AlAMAQsgA0HYAGpBATYCACADIAY2AlQgAyABKAIANgJQCyADQUBrIAVBASADQdAAahDBBiADQcgAaigCACEFIAMoAkQhBiADKAJAQQFHBEAgASAGNgIAIAFBBGogBTYCAAwBCyAFRQ0DDAYLIAFBCGogADYCACACIAZqIA44AABBACEBDAQLIAFBCGogBTYCACAAIAZqQQE2AAAgByACEPcBIQEMAwsgACAFakEANgAAIAJBCGogATYCACAHKgIAIQ4gAkEEaigCACIGIAFrQQRPBEAgAUEEaiEAIAIoAgAhBgwCCyABQQRqIgAgAUkNACAGQQF0IgUgACAFIABLGyIFQQggBUEISxshBQJAIAZFBEAgA0EANgJQDAELIANB2ABqQQE2AgAgAyAGNgJUIAMgAigCADYCUAsgA0FA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QRRqKAIANgIAIAggCCkC9AI3A5gCIAggCCkCpAI3A4ABIANBFGogCygCADYCACAIIAgpAvQCNwKMASADQSBqIgsgAkEsaigCADYCACADQRhqIgIgCCkCvAI3AwAgA0EsaiAEKAIANgIAIAggBSkDADcCpAEgCiADQShqKQMANwMAIAQgCykDADcDACAFIAIpAwA3AwAgBiADQRBqKQMANwMAIAkgDCkDADcDACAIIAgpA4ABNwOYAiABQShqIAopAwA3AwAgAUEgaiAEKQMANwMAIAFBGGogBSkDADcDACABQRBqIAYpAwA3AwAgAUEIaiAJKQMANwMAIAggCCkDmAI3A/ACQQAgB0MAAAAAXw0AGiAIQYgBaiAIQaACaigCADYCACAIQbgBaiAIQYQDaigCADYCACAIIAgpA5gCNwOAASAIIAgpAvwCNwOwAUEBCzYCACAAIAgpA4ABNwIEIABBEGogCCkDsAE3AgAgAEEMaiAIQYgBaigCADYCACAAQRhqIAhBuAFqKAIANgIADA4LIAhB8AJqIAIgAyAEIAkgBxClAiAAAn9BAiAIKALwAkEBRw0AGiAIQcACaiAIQZwDaikCADcDACAIQbgCaiAIQZQDaikCADcDACAIQbACaiAIQYwDaikCADcDACAIQagCaiAIQYQDaikCADcDACAIQaACaiAIQfwCaikCADcDACAIIAgpAvQCNwOYAkEAIAhBpANqKgIAQwAAAABfDQAaIAhBiAFqIAhB8AJqQQRyIgFBCGooAgA2AgAgCEG4AWogCEGsAmooAgA2AgAgCCAIKQKkAjcDsAEgCCABKQIANwOAAUEBCzYCACAAIAgpA4ABNwIEIABBEGogCCkDsAE3AgAgAEEMaiAIQYgBaigCADYCACAAQRhqIAhBuAFqKAIANgIADA0LIAhB8AJqIgEgAiAJIAogBxCWASAAQRhqIAFBGGooAgA2AgAgAEEQaiABQRBqKQMANwIAIABBCGogAUEIaikDADcCACAAIAgpA/ACNwIADAwLIAhB8AJqIgEgAiAJIAogBxCWASAAQRhqIAFBGGooAgA2AgAgAEEQaiABQRBqKQMANwIAIABBCGogAUEIaikDADcCACAAIAgpA/ACNwIADAsLIAhBsAFqIgFBCGoiAyACQQhqKQIANwMAIAFBGGoiBCACQRhqKAIANgIA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ABDzBwALQQRBBEGc2sAAEPMHAAsgC0E0bCAIaiIIIBUgFCAGGzYCICAIIBQgFSAGGzYCHCAIICE4AhggJiAiIC+TIiGUICMgJyA4kyIilJMhKCAIICwgIiAqICMgJCAzkyInlCArICGUkyIkICSSIiSUICMgKCAokiIolCArICsgIpQgJiAnlJMiIiAikiIilJOSkiIuIAYbOAIMIAggISAqICKUICsgJJQgJiAolJOSkiIhICAgBhs4AgggCCAnICogKJQgJiAilCAjICSUk5KSIiIgKSAGGzgCBCAIIC4gLCAGGzgCACAIQRRqICAgISAGGzgCACAIQRBqICkgIiAGGzgCACAIIAcpA2g3AiQgCEEsaiAcKQMANwIAIAUgC0EBajYCWAsgAUEIaiEBIApBDGohCiAOQQRqIQ4gDSAAQQFqIgBqQQFHDQALDAILQQRBBEH82cAAEPMHAAtBBEEEQezZwAAQ8wcACyAJIBFHDQALDAMLIAAqAgAiISADQRBqKgIAIjiUIABBBGoqAgAiIyADKgIMIiKUkyEzIAFBCGoqAgAiKLxBgICAgHhxQYCAgPwDcr4hICABKgIAIjAgAUEEaioCACIqlEMAAIC/ICggIJKVIi+UIiUgACoCECIsICIgAEEMaioCACIrICMgA0EUaioCACItlCAAQQhqKgIAIiYgOJSTIikgKZIiKZQgIyAzIDOSIieUICYgJiAilCAhIC2UkyIiICKSIiSUk5KSkiI0lCAgICogKpQgL5SSIiIgAEEUaioCACIzIDggKyAklCAmICmUICEgJ5STkpKSIjKUkiAqIABBGGoqAgAiOCAtICsgJ5QgISAklCAjICmUk5KSkiI7lJMhNSAwICCMlCItIDuUIC8gMCAwICCUlJRDAACAP5IiLyA0lCAgICWUIiAgMpSSkiADKgIEIikgIZQgAyoCACInICOUkyEkICUgLCAnICsgAyoCCCIuICOUICkgJpSTIjogOpIiMZQgIyAkICSSIiSUICYgJyAmlCAuICGUkyInICeSIieUk5KSkiI6lCAiIDMgKSArICeUICYgMZQgISAklJOSkpIiP5SSICogOCAuICsgJJQgISAnlCAjIDGUk5KSkiIxlJMhJCAtIDGUIC8gOpQgICA/lJKSIS4gAkEMaiIAKgIAIjYgL5QgICACQRBqKgIAIjyU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AXFBBEYNASARIBNNDQEgDCALKQOQBDcAACAMQTBqIDUpAwA3AAAgDEEoaiA0KQMANwAAIAxBIGogMykDADcAACAMQRhqIDIpAwA3AAAgDEEQaiAxKQMANwAAIAxBCGogMCkDADcAACALQc4AaiA2LQAAOgAAIAsgCy8BpAU7AUwgC0HQAGoiAUE3aiALQfcBaigAADYAACABQTBqIB8pAAA3AwAgAUEoaiAeKQAANwMAIAFBIGogHSkAADcDACABQRhqIBwpAAA3AwAgAUEQaiAQKQAANwMAIAFBCGogBykAADcDACALIAspAMABNwNQIAIhASBJIQkMAQsgEyAETw0AIAtBQGsgEyBJjBDmAwsCQCBGQgKDUA0AIBcEQCBIIAldQQFzDQEgA0H/AXFBBEYNASARIBZNDQEgDCALKQPQAzcAACAMQTBqIDwpAwA3AAAgDEEoaiA7KQMANwAAIAxBIGogOikDADcAACAMQRhqIDkpAwA3AAAgDEEQaiA4KQMANwAAIAxBCGogNykDADcAACALQc4AaiBELQAAOgAAIAsgCy8BkAU7AUwgC0HQAGoiAUE3aiALQfcBaigAADYAACABQTBqIB8pAAA3AwAgAUEoaiAeKQAANwMAIAFBIGogHSkAADcDACABQRhqIBwpAAA3AwAgAUEQaiAQKQAANwMAIAFBCGogBykAADcDACALIAspAMABNwNQIAMhASBIIQkMAQsgFiAETw0AIAtBQGsgFiBIjBDmAwsCQCBGQgSDUA0AIBcEQCBHIAldQQFzDQEgBUH/AXFBBEYNASARIBVNDQEgDCALKQOoBTcAACAMQTBqID0pAwA3AAAgDEEoaiAaKQMANwAAIAxBIGogPikDADcAACAMQRhqID8pAwA3AAAgDEEQaiAbKQMANwAAIAxBCGogKykDADcAACALQc4AaiBFLQAAOgAAIAsgCy8BtAM7AUwgC0HQAGoiAUE3aiALQfcBaigAADYAACABQTBqIB8pAAA3AwAgAUEoaiAeKQAANwMAIAFBIGogHSkAADcDACABQRhqIBwpAAA3AwAgAUEQaiAQKQAANwMAIAFBCGogBykAADcDACALIAspAMABNwNQIAUhASBHIQkMAQsgFSAETw0AIAtBQGsgFSBHjBDmAwsCQCBGQgiDUA0AIBcEQCAIIAldQQFzDQEgBkH/AXFBBEYNASARIBRNDQEgDCALKQPYBDcAACAMQTBqIEApAwA3AAAgDEEoaiAYKQMANwAAIAxBIGogQSkDADcAACAMQRhqIEIpAwA3AAAgDEEQaiAZKQMANwAAIAxBCGogQykDADcAACALQc4AaiAhLQAAOgAAIAsgCy8BqAE7AUwgC0HQAGoiAUE3aiALQfcBaigAADYAACABQTBqIB8pAAA3AwAgAUEoaiAeKQAANwMAIAFBIGogHSkAADcDACABQRhqIBwpAAA3AwAgAUEQaiAQKQAANwMAIAFBCGogBykAADcDACALIAspAMABNwNQIAYhASAIIQkMAQsgFCAETw0AIAtBQGsgFCAIjBDmAwsgC0GQAWogC0FAaxCDAyALKAKQAUEBRg0BDAILCyACIARB8M/BABDzBwALIAtBkARqIgJBCGogC0HQAGoiA0EIaikDADcDACACQRBqIANBEGopAwA3AwAgAkEYaiADQRhqKQMANwMAIAJBIGogA0EgaikDADcDACACQShqIANBKGopAwA3AwAgAkEwaiADQTBqKQMANwMAIAJBN2ogA0E3aigAADYAACALQdIDaiALQc4Aai0AADoAACALIAspA1A3A5AEIAsgCy8BTDsB0AMCQCALKAJEIgJFDQAgCygCQCIDRQ0AIAJBA3RFDQAgAxDMAQsgAUH/AXFBBEcNAQsgAEEEOgA0DAELIAAgCy8B0AM7ADUgC0HAAWoiAkE3aiIEIAtBkARqIgNBN2ooAAA2AAAgAkEwaiADQTBqKQMANwMAIAJBKGogA0EoaikDADcDACACQSBqIANBIGopAwA3AwAgAkEYaiADQRhqKQMANwMAIAJBEGogA0EQaikDADcDACACQQhqIANBCGopAwA3AwAgAEE3aiALQdIDai0AADoAACALIAspA5AENwPAASAAIAE6ADQgAEEwaiAEKAAANgAAIABBKGogC0HvAWopAAA3AAAgAEEgaiALQecBaikAADcAACAAQRhqIAtB3wFqKQAANwAAIABBEGogC0HXAWopAAA3AAAgAEEIaiALQc8BaikAADcAACAAIAspAMcBNwAACyALQeAFaiQAC6ElAyh/A34wfSMAQfAJayIKJAAgCkEIaiIPQRBqIAk2AgAgCkEANgIUIAogCDYCECAKIAI2AgwgCiABNgIIQQQhCSABQQRq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IBxBAUgNBSANQQFIDQUgFCAXaiEGA0BBAEF/IAdBdGoiHSoCACIjIANBdGoiFyoCACIkYCING0EBQQIgDRsgIyAkXxtBf0YhGyAGIBcgHSAbGyINKQIANwIAIAZBCGogDUEIaigCADYCACAHIB0gGxshByAKIBcgAyAbGyIDTw0GIAZBdGohBiAHIAtLDQALDAULIAMgAkGswcAAEPMHAAsgCSACQbzBwAAQ8wcACyAhIAZBzMHAABD1BwALIAYgD0HMwcAAEPQHAAsgEiAXaiENA0AgCiADIAZBAEF/IAMqAgAiIyAGKgIAIiRgIgsbQQFBAiALGyAjICRfG0F/RiIXGyILKQIANwIAIApBCGogC0EIaigCADYCACAGIAZBDGogFxshBiAKQQxqIQogA0EMaiADIBcbIgMgDU8NAiAGIAdJDQALDAELIAshBiADIQoLIAogBiAHIAZrIgMgA0EMcGsQogkaIBEgECAcajYCACAZICE2AgAgGiAaQQhqIAIgCWtBA3RBcGoQyAcaQQEhByAMQQFLDQALCyAIDQALDAILIAMgAkGElMMAKAIAIgBBrQYgABsRAAAACyACRQ0DIBUgAkGElMMAKAIAIgBBrQYgABsRAAAACwJAIBZFDQAgFkEDdEUNACAVEMwBCyAYRQ0AIBhBDGxFDQAgExDMAQsgAEEIaiENAkAgAEEcaigCACICIABBEGoiCygCACIMaiIIIAxNBEAgCCEHDAELIA0gAhDgBSAAKAIIIAsoAgAiB0EDdGohAyACQQJPBEAgAkF/aiEGA0AgA0L////79/////8ANwIAIANBCGohAyAGQX9qIgYNAAsgAiAHakF/aiEHCyACBEAgA0L////79/////8ANwIAIAdBAWohBwsgAEEcaigCACECCyALIAc2AgAgACgCFCEPAkACQAJAIAIEQCAMQX5qIQkgCEF+aiEKIAJBDGwgD2ohCyANKAIAIQwCQAJAA0AgByAJSwRAIAtBdGohCCAKQQN0IAxqIQMgCUEDdCAMaiEGA0AgBioCACIjIAgqAgAiJF9BAXNFBEAgByAKTQ0EIANBBGogC0F4aigCADYCACADICQ4AgAgC0F8aiAKNgIAIApBf2ohCiAPIAgiC0cNAyAHQX9qIRYMBwsgByAKTQ0EIANBBGogBkEEaigCADYCACADICM4AgAg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AgAhASAAIAIoAqQCNgIAIAIgATYCmAECQCABRQ0AIAEgASgCACIAQX9qNgIAIABBAUcNACACQZgBahCxCAsgAkHAAWoiAEEIaiACQfABaiIBQQhqKQMANwMAIABBEGogAUEQaikDADcDACAAQRhqIAFBGGopAwA3AwAgAEEgaiABQSBqKQMANwMAIABBKGogAUEoaikDADcDACACIAIpA/ABNwPAAQwCCyACIAIpA8ABNwNgIAIoAlxBQGsiASACKAJkNgIAIAJB6ABqIAJByAFqKAIANgIAIABBADoAPCACIAIoABs2AJsBIAIgAigCGDYCmAECQCABKAIAIgBFBEAgCUECRg0BQbC9wABBK0H8t8AAEOcIAAsgACACKQMgNwMAIAAgCToAICAAIAIoAhg2ACEgAEEBOgApIABBJGogAigAGzYAACAAQRhqIAJBIGoiAUEYaikDADcDACAAQRBqIAFBEGopAwA3AwAgAEEIaiABQQhqKQMANwMACyACQgI3A/ABIAIoAmgiASgCACEAIAEgAEF/ajYCACAAQQFHDQYgAkHoAGoQsQggAikD8AEhDwwLCyACEJkHIgA2AvABIAJBwAFqIAJB4ABqIAJB8AFqEK4BIAAgACgCACIAQX9qNgIAIABBAUcNACACQfABahCxCAsgAkGgAWoiBCACQcABaiIAQRBqKQMANwMAIAJBmAFqIgFBEGoiBSAAQRhqKQMANwMAIAFBGGoiAyAAQSBqKQMANwMAIAFBIGoiASAAQShqKQMANwMAIAIgAikDyAE3A5gBIAIpA8ABIg9CA1INAQsgAhCZByIANgLAASACQfABaiACQeAAaiACQcABahCuASAAIAAoAgAiAEF/ajYCACAAQQFHDQEgAkHAAWoQsQgMAQsgAkHwAWoiAEEQaiAEKQMANwMAIABBGGogBSkDADcDACAAQSBqIAMpAwA3AwAgAEEoaiABKQMANwMAIAIgDzcD8AEgAiACKQOYATcD+AELIAItAIABQQJHBEAgAigCjAFBADoANAsgAikD8AEhDwwGCyAAQQA6ADwgAkGYAmogCToAACACQZwCaiACKAAbNgAAIAJBkAJqIAJBIGoiAEEYaikDADcDACACQfABaiIBQRhqIABBEGopAwA3AwAgAUEQaiACQShqKQMANwMAIAIgAikDIDcD+AEgAiAC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HZQgGCAelCAZIBkgG5QgGiAjlJMiGyAbkiIblJOSkpI4AgAgDkEUaiAEQRRqKgIAICMgHCAelCAaIBuUIBggHZSTkpKSOAIAIAUgGiAflCAYICGUIBwgIpSSIBkgIJSTkjgC0AEgBSAaICCUIBkgH5QgHCAhlCAYICKUk5KSOALMASAFIBkgIpQgHCAglCAYIB+UkpIgGiAhlJM4AsgBIAUgBCoCECAkIBsgHJQgGSAdlCAaIB6Uk5KSkjgC2AELIAwgBUHIAWogACgCJEGcycAAIAIgAyAAKAIoKgIAIAYgBygCEBEWABoLIAVBsARqJAAPCyAEIAdBzM/AABDzBwALnR8CDH8DfiMAQeACayICJAAgAUEIaiEEIAEpAwAhDgJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAIAAoAghBAWsOAgIAAQsgAEEMaigCACEBIAJBEGoiAEEYaiAEQRhqKQMANwMAIABBEGogBEEQaikDADcDACAAQQhqIARBCGopAwA3AwAgAiAEKQMANwMQIAJCADcDMCACIAFBCGoiBjYCSCACQdACakIANwMAQQAhACACQdgCakEANgIAIAFBPGoiBC0AACAEQQE6AAAgAkIANwPIAiACQgA3A7ACIAJCADcDmAIgAiACQZgCajYCTARAA0AgACAAQQFqIABBB09BACAAQQpLGxshACABLQA8IAFBAToAPA0ACwsgAkGIAWogAUEgahCKAwJAAkACQAJAAkACQAJAIAIoApABRQRAIAFBOGotAAANBiACQdAAaiIAQRBqIAJBGGopAwA3AwAgAEEYaiACQRBqIgBBEGopAwA3AwAgAkHwAGogAEEYaikDADcDACACIA43A1AgAiACKQMQNwNYIAIgBjYCfCACQYABaiACQTBqNgIAIAJB+ABqIAJBzABqNgIAIAIgAkHIAGo2AoQBEK0HIgBFDQMgACgCACEBIABBADYCACABRQ0BIAFCADcCECACIAE2ApQCIAJB4AFqIAJB0ABqIAJBlAJqELsBIAAoAgAhASAAIAIoApQCNgIAIAIgATYCiAECQCABRQ0AIAEgASgCACIAQX9qNgIAIABBAUcNACACQYgBahCxCAsgAkGwAWoiAEEIaiACQeABaiIBQQhqKQMANwMAIABBEGogAUEQaikDADcDACAAQRhqIAFBGGopAwA3AwAgAEEgaiABQSBqKQMANwMAIABBKGogAUEoaikDADcDACACIAIpA+ABNwOwAQwCCyACIAIpA4gBNwOwASACKAJMQUBrIgYgAigCtAE2AgAgAkG4AWogAkGQAWooAgA2AgAgAUEAOgA8IAJB0ABqIgBBGGoiBCACQRBqIgFBGGopAwA3AwAgAEEQaiIDIAFBEGopAwA3AwAgAEEIaiIHIAFBCGopAwA3AwAgAiACKQMQNwNQAkAgBigCACIABEAgACAONwMAIABBAToAKSAAIAIpA1A3AwggAEEQaiAHKQMANwMAIABBGGogAykDADcDACAAQSBqIAQpAwA3AwAMAQsgDkICUg0KCyACKAK4ASIBKAIAIQAgASAAQX9qNgIAIAJCAjcD4AEgAEEBRw0GIAJBuAFqELEIIAIpA+ABIQ8MFAsgAhCZByIANgLgASACQbABaiACQdAAaiACQeABahC7ASAAIAAoAgAiAEF/ajYCACAAQQFHDQAgAkHgAWoQsQgLIAJBkAFqIgYgAkGwAWoiAEEQaikDADcDACACQYgBaiIBQRBqIgQgAEEYaikDADcDACABQRhqIgMgAEEgaikDADcDACABQSBqIgEgAEEoaikDADcDACACIAIpA7gBNwOIASACKQOwASIOQgNSDQELIAIQmQciADYCsAEgAkHgAWogAkHQAGogAkGwAWoQuwEgACAAKAIAIgBBf2o2AgAgAEEBRw0BIAJBsAFqELEIDAELIAJB4AFqIgBBEGogBikDADcDACAAQRhqIAQpAwA3AwAgAEEgaiADKQMANwMAIABBKGogASkDADcDACACIA43A+ABIAIgAikDiAE3A+gBCyACKQNQQgJSBEAgAigCfEEAOgA0CyACKQPgASEPDA8LIAFBADoAPCACQeABaiIAQRBqIAIpAxA3AwAgAEEYaiACQRhqKQMANwMAIAJBgAJqIAJBEGoiAEEQaikDADcDACACQYgCaiAAQRhqKQMANwMAIAIgDjcD6AEgAkIBNwPgAQsgAikD4AEhDwwNCyAAQQxqKAIAIQUgAkGwAWoiAEEYaiAEQRhqKQMANwMAIABBEGogBEEQaikDADcDACAAQQhqIARBCGopAwA3AwAgAiAEKQMANwOwASACQgA3A4gBIAIgBTYClAIgAkGYAmoiCEFAa0EANgIAIAJB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MGoiDCkCADcDACAEQQhqIgQgAUEoaiIIKQIANwMAIAggAkEIaiIIKQIANwIAIAwgAkEQaiIMKQIANwIAIAkgAkEYaiIJKQIANwIAIAYgAkEgaiIGKAIANgIAIAMgEzcDQCACIAMpA0A3AgAgBiAFKAIANgIAIAkgCykDADcCACAMIAopAwA3AgAgCCAEKQMANwIAIAFBADYCvAEgAUGAgID8AzYCsAEgASABKQIAQiCJNwIADAELIANB2ABqKgIAIRcgASAENgKwASABQbQBaiAXOAIACyAAIAMpAxg3AgAgAEEIaiADQSBqKAIANgIADAoLIANBQGsiBUEIaiABQShqKAIANgIAIAVBFGogAUHMAGooAgA2AgAgBUEgaiABQfAAaigCADYCACADIAEpAiA3A0AgAyABQcQAaiIEKQIANwJMIAMgAUHoAGoiAikCADcDWCADQQA2AnggA0IANwNwIANBGGoiBiAFIANB8ABqQQEQTCADQRBqIgsgBkEIaikDADcDACADIAMpAxg3AwggBkEUaigCACEFIANBMGoqAgAhFyADQTRqKgIAIRgCQAJAAkACQAJAAkACQCADKAIoDgMBAAUGCyAFDgMBAgMFCyAFQQRPDQcgA0FAayICQSBqIgQgAUFAayIGKAIANgIAIAJBGGoiCSABQThqIgopAgA3AwAgAkEQaiIMIAFBMGoiCCkCADcDACACQQhqIgcgAUEoaiINKQIANwMAIAFBIGogBUEkbGoiAkEgaiIOKAIAIQ8gAkEYaiIQKQIAIRMgAkEQaiIRKQIAIRQgAkEIaiISKQIAIRUgASkCICEWIAEgAikCADcCICANIBU3AgAgCCAUNwIAIAogEzcCACAGIA82AgAgAyAWNwNAIAIgAykDQDcCACASIAcpAwA3AgAgESAMKQMANwIAIBAgCSkDADcCACAOIAQoAgA2AgAgASgCACECIAEgBUECdCABaiIEKAIANgIAIAQgAjYCACABQQA2ArwBIAFBgICA/AM2ArABDAQLIAFBATYCvAEgASAXOAKwASABQbQBaiAYOAIADAMLIAEpAiAhEyABIAIpAgA3AiAgA0FAayIEQSBqIgUgAUFAayIGKAIANgIAIARBGGoiCSABQThqIgopAgA3AwAgBEEQaiIMIAFBMGoiCCkCADcDACAEQQhqIgQgAUEoaiIH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DAYLIAEpAiAhEyABIAUpAgA3AiAgA0FAayICQSBqIgQgAUFAayIGKAIANgIAIAJBGGoiCyABQThqIgkpAgA3AwAgAkEQaiIKIAFBMGoiCCkCADcDACACQQhqIgIgAUEoaiIHKQIANwMAIAcgBUEIaiIHKQIANwIAIAggBUEQaiIIKQIANwIAIAkgBUEYaiIJKQIANwIAIAYgBUEgaiIGKAIANgIAIAMgEzcDQCAFIAMpA0A3AgAgBiAEKAIANgIAIAkgCykDADcCACAIIAopAwA3AgAgByACKQMANwIAIAFBDGohAgwFCyABKQIgIRMgASACKQIANwIgIANBQGsiBkEgaiILIAFBQGsiCCgCADYCACAGQRhqIgkgAUE4aiIHKQIANwMAIAZBEGoiCiABQTBqIg0pAgA3AwAgBkEIaiIGIAFBKGoiDikCADcDACAOIAJBCGoiDikCADcCACANIAJBEGoiDSkCADcCACAHIAJBGGoiBykCADcCACAIIAJBIGoiCCgCADYCACADIBM3A0AgAiADKQNANwIAIAggCygCADYCACAHIAkpAwA3AgAgDSAKKQMANwIAIA4gBikDADcCACABKAIIIQIgASABKAIANgIIIAEgAjYCACALIARBIGoiAigCADYCACAJIARBGGoiCCkCADcDACAKIARBEGoiBykCADcDACAGIARBCGoiDSkCADcDACAEKQIAIRMgBCAFKQIANwIAIA0gBUEIaiIEKQIANwIAIAcgBUEQaiIHKQIANwIAIAggBUEYaiIIKQIANwIAIAIgBUEgaiICKAIANgIAIAMgEzcDQCAFIAMpA0A3AgAgAiALKAIANgIAIAggCSkDADcCACAHIAopAwA3AgAgBCAGKQMANwIAIAFBBGohBCABQQxqCyECIBchGAwECyADQThqKgIAIRgCQAJAAn0CQAJAAkACQCAGDgQGAQIDAAtBgMfBAEEoQajpwQAQ5wgACyAZIRoMAwsgBCECIBghGiAXDAELIAFBIGohAiAXIRogGAshFyAZIRgLIAIgBSkCADcCACACQSBqIAVBIGooAgA2AgAgAkEYaiAFQRhqKQIANwIAIAJBEGogBUEQaikCADcCACACQQhqIAVBCGopAgA3AgAgGiEZCyABIBc4ArABIAFBuAFqIBg4AgAgAUG0AWogGTgCAEECDAULIAVB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IARBf2oiBjYCACATKAJ8IgogEUECdCIFaiIEKAIAIQcgBCAGQQJ0IApqKAIANgIAIAggBzYCYCAIKAIkIAdHDQMgDSgCACARTQ0AIA8gEygCfCAFaigCACIETQ0EIARBOGwgFWoiBCgCAEEBRw0FIAQoAgQiBEUNBiAEIBE2AogBCyACKAIIIgQgFE0NBiACKAIMIQQgAiAUNgIMIAIoAgAgFEE4bGoiBUL////39/////4ANwIYIAUgBDYCMCAFQShqQv////f3/////gA3AgAgBUEgakL////39/////4ANwIAIAMoAggiBiADQQRqIgooAgBHBEAgAygCACEEDAgLIAZBAWoiBSAGSQ0AIAZBAXQiBCAFIAQgBUsbIgRBBCAEQQRLGyIEIARB/////wNxRkECdCEFIARBAnQhBAJAIAZFBEAgCEEANgJIDAELIAhBBDYCUCAIIAZBAnQ2AkwgCCADKAIANgJICyAIQeAAaiAEIAUgCEHIAGoQwQYgCCgCZCEEIAgoAmghBSAIKAJgQQFHBEAgAyAENgIAIAogBUECdjYCAAwICyAFRQ0AIAQgBUGElMMAKAIAIgBBrQYgABsRAAAACxCUCwALIBEgBBDxBwALIAhBADYCSEEAIAhB4ABqIAhBJGogCEHIAGpB1KHBABD6BwALIAQgD0HkocEAEPMHAAtBhKPBAEETQbikwQAQ+wkAC0GwvcAAQStByKTBABDnCAALIBQgBEHUosEAEPMHAAsgAyAGQQFqNgIIIAZBAnQgBGogCzYCAAsgICAaQQxqIhpHDQALCyAIQfAAaiQAC48gAwt/An4efSMAQeABayIIJAACQAJAAkACQAJ9AkACQAJAAkACQCADQQRNBEAgAUEgaiIPKAIAIQ0gCEHYAGpC////+////79/NwMAIAhB0ABqQv////v3//+/fzcDACAIQUBrQv////v///+/fzcDACAIQThqQv////v3//+/fzcDACAIQShqQv////v///+/fzcDACAIQSBqQv////v3//+/fzcDACAIQRBqQv////v///+/fzcDACAIQv////v3//+//wA3A0ggCEL////79///v/8ANwMwIAhC////+/f//7//ADcDGCAIQv////v3//+/fzcDCCAIQv////v3//+//wA3AwAgCEGYAWoiEEJ/NwMAIAhCfzcDkAEgAw0BQ///f38hGUP//3//IRdD//9//yEWQ///f/8hGkP//39/ISBD//9/fyEhQ///f/8hIkP//3//ISND//9//yEmQ///f38hJ0P//39/IShD//9/fyEkQ///f/8hJUP//3//ISlD//9//yEqQ///f38hK0P//39/ISxD//9/fyEtQ///f/8hMEP//3//ITFD//9//yEuQ///f38hL0P//39/ITJD//9//yEcQ///f/8hHUP//3//IR5D//9/fyEfQ///f38hG0P//39/IRhD//9/fwwGCyAIQQA2AmggCEIANwNgIANBAnQhC0MAAIA/IAOzlSEVA0AgAiAJaigCACIKIAVPDQIgCCAVIApBGGwgBGoiCioCACAKKgIMkkMAAAA/lCIclCAZkiIZOAJgIAggFSAKKgIIIApBFGoqAgCSQwAAAD+UIh2UIBuSIhs4AmggCCAVIAoqAgQgCkEQaioCAJJDAAAAP5QiHpQgGJIiGDgCZCAaIBUgHCAclJSSIRogFyAVIB0gHZSUkiEXIBYgFSAeIB6UlJIhFiALIAlBBGoiCUcNAAsMAwsgA0ECdCEOQQAhA0P//3//IR5D//9/fyEYIAghCSAIQZABaiEMQ///f38hG0P//39/IR9D//9//yEdQ///f/8hHAJAA0AgAigCACIKIAVJBEAgA0EERg0CIApBGGwgBGoiCyoCACEVIAtBFGoqAgAhGSALQRBqIhEqAgAhFyALQQxqKgIAIRYgC0EIaiISKgIAIRogC0EEaioCACEgIAwgCjYCACAJIAspAgA3AgAgCUEQaiARKQIANwIAIAlBCGogEikCADcCACABKAI8IgsgCk0NBCACQQRqIQIgGCAVIBggFV8bIRggHCAZIBwgGWAbIRwgHSAXIB0gF2AbIR0gHiAWIB4gFmAbIR4gHyAaIB8gGl8bIR8gGyAgIBsgIF8bIRsgASgCNCAKQQxsaiIKIAM6AAQgCiANNgIAIAxBBGohDCAJQRhqIQkgA0EBaiEDIA5BfGoiDg0BDAYLCyAKIAVB8M7BABDzBwALQQRBBEGAz8EAEPMHAAsgCiAFQaDPwQAQ8wcACyAKIAtBkM/BABDzBwALIAggAiADIAQgBSAIQeAAaiICQQIgFiAYIBiUkyIVIBogGSAZlJMiGF0iAyAXIBsgG5STIBUgGCADG10bIglBAWpBA3AQsQQgCEEMaiIDKAIAIQogCCgCCCELIAggCCgCACAIKAIEIAQgBSACIAlBAmpBA3AiCRCxBCADKAIAIQwgCCgCCCENIAgoAgQhDiAIKAIAIQ8gCCALIAogBCAFIAIgCRCxBCADKAIAIQogCCgCCCELIAgoAgQhECAIKAIAIREgAUEgaigCACEJIAhCADcDACAIQgA3AwgCQCABQRxqKAIAIAlHBEAgASgCGCEDDAELIAlBAWoiAiAJSQ0DIAlBAXQiAyACIAMgAksbIgJBBCACQQRLGyICIAJB////D3FGQQR0IQMgAkEHdCECAkAgCUUEQCAIQQA2ArABDAELIAhBuAFqQRA2AgAgCCAJQQd0NgK0ASAIIAEoAhg2ArABCyAIQZABaiACIAMgCEGwAWoQxQYgCEGYAWooAgAhAiAIKAKUASEDIAgoApABQQFHBEAgASADNgIYIAFBHGogAkEHdjYCAAwBCyACRQ0DDAYLIAlBB3QiEiADaiICQv////v///+/fzcDMCACQv////v3//+//wA3AyAgAkL////79///v/8ANwMQIAJC////+/f//7//ADcDCCACQv////v3//+//wA3AwAgAkHYAGpC////+////79/NwMAIAJB0ABqQv////v///+/fzcDACACQcgAakL////7////v383AwAgAkFAa0L////7////v383AwAgAkE4akL////7////v383AwAgAkEoakL////79///v/8ANwMAIAJBGGpC////+/f//7//ADcDACACQegAaiAIKQMINwMAIAIgCCkDADcDYCACIAY2AnAgAkH0AGogBzoAACACQfcAaiAIQZABaiIGQQJqLQAAOgAAIAIgCC8AkAE7AHUgAkEAOwF4IAJB/gBqIAhBtAFqLwEAOwEAIAIgCCgBsAE2AXogAUEgaiIDIAlBAWo2AgAgCEHwAGogASAPIA4gBCAFIAlBABBOIAYgASANIAwgBCAFIAlBARBOIAhBsAFqIAEgESAQIAQgBSAJQQIQTiAIIAEgCyAKIAQgBSAJQQMQTgJAAkAgAygCACICIAlLBEAgCCgCACEEIAgoArABIQUgCCgCkAEhBiABKAIYIBJqIgIgCCgCcDYCYCACQewAaiAENgIAIAJB6ABqIAU2AgAgAkHkAGogBjYCACADKAIAIgIgCU0N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ACIVvEH/////B3G+IhYgFiAUXxsiFCABQQhqIgUqAgAiF7xB/////wdxviIWIBYgFF8bIhQgAUEMaiIEKgIAIhi8Qf////8Hcb4iFiAWIBRfGyIUIAFBEGoiCioCACIZvEH/////B3G+IhYgFiAUXxsiFCABQRRqIggqAgAiGrxB/////wdxviIWIBYgFF8bIhQgAUEYaiIGKgIAIhu8Qf////8Hcb4iFiAWIBRfGyIUIAFBHGoiByoCACIcvEH/////B3G+IhYgFiAUXxsiFCABQSBqIgkqAgAiHbxB/////wdxviIWIBYgFF8bIhZDAAAAAFwEQCAJIB0gFpU4AgAgByAcIBaVOAIAIAYgGyAWlTgCACAIIBogFpU4AgAgCiAZIBaVOAIAIAQgGCAWlTgCACAFIBcgFpU4AgAgAyAVIBaVOAIAIAEgEyAWlTgCAAsgAkG4AWoiA0EgaiABQSBqKAIANgIAIANBGGogAUEYaikCADcDACADQRBqIAFBEGopAgA3AwAgA0EIaiABQQhqKQIANwMAIAIgASkCADcDuAEgAkGAAWoiBSADEKEBIAIqAoABIRcgAioCkAEhGCACKgKgASEZIANBDGpCADcCACADQRRqIgFCADcCACACQdQBakKAgICAgICAwD83AgAgAkIANwK8ASACQYCAgPwDNgK4ASACQYCAgPwDNgLIASACQgE3AuQBIAIgBUEUajYC4AEgAkGoAWoqAgAhEyACQQE2AlwgAiABNgJYQwAAwH9DAACAPyATmCATIBNcGyITQwAAAMCUIhQgAkHgAWogAkHYAGoQ0gKUIRUCQCATQwAAAABbBEAgAiAVIAIqApQBlDgCzAEgAkEBNgJcIAIgAUEMajYCWCACIBQgAkHgAWogAkHYAGoQ0gKUIAIqApQBlDgC2AEMAQsgAiAVIAIqApQBlCATIAIqAswBlJI4AswBIAJBATYCXCACIAFBDGo2AlggAiAUIAJB4AFqIAJB2ABqENIClCACKgKUAZQgEyACKgLYAZSSOALYAQsgAkG4AWpBBHIhASACQgI3AuQBIAIgAkGAAWpBBHI2AuABQwAAwH9DAACAPyACKgKkASITmCATIBNcGyITQwAAAMCUIRQCQCATQwAAAABcBEAgAkECNgJcIAIgATYCWCACIBQgAkHgAWoiAyACQdgAaiIFENIClCIVIAIqAoQBlCATIAIqArwBlJI4ArwBIAIgFSACKgKIAZQgEyACKgLAAZSSOALAASACQQI2AlwgAiABQQxqNgJYIAIgFCADIAUQ0gKUIhUgAioChAGUIBMgAioCyAGUkjgCyAEgAiAVIAIqAogBlCATIAIqAswBlJI4AswBIAJBAjYCXCACIAFBGGo2AlggAiAUIAMgBRDSApQiFCACKgKEAZQgEyACKgLUAZSSOALUASACIBQgAioCiAGUIBMgAioC2AGUkjgC2AEMAQsgAkECNgJcIAIgATYCWCACIBQgAkHgAWoiAyACQdgAaiIFENIClCITIAIqAoQBlDgCvAEgAiATIAIqAogBlDgCwAEgAkECNgJcIAIgAUEMajYCWCACIBQgAyAFENIClCITIAIqAoQBlDgCyAEgAiATIAIqAogBlDgCzAEgAkECNgJcIAIgAUEYajYCWCACIBQgAyAFENIClCITIAIqAoQBlDgC1AEgAiATIAIqAogBlDgC2AELIAJB2ABqIgFBCGoiBSACQbgBaiIDQQhqKQMANwMAIAFBEGoiBCADQRBqKQMANwMAIAFBGGoiCiADQRhqKQMANwMAIAFBIGoiASADQSBqKAIANgIAIAIgAikDuAE3A1ggAioCpAG8Qf////8Hcb4hEyACKgKoAbxB/////wdxviEUIAJBJGogBSkDADcCACACQSxqIAQpAwA3AgAgAkE0aiAKKQMANwIAIAJBPGogASgCADYCACACQQE2AhggAiAZOAJIIAIgGDgCRCACIBc4AkAgAiAUOAJUIAIgEzgCUCACIAIpA1g3AhwgAkEQaiACQUBrIgsgAkHQAGoiBUECEIoFIAVBBGohDiACQTBqIQ9BACEBIAIoAhQhBiACKAIQIQMCQAJAAkACQAJAAkACQAJAAkACQAJAAkADQCABIQogAyAGRgRAIAJByABqIgMgFiADKgIAlDgCACACIBYgAioCQJQ4AkAgAiAWIAIqAkSUOAJEIAJBgAFqIgFBCGoiBSADKAIANgIAIAJBlAFqIAJBGGoiA0EIaikDADcCACACQZwBaiADQRBqKQMANwIAIAJBpAFqIANBGGopAwA3AgAgAkGsAWogA0EgaikDADcCACAAIAIpA0A3AgAgAiACKQMYNwKMASAAQQhqIAUpAwA3AgAgAEEQaiABQRBqKQMA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LQDIASAAQQE6AMgBRQ0DIAQoAhQiAygCBCEBIAMoAgBBfnEiACADKAJAQX5xIgVHBEADQCAAQT5xQT5GBEAgASgC0AsgARDMASEBCyAFIABBAmoiAEcNAAsLIAEEQCABEMwBCyADQYABahCjBSADEMwBDAMLQQALIQJBACEBIABBADoAqAEgAEGsAWogAjoAACAAQcgBaiICLQAAIAJBAToAAARAA0AgASABQQFqIAFBB09BACABQQpLGxshASAALQDIASAAQQE6AMgBDQALCyAAQbABaiEFIABBuAFqIgYoAgAiAQRAIAFBDGwhAiAFKAIAQQhqIQEDQCABKAIAIgcoAhAhAyAHIANBAiADGzYCECADRQRAIAEoAgAoAhhBGGoQrwULIAFBDGohASACQXRqIgINAAsLIAUQygMCfwJAIAYoAgANACAAQcQBaigCAA0AQQEMAQtBAAshASAAQQA6AMgBIABBzAFqIAE6AAALIAQoAhQiAC0AiAIgAEEBOgCIAkUNACAEKAIUIgAoAoQBQTBsBEAgACgCgAEQzAELIABBkAFqEKMFIABBsAFqEKMFIAAQzAELIAQoAhAhAAsCQAJAAkAgAEF9ag4CAAECCyAEQRRqKAIAIgEoAgAhACABIABBf2o2AgAgAEEBRw0BIAQoAhQQ1QkMAQsgBEEUaigCACIBKAIAIQAgASAAQX9qNgIAIABBAUcNACAEKAIUENUJCwJAAkACQAJ/AkACQAJ/AkACQAJAAkAgBCgCGCIAQQFrDgUBAgoKCgALIARBHGooAgAiASgChAIhACABIABBf2o2AoQCIABBAUcNCCAEKAIcIgAoAkAhASAAIAAoAowBIgIgAXI2AkAgASACcQ0HIABBqAFqIgEtAAAgAUEBOgAABEBBACEBA0AgASABQQFqIAFBB09BACABQQpLGxshASAALQCoASAAQQE6AKgBDQALCyAAQZABaiEFIABBmAFqIgYoAgAiAQRAIAFBDGwhAiAFKAIAQQhqIQEDQCABKAIAIgcoAhAhAyAHIANBAiADGzYCECADRQRAIAEoAgAoAhhBGGoQrwULIAFBDGohASACQXRqIgINAAsLIAUQygMgBigCAA0FIABBpAFqKAIADQVBAQwGCyAEQRxqKAIAIgEoAsQBIQAgASAAQX9qNgLEASAAQQFHDQcgBCgCHCIB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AAsgFCAFQbCYwgAQ8wcACyAVIAVBwJjCABDzBwALIAsgBUHQmMIAEPMHAAsgBEHwAGogBEHIAGoQgwMgBCgCcEEBRg0ACwsgBEHQA2oiAUEIaiAEQdgAaiICQQhqKQMANwMAIAFBD2ogAkEPaikAADcAACAEIAQpA1g3A9ADAkAgBCgCTCIBRQ0AIAQoAkgiAkUNACABQQN0RQ0AIAIQzAELIAdBBEcNAQtBnLzBAEErQYjxwQAQ5wgACyAEQYABaiIBQQ9qIARB0ANqIgJBD2opAAA3AAAgAUEIaiACQQhqKQMANwMAIARBoAVqIARBiwFqKQAAIh03AwAgBEGoBWogBEGTAWooAAA2AgAgBCAEKQPQAzcDgAEgBCAEKQCDASIeNwOYBSAAQQhqIB03AgAgACAeNwIAIARBwAVqJAALyBkCC38XfSMAQaAEayIJJAACQAJAAkACQAJAAkACQAJAIANBBE0EQCABQSBqIhAoAgAhDiAJQZgEakL////7////v383AwAgCUGQBGpC////+/f//79/NwMAIAlBgARqQv////v///+/fzcDACAJQfgDakL////79///v383AwAgCUHoA2pC////+////79/NwMAIAlBwANqIgtBIGpC////+/f//79/NwMAIAtBEGpC////+////79/NwMAIAlC////+/f//7//ADcDiAQgCUL////79///v/8ANwPwAyAJQv////v3//+//wA3A9gDIAlC////+/f//79/NwPIAyAJQv////v3//+//wA3A8ADIAlBqANqIhFCfzcDACAJQn83A6ADIAMNAUP//39/IRRD//9//yEVQ///f/8hGUP//3//IRhD//9/fyEWQ///f38hFwwFCyAJQbgCakEANgIAIAlCADcDsAIgA0ECdCEMQwAAgD8gA7OVIRQDQCACIAtqKAIAIgogBU8NAiAJIBQgCkEYbCAEaiIKKgIAIAoqAgySQwAAAD+UIhyUIBWSIhU4ArACIAkgFCAKKgIIIApBFGoqAgCSQwAAAD+UIh2UIBaSIhY4ArgCIAkgFCAKKgIEIApBEGoqAgCSQwAAAD+UIhqUIBeSIhc4ArQCIBkgFCAcIByUlJIhGSAbIBQgHSAdlJSSIRsgGCAUIBogGpSUkiEYIAwgC0EEaiILRw0ACwwDCyADQQJ0IQ9D//9//yEY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aigCAEYNASABKAIAIQUMBwsgACgCCCgCACIFQQhqKAIAIQogACgCDC0AACEOIAAoAhAtAAAhBiADQegDakEANgIAIANBwANqQgA3AwAgA0HIA2pBADYCACADQbADakEANgIAIANCADcD4AMgA0IANwPQAyADQgA3AdYDIANCADcDuAMgA0IANwOoAyAFQQRqKAIAIApHBEAgBSgCACECDAQLIApBAWoiAiAKSQ0EIApBAXQiBCACIAQgAksbIgJBBCACQQRLG61CwAF+IhJCIIinRUEDdCECIBKnIQQCQCAKRQRAIANBADYC6AEMAQsgA0HwAWpBCDYCACADIApBwAFsNgLsASADIAUoAgA2AugBCyADQShqIAQgAiADQegBahDBBiADQTBqKAIAIQQgAygCLCECIAMoAihBAUcEQCAFIAI2AgAgBUEEaiAEQcABbjYCAAwECyAERQ0EIAIgBEGElMMAKAIAIgBBrQYgABsRAAAACyAEQQFqIgggBEkNAyAEQQF0IgUgCCAFIAhLGyIIQQQgCEEESxutQsABfiISQiCIp0VBA3QhCCASpyEFAkAgBEUEQCADQQA2ArgDDAELIANBwANqQQg2AgAgAyAEQcABbDYCvAMgAyABKAIANgK4AwsgA0HQA2ogBSAIIANBuANqEMEGIANB2ANqKAIAIQggAygC1AMhBSADKALQA0EBRwRAIAEgBTYCACABQQRqIAhBwAFuNgIADAYLIAhFDQMgBSAIQYSUwwAoAgAiAEGtBiAAGxEAAAALIAYgDkGI3MAAEPMHAAsgAiAIQeTLwAAQ8wcACyAKQcABbCACaiIEQgA3AyggBEKAgID8AzcDICAEQn83AxAgBEF/NgIIIARCfzcDACAEQRhqQX82AgAgBCADKQPgAzcDMCAEQThqIANB6ANqKAIANgIAIARBgMDAACgCACICNgI8IARBQGsgAykD0AM3AwAgBEHGAGogAykB1gM3AQAgBCACNgJQIARB5ABqIANBuANqIgJBEGooAgA2AgAgBEHcAGogAkEIaikDADcCACAEQdQAaiADKQO4AzcCACADQbADaigCACEJIAMpA6gDIRJBACECIARBADYCfCAEIAFBACAGGzYCeCAEQQAgASAGGzYCdCAEQfAAaiAJNgIAIAQgEjcDaCAEQYgBaiADQShqIgZBCGopAwA3AwAgBEGAAWogAykDKDcDACAGQRBqKQMAIRIgBkEYaigCACEGIARBADYCnAEgBEGYAWogBjYCACAEQZABaiASNwMAIARBqAFqIANB6AFqIgZBCGopAwA3AwAgBEGgAWogAykD6AE3AwAgBEG4AWogBkEYaikDADcDACAEQbABaiAGQRBqKQMANwMAIAVBCGogCkEBajYCACAHQQRqKAIAIQUgB0EYaigCACEGIAcoAgAhCSAHKAIQIQwgCCEEA0AgAkEEaiICIAQgCXEiC2ohBCAFIAtqKAAAQYCBgoR4cSINRQ0ACyAFIA1oQQN2IAtqIAlxIgJqLAAAIgRBAE4EQCAFIAUoAgBBgIGChHhxaEEDdiICai0AACEECyAHQQhqIQsCQCAEQQFxIg1FDQAgCygCAA0AIANB6AFqIAcgDCAGELMBIAdBBGooAgAhBSAHKAIAIQlBACECIAghBANAIAJBBGoiAiAEIAlxIgxqIQQgBSAMaigAAEGAgYKEeHEiD0UNAAsgBSAPaEEDdiAMaiAJcSICaiwAAEEASA0AIAUoAgBBgIGChHhxaEEDdiECCyACIAVqIBA6AAAgAkF8aiAJcSAFakEEaiAQOgAAIAsgCygCACANayIJNgIAIAdBDGoiCygCAEEBaiEEIAsgBDYCACAFIAJBAnRrQXxqIAY2AgACQCAGIAdBFGooAgAiAkcEQCAHQRhqKAIAIQQMAQsgBCAJaiAHQRhqKAIAIgRrIQIgBiAEayACTwRAIAYhAgwBCyACIARqIgIgBEkNASACQQR0IQUgAkH/////AHEgAkZBAnQhAgJAIAZFBEAgA0EANgLoAQwBCyADQfABakEENgIAIAMgBkEEdDYC7AEgAyAHKAIQNgLoAQsgA0EoaiAFIAIgA0HoAWoQwQYgA0EwaigCACECIAMoAiwhBSADKAIoQQFHBEAgByAFNgIQIAdBFGogAkEEdiICNgIADAELIAJFDQEgBSACQYSUwwAoAgAiAEGtBiAAGxEAAAALIAIgBEcEQCAHKAIQIQIMAgsgAkEBaiIFIAJJDQAgAkEBdCIJIAUgCSAFSxsiBUEEIAVBBEsbIgUgBUH/////AHFGQQJ0IQkgBUEEdCEFAkAgAkUEQCADQQA2AugBDAELIANB8AFqQQQ2AgAgAyACQQR0NgLsASADIAcoAhA2AugBCyADQShqIAUgCSADQegBahDBBiADQTBqKAIAIQUgAygCLCECIAMoAihBAUcEQCAHIAI2AhAgB0EUaiAFQQR2NgIADAILIAVFDQAgAiAFQYSUwwAoAgAiAEGtBiAAGxEAAAALEJQLAAsgBEEEdCACaiICQQxqIA46AAAgAiADLwDoATsADSACQQ9qIANB6gFqLQAAOgAAIAIgCjYCCCACIAE2AgQgAiAINgIAIAdBGGogBEEBaiIBNgIAIAEgBksEQCAHKAIQIAZBBHRqQQhqIQIMAgsgBiABQbjcwAAQ8wcACyAEQcABbCAFaiADQegBakHAARCiCRogASAEQQFqNgIICyAAKAIIKAIAIgQoAggiCCACKAIAIgFLBEAgBCgCACABQcABbGohAiAAKAIUIgEoAgQhBCABKAIAIQgCQCAAKAIQLQAABEAgA0HoAWoiBUEIaiIGIAAoAhgoAgAiAUEIaikCADcDACABKQIAIRIgBUEYaiIKIAFBGGooAgA2AgAgBiAGKgIAIhOMOAIAIAMgEjcD6AEgAyABKQIQNwP4ASAKIANB9AFqKgIAIhkgAyoC6AEiFCADQfwBaiIBKgIAIhqUIAMqAuwBIhUgAyoC+AEiG5STIhYgFpIiFpQgFSAVIAoqAgAiHJQgEyAalJMiFyAXkiIXlCAUIBMgG5QgFCAclJMiGCAYkiIYlJOSIByTOAIAIAEgGSAYlCAUIBaUIBMgF5STkiAakzgCACADIBWMOALsASADIBSMOALoASADIBkgF5QgEyAYlCAVIBaUk5IgG5M4AvgBIAggBSAAKAIcIgEoAgAgASgCBCADQZzJwAAgACgCICoCACACIAQoAhARFgAaDAELIAggACgCGCgCACADQZzJwAAgACgCHCIBKAIAIAEoAgQgACgCICoCACACIAQoAhARFgAaCyADQfADaiQADwsgASAIQfTLwAAQ8wcAC44XAw1/A34MfSMAQZAEayIHJAAgByAGNgIoIAdBITYCLCAHQTBqIgZBCGogA0EIaiIJKQIANwMAIAZBGGogAkEIaiIIKAIANgIAIAcgAykCADcDMCAHIAIpAgA3A0AgB0EgaiIKIARBBGooAgAiCzYCBCAKIAQoAgAgCygCCEEHakF4cWo2AgAgBygCICEEIAcoAiQhCiAHQQA2AmAgByAFNgJcIAcgCjYCVCAHIAQ2AlAgByABNgJMIAcgB0EsajYCbCAHIAdBKGo2AmggByAAQQRqKAIAIgE2AnQgByAAKAIAIAEoAghBB2pBeHFqNgJwIAdB+ABqIgFBCGoiBSAJKQIANwMAIAFBGGoiCSAIKAIANgIAIAUgBSoCACIZjDgCACAHIAIpAgA3A4gBIAcgAykCADcDeCAZIAcqAogBIhqUIAcqAngiGyAJKgIAIh6UkyIYIBiSIRwgGyABQRRqIgIqAgAiH5QgByoCfCIYIBqUkyIXIBeSIRcgAiABQQxqKgIAIh0gHJQgGyAXlCAZIBggHpQgGSAflJMiICAgkiIglJOSIB+TOAIAIAkgHSAXlCAYICCUIBsgHJSTkiAekzgCACAHIBuMOAJ4IAcgGIw4AnwgByAdICCUIBkgHJQgGCAXlJOSIBqTOAKIASAHIAdBmAFqNgKUASAHIAdB6ABqNgKwASAHIAdB0ABqNgKsASAHIAdB8ABqNgKoASAHIAE2AqQBIAcgB0HgAGo2AqABIAcgB0HcAGo2ApwBIAcgB0HMAGo2ApgBIAdBuAFqIgIgBCAGIAcoAlQoAhgRAQAgB0HAAmoiAUEQaiACQRBqKQMANwMAIAFBCGogAkEIaikDADcDACAHIAcpA7gBNwPAAiAHQdABaiABENMFIAcgB0GUAWo2ArACIAdBADYCwAIgB0HoA2oiAkEQQQQgARDBBiACQQhqKAIAIQEgBygC7AMhBQJAIAcoAugDQQFGBEAgAUUNASAFIAFBhJTDACgCACIAQa0GIAAbEQAAAAsgBUEANgIAIAFBAnYhCSAAQShqIg4oAgAhA0EBIQYCQAJAA0AgAyAGQX9qIgFBAnQiDyAFaigCACICTQ0BIAdBwAJqIAAoAiAgAkEHdGpBgAEQogkaIActALgDIgQEQCAAKAI8IgIgBygCrAMiCEEYbGpBACAAKAJEIgMgCEsbIRAgBygCqAMiCEEYbCACakEAIAMgCEsbIREgBygCpAMiCEEYbCACakEAIAMgCEsbIRIgAiAHKAKgAyICQRhsakEAIAMgAksbIQ0LIAdBwANqIAdBwAJqIAdB0AFqEO4CAkAgBARAIAcgEDYC5AMgByARNgLgAyAHIBI2AtwDIAcgDTYC2AMgBy0AwAMgBy0AwQNBAXRyIActAMIDQQJ0ciAHLQDDA0EDdHKtQv8BgyEWQgAhFCAHQdgDaiECA0ACQCAWIBSIQgGDUA0AIAIoAgAiBEUNACAHKAKwAigCACIDKAIAKAIAIAQpAwAiFSAEQQhqKAIAIgsQ0wgiCkUNACADKAIEKAIAIgQgCigCeCIIQRB2cUUNACAEQRB2IAhxRQ0AIAMoAggiBCgCACIIBEAgCCAVIAsgCiAEKAIEKAIMERsARQ0BCyADKAIMIgQqAhAhICAEKgIUISEgBCoCGCEiIAcgBCoCCCIZIApB1ABqIghBDGoqAgAiF5QgBCoCACIbIAgqAgQiGpQgBCoCDCIcIAgqAggiHpSSIAQqAgQiGCAIKgIAIh+Uk5I4AvADIAcgGSAflCAYIBeUIBwgGpQgGyAelJOSkjgC7AMgByAcIBeUIBsgH5STIBggGpSTIBkgHpSTOAL0AyAHIBggHpQgHCAflCAbIBeUkpIgGSAalJM4AugDIBsgCEEUaioCACIelCAYIAhBEGoqAgAiH5STIhcgF5IhFyAZIB+UIBsgCEEYaioCACIdlJMiGiAakiEaIAcgIiAdIBwgF5QgGyAalCAYIBggHZQgGSAelJMiHSAdkiIdlJOSkpI4AoAEIAcgISAeIBwgGpQgGSAdlCAbIBeUk5KSkjgC/AMgByAgIB8gHCAdlCAYIBeUIBkgGpSTkpKSOAL4AyADKAIQIgQoAgAgAygCFCIMKAIAIRMgDCgCBCEMIAQoAgQhBCAHQRhqIAoQ2AkgB0HoA2ogEyAMIAcoAhggBygCHCAEKAIMERcAQf0BcUUNACADKAIYIgMoAgQhBCADKAIAKAIAIQMgB0EIaiIIIBU3AwggCCALNgIAIAcgBygCCLgQADYCiAQgByADIAQgB0GIBGoQzgggBygCBCEDAkAgBygCAEUEQCAHIAM2AowEIAdBjARqEJ8KQf8BcSIDQQFxIQQgA0ECRiAHKAKMBCIIQSRPBEAgCBABCyAEciEEDAELQQEhBCADQSRJDQAgAxABCyAHKAKIBCIDQSRPBEAgAxABCyAERQ0DCyACQQRqIQIgFEIBfCIUQgRSDQALCyAHLQDAAyIEQQJGDQAgDigCACEDIActALgDIQICQCAHLQDBA0EBdCAEciAHLQDCA0ECdHIgBy0AwwNBA3RyrSIUQgGDUARAIAEhBgwBCyACQf8BcQRAIAEhBgwBC0EAIQIgBygCoAMiCCADSwRAIAEhBgwBCyABIAlGBEAgCUEBaiIBIAlJDQYgCUEBdCICIAEgAiABSxsiAUEEIAFBBEsbIgEgAUH/////A3FGQQJ0IQIgAUECdCEBAkAgCUUEQCAHQQA2AugDDAELIAdBBDYC8AMgByAFNgLoAyAHIAlBAnQ2AuwDCyAHQdgDaiABIAIgB0HoA2oQwQYgBygC3AMhBSAHKALgAyEEIAcoAtgDQQFGDQUgBEECdiEJCyAFIA9qIAg2AgAgBy0AuAMhAgsCQCAUQv8BgyIUQgKDUA0AIAJB/wFxDQBBACECIAcoAqQDIgggA0sNACAGIAlGBEAgBkEBaiIBIAZJDQYgBkEBdCICIAEgAiABSxsiAUEEIAFBBEsbIgEgAUH/////A3FGQQJ0IQIgAUECdCEBAkAgBgRAIAdBBDYC8AMgByAFNgLoAyAHIAZBAnQ2AuwDDAELIAdBADYC6AMLIAdB2ANqIAEgAiAHQegDahDBBiAHKALcAyEFIAcoAuADIQQgBygC2ANBAUYNBSAEQQJ2IQkLIAZBAnQgBWogCDYCACAGQQFqIQYgBy0AuAMhAgsCQCAUQgSDUA0AIAJB/wFxDQBBACECIAcoAqgDIgggA0sNACAGIAlGBEAgBkEBaiIBIAZJDQYgBkEBdCICIAEgAiABSxsiAUEEIAFBBEsbIgEgAUH/////A3FGQQJ0IQIgAUECdCEBAkAgBgRAIAdBBDYC8AMgByAFNgLoAyAHIAZBAnQ2AuwDDAELIAdBADYC6AMLIAdB2ANqIAEgAiAHQegDahDBBiAHKALcAyEFIAcoAuADIQQgBygC2ANBAUYNBSAEQQJ2IQkLIAZBAnQgBWogCDYCACAGQQFqIQYgBy0AuAMhAgsCQCAUQgiDUA0AIAJB/wFxDQAgBygCrAMiAiADSw0AIAYgCUYEQCAGQQFqIgEgBkkNBiAGQQF0IgQgASAEIAFLGyIBQQQgAUEESxsiASABQf////8DcUZBAnQhBCABQQJ0IQECQCAGBEAgB0EENgLwAyAHIAU2AugDIAcgBkECdDYC7AMMAQsgB0EANgLoAwsgB0HYA2ogASAEIAdB6ANqEMEGIAcoAtwDIQUgBygC4AMhBCAHKALYA0EBRg0FIARBAnYhCQsgBkECdCAFaiACNgIAIAZBAWohBgsgBg0BCwsCQCAJRQ0AIAlBAnRFDQAgBRDMAQsgBygCLCIAQSRPBEAgABABCyAHQZAEaiQADwsgAiADQaiewAAQ8wcACyAERQ0AIAUgBEGElMMAKAIAIgBBrQYgABsRAAAACxCUCwALjhYBB38CQAJAAn8CQAJAAkACQCAAKAIAQQFrDgICAAELIAAoAgQiAigCACEBIAIgAUF/ajYCACABQQFHDQUgACgCBCIBQTxqIgItAAAgAkEBOgAABEBBACEDA0AgAyADQQFqIANBB09BACADQQpLGxshAyABLQA8IAFBAToAPA0ACwsgAUE4ai0AAEUEQCABQQhqIAFBAToAOCABQRBqKAIAIgIEQCACQQxsIQIgASgCCEEIaiEDA0AgAygCACIGKAIQIQQgBiAEQQIgBBs2AhAgBEUEQCADKAIAKAIYQRhqEK8FCyADQQxqIQMgAkF0aiICDQALCxDKAyABQSBqIQUgAUEoaigCACICBEAgAkEMbCECIAUoAgBBCGohAwNAIAMoAgAiBigCECEEIAYgBEECIAQbNgIQIARFBEAgAygCACgCGEEYahCvBQsgA0EMaiEDIAJBdGoiAg0ACwsgBRDKAwsgAUEAOgA8IAAoAgQiAS0AQCABQQE6AEBFDQUgACgCBCIBQQhqEKMFIAFBIGoQowUgARDMAQwFCyAAKAIEIgIoAoACIQEgAiABQX9qNgKAAiABQQFHDQQgACgCBCIDKAJAIQEgAyADKAKMASICIAFyNgJAIAEgAnENAyADQagBaiIBLQAAIAFBAToAAARAQQAhAQNAIAEgAUEBaiABQQdPQQAgAUEKSxsbIQEgAy0AqAEgA0EBOgCoAQ0ACwsgA0GQAWohBSADQZgBaiIGKAIAIgEEQCABQQxsIQIgBSgCAEEIaiEBA0AgASgCACIHKAIQIQQgByAEQQIgBBs2AhAgBEUEQCABKAIAKAIYQRhqEK8FCyABQQxqIQEgAkF0aiICDQALCyAFEMoDIAYoAgANASADQaQBaigCAA0BQQEMAgsgACgCBCICKALAASEBIAIgAUF/ajYCwAEgAUEBRw0DIAAoAgQiASgCQCECIAEgAkEBcjYCQCACQQFxRQRAIAFBmAFqIgItAAAgAkEBOgAABEBBACEDA0AgAyADQQFqIANBB09BACADQQpLGxshAyABLQCYASABQQE6AJgBDQALCyABQYABaiEFIAFBiAFqIgYoAgAiAgRAIAJBDGwhAiAFKAIAQQhqIQMDQCADKAIAIgcoAhAhBCAHIARBAiAEGzYCECAERQRAIAMoAgAoAhhBGGoQrwULIANBDGohAyACQXRqIgINAAsLIAUQygMCfwJAIAYoAgANACABQZQBaigCAA0AQQEMAQtBAAshAiABQQA6AJgBIAFBnAFqIAI6AAALIAAoAgQiAS0AyAEgAUEBOgDIAUUNAyAAKAIEIgQoAgQhASAEKAIAQX5xIgMgBCgCQEF+cSIFRwRAA0AgA0E+cUE+RgRAIAEoAtALIAEQzAEhAQsgBSADQQJqIgNHDQALCyABBEAgARDMAQsgBEGAAWoQowUgBBDMAQwDC0EACyECQQAhASADQQA6AKgBIANBrAFqIAI6AAAgA0HIAWoiAi0AACACQQE6AAAEQANAIAEgAUEBaiABQQdPQQAgAUEKSxsbIQEgAy0AyAEgA0EBOgDIAQ0ACwsgA0GwAWohBSADQbgBaiIGKAIAIgEEQCABQQxsIQIgBSgCAEEIaiEBA0AgASgCACIHKAIQIQQgByAEQQIgBBs2AhAgBEUEQCABKAIAKAIYQRhqEK8FCyABQQxqIQEgAkF0aiICDQALCyAFEMoDAn8CQCAGKAIADQAgA0HEAWooAgANAEEBDAELQQALIQEgA0EAOgDIASADQcwBaiABOgAACyAAKAIEIgEtAIgCIAFBAToAiAJFDQAgACgCBCIBKAKEAUEwbARAIAEoAoABEMwBCyABQZABahCjBSABQbABahCjBSABEMwBCwJAAkACfwJAAkACQAJAIAAoAghBAWsOAgIAAQsgAEEMaigCACICKAIAIQEgAiABQX9qNgIAIAFBAUcNBSAAKAIMIgFBPGoiAi0AACACQQE6AAAEQEEAIQMDQCADIANBAWogA0EHT0EAIANBCksbGyEDIAEtADwgAUEBOgA8DQALCyABQThqLQAARQRAIAFBCGogAUEBOgA4IAFBEGooAgAiAgRAIAJBDGwhAiABKAIIQQhqIQMDQCADKAIAIgYoAhAhBCAGIARBAiAEGzYCECAERQRAIAMoAgAoAhhBGGoQrwULIANBDGohAyACQXRqIgINAAsLEMoDIAFBIGohBSABQShqKAIAIgIEQCACQQxsIQIgBSgCAEEIaiEDA0AgAygCACIGKAIQIQQgBiAEQQIgBBs2AhAgBEUEQCADKAIAKAIYQRhqEK8FCyADQQxqIQMgAkF0aiICDQALCyAFEMoDCyABQQA6ADwgACgCDCIBLQBAIAFBAToAQEUNBSAAKAIMIgBBCGoQowUgAEEgahCjBSAAEMwBDwsgAEEMaigCACICKAKAAiEBIAIgAUF/ajYCgAIgAUEBRw0EIAAoAgwiAygCQCEBIAMgAygCjAEiAiABcjYCQCABIAJxDQMgA0GoAWoiAS0AACABQQE6AAAEQEEAIQEDQCABIAFBAWogAUEHT0EAIAFBCksbGyEBIAMtAKgBIANBAToAqAENAAsLIANBkAFqIQUgA0GYAWoiBigCACIBBEAgAUEMbCECIAUoAgBBCGohAQNAIAEoAgAiBygCECEEIAcgBEECIAQbNgIQIARFBEAgASgCACgCGEEYahCvBQsgAUEMaiEBIAJBdGoiAg0ACwsgBRDKAyAGKAIADQEgA0GkAWooAgANAUEBDAILIABBDGooAgAiAigCwAEhASACIAFBf2o2AsABIAFBAUcNAyAAKAIMIgEoAkAhAiABIAJBAXI2AkAgAkEBcUUEQCABQZgBaiICLQAAIAJBAToAAARAQQAhAwNAIAMgA0EBaiADQQdPQQAgA0EKSxsbIQMgAS0AmAEgAUEBOgCYAQ0ACwsgAUGAAWohBSABQYgBaiIGKAIAIgIEQCACQQxsIQIgBSgCAEEIaiEDA0AgAygCACIHKAIQIQQgByAEQQIgBBs2AhAgBEUEQCADKAIAKAIYQRhqEK8FCyADQQxqIQMgAkF0aiICDQALCyAFEMoDAn8CQCAGKAIADQAgAUGUAWooAgANAEEBDAELQQALIQIgAUEAOgCYASABQZwBaiACOgAACyAAKAIMIgEtAMgBIAFBAToAyAFFDQMgACgCDCICKAIEIQAgAigCAEF+cSIDIAIoAkBBfnEiBEcEQANAIANBPnFBPkYEQCAAKALQCyAAEMwBIQALIAQgA0ECaiIDRw0ACwsgAARAIAAQzAELIAJBgAFqEKMFIAIQzAEMAwtBAAshAkEAIQEgA0EAOgCoASADQawBaiACOgAAIANByAFqIgItAAAgAkEBOgAABEADQCABIAFBAWogAUEHT0EAIAFBCksbGyEBIAMtAMgBIANBAToAyAENAAsLIANBsAFqIQUgA0G4AWoiBigCACIBBEAgAUEMbCECIAUoAgBBCGohAQNAIAEoAgAiBygCECEEIAcgBEECIAQbNgIQIARFBEAgASgCACgCGEEYahCvBQsgAUEMaiEBIAJBdGoiAg0ACwsgBRDKAwJ/AkAgBigCAA0AIANBxAFqKAIADQBBAQwBC0EACyEBIANBADoAyAEgA0HMAWogAToAAAsgACgCDCIBLQCIAiABQQE6AIgCRQ0AIAAoAgwiACgChAFBMGwEQCAAKAKAARDMAQsgAEGQAWoQowUgAEGwAWoQowUgABDMAQsL0hYDHH8Cfgp9IwBB0ANrIgUkACAFIAI2AmQgBUE8aiACKgIMIiM4AgAgBUE4aiAjOAIAIAVBNGogIzgCACAFQSxqIAIqAggiJTgCACAFQShqICU4AgAgBUEkaiAlOAIAIAVBHGogAioCBCImOAIAIAVBGGogJjgCACAFQRRqICY4AgAgBUHcAGogAkEUaioCACIkOAIAIAVB2ABqICQ4AgAgBUHUAGogJDgCACAFQdAAaiAkOAIAIAVBzABqIAJBEGoqAgAiJDgCACAFQcgAaiAkOAIAIAVBxABqICQ4AgAgBUFAayAkOAIAIAUgATYCYCAFIAQ6AGwgBSADOAJoIAUgIzgCMCAFICU4AiAgBSAmOAIQIAUgAioCACIDOAIMIAUgAzgCCCAFIAM4AgQgBSADOAIAAkACQCABQSBqKAIAIgwEQCAFQgA3AnQgBUGUv8EAKAIANgJwIAVB8ABqIgJBAEP////+EOYDIAVBkAFqIAIQgwMCQCAFKAKQAUEBRwRAQQQhBAwBCyAFQdACakEEciENIAVBsANqIgJBDGohCyACQQRyIRVD//9/fyEjQQQhBANAICMgBSoCmAGMXw0BAkACQAJAAkAgDCAFKAKUASICSwRAIAVBoAFqIAEoAhggAkEHdGpBgAEQogkaIAUtAJgCIhYEQCABKAI0IgIgBSgCjAIiBkEMbGpBACABKAI8IgcgBksbIgZBCGpBACAGGyEXIAUoAogCIgZBDGwgAmpBACAHIAZLGyIGQQhqQQAgBhshGCAFKAKEAiIGQQxsIAJqQQAgByAGSxsiBkEIakEAIAYbIRkgAiAFKAKAAiICQQxsakEAIAcgAksbIgJBCGpBACACGyEUCyAFIAUqAmgiJzgCvAMgBSAnOAK4AyAFICc4ArQDIAUgJzgCsAMgBUHQAmogBUGgAWogBSAFQbADahDsASAFQcgCaiIHIA1BCGoiECgCADYCACAFIA0pAgA3A8ACIAUoAtACIQIgBSoC4AIhJSAFKgLkAiEDIAUqAugCISYgBSoC7AIhJAJAIBZFBEBBBCEHQQQhBkEEIQ5BBCEPDAELIBUgBSkDwAI3AgAgFUEIaiAHKAIANgIAIAUgAjYCsAMgBSAkICNdOgDTAiAFICYgI106ANICIAUgAyAjXToA0QIgBSAlICNdOgDQAiAFQaADaiAFQbADaiAFQdACahCiCCAFLQCgAyAFLQChA0EBdHIgBS0AogNBAnRyIAUtAKMDQQN0cq0hIUMAAAAAIQNBACEaQQQhDiAFLQBsIREgBSgCZCESIAUoAmAhAkEEIQ9BACEbAn1DAAAAACAURQ0AGkMAAAAAICFCAYNQDQAaIAIoAlQiCSAUKAIAIghNDQMgAigCSCIJIAIoAkwgCEEDdGoiBygCACIITQ0EIAkgBygCBCIKTQ0FIAsgAigCQCIHIApBDGxqIgYpAgA3AgAgBUGwA2oiD0EIaiAIQQxsIAdqIgdBCGooAgA2AgAgC0EIaiAGQQhqKAIANgIAIAUgBykCADcDsAMgBUHQAmogDyASICcgEUEARxDqAUMAAAAAIAUoAuACIg9BBEYNABogBUGoA2ogECgCADYCACAFIA0pAgA3A6ADQQEhGyAFKALkAiEeIAUqAtACIikLISUgIUL/AYMhIQJAIBlFDQAgIUICg1ANACACKAJUIgkgGSgCACIITQ0DIAIoAkgiCSACKAJMIAhBA3RqIgcoAgAiCE0NBCAJIAcoAgQiCk0NBSALIAIoAkAiByAKQQxsaiIGKQIANwIAIAVBsANqIg5BCGogCEEMbCAHaiIHQQhqKAIANgIAIAtBCGogBkEIaigCADYCACAFIAcpAgA3A7ADIAVB0AJqIA4gEiAnIBFBAEcQ6gEgBSgC4AIiDkEERg0AIAVBmANqIBAoAgA2AgAgBSANKQIANwOQA0GAAiEaIAUoAuQCIR8gBSoC0AIiKiEDC0MAAAAAISRBACEcQQQhB0EEIQZBACEdAn1DAAAAACAYRQ0AGkMAAAAAICFCBINQDQAaIAIoAlQiCSAYKAIAIghNDQMgAigCSCIJIAIoAkwgCEEDdGoiBigCACIITQ0EIAkgBigCBCIKTQ0FIAsgAigCQCIGIApBDGxqIgkpAgA3AgAgBUGwA2oiCkEIaiAIQQxsIAZqIgZBCGooAgA2AgAgC0EIaiAJQQhqKAIANgIAIAUgBikCADcDsAMgBUHQAmogCiASICcgEUEARxDqAUMAAAAAIAUoAuACIgZBBEYNABogBUGIA2ogECgCADYCACAFIA0pAgA3A4ADQYCABCEdIAUoAuQCISAgBSoC0AIiKwshJgJAIBdFDQAgIUIIg1ANACACKAJUIgkgFygCACIITQ0DIAIoAkgiCSACKAJMIAhBA3RqIgcoAgAiCE0NBCAJIAcoAgQiCk0NBSALIAIoAkAiAiAKQQxsaiIHKQIANwIAIAVBsANqIglBCGogCEEMbCACaiICQQhqKAIANgIAIAtBCGogB0EIaigCADYCACAFIAIpAgA3A7ADIAVB0AJqIAkgEiAnIBFBAEcQ6gEgBSgC4AIiB0EERg0AIAVB+AJqIBAoAgA2AgAgBSANKQIANwPwAkGAgIAIIRwgBSgC5AIhCCAFKgLQAiIkISwLIAVB2AJqIAVBqANqKAIANgIAIAVBuANqIAVBmANqKAIANgIAIAVBuAJqIAVBiANqKAIANgIAIAUgBSkDoAM3A9ACIAUgBSkDkAM3A7ADIAUgBSkDgAM3A7ACIAUgBSkD8AI3A6ACIAUgBUH4AmooAgA2AqgCIB1BgIAEcSAaQYACcSAbcnIgHHIhAgsgAkEVdkH4AXEgAkEOdkH8AXEgAkEHdkH+AXEgAkH/AXFycnKtIiFCAYMhIiAWBEAgASgCPCECAkAgJSAjXUEBcw0AICJQDQAgD0EERg0AIAIgBSgCgAJNDQAgBUGIAWogBUHYAmooAgA2AgAgBSAFKQPQAjcDgAEgKSEoIB4hEyAPIQQgJSEjCwJAIAIgBSgChAJNDQAgDkEERg0AICFCAoNQDQAgAyAjXUEBcw0AIAVBiAFqIAVBuANqKAIANgIAIAUgBSkDsAM3A4ABICohKCAfIRMgDiEEIAMhIwsCQCACIAUoAogCTQ0AIAZBBEYNACAhQgSDUA0AICYgI11BAXMNACAFQYgBaiAFQbgCaigCADYCACAFIAUpA7ACNwOAASArISggICETIAYhBCAmISMLIAIgBSgCjAJNDQUgB0EERg0FICFCCINQDQUgJCAjXUEBcw0FIAVBiAFqIAUoAqgCNgIAIAUgBSkDoAI3A4ABICwhKCAIIRMgByEEICQhIwwFCwJAICJQDQAgBSgCgAIiAiAMTw0AIAVB8ABqIAIgJYwQ5gMLAkAgIUICg1ANACAFKAKEAiICIAxPDQAgBUHwAGogAiADjBDmAwsCQCAhQgSDUA0AIAUoAogCIgIgDE8NACAFQfAAaiACICaMEOYDCyAhQgiDUA0EIAUoAowCIgIgDE8NBCAFQfAAaiACICSMEOYDDAQLIAIgDEHwz8EAEPMHAAsgCCAJQfT2wQAQ8wcACyAIIAlBhPfBABDzBwALIAogCUGU98EAEPMHAAsgBUGQAWogBUHwAGoQgwMgBSgCkAFBAUYNAAsLIAVBqAFqIAVBiAFqKAIANgIAIAUgBSkDgAE3A6ABAkAgBSgCdCIBRQ0AIAUoAnAiAkUNACABQQN0RQ0AIAIQzAELIARBBEcNAQsgAEEENgIQDAELIAAgKDgCACAAIAUpA6ABNwIEIAAgEzYCFCAAIAQ2AhAgAEEMaiAFQagBaigCADYCAAsgBUHQA2okAAu6FgMPfwJ+BX0jAEGwA2siBCQAIAQgAjYCNCAEQSxqIAIqAggiFjgCACAEQShqIBY4AgAgBEEkaiAWOAIAIARBHGogAioCBCIVOAIAIARBGGogFTgCACAEQRRqIBU4AgAgBCABNgIwIAQgAzoAOCAEIBY4AiAgBCAVOAIQIAQgAioCACIWOAIMIAQgFjgCCCAEIBY4AgQgBCAWOAIAAkAgAUEsaigCACILBEAgBEIANwJEIARBlL/BACgCADYCQCAEQUBrIgJBAEP////+EOYDIARB4ABqIAIQgwNBAiECAkAgBCgCYEEBRw0AIARBrQNqIQhD//9/fyEWIARBowNqIg1BCGohDgNAIBYgBCoCaIxfDQECQCALIAQoAmQiA0sEQCAEQfAAaiABKAIkIANBB3RqQYABEKIJGiAELQDoASIJBEAgASgCQCIDIAQoAtwBIgVBDGxqQQAgASgCSCIGIAVLGyIFQQhqQQAgBRshECAEKALYASIFQQxsIANqQQAgBiAFSxsiBUEIakEAIAUbIREgBCgC1AEiBUEMbCADakEAIAYgBUsbIgVBCGpBACAFGyESIAMgBCgC0AEiA0EMbGpBACAGIANLGyIDQQhqQQAgAxshDwsgBEHAAmogBEHwAGogBBD+ASAEKgLAAiIZIBZdIQMgBCoCzAIhFSAEKgLIAiEXIAQqAsQCIRgCQCAJRQRAQQIhBSAYIBZdQQF0IANyIBcgFl1BAnRyIBUgFl1BA3RyrSETQQIhBkECIQxBAiEDDAELQQIhDCAYIBZdQQF0IANyIBcgFl1BAnRyIBUgFl1BA3RyrSETQwAAAAAhGEMAAAAAIRkCf0ECIA9FDQAaQQIgE0IBg1ANABpBAiAEKAIwIgYoAgggDygCACIFTQ0AGiAGKAIAIAVBJGxqIgNBIGooAgAhBiAEQaADaiIFIAMoAhwgBigCCEEHakF4cWogAyAEKAI0IAQtADggBigCcBEIACAEKgKgAyAEKAI0IgMqAgCTIhUgFZQgBCoCpAMgAyoCBJMiFSAVlJIgBUEIaiIGKgIAIAMqAgiTIhUgFZSSQwAAAACSEJ0BIRkgBEGYA2ogBigCADYCACAEQY4DaiAIQQJqLQAAOgAAIAQgBCkDoAM3A5ADIAQgCC8AADsBjAMgBC0ArAMLIQMCQCASRQ0AIBNCAoNQDQAgBCgCMCIGKAIIIBIoAgAiBU0NACAGKAIAIAVBJGxqIgZBIGooAgAhBSAEQaADaiIMIAYoAhwgBSgCCEEHakF4cWogBiAEKAI0IAQtADggBSgCcBEIACAEKgKgAyAEKAI0IgYqAgCTIhUgFZQgBCoCpAMgBioCBJMiFSAVlJIgDEEIaiIFKgIAIAYqAgiTIhUgFZSSQwAAAACSEJ0BIRggBEGIA2ogBSgCADYCACAEQf4CaiAIQQJqLQAAOgAAIAQgBCkDoAM3A4ADIAQgCC8AADsB/AIgBC0ArAMhDAtBAiEFQwAAAAAhFUMAAAAAIRcCf0ECIBFFDQAaQQIgE0IEg1ANABpBAiAEKAIwIgcoAgggESgCACIKTQ0AGiAHKAIAIApBJGxqIgZBIGooAgAhByAEQaADaiIKIAYoAhwgBygCCEEHakF4cWogBiAEKAI0IAQtADggBygCcBEIACAEKgKgAyAEKAI0IgYqAgCTIhcgF5QgBCoCpAMgBioCBJMiFyAXlJIgCkEIaiIHKgIAIAYqAgiTIhcgF5SSQwAAAACSEJ0BIRcgBEH4AmogBygCADYCACAEQe4CaiAIQQJqLQAAOgAAIAQgBCkDoAM3A/ACIAQgCC8AADsB7AIgBC0ArAMLIQYCQCAQRQ0AIBNCCINQDQAgBCgCMCIHKAIIIBAoAgAiCk0NACAHKAIAIApBJGxqIgVBIGooAgAhByAEQaADaiIKIAUoAhwgBygCCEEHakF4cWogBSAEKAI0IAQtADggBygCcBEIACAEKgKgAyAEKAI0IgUqAgCTIhUgFZQgBCoCpAMgBSoCBJMiFSAVlJIgCkEIaiIHKgIAIAUqAgiTIhUgFZSSQwAAAACSEJ0BIRUgBEHoAmogBygCADYCACAEQd4CaiAIQQJqLQAAOgAAIAQgBCkDoAM3A+ACIAQgCC8AADsB3AIgBC0ArAMhBQsgBEG4AmogBEGYA2ooAgA2AgAgBEGoAmogBEGIA2ooAgA2AgAgBEGYAmogBEH4AmooAgA2AgAgBEGuAmogBEGOA2otAAA6AAAgBCAEKQOQAzcDsAIgBCAEKQOAAzcDoAIgBCAEKQPwAjcDkAIgBCAEKQPgAjcDgAIgBCAELwGMAzsBrAIgBCAEQegCaigCADYCiAIgBEGeAmogBEH+AmotAAA6AAAgBEGOAmogBEHuAmotAAA6AAAgBEH+AWogBEHeAmotAAA6AAAgBCAELwH8AjsBnAIgBCAELwHsAjsBjAIgBCAELwHcAjsB/AELIBNCAYMhFCAJBEAgASgCSCEJAkAgFFANACAZIBZdQQFzDQAgA0H/AXFBAkYNACAJIAQoAtABTQ0AIA0gBCkDsAI3AAAgDiAEQbgCaigCADYAACAEQc4AaiAEQa4Cai0AADoAACAEIARBpwNqKQAANwDHAiAEIAQpAKADNwPAAiAEIAQvAawCOwFMIAQgBCkDwAI3A1AgBCAEKQDHAjcAVyADIQIgGSEWCwJAIAkgBCgC1AFNDQAgDEH/AXFBAkYNACATQgKDUA0AIBggFl1BAXMNACANIAQpA6ACNwAAIA4gBEGoAmooAgA2AAAgBEHOAGogBEGeAmotAAA6AAAgBCAEQacDaikAADcAxwIgBCAEKQCgAzcDwAIgBCAELwGcAjsBTCAEIAQpA8ACNwNQIAQgBCkAxwI3AFcgDCECIBghFgsCQCAJIAQoAtgBTQ0AIAZB/wFxQQJGDQAgE0IEg1ANACAXIBZdQQFzDQAgDSAEKQOQAjcAACAOIARBmAJqKAIANgAAIARBzgBqIARBjgJqLQAAOgAAIAQgBEGnA2opAAA3AMcCIAQgBCkAoAM3A8ACIAQgBC8BjAI7AUwgBCAEKQPAAjcDUCAEIAQpAMcCNwBXIAYhAiAXIRYLIAkgBCgC3AFNDQIgBUH/AXFBAkYNAiATQgiDUA0CIBUgFl1BAXMNAiAOIAQoAogCNgAAIA0gBCkDgAI3AAAgBEHOAGogBEH+AWotAAA6AAAgBCAEQacDaikAADcAxwIgBCAEKQCgAzcDwAIgBCAELwH8ATsBTCAEIAQpA8ACNwNQIAQgBCkAxwI3AFcgBSECIBUhFgwCCwJAIBRQDQAgBCgC0AEiAyALTw0AIARBQGsgAyAZjBDmAwsCQCATQgKDUA0AIAQoAtQBIgMgC08NACAEQUBrIAMgGIwQ5gMLAkAgE0IEg1ANACAEKALYASIDIAtPDQAgBEFAayADIBeMEOYDCyATQgiDUA0BIAQoAtwBIgMgC08NASAEQUBrIAMgFYwQ5gMMAQsgAyALQfDPwQAQ8wcACyAEQeAAaiAEQUBrEIMDIAQoAmBBAUYNAAsLIARBwgJqIARBzgBqLQAAOgAAIAQgBCkDUDcDcCAEIAQpAFc3AHcgBCAELwFMOwHAAgJAIAQoAkQiAUUNACAEKAJAIgNFDQAgAUEDdEUNACADEMwBCyACQf8BcUECRw0BC0GcvMEAQStB6PDBABDnCAALIAAgBC8BwAI7AA0gAEEPaiAEQcICai0AADoAACAEIAQpAHc3AKcDIAQgBCkDcDcDoAMgAEEIaiAEQasDaigAADYAACAAIAQpAKMDNwAAIAAgAjoADCAEQbADaiQAC6IWAxF/Bn4EfSMAQbAFayIIJAAgCEEIaiIKQRBqIAc2AgAgCEEANgIUIAggBjYCECAIIAI2AgwgCCABNgIIIAhBsARqIgJBEGogA0EQaikCADcDACACQQhqIANBCGopAgA3AwAgCCADKQIANwOwBCAIQSBqIAIQ0wUgCCAFOgCMASAIIAQ4AogBIAggAzYChAEgCCAKNgKAASAAAn5CACABQShqKAIAIgtFDQAaIAhCADcClAEgCEGAwMAAKAIANgKQASAIQZABaiICQQBD/////hDjAyAIQcABaiACEIMDAkAgCCgCwAFBAUcNACAIQbAEaiICQQNqIQcgCEGYBWohDiAIQfgEaiEPIAhB2ARqIRAgAkEIaiEKIAhB0ANqQQRyIRIgAkEEciETQ///f38hBANAIAQgCCoCyAGMXw0BIAsgCCgCxAEiAksEQCAIQdABaiABKAIgIAJBB3RqQYABEKIJGiAILQDIAiIFBEAgASgCPCICIAgoArwCIgZBGGxqQQAgASgCRCIDIAZLGyEVIAgoArgCIgZBGGwgAmpBACADIAZLGyEWIAgoArQCIgZBGGwgAmpBACADIAZLGyEXIAIgCCgCsAIiAkEYbGpBACADIAJLGyEUCyAIIAgqAogBIh84AtwCIAggHzgC2AIgCCAfOALUAiAIIB84AtACIAhBsARqIAhB0AFqIAhBIGogCEHQAmoQ7AEgCEGABGoiBiATQQhqKAIANgIAIAggEykCADcD+AMgCCgCsAQhAyAIKgLABCEfIAgqAsQEISAgCCoCyAQhISAIKgLMBCEiAn4gBUUEQEIAIRxCACEdQgAhHkIADAELIAggFTYClAQgCCAWNgKQBCAIIBc2AowEIAggFDYCiARCACEbIAhBmARqIgJBCGpCADcDACAIQgA3A5gEIAhBADYCrAQgCEIANwOQBSAIQgA3A/AEIAhCADcD0AQgCEIANwOwBCAIIAM2AtADIBIgCCkD+AM3AgAgEkEIaiAGKAIANgIAIAggIiAEXToA0wIgCCAhIARdOgDSAiAIICAgBF06ANECIAggHyAEXToA0AIgCEGwA2ogCEHQA2ogCEHQAmoQogggCC0AsAMgCC0AsQNBAXRyIAgtALIDQQJ0ciAILQCzA0EDdHKtQv8BgyEcIAhBrARqIQYgCEGwBGohBSAIQYgEaiEDA0AgGyIZQgF8IRsCQCAcIBmIQgGDUA0AIAMoAgAiDEUNACAIKAKAASINKAIEIglBEGooAgAgDCgCCCIRTQ0AIAkoAgggEUGYAWxqIgkoAgBBAUcNACAMKQMAIhkgCUEIaikDAFINACANKAIIIgwgCUGIAWooAgAiGEEQdnFFDQAgDEEQdiAYcUUNACANKAIMIgwEQCAMIBkgESAJQRBqIA1BEGooAgAoAgwRGwBFDQELIAggCUEwaigCACAJQTRqKAIAIg0oAghBB2pBeHFqIAlB5ABqIAgoAoQBIAgqAogBIAgtAIwBIA0oAowBEQkAIAgoAgBBAUcNACAIKgIEIR8gBUIBNwMAIAZBAToAACACIB84AgAgBUEYaiAfOAIAIAVBEGogETYCACAFQQhqIBk3AwALIANBBGohAyAFQSBqIQUgBkEBaiEGIAJBBGohAiAbQgRSDQALIAhBsANqIgJBCGogCkEIaikDADcDACACQRBqIApBEGopAwA3AwAgCEGgA2ogEEEQaikDADcDACAIIAopAwA3A7ADIAggECkDADcDkAMgCCAQQQhqKQMANwOYAyAIKQOwBCEeIAgoAqwEIQMgCCoCpAQhIiAIKgKgBCEhIAgqApwEISAgCCoCmAQhHyAIKQPQBCEdIAhBgANqIA9BEGopAwA3AwAgCEHgAmogDkEQaikDADcDACAIIA9BCGopAwA3A/gCIAggDykDADcD8AIgCCAOQQhqKQMANwPYAiAIIA4pAwA3A9ACIAgpA/AEIRwgCCkDkAULIRsgASgCRCECAkAgA0EVdkH4AXEgA0EOdkH8AXEgA0EHdkH+AXEgA0H/AXFycnKtIhlCAYNQDQAgCC0AyAIEQCAfIARdQQFzDQEgHkIBUg0BIAIgCCgCsAJNDQEgByAIKQOwAzcAACAHQRBqIAhBsANqIgNBEGopAwA3AAAgB0EIaiADQQhqKQMANwAAIAhB0ANqIgNBF2oiBSAIQbAEaiIGQRdqKAAANgAAIANBEGoiCSAGQRBqKQAANwMAIANBCGogCikAACIaNwMAIAggCCkAsAQiHjcD0AMgCEGgAWoiA0EXaiAFKAAANgAAIANBEGogCSkDADcDACADQQhqIBo3AwAgCCAeNwOgAUIBIRogHyEEDAELIAgoArACIgMgC08NACAIQZABaiADIB+MEOMDCwJAIBlCAoNQDQAgCC0AyAIEQCAdQgFSDQEgICAEXUEBcw0BIAIgCCgCtAJNDQEgB0EIaiAIKQOYAzcAACAHIAgpA5ADNwAAIAdBEGogCEGgA2opAwA3AAAgCEHQA2oiA0EXaiIFIAhBsARqIgZBF2ooAAA2AAAgA0EQaiIJIAZBEGopAAA3AwAgA0EIaiAKKQAAIho3AwAgCCAIKQCwBCIdNwPQAyAIQaABaiIDQRdqIAUoAAA2AAAgA0EQaiAJKQMANwMAIANBCGogGjcDACAIIB03A6ABQgEhGiAgIQQMAQsgCCgCtAIiAyALTw0AIAhBkAFqIAMgIIwQ4wMLAkAgGUIEg1ANACAILQDIAgRAIBxCAVINASAhIARdQQFzDQEgAiAIKAK4Ak0NASAHQQhqIAgpA/gCNwAAIAcgCCkD8AI3AAAgB0EQaiAIQYADaikDADcAACAIQdADaiIDQRdqIgUgCEGwBGoiBkEXaigAADYAACADQRBqIgkgBkEQaikAADcDACADQQhqIAopAAAiGjcDACAIIAgpALAEIhw3A9ADIAhBoAFqIgNBF2ogBSgAADYAACADQRBqIAkpAwA3AwAgA0EIaiAaNwMAIAggHDcDoAFCASEaICEhBAwBCyAIKAK4AiIDIAtPDQAgCEGQAWogAyAhjBDjAwsCQCAZQgiDUA0AIAgtAMgCBEAgG0IBUg0BICIgBF1BAXMNASACIAgoArwCTQ0BIAdBCGogCCkD2AI3AAAgByAIKQPQAjcAACAHQRBqIAhB4AJqKQMANwAAIAhB0ANqIgJBF2oiAyAIQbAEaiIFQRdqKAAANgAAIAJBEGoiBiAFQRBqKQAANwMAIAJBCGogCikAACIbNwMAIAggCCkAsAQiGTcD0AMgCEGgAWoiAkEXaiADKAAANgAAIAJBEGogBikDADcDACACQQhqIBs3AwAgCCAZNwOgAUIBIRogIiEEDAELIAgoArwCIgIgC08NACAIQZABaiACICKMEOMDCyAIQcABaiAIQZABahCDAyAIKALAAUEBRg0BDAILCyACIAtB8MXAABDzBwALIAhB0AFqIgFBCGogCEGgAWoiAkEIaikDADcDACABQRBqIAJBEGopAwA3AwAgAUEXaiACQRdqKAAANgAAIAggCCkDoAE3A9ABAkAgCCgClAEiAUUNACAIKAKQASICRQ0AIAFBA3RFDQAgAhDMAQtCACAaQgFSDQAaIAhBsARqIgFBCGogCEHQAWoiAkEIaikDADcDACABQRBqIAJBEGopAwA3AwAgAUEXaiACQRdqKAAANgAAIAggCCkD0AE3A7AEIAAgCCkAswQ3AAggAEEQaiAIQbsEaikAADcAACAAQRhqIAhBwwRqKQAANwAAQgELNwMAIAhBsAVqJAALphkDDn8Dfg59IwBBgAFrIgMkAAJAAkACQAJAAkAgAigCACIKRQRAIAFBCGooAgBBf2oiCCAIQf////8BcUYiAkUNBCAIQQN0IgVBf0wNBCACQQJ0IQQCfyAFBEAgBUEDdkEAIAUgBBDICiIKGwwBCyAEIQpBAAshCyAKRQ0BAkAgCyAISQRAIAtBAXQiAiAIIAIgCEsbIgJBBCACQQRLG0EDdCECAkAgC0UEQCADQQA2AgAMAQsgA0EIakEENgIAIAMgCjYCACADIAtBA3Q2AgQLIANB0ABqIAJBBCADEMUGIANB2ABqKAIAIQIgAygCVCEKIAMoAlBBAUcEQCACQQN2IQsMAgsgAkUNBiAKIAJBhJTDACgCACIAQa0GIAAbEQAAAAsgCEUNAwsgCiECIAitIRFCgICAgBAhEgNAIAIgEiAThDcCACASQoCAgIAQfCESIAJBCGohAiARIBNCAXwiE1INAAsMAwsgAkEIaigCACEIIAIoAgQhCwwCCyAFIARBhJTDACgCACIAQa0GIAAbEQAAAAtBACEIC0EEIQwCQEEgQQQQyAoiAgRAIANBHGpCADcCACADQRBqQv////v///+/fzcDACADQSRqQgA3AgAgA0EwakEINgIAIANBLGogAjYCACADQThqQgA3AwAgA0EgakEANgIAIANBnL/BACgCADYCGCADQv////v3//+/fzcDCCADQv////v3//+//wA3AwAgA0GUv8EAKAIANgI0AkAgCEEDdCIGBEAgBkEBdiICQQQQyAoiDEUNAQsgA0HQAGoiAkEQakL////7////v383AwAgA0L////79///v383A1ggA0L////79///v/8ANwNQIANBQGsgAiAIQf////8BcSIJELsEIAmtQgx+IhFCIIinIgINAyARpyIHQX9MDQMgAkVBAnQhBQJ/IAcEQCAHQQxuQQAgByAFEMgKIgQbDAELIAUhBEEACyECIAQEQCAGIApqIRAgA0E0aiENQQAhBiADQQA2AnggAyACNgJ0IAMgBDYCcCADQX82AlggA0EAOgBUIANBfzYCUCADQfAAaiAJIANB0ABqEJcEAkAgAygCOCIERQ0AIAMoAjQiAkUNACAEQQxsRQ0AIAIQzAELIA0gAykDcDcCACANQQhqIANB+ABqKAIANgIAIAogEEYNAyAKIQUCQAJAAkADQAJAAkACQCABKAIIIgIgBSgCACIESwRAIAIgBSgCBCIHTQRAIAcgAkHk9sEAEPMHAAsgASgCACICIARBDGxqIgQqAgghFCAEKgIEIRUgBCoCACEWIAdBDGwgAmoiAioCBCEXIAIqAgAhGCACKgIIIRkgBiADKAI8IgRJDQMgA0F/NgJYIANBADoAVCADQX82AlAgDSAGQQFqIgIgBGsgA0HQAGoQlwQgBiADKAJIIgRJDQIgAygCRCIOIARrIAIgBGsiD08EQCADKAJAIQIMAgsgBCAPaiIHIARJDQwgDkEBdCICIAcgAiAHSxsiAkEEIAJBBEsbrUIYfiIRQiCIp0VBAnQhByARpyECAkAgDkUEQCADQQA2AlAMAQsgA0EENgJYIAMgAygCQDYCUCADIA5BGGw2AlQLIANB8ABqIAIgByADQdAAahDFBiADKAJ0IQIgAygCeCEHIAMoAnBBAUcEQCADIAI2AkAgAyAHQRhuNgJEDAILIAdFDQwgAiAHQYSUwwAoAgAiAEGtBiAAGxEAAAALIAQgAkHU9sEAEPMHAAsgBEEYbCACaiECIA9BAk8EQANAIAJC////+/f//7//ADcCACACQRBqQv////v///+/fzcCACACQQhqQv////v3//+/fzcCACACQRhqIQIgBiAEQQFqIgRHDQALIAYhBAsgD0UEQCAEIQIMAQsgAkL////79///v383AgggAkL////79///v/8ANwIAIAJBEGpC////+////79/NwIAIARBAWohAgsgAyACNgJICyADKAI8IgIgBk0NASADKAI0IAZBDGxqIAY2AgggAygCSCICIAZNDQIgAygCQCAGQRhsaiICIBYgGCAWIBVDAAAAAJQiGpIgFEMAAAAAlCIekiAYIBdDAAAAAJQiG5IgGUMAAAAAlCIfkl4bOAIMIAIgFCAZIBZDAAAAAJQiHCAakiIgIBSTIBhDAAAAAJQiHSAbkiIhIBmTXhs4AgggAiAVIBcgHCAVkyAekiAdIBeTIB+SXhs4AgQgAiAWIBggGiAWkyAekiAbIBiTIB+SXhs4AgAgAkEUaiAUIBkgFCAgkiAZICGSXhs4AgAgAkEQaiAVIBcgHCAVkiAekiAdIBeSIB+SXhs4AgACQCAGIAlGBEAgCUEBaiIEIAlJDQogCUEBdCICIAQgAiAESxsiAkEEIAJBBEsbIgIgAkH/////A3FGQQJ0IQQgAkECdCECAkAgCUUEQCADQQA2AlAMAQsgA0EENgJYIAMgDDYCUCADIAlBAnQ2AlQLIANB8ABqIAIgBCADQdAAahDFBiADKAJ0IQwgAygCeCECIAMoAnBBAUYNASACQQJ2IQkLIAZBAnQgDGogBjYCACAGQQFqIQYgECAFQQhqIgVHDQEMCAsLIAINAgwHCyAGIAJBwM7BABDzBwALIAYgAkHQzsEAEPMHAAsgDCACQYSUwwAoAgAiAEGtBiAAGxEAAAALIAcgBUGElMMAKAIAIgBBrQYgABsRAAAACyACQQRBhJTDACgCACIAQa0GIAAbEQAAAAtBIEEEQYSUwwAoAgAiAEGtBiAAGxEAAAALIAMoAiAiBSADKAIcRwRAIAMoAhghAgwCCyAFQQFqIgQgBUkNACAFQQF0IgIgBCACIARLGyICQQQgAkEESxsiAiACQf///w9xRkEEdCEEIAJBB3QhAgJAIAVFBEAgA0EANgJQDAELIANB2ABqQRA2AgAgAyADKAIYNgJQIAMgBUEHdDYCVAsgA0HwAGogAiAEIANB0ABqEMUGIANB+ABqKAIAIQQgAygCdCECIAMoAnBBAUcEQCADIAI2AhggAyAEQQd2NgIcDAILIARFDQAgAiAEQYSUwwAoAgAiAEGtBiAAGxEAAAALEJQLAAsgBUEHdCACaiICQfQAakEAOgAAIAJBATYCYCACQv////v///+/fzcDMCACQv////v3//+//wA3AyAgAkL////79///v/8ANwMQIAJC////+/f//7//ADcDCCACQv////v3//+//wA3AwAgAkHYAGpC////+////79/NwMAIAJB0ABqQv////v///+/fzcDACACQcgAakL////7////v383AwAgAkFAa0L////7////v383AwAgAkE4akL////7////v383AwAgAkEoakL////79///v/8ANwMAIAJBGGpC////+/f//7//ADcDACACQewAakJ/NwIAIAJB5ABqQn83AgAgAkH3AGogA0HyAGotAAA6AAAgAiADLwBwOwB1IAJBADsBeCACIAMoAVA2AXogAkH+AGogA0HUAGovAQA7AQAgAyAFQQFqNgIgIANB0ABqIgIgAyAMIAYgAygCQCIEIAMoAkhBAEEAEE4gAyACQRhqKgIAIho4AhQgAyADQeQAaioCACIbOAIQIAMgA0HgAGoqAgAiHDgCDCADIANB3ABqKgIAIh04AgggAyADQdgAaioCACIgOAIEIAMgAyoCVCIhOAIAIAMoAiAEQCADKAIYIgJB////ezYCXCACQv////v///+/fzcCVCACIBo4AlAgAkH///97NgJMIAJC////+////79/NwJEIAIgGzgCQCACQf///3s2AjwgAkL////7////v383AjQgAiAcOAIwIAJB////+wc2AiwgAkL////79///v/8ANwIkIAIgHTgCICACQf////sHNgIcIAJC////+/f//7//ADcCFCACICA4AhAgAkH////7BzYCDCACQv////v3//+//wA3AgQgAiAhOAIAAkAgAygCRCICRQ0AIAJBGGxFDQAgBBDMAQsCQCAJRQ0AIAlBAnRFDQAgDBDMAQsgACADKQMANwIAIAAgASkCADcCQCAAQThqIANBOGopAwA3AgAgAEEwaiADQTBqKQMANwIAIABBKGogA0EoaikDADcCACAAQSBqIANBIGopAwA3AgAgAEEYaiADQRhqKQMANwIAIABBEGogA0EQaikDADcCACAAQQhqIANBCGopAwA3AgAgAEHIAGogAUEIaigCADYCACAAQdQAaiAINgIAIABB0ABqIAs2AgAgACAKNgJMIANBgAFqJAAPC0EAQQBB4M7BABDzBwALoBUCCH8FfiMAQfAAayIDJAACQAJAAkACQAJAAkACQAJAIAEoAgBBAWsOBQIFBAMAAQsgAEEBOwEADAYLIAEoAgQiBCgCACEBAkADQAJAIAQoAoABIgkgBCgCjAFBf2ogAXEiBkEwbGooAigiCCABQQFqRgRAIAQoAgAiAiABRiEHIAQgCCAEKAKIAUEAIAQoAogBayABcWogBkEBaiAEKAKEAUkbIAIgBxs2AgAgBw0BIAVBBiAFQQZJG0EfcSEGQQAhAQNAIAEgBnYgAUEBaiEBRQ0ACyAFQQdJIAVqIQUgAiEBDAILIAEgCEcEQCAFIAVBAWogBUEHT0EAIAVBCksbGyEFIAQoAgAhAQwCCyAEKAJAIgIgBCgCjAEiBkF/c3EgAUYNAiAFQQYgBUEGSRtBH3EhAkEAIQEDQCABIAJ2IAFBAWohAUUNAAsgBUEHSSAFaiEFIAQoAgAhAQwBCwsgBCgCiAEgAWohBSAGQTBsIAlqIQEMBQtBACEFQQAhASACIAZxDQQgAEEBOwEADAULIAEoAgQiCCgCBCEFIAgoAgAhAQNAAkACQCABQQF2IgJBH3EiB0EfRgRAIAZBB0kNASAGQQpLDQIMAQsgAUECaiEEAkAgAUEBcUUEQCACIAgoAkAiAkEBdkYEQEEAIQVBACEHIAJBAXENAiAAQQE7AQAMCgsgASACc0E/SyAEciEECyAFRQRAIAZBB0kNAiAGQQpNDQIMAwsgCCgCACICIAFGIQEgCCAEIAIgARs2AgAgAUUEQCAGQQYgBkEGSRtBH3EhBCAIKAIEIQVBACEBA0AgASAEdiABQQFqIQFFDQALIAZBB0kgBmohBiACIQEMBAsgB0EeRw0AIAUoAtALIgJFBEBBACEBA0AgASABQQFqIAFBB09BACABQQpLGxshASAFKALQCyICRQ0ACwsgAigC0AshASAIIAI2AgQgCCAEQQJqQX5xIAFBAEdyNgIACwJAIAUEQCAHQTBsIAVqIgJBKGohBCACLQAoQQFxRQRAQQAhAQNAIAEgAUEBaiABQQdPQQAgAUEKSxsbIQEgBC0AAEEBcUUNAAsLIANB0ABqIgFBCGogAkEIaikDADcDACABQRBqIAJBEGopAwA3AwAgAUEYaiACQRhqKQMANwMAIAMgAikDADcDUCACLQAgIQYgAyACQSRqKAAANgA7IAMgAigAITYCOAJAIAdBHkYEQEEoIQEDQCABIAVqIgItAABBAnFFBEAgAiACKAIAIgJBBHI2AgAgAkECcUUNAwsgAUEwaiIBQcgLRw0ACyAFEMwBDAELIAQgBCgCACIBQQJyNgIAIAFBBHFFDQAgB0EcTQRAIAdBMGwhASAFQdgAaiEEA0AgASAEaiICLQAAQQJxRQRAIAIgAigCACICQQRyNgIAIAJBAnFFDQMLIAFBMGoiAUHwCkcNAAsLIAUQzAELIANBGGoiAUEYaiIEIANB0ABqIgJBGGopAwA3AwAgAUEQaiIFIAJBEGopAwA3AwAgAUEIaiIBIAJBCGopAwA3AwAgAyADKQNQNwMYIAMgAygCODYCECADIAMoADs2ABMgBkH/AXFBAkcNAQsgAEEBOgABIABBAToAAAwICyAAQQhqIAMpAxg3AwAgAEEoaiAGOgAAIABBKWogAygCEDYAACAAQSxqIAMoABM2AAAgAEEgaiAEKQMANwMAIABBGGogBSkDADcDACAAQRBqIAEpAwA3AwAgAEEAOgAADAcLIAZBAWohBgsgCCgCBCEFIAgoAgAhAQwACwALIANB0ABqIgIgASgCBEEIahCgAyAAQShqIAJBKGopAwA3AwAgAEEgaiACQSBqKQMANwMAIABBGGogAkEYaikDADcDACAAQRBqIAJBEGopAwA3AwAgAEEIaiACQQhqKQMANwMAIAAgAykDUDcDAAwDC0EBIQQCQCABKAIEIgEtABgNABC3C0F/IAMpAwAiCiABKQMIIgtSIAogC1QbIgJBfyADKAIIIgUgAUEQaigCACIGRyAFIAZJGyACG0F/Rg0AIAEtABghAiABQQE6ABggAg0AIAFBEGooAgAhAiABKQMIIQpBACEECyAAQQA6AAEgACAEOgAAIABBAmogAygBUDYBACAAQRBqIAI2AgAgAEEIaiAKNwMAIABBBmogA0HUAGovAQA7AQAMAgsgASgCBCICQTxqIgEtAAAgAUEBOgAAIAJBCGohBQRAQQAhAQNAIAEgAUEBaiABQQdPQQAgAUEKSxsbIQEgAi0APCACQQE6ADwNAAsLIANBGGogBRCJAyADKAIgRQRAIABBAToAACACQQA6ADwgACACQThqLQAAOgABIAMoAiAiAEUNAiAAIAAoAgAiAEF/ajYCACAAQQFHDQIgA0EgahCxCAwCCyACQQA6ADwgA0HYAGogA0EgaigCADYCACADIAMpAxg3A1AgAAJ/IAMoAlQiAQRAAkACQAJAIAEtACgEQCABKQMgIQogAUICNwMgIAqnQf8BcUECRg0CIAFBGGopAwAhCyABKQMQIQwgASkDCCENIAEpAwAhDiABQQE6ACkMAQsgAS0AKUUEQEEAIQQDQCAEIARBAWogBEEHT0EAIARBCksbGyEEIAEtAClFDQALCyABKQMgIQogAUICNwMgIAqnQf8BcUECRg0CIAFBGGopAwAhCyABKQMQIQwgASkDCCENIAEpAwAhDiABEMwBCyAAQRBqIA03AwAgAEEIaiAONwMAIABBKGogCjcDACAAQRhqIAw3AwAgAEEgaiALNwMAQQAMAwtBuJrAAEErQZCHwAAQ5wgAC0G4msAAQStBoIfAABDnCAALIABBAToAAUEBCzoAACADKAJYIgEoAgAhACABIABBf2o2AgAgAEEBRw0BIANB2ABqELEIDAELAkAgAQRAIAEgBTYCKCADQdAAaiICQQhqIgUgAUEIaikDADcDACACQRBqIgYgAUEQaikDADcDACACQRhqIgggAUEYaikDADcDACADIAEpAwA3A1AgAyABKAAhNgI4IAMgAUEkaigAADYAOyABLQAgIQIgBEGsAWotAABFBEAgBEGoAWoi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QaAEayIDJAAgAyACNgI0IANBLGogAioCCCIfOAIAIANBKGogHzgCACADQSRqIB84AgAgA0EcaiACKgIEIh44AgAgA0EYaiAeOAIAIANBFGogHjgCACADIAE2AjAgA0EAOgA4IAMgHzgCICADIB44AhAgAyACKgIAIh44AgwgAyAeOAIIIAMgHjgCBCADIB44AgACQCABQSBqKAIAIg0EQCADQgA3AkwgA0GUv8EAKAIANgJIIANByABqIgJBAEP////+EOYDIANB8ABqIAIQgwMCQCADKAJwQQFHBEBBBCEFDAELIANB4AJqIgJBGGohFyACQQNqIQogAkHUAGohESADQZgDaiESIAJBHGohEyADQdADaiICQRhqIRQgAkEMaiEVQ///f38hHiADQdgCaiEYQQQhBQNAIB4gAyoCeIxfDQECQAJAAkACQAJAIA0gAygCdCICSwRAIANBgAFqIAEoAhggAkEHdGpBgAEQogkaIAMtAPgBIgQEQCABKAI0IgcgAygC7AEiAkEMbGpBACABKAI8IgYgAksbIgJBCGpBACACGyEZIAMoAugBIgJBDGwgB2pBACAGIAJLGyICQQhqQQAgAhshGiADKALkASICQQxsIAdqQQAgBiACSxsiAkEIakEAIAIbIRsgAygC4AEiAkEMbCAHakEAIAYgAksbIgJBCGpBACACGyEWCyADQbACaiADQYABaiADEP4BIAMqArACIh8gHl0hAiADKgK8AiEgIAMqArgCISEgAyoCtAIhIiAEBEAgAyAZNgLMAiADIBo2AsgCIAMgGzYCxAIgAyAWNgLAAkIAIRwgGEIANwMAIANCADcD0AIgA0EENgLIAyADQQQ2AqwDIANBBDYCkAMgA0EENgL0AiAiIB5dQQF0IAJyICEgHl1BAnRyICAgHl1BA3RyrSEdIANB0AJqIQsgA0HAAmohDyAXIQIDQAJAIB0gHIhCAYNQDQAgDygCACIGRQ0AIAMoAjAiCEHUAGooAgAiBCAGKAIAIhBNDQQgCEHIAGooAgAiCSAIKAJMIBBBDGxqIgQoAgAiDk0NBSAJIAQoAgQiB00NBiAJIAQoAggiBk0NByAVIAgoAkAiBCAHQQxsaiIIKQIANwIAIBQgBkEMbCAEaiIHKQIANwIAIANB0ANqIgZBCGogDkEMbCAEaiIEQQhqKAIANgIAIBVB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DiAOIAEoAgCylCIOkiETIARBCGooAgAhCiAEKAIEIQgCQAJAAkAgAygCCCIBRQRAIARBADYCcAwBCyADIAFBf2oiATYCCCAEIAMoAgAgAUECdGooAgAiATYCcCABDQELIA4gE19FDQhBEEEEEMgKIgVFDQkgBUL////79/////8ANwIIIAVC////ezcCACARIBJfRQ0IQRBBBBDICiIHRQ0JIAdC////+/f/////ADcCCCAHQv///3s3AgAgDyAQX0UNCEEQQQQQyAoiBkUNCSAGQv////v3/////wA3AgggBkL///97NwIAQZQBQQQQyAoiAQ0BQZQBQQRBhJTDACgCACIAQa0GIAAbEQAAAAsgAUEQakEANgIAIAFBHGpBADYCACABQQhqIQkgAUEMaiIDKAIAIgdFBEAgCUEBEOAFIAMoAgAhByABKAIQIQULIAEgBUEBaiIDNgIQIAEoAggiBiAFQQN0akL///97NwIAIAMgB0YEQCAJQQEQ4AUgASgCCCEGIAEoAhAhAwsgA0EDdCAGakL////79/////8ANwIAIAEgA0EBajYCEEEAIQUgAUEwakEANgIAIAEgDjgCACABIBM4AgQgAUE8akEANgIAIAFBKGohCSABQSxqIgMoAgAiB0UEQCAJQQEQ4AUgAygCACEHIAEoAjAhBQsgASAFQQFqIgM2AjAgASgCKCIGIAVBA3RqQv///3s3AgAgAyAHRgRAIAlBARDgBSABKAIoIQYgASgCMCEDCyADQQN0IAZqQv////v3/////wA3AgAgASADQQFqNgIwQQAhBSABQdAAakEANgIAIAEgETgCICABQSRqIBI4AgAgAUHcAGpBADYCACABQcgAaiEJIAFBzABqIgMoAgAiB0UEQCAJQQEQ4AUgAygCACEHIAEoAlAhBQsgASAFQQFqIgM2AlAgASgCSCIGIAVBA3RqQv///3s3AgAgAyAHRgRAIAlBARDgBSABKAJIIQYgASgCUCEDCyADQQN0IAZqQv////v3/////wA3AgAgASADQQFqNgJQIAEgDzgCQCABQcQAaiAQOAIAIAFBADoAkAFBgMDAACgCACEDIAFB5ABqIgUoAgAiBw0DDAQLIAFBADsBkAEgAUL/////DzcCiAEgAUIANwKAASABQYDAwAAoAgAiAzYCfCABQgA3AnQgASADNgJwIAFBADYCbCABQgA3AmQgASADNgJgIAFCADcCWCABIAM2AlQgAUKCgICAIDcCTCABIAY2AkggASAQOAJEIAEgDzgCQCABQgA3AjggASADNgI0IAFCgoCAgCA3AiwgASAHNgIoIAEgEjgCJCABIBE4AiAgAUIANwIYIAEgAzYCFCABQoKAgIAgNwIMIAEgBTYCCCABIBM4AgQgASAOOAIAIAQoAnANAQwECyAEKAIEIgFBGGooAgAiAiAEQQhqKAIAQXxqKAIAIgBLBEAgASgCECAAQRRsaigCECEHDAULIAAgAkHM3cAAEPMHAAsgBEHwAGoQyAMMAgsgAUHgAGooAgAiBkUNACAHQQJ0RQ0AIAYQzAELIAEgAzYCYCABQQA6AJEBIAFB7ABqQQA2AgAgBUIANwIAIAFBhAFqQoCAgIBwNwIAIAEoAowBBEAgBEEANgIoQQAgAUGMAWpBrL3AACAEQShqQfilwQAQ/AcACyABQfgAaigCAEUNAEGIpsEAQSpBtKbBABDnCAALIAAtADkhAyAALQA4IQUgBEEoaiIHQSxqIBA4AgAgBEHQAGogEjgCACAEQcwAaiATOAIAIARByABqIA84AgAgBEHEAGogETgCACAEIAU6AF0gBCADOgBcIARBfzYCWCAEIA44AkAgBCABNgIsIARBATYCKCACIAcQ/wEhByAAQTRqKAIAIgEgAEEwaigCAEYEQCAAQSxqQQEQ3wUgACgCNCEBCyAAIAFBAWo2AjQgACgCLCABQQJ0aiAHNgIAIAhBBGooAgAhAiAIQRBqKAIAIQkgCEEYaigCACEDIAgoAgAhBUEAIQEgCiEAA0AgAUEEaiIBIAAgBXEiBmohACACIAZqKAAAQYCBgoR4cSILRQ0ACyACIAtoQQN2IAZqIAVxIgFqLAAAIgBBAE4EQCACIAIoAgBBgIGChHhxaEEDdiIBai0AACEACyAIQQhqIQYCQCAAQQFxIgtFDQAgBigCAA0AIARBKGogCCAJIAMQtAEgCEEEaigCACECIAgoAgAhBUEAIQEgCiEAA0AgAUEEaiIBIAAgBXEiCWohACACIAlqKAAAQYCBgoR4cSIMRQ0ACyACIAxoQQN2IAlqIAVxIgFqLAAAQQBIDQAgAigCAEGAgYKEeHFoQQN2IQELIAEgAmogCkEZdiIAOgAAIAFBfGogBXEgAmpBBGogADoAACAGIAYoAgAgC2siBjYCACAIQQxqIgAoAgBBAWohBSAAIAU2AgAgAiABQQJ0a0F8aiADNgIAAkACQAJAIAMgCEEUaigCACIARwRAIAhBGGooAgAhAQwBCyAFIAZqIAhBGGooAgAiAWshACADIAFrIABPBEAgAyEADAELIAAgAWoiACABSQ0BIACtQhR+Ig1CIIinRUECdCEAIA2nIQICQCADRQRAIARBADYCKAwBCyAEQTBqQQQ2AgAgBCADQRRsNgIsIAQgCCgCEDYCKAsgBEHwAGogAiAAIARBKGoQwQYgBEH4AGooAgAhACAEKAJ0IQIgBCgCcEEBRwRAIAggAjYCECAIQRRqIABBFG4iADYCAAwBCyAARQ0BIAIgAEGElMMAKAIAIgBBrQYgABsRAAAACyAEQegAaiAEQSBqKAIANgIAIAQgBCkDGDcDYCAAIAFHBEAgCCgCECEADAILIABBAWoiAiAASQ0AIABBAXQiBSACIAUgAksbIgJBBCACQQRLG61CFH4iDUIgiKdFQQJ0IQIgDachBQJAIABFBEAgBEEANgIoDAELIARBMGpBBDYCACAEIABBFGw2AiwgBCAIKAIQNgIoCyAEQfAAaiAFIAIgBEEoahDBBiAEQfgAaigCACECIAQoAnQhACAEKAJwQQFHBEAgCCAANgIQIAhBFGogAkEUbjYCAAwCCyACRQ0AIAAgAkGElMMAKAIAIgBBrQYgABsRAAAACxCUCwALIAFBFGwgAGoiACAKNgIAIAAgBCkDYDcCBCAAQQxqIARB6ABqKAIANgIAIAAgBzYCECAIQRhqIAFBAWoiADYCACAAIANLDQAgAyAAQbjcwAAQ8wcACyAEQYABaiQAIAcPC0GwmcEAQShB2JrBABDnCAALQRBBBEGElMMAKAIAIgBBrQYgABsRAAAAC5oTAxl/AX4BfSMAQZACayILJAAgC0EANgIAIAtBgAFqIgVBEEEEIAsQxQYgBUEIaigCACEFIAsoAoQBIQgCQAJ/AkACQCALKAKAAUEBRgRAIAVFDQEgCCAFQYSUwwAoAgAiAEGtBiAAGxEAAAALIAhBADYCACAFQQJ2IQkgAEE8aigCACEOIABBGGooAgAhGSAAQSBqKAIAIQ0gC0HUAWohCiAAKAI0IQ9BASEFA0ACQAJAAkACQAJAIA0gBUF/aiIEQQJ0IhogCGooAgAiAksEQCALIAJBB3QgGWpBgAEQogkiAi0AeCISBEAgAigCbCIDQQxsIA9qQQAgDiADSxsiA0EIakEAIAMbIRMgAigCaCIDQQxsIA9qQQAgDiADSxsiA0EIakEAIAMbIRQgAigCZCIDQQxsIA9qQQAgDiADSxsiA0EIakEAIAMbIRUgAigCYCIDQQxsIA9qQQAgDiADSxsiA0EIakEAIAMbIRALIAIgASoCCCIcOAKsASACIBw4AqgBIAIgHDgCpAEgAiAcOAKgASACIAEqAgQiHDgCnAEgAiAcOAKYASACIBw4ApQBIAIgHDgCkAEgAiABKgIAIhw4AowBIAIgHDgCiAEgAiAcOAKEASACIBw4AoABIAJBsAFqIAIgAkGAAWoQiwMgAi0AswEhFiACLQCyASEXIAItALEBIRggAi0AsAEhEQJAIBJFDQAgGEEBdCARciAXQQJ0ciAWQQN0cq0hGwJAIBBFDQAgG0IBg1ANACAAKAJUIgYgECgCACIDTQ0DIAAoAkgiBiAAKAJMIANBA3RqIgcoAgAiA00NBCAGIAcoAgQiB00NBSAKIAAoAkAiBiAHQQxsaiIHKQIANwIAIAJByAFqIgxBCGogA0EMbCAGaiIDQQhqKAIANgIAIApBCGogB0EIaigCADYCACACIAMpAgA3A8gBIAJB4AFqIgNBCGogAUEIaigCADYCACACIAEpAgA3A+ABIAJB8AFqIAwgAxDaAiACLQD8AQ0KCyAbQv8BgyEbAkAgFUUNACAbQgKDUA0AIAAoAlQiBiAVKAIAIgNNDQMgACgCSCIGIAAoAkwgA0EDdGoiBygCACIDTQ0EIAYgBygCBCIHTQ0FIAogACgCQCIGIAdBDGxqIgcpAgA3AgAgAkHIAWoiDEEIaiADQQxsIAZqIgNBCGooAgA2AgAgCkEIaiAHQQhqKAIANgIAIAIgAykCADcDyAEgAkHgAWoiA0EIaiABQQhqKAIANgIAIAIgASkCADcD4AEgAkHwAWogDCADENoCIAItAPwBDQoLAkAgFEUNACAbQgSDUA0AIAAoAlQiBiAUKAIAIgNNDQMgACgCSCIGIAAoAkwgA0EDdGoiBygCACIDTQ0EIAYgBygCBCIHTQ0FIAogACgCQCIGIAdBDGxqIgcpAgA3AgAgAkHIAWoiDEEIaiADQQxsIAZqIgNBCGooAgA2AgAgCkEIaiAHQQhqKAIANgIAIAIgAykCADcDyAEgAkHgAWoiA0EIaiABQQhqKAIANgIAIAIgASkCADcD4AEgAkHwAWogDCADENoCIAItAPwBDQoLIBNFDQAgG0IIg1ANACAAKAJUIgYgEygCACIDTQ0CIAAoAkgiBiAAKAJMIANBA3RqIgcoAgAiA00NAyAGIAcoAgQiB00NBCAKIAAoAkAiBiAHQQxsaiIHKQIANwIAIAJByAFqIgxBCGogA0EMbCAGaiIDQQhqKAIANgIAIApBCGogB0EIaigCADYCACACIAMpAgA3A8gBIAJB4AFqIgNBCGogAUEIaigCADYCACACIAEpAgA3A+ABIAJB8AFqIAwgAxDaAiACLQD8AQ0JCyARQQJGDQUgEgRAIAQhBQwFCwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAXQQJ0IBZBA3RyIBFyIBhBAXRyrUL/AYMiG0IBg1AEQCAEIQUMAQsgAigCYCIDIA1LBEAgBCEFDAELIAQgCUYEQCAJQQF0IgQgBSAEIAVLGyIEQQQgBEEESxsiBCAEQf////8DcUZBAnQhBiAEQQJ0IQQCQCAJRQRAIAJBADYCgAEMAQsgAkEENgKIASACIAg2AoABIAIgCUECdDYChAELIAJB8AFqIAQgBiACQYABahDFBiACKAL0ASEIIAIoAvgBIQQgAigC8AFBAUYNAiAEQQJ2IQkLIAggGmogAzYCAAsgG0ICg1ANAyACKAJkIgMgDUsNAyAFIAlHDQIgBUEBaiIEIAVPDQEMFQsgBEUNFAwXCyAFQQF0IgYgBCAGIARLGyIEQQQgBEEESxsiBCAEQf////8DcUZBAnQhBiAEQQJ0IQQCQCAFRQRAIAJBADYCgAEMAQsgAkEENgKIASACIAg2AoABIAIgBUECdDYChAELIAJB8AFqIAQgBiACQYABahDFBiACKAL0ASEIIAIoAvgBIQQgAigC8AFBAUYNAiAEQQJ2IQkLIAVBAnQgCGogAzYCACAFQQFqIQULIBtCBINQDQQgAigCaCIDIA1LDQQgBSAJRw0DIAVBAWoiBCAFSQ0RIAVBAXQiBiAEIAYgBEsbIgRBBCAEQQRLGyIEIARB/////wNxRkECdCEGIARBAnQhBCAFDQEgAkEANgKAAQwCCyAERQ0QDBMLIAJBBDYCiAEgAiAINgKAASACIAVBAnQ2AoQBCyACQfABaiAEIAYgAkGAAWoQxQYgAigC9AEhCCACKAL4ASEEIAIoAvABQQFGDQIgBEECdiEJCyAFQQJ0IAhqIAM2AgAgBUEBaiEFCyAbQgiDUA0JIAIoAmwiAyANSw0JIAUgCUcNAyAFQQFqIgQgBUkNDCAFQQF0IgYgBCAGIARLGyIEQQQgBEEESxsiBCAEQf////8DcUZBAnQhBiAEQQJ0IQQgBQ0BIAJBADYCgAEMAgsgBEUNCwwOCyACQQQ2AogBIAIgCDYCgAEgAiAFQQJ0NgKEAQsgAkHwAWogBCAGIAJBgAFqEMUGIAIoAvQBIQggAigC+AEhBCACKALwAUEBRg0BIARBAnYhCQsgBUECdCAIaiADNgIAIAVBAWohBQwFCyAERQ0HDAoLIAIgDUHgz8EAEPMHAAsgAyAGQfT2wQAQ8wcACyADIAZBhPfBABDzBwALIAcgBkGU98EAEPMHAAsgBQ0BCwtBAAwCCxCUCwALQQELAkAgCUUNACAIRQ0AIAlBAnRFDQAgCBDMAQsgAkGQAmokAA8LIAggBEGElMMAKAIAIgBBrQYgABsRAAAAC6wTAhR/A34jAEHQA2siCCQAIAggBzYCFCAIQYABaiIHQQhqIAJBCGooAgA2AgAgCCACKQIANwOAASAIQYACaiICQQhqIgsgA0EIaigCADYCACAIIAMpAgA3A4ACIAhBGGoiAyAHIAIQpwkgCEEhNgIwIAhBADYCSCAIIAY2AkQgCCAFOgBDIAggBDgCPCAIIAE2AjQgCCAIQTBqNgJUIAggCEEUajYCUCAIIAM2AjggCCAIQeAAajYCXCAIIAhB0ABqNgJ4IAggCEHDAGo2AnQgCCAIQTxqNgJwIAggCEE4ajYCbCAIIAhByABqNgJoIAggCEHEAGo2AmQgCCAIQTRqNgJgIAJBEGogA0EQaikDADcDACALIANBCGopAwA3AwAgCCAIKQMYNwOAAiAHIAIQ0wUgCEHsAWogBDgCACAIQegBaiAEOAIAIAhB5AFqIAQ4AgAgCCAEOALgASAIIAhB3ABqNgLwASAIQQA2AoACIAhBgANqIgFBEEEEIAIQwQYgAUEIaiIUKAIAIQEgCCgChAMhBwJAIAgoAoADQQFGBEAgAUUNASAHIAFBhJTDACgCACIAQa0GIAAbEQAAAAsgB0EANgIAIAFBAnYhBiAAQShqKAIAIQsgCEGAA2oiAUEEaiEOIAhB4AFqIhVBCGohFiABQRhqIRdBASEFAkACQANAIAsgBUF/aiICQQJ0IhggB2ooAgAiAU0NASAIQYACaiAAKAIgIAFBB3RqQYABEKIJGiAILQD4AiIJBEAgACgCPCIBIAgoAuwCIgpBGGxqQQAgACgCRCIDIApLGyEZIAgoAugCIgpBGGwgAWpBACADIApLGyEaIAgoAuQCIgpBGGwgAWpBACADIApLGyEbIAEgCCgC4AIiAUEYbGpBACADIAFLGyEQCyAIIBYpAwA3A7gDIAggFSkDADcDsAMgCEGAA2ogCEGAAmogCEGAAWogCEGwA2oQ7AEgCC0AgAMhCiAILQCBAyERIAgtAIIDIRIgCC0AgwMhEwJAIAkEQCAIIBk2AqwDIAggGjYCqAMgCCAbNgKkAyAIIBA2AqADIBFBAXQgCnIgEkECdHIgE0EDdHKtQv8BgyEeQgAhHCAIQaADaiEDA0ACQCAeIByIQgGDUA0AIAMoAgAiCUUNACAIKALwASgCACIBKAIAKAIAIAkpAwAiHSAJQQhqKAIAIg0Q0wgiCUUNACABKAIEKAIAIgwgCSgCeCIPQRB2cUUNACAMQRB2IA9xRQ0AIAEoAggiDCgCACIPBEAgDyAdIA0gCSAMKAIEKAIMERsARQ0BCyAIQQhqIAkQ2AkgCEGwA2ogCCgCCCAJQdQAaiABKAIMKAIAIAEoAhAqAgAgASgCFC0AACAIKAIMKAKQAREJACAIKALAA0EERg0AIAEoAhghASAOQRBqIAhBsANqIglBEGopAwA3AgAgDkEIaiAJQQhqKQMANwIAIA4gCCkDsAM3AgAgASgCBCEJIAEoAgAoAgAhDAJAQTBBCBDICiIBBEAgASANNgIQIAEgHTcCCCABQQA2AgAgASAIKQKAAzcCFCABQRxqIBQpAgA3AgAgAUEkaiAIQZADaikCADcCACABQSxqIBcoAgA2AgAgCCABEAI2AsgDIAggDCAJIAhByANqEM4IIAgoAgQhCSAIKAIARQRAIAggCTYCzAMgCEHMA2oQnwpB/wFxIgFBAXEhCSABQQJGIAgoAswDIg1BJE8EQCANEAELIAlyIQEMAgtBASEBIAlBJEkNASAJEAEMAQtBMEEIQYSUwwAoAgAiAEGtBiAAGxEAAAALIAgoAsgDIglBJE8EQCAJEAELIAFFDQMLIANBBGohAyAcQgF8IhxCBFINAAsLIApB/wFxQQJGDQAgCC0A+AIhAwJAIBFBAXQgCnIgEkECdHIgE0EDdHKtIhxCAYNQBEAgAiEFDAELIANB/wFxBEAgAiEFDAELQQAhAyAIKALgAiIJIAtLBEAgAiEFDAELIAIgBkYEQCAGQQFqIgEgBkkNBiAGQQF0IgIgASACIAFLGyIBQQQgAUEESxsiASABQf////8DcUZBAnQhAiABQQJ0IQECQCAGRQRAIAhBADYCgAMMAQsgCEEENgKIAyAIIAc2AoADIAggBkECdDYChAMLIAhBsANqIAEgAiAIQYADahDBBiAIKAK0AyEHIAgoArgDIQIgCCgCsANBAUYNBSACQQJ2IQYLIAcgGGogCTYCACAILQD4AiEDCwJAIBxC/wGDIhxCAoNQDQAgA0H/AXENAEEAIQMgCCgC5AIiCSALSw0AIAUgBkYEQCAGQQFqIgEgBkkNBiAGQQF0IgIgASACIAFLGyIBQQQgAUEESxsiASABQf////8DcUZBAnQhAiABQQJ0IQECQCAGBEAgCEEENgKIAyAIIAc2AoADIAggBkECdDYChAMMAQsgCEEANgKAAwsgCEGwA2ogASACIAhBgANqEMEGIAgoArQDIQcgCCgCuAMhAiAIKAKwA0EBRg0FIAJBAnYhBgsgBUECdCAHaiAJNgIAIAVBAWohBSAILQD4AiEDCwJAIBxCBINQDQAgA0H/AXENAEEAIQMgCCgC6AIiCSALSw0AIAUgBkYEQCAGQQFqIgEgBkkNBiAGQQF0IgIgASACIAFLGyIBQQQgAUEESxsiASABQf////8DcUZBAnQhAiABQQJ0IQECQCAGBEAgCEEENgKIAyAIIAc2AoADIAggBkECdDYChAMMAQsgCEEANgKAAwsgCEGwA2ogASACIAhBgANqEMEGIAgoArQDIQcgCCgCuAMhAiAIKAKwA0EBRg0FIAJBAnYhBgsgBUECdCAHaiAJNgIAIAVBAWohBSAILQD4AiEDCwJAIBxCCINQDQAgA0H/AXENACAIKALsAiIDIAtLDQAgBSAGRgRAIAZBAWoiASAGSQ0GIAZBAXQiAiABIAIgAUsbIgFBBCABQQRLGyIBIAFB/////wNxRkECdCECIAFBAnQhAQJAIAYEQCAIQQQ2AogDIAggBzYCgAMgCCAGQQJ0NgKEAwwBCyAIQQA2AoADCyAIQbADaiABIAIgCEGAA2oQwQYgCCgCtAMhByAIKAK4AyECIAgoArADQQFGDQUgAkECdiEGCyAFQQJ0IAdqIAM2AgAgBUEBaiEFCyAFDQELCwJAIAZFDQAgB0UNACAGQQJ0RQ0AIAcQzAELIAgoAjAiAEEkTwRAIAAQAQsgCEHQA2okAA8LIAEgC0GonsAAEPMHAAsgAkUNACAHIAJBhJTDACgCACIAQa0GIAAbEQAAAAsQlAsAC5wTAxh/An4FfSMAQZAEayIDJAAgAyACNgI0IANBLGogAioCCCIeOAIAIANBKGogHjgCACADQSRqIB44AgAgA0EcaiACKgIEIh04AgAgA0EYaiAdOAIAIANBFGogHTgCACADIAE2AjAgA0EAOgA4IAMgHjgCICADIB04AhAgAyACKgIAIh04AgwgAyAdOAIIIAMgHTgCBCADIB04AgACQCABQSBqKAIAIgwEQCADQgA3AkwgA0GUv8EAKAIANgJIIANByABqIgJBAEP////+EOYDIANB8ABqIAIQgwMCQCADKAJwQQFHBEBBBCEEDAELIANBgANqIRYgA0HoAmoiAkEDaiEJIAJB1ABqIREgA0GgA2ohEiACQRxqIRMgA0HkA2ohFEP//39/IR0gA0HgAmohF0EEIQQDQCAdIAMqAniMXw0BAkACQAJAAkAgDCADKAJ0IgJLBEAgA0GAAWogASgCGCACQQd0akGAARCiCRogAy0A+AEiBQRAIAEoAjQiByADKALsASICQQxsakEAIAEoAjwiBiACSxsiAkEIakEAIAIbIRggAygC6AEiAkEMbCAHakEAIAYgAksbIgJBCGpBACACGyEZIAMoAuQBIgJBDGwgB2pBACAGIAJLGyICQQhqQQAgAhshGiADKALgASICQQxsIAdqQQAgBiACSxsiAkEIakEAIAIbIRULIANBsAJqIANBgAFqIAMQ/gEgAyoCsAIiHiAdXSECIAMqArwCIR8gAyoCuAIhICADKgK0AiEhIAUEQCADIBg2AtQCIAMgGTYC0AIgAyAaNgLMAiADIBU2AsgCQgAhGyAXQgA3AwAgA0IANwPYAiADQQQ2AtADIANBBDYCtAMgA0EENgKYAyADQQQ2AvwCICEgHV1BAXQgAnIgICAdXUECdHIgHyAdXUEDdHKtIRwgA0HYAmohCiADQcgCaiENIBYhAgNAAkAgHCAbiEIBg1ANACANKAIAIgZFDQAgAygCMCIOQdQAaigCACIFIAYoAgAiD00NBCAOQcgAaigCACIHIA4oAkwgD0EDdGoiBSgCACIITQ0FIAcgBSgCBCIGTQ0GIBQgDigCQCIFIAZBDGxqIgcpAgA3AgAgA0HYA2oiBkEIaiAIQQxsIAVqIgVBCGooAgA2AgAgFEEIaiAHQQhqKAIANgIAIAMgBSkCADcD2AMgA0HwA2ogBiADKAI0ENoCIAMoAoAEIQggAygChAQhBiADKAL8AyEFIAMqAvADIh8gAygCNCIHKgIAkyIeIB6UIAMqAvQDIiAgByoCBJMiHiAelJIgAyoC+AMiISAHKgIIkyIeIB6UkkMAAAAAkhCdASEeIAJBACAGIAgbNgIAIAJBfGogCEEARzYCACACQXhqIA82AgAgAkF0aiAFNgIAIAJBcGogITgCACACQWxqICA4AgAgAkFoaiAfOAIAIAogHjgCAAsgDUEEaiENIApBBGohCiACQRxqIQIgG0IBfCIbQgRSDQALIANB4ANqIgggA0HwAmoiECkDADcDACADQagCaiINIBNBCGopAgA3AwAgA0GYAmoiDiASQQhqKQIANwMAIAMgAykD6AI3A9gDIAMgEykCADcDoAIgAyASKQIANwOQAiADKgLkAiEeIAMqAuACIR8gAyoC3AIhICADKgLYAiEhIAMoAvgCIQUgAygC/AIhByADKAKUAyECIAMoApgDIQYgA0GIAmoiDyARQQhqKQIANwMAIAMgESkCADcDgAIgASgCPCEKAkAgHEIBg1ANACAhIB1dQQFzDQAgB0EERg0AIAogAygC4AFNDQAgCSADKQPYAzcAACAJQQhqIAgpAwA3AAAgA0HwA2oiBEEPaiIIIANB9wJqKAAANgAAIARBCGoiCyAQKQAANwMAIANB2ABqIgRBCGogCykDADcDACAEQQ9qIAgoAAA2AAAgAyADKQDoAjcDWCAFIQsgByEEICEhHQsCQCAKIAMoAuQBTQ0AIAZBBEYNACAcQgKDUA0AICAgHV1BAXMNACAJIAMpA6ACNwAAIAlBCGogDSkDADcAACADQfADaiIEQQ9qIgUgA0H3AmooAAA2AAAgBEEIaiILIBApAAA3AwAgA0HYAGoiBEEIaiALKQMANwMAIARBD2ogBSgAADYAACADIAMpAOgCNwNYIAIhCyAGIQQgICEdCwJAIAogAygC6AFNDQAgAygCtAMiAkEERg0AIBxCBINQDQAgHyAdXUEBcw0AIAMoArADIQsgCSADKQOQAjcAACAJQQhqIA4pAwA3AAAgA0HwA2oiBEEPaiIGIANB9wJqKAAANgAAIARBCGoiBSAQKQAANwMAIANB2ABqIgRBCGogBSkDADcDACAEQQ9qIAYoAAA2AAAgAyADKQDoAjcDWCACIQQgHyEdCyAKIAMoAuwBTQ0FIAMoAtADIgJBBEYNBSAcQgiDUA0FIB4gHV1BAXMNBSADKALMAyELIAkgAykDgAI3AAAgCUEIaiAPKQMANwAAIANB8ANqIgRBD2oiBiADQfcCaigAADYAACAEQQhqIgUgECkAADcDACADQdgAaiIEQQhqIAUpAwA3AwAgBEEPaiAGKAAANgAAIAMgAykA6AI3A1ggAiEEIB4hHQwFCwJAICEgHV1BAXQgAnIgICAdXUECdHIgHyAdXUEDdHKtIhtCAYNQDQAgAygC4AEiAiAMTw0AIANByABqIAIgHowQ5gMLAkAgG0ICg1ANACADKALkASICIAxPDQAgA0HIAGogAiAhjBDmAwsCQCAbQgSDUA0AIAMoAugBIgIgDE8NACADQcgAaiACICCMEOYDCyAbQgiDUA0EIAMoAuwBIgIgDE8NBCADQcgAaiACIB+MEOYDDAQLIAIgDEHwz8EAEPMHAAsgDyAFQfT2wQAQ8wcACyAIIAdBhPfBABDzBwALIAYgB0GU98EAEPMHAAsgA0HwAGogA0HIAGoQgwMgAygCcEEBRg0ACwsgA0GAAWoiAkEIaiADQdgAaiIBQQhqKQMANwMAIAJBD2ogAUEPaigAADYAACADIAMpA1g3A4ABAkAgAygCTCICRQ0AIAMoAkgiAUUNACACQQN0RQ0AIAEQzAELIARBBEcNAQtBnLzBAEErQcjwwQAQ5wgACyADQegCaiICQQ9qIANBgAFqIgFBD2ooAAA2AAAgAkEIaiABQQhqKQMANwMAIAMgAykDgAE3A+gCIABBCGogA0HzAmopAAA3AAAgACADKQDrAjcAACAAQRRqIAs2AgAgAEEBNgIQIANBkARqJAAL7BIDE38Cfgp9IwBB8AJrIgUkACAFIAI2AmQgBUE8aiACKgIMIho4AgAgBUE4aiAaOAIAIAVBNGogGjgCACAFQSxqIAIqAggiHTgCACAFQShqIB04AgAgBUEkaiAdOAIAIAVBHGogAioCBCIcOAIAIAVBGGogHDgCACAFQRRqIBw4AgAgBUHcAGogAkEUaioCACIbOAIAIAVB2ABqIBs4AgAgBUHUAGogGzgCACAFQdAAaiAbOAIAIAVBzABqIAJBEGoqAgAiGzgCACAFQcgAaiAbOAIAIAVBxABqIBs4AgAgBUFAayAbOAIAIAUgATYCYCAFIAQ6AGwgBSADOAJoIAUgGjgCMCAFIB04AiAgBSAcOAIQIAUgAioCACIDOAIMIAUgAzgCCCAFIAM4AgQgBSADOAIAAn9BACABQSBqKAIAIgtFDQAaIAVCADcCdCAFQZS/wQAoAgA2AnAgBUHwAGoiAkEAQ/////4Q5gMgBUGAAWogAhCDAwJAIAUoAoABQQFHDQAgBUHQAmoiAkEMaiEKIAJBBHIhEiAFQaACakEEciETQ///f38hGgNAIBogBSoCiAGMXw0BAkACQAJAAkACQCALIAUoAoQBIgJLBEAgBUGQAWogASgCGCACQQd0akGAARCiCRogBS0AiAIiFARAIAEoAjQiAiAFKAL8ASIGQQxsakEAIAEoAjwiBCAGSxsiBkEIakEAIAYbIRUgBSgC+AEiBkEMbCACakEAIAQgBksbIgZBCGpBACAGGyEWIAUoAvQBIgZBDGwgAmpBACAEIAZLGyIGQQhqQQAgBhshFyACIAUoAvABIgJBDGxqQQAgBCACSxsiAkEIakEAIAIbIRALIAUgBSoCaCIcOALcAiAFIBw4AtgCIAUgHDgC1AIgBSAcOALQAiAFQaACaiAFQZABaiAFIAVB0AJqEOwBIAVBmAJqIgQgE0EIaigCADYCACAFIBMpAgA3A5ACIAUoAqACIQIgBSoCsAIhGyAFKgK0AiEDIAUqArgCIR4gBSoCvAIhHQJAIBRFBEBBACEMQQAhBkEAIQ1BACEEDAELIBIgBSkDkAI3AgAgEkEIaiAEKAIANgIAIAUgAjYC0AIgBSAdIBpdOgCjAiAFIB4gGl06AKICIAUgAyAaXToAoQIgBSAbIBpdOgCgAiAFQcACaiAFQdACaiAFQaACahCiCCAFLQDAAiAFLQDBAkEBdHIgBS0AwgJBAnRyIAUtAMMCQQN0cq0hGEMAAAAAIQNBACENIAUtAGwhDiAFKAJkIQ8gBSgCYCEIQwAAAAAhGwJ/QQAgEEUNABpBACAYQgGDUA0AGiAIKAJUIgcgECgCACICTQ0DIAgoAkgiByAIKAJMIAJBA3RqIgQoAgAiAk0NBCAHIAQoAgQiCU0NBSAKIAgoAkAiBCAJQQxsaiIGKQIANwIAIAVB0AJqIgdBCGogAkEMbCAEaiICQQhqKAIANgIAIApBCGogBkEIaigCADYCACAFIAIpAgA3A9ACIAVBoAJqIAcgDyAcIA5BAEcQ6gFDAAAAACAFKgKgAiIgIAUoArACIgJBBEYbIRsgAkEERwshBCAYQv8BgyEYAkAgF0UNACAYQgKDUA0AIAgoAlQiByAXKAIAIgJNDQMgCCgCSCIHIAgoAkwgAkEDdGoiBigCACICTQ0EIAcgBigCBCIJTQ0FIAogCCgCQCIGIAlBDGxqIgcpAgA3AgAgBUHQAmoiCUEIaiACQQxsIAZqIgJBCGooAgA2AgAgCkEIaiAHQQhqKAIANgIAIAUgAikCADcD0AIgBUGgAmogCSAPIBwgDkEARxDqAUMAAAAAIAUqAqACIiEgBSgCsAIiAkEERhshAyACQQRHIQ0LQwAAAAAhHUEAIQxDAAAAACEeAn9BACAWRQ0AGkEAIBhCBINQDQAaIAgoAlQiByAWKAIAIgJNDQMgCCgCSCIHIAgoAkwgAkEDdGoiBigCACICTQ0EIAcgBigCBCIJTQ0FIAogCCgCQCIGIAlBDGxqIgcpAgA3AgAgBUHQAmoiCUEIaiACQQxsIAZqIgJBCGooAgA2AgAgCkEIaiAHQQhqKAIANgIAIAUgAikCADcD0AIgBUGgAmogCSAPIBwgDkEARxDqAUMAAAAAIAUqAqACIiIgBSgCsAIiAkEERhshHiACQQRHCyEGAkAgFUUNACAYQgiDUA0AIAgoAlQiByAVKAIAIgJNDQMgCCgCSCIHIAgoAkwgAkEDdGoiCSgCACICTQ0EIAcgCSgCBCIJTQ0FIAogCCgCQCIIIAlBDGxqIgcpAgA3AgAgBUHQAmoiCUEIaiACQQxsIAhqIgJBCGooAgA2AgAgCkEIaiAHQQhqKAIANgIAIAUgAikCADcD0AIgBUGgAmogCSAPIBwgDkEARxDqAUMAAAAAIAUqAqACIiMgBSgCsAIiAkEERhshHSACQQRHIQwLIA1BCHQgBHIgBkEQdHIgDEEYdHIhAgsgAkEVdkH4AXEgAkEOdkH8AXEgAkEHdkH+AXEgAkH/AXFycnKtIhhCAYMhGSAUBEAgGKciB0EBdiADIBsgGiAZQgBSIBsgGl1xIARBAEdxIAEoAjwiAiAFKALwAUtxIggbIhpdcSANQQBHcSACIAUoAvQBS3EhBCAHQQJ2IB4gAyAaIAQbIgNdcSAGQQBHcSACIAUoAvgBS3EhBiAeIAMgBhshGkEBQQFBASARIAgbIAQbIAYbIREgIiAhICAgHyAIGyAEGyAGGyEfIAIgBSgC/AFNDQYgDEUNBiAYQgiDUA0GIB0gGl0NBQwGCwJAIBlQDQAgBSgC8AEiAiALTw0AIAVB8ABqIAIgG4wQ5gMLAkAgGEICg1ANACAFKAL0ASICIAtPDQAgBUHwAGogAiADjBDmAwsCQCAYQgSDUA0AIAUoAvgBIgIgC08NACAFQfAAaiACIB6MEOYDCyAYQgiDUA0FIAUoAvwBIgIgC08NBSAFQfAAaiACIB2MEOYDDAULIAIgC0Hwz8EAEPMHAAsgAiAHQfT2wQAQ8wcACyACIAdBhPfBABDzBwALIAkgB0GU98EAEPMHAAtBASERICMhHyAdIRoLIAVBgAFqIAVB8ABqEIMDIAUoAoABQQFGDQALCwJAIAUoAnQiAUUNACAFKAJwIgJFDQAgAUEDdEUNACACEMwBCyARQQFGCyECIAAgHzgCBCAAIAI2AgAgBUHwAmokAAvxEgMWfwF+AX0jAEEgayIFJAACQAJAAkAgAC0AeEUNACAAQRBqKAIAIgJFDQAgACgCCCEIIAJBqAJsQdh9aiEEIABB2ABqIQsDQCAIKAIAQQFGBEAgCEEIaikDACEYAkAgACgCXCICIAsoAgBHBEAgACgCVCEHDAELIAJBAWoiByACSQ0EIAJBAXQiAyAHIAMgB0sbIgdBBCAHQQRLGyIHIAdB/////wBxRkEDdCEDIAdBBHQhBwJAIAJFBEAgBUEANgIQDAELIAVBCDYCGCAFIAJBBHQ2AhQgBSAAKAJUNgIQCyAFIAcgAyAFQRBqEMEGIAUoAgQhByAFKAIIIQMgBSgCAEEBRwRAIAAgBzYCVCALIANBBHY2AgAMAQsgA0UNBCAHIANBhJTDACgCACIAQa0GIAAbEQAAAAsgACACQQFqNgJcIAJBBHQgB2oiAiAGNgIIIAIgGDcDAAsgBEUNASAGQQFqIQYgCEGoAmohCCAEQdh9aiEEDAALAAsgAEHcAGoiCCgCACECIAhBADYCACACBEAgAEHUAGooAgAiCCACQQR0aiEVIABBIGohFiAAQSxqIRcgAEEQaigCACERIAAoAgghEiAAQShqIQ4gAEEkaiETIABBPGohFCAAQTRqIQwgAEEwaiEPA0ACQCARIAhBCGooAgAiB00NACAHQagCbCASaiIGKAIAQQFHDQAgCCkDACIYIAZBCGopAwBSDQAgBkEQaiENQQIhEAJAAkACQAJAAkACQAJAAkAgBkGUAmoiCy0AAEEQcUUNAAJAAkAgDS0AkQJBAWsOAgIBAAsCQCAMKAIAIgQgBkGIAmoiAygCACIKTQ0AIAAoAiwiCSAKQQR0aiICKQMAIBhSDQAgAkEIaigCACAHRw0AIAIgBEF/aiIKQQR0IAlqIgQpAwA3AwAgAiAEKAIINgIIIAwgCjYCACADKAIAIQpBACEQCyAGQfwBaiICLQAABEAgAkEAOgAAIAsgCygCAEEEcjYCAAsgDS0AkQJFBEAgBkH4AWogBkH0AWoqAgCLIhkgGZI4AgALIAsgCygCAEEEcjYCAAwBCwJAIA4oAgAiBCAGQYgCaiIDKAIAIgpNDQAgACgCICIJIApBBHRqIgIpAwAgGFINACACQQhqKAIAIAdHDQAgAiAEQX9qIgpBBHQgCWoiBCkDADcDACACIAQoAgg2AgggDiAKNgIAIAMoAgAhCkEBIRALIAAoAiwhAgJAIAwoAgAiBCAKTQ0AIApBBHQgAmoiCSkDACAYUg0AIAlBCGooAgAgB0YNAQsgAyAENgIAIA8oAgAgBEYEQCAEQQFqIgMgBEkNDCAEQQF0IgkgAyAJIANLGyIDQQQgA0EESxsiAyADQf////8AcUZBA3QhCSADQQR0IQMCQCAERQRAIAVBADYCEAwBCyAFQQg2AhggBSACNgIQIAUgBEEEdDYCFAsgBSADIAkgBUEQahDBBiAFKAIEIQIgBSgCCCEDIAUoAgBBAUYNAiAAIAI2AiwgDyADQQR2NgIACyAMIARBAWo2AgAgBEEEdCACaiICIAc2AgggAiAYNwMACyALLQAAQQpxRQ0DIA0gARDUAiANLQCRAiICQQFGDQEMAgsgA0UNCQwKCwJAIAAoAkAiBCAUKAIARwRAIAAoAjghAgwBCyAEQQFqIgIgBEkNCSAEQQF0IgMgAiADIAJLGyICQQQgAkEESxsiAiACQf////8AcUZBA3QhAyACQQR0IQICQCAERQRAIAVBADYCEAwBCyAFQQg2AhggBSAEQQR0NgIUIAUgACgCODYCEAsgBSACIAMgBUEQahDBBiAFKAIEIQIgBSgCCCEDIAUoAgBBAUcEQCAAIAI2AjggFCADQQR2NgIADAELIANFDQkMCgsgBEEEdCACaiICIAc2AgggAiAYNwMAIAAgBEEBajYCQCANLQCRAiECCyACQf8BcUECRw0AIAAoAiwhAgJAIAwoAgAiBCAGQYgCaiIDKAIAIglNDQAgCUEEdCACaiIJKQMAIBhSDQAgCUEIaigCACAHRg0BCyADIAQ2AgAgDygCACAERgRAIARBAWoiAyAESQ0IIARBAXQiCSADIAkgA0sbIgNBBCADQQRLGyIDIANB/////wBxRkEDdCEJIANBBHQhAwJAIARFBEAgBUEANgIQDAELIAVBCDYCGCAFIAI2AhAgBSAEQQR0NgIUCyAFIAMgCSAFQRBqEMEGIAUoAgQhAiAFKAIIIQMgBSgCAEEBRg0CIAAgAjYCLCAPIANBBHY2AgALIAwgBEEBajYCACAEQQR0IAJqIgIgBzYCCCACIBg3AwALIAstAABBBHFFDQIgBkH8AWotAAANAiANLQCRAkUNAQwCCyADRQ0FDAYLIAAoAiAhAgJAIA4oAgAiBCAGQYgCaiIGKAIAIgNNDQAgA0EEdCACaiIDKQMAIBhSDQAgA0EIaigCACAHRg0BCyAGIAQ2AgACQCATKAIAIARGBEAgBEEBaiIGIARJDQYgBEEBdCIDIAYgAyAGSxsiBkEEIAZBBEsbIgYgBkH/////AHFGQQN0IQMgBkEEdCEGAkAgBEUEQCAFQQA2AhAMAQsgBUEINgIYIAUgAjYCECAFIARBBHQ2AhQLIAUgBiADIAVBEGoQwQYgBSgCBCECIAUoAgghBiAFKAIAQQFGDQEgACACNgIgIBMgBkEEdjYCAAsgDiAEQQFqNgIAIARBBHQgAmoiAiAHNgIIIAIgGDcDAAwBCyAGRQ0EIAIgBkGElMMAKAIAIgBBrQYgABsRAAAACyALQQA2AgAgEEECRg0AIAogFiAXIBAbIgJBCGooAgBPDQAgESACKAIAIApBBHRqIgYoAggiAk0NACACQagCbCASaiICKAIAQQFHDQAgAkEIaikDACAGKQMAUg0AIAJBiAJqIAo2AgALIBUgCEEQaiIIRw0ACwsCQCAALQB4BEACQCAAQdgAaigCACIIIABB3ABqKAIAIgFNDQAgACgCVCICRQ0AIAhBBHQhBwJAIAFBBHQiCEUEQEEAIQhBCCEGIAdFDQEgAhDMAQwBCyACIAdBCCAIELgKIgZFDQMgAUH/////AHEhCAsgACAGNgJUIABB2ABqIAg2AgALIABBADoAeAsgBUEgaiQADwsgCEEIQYSUwwAoAgAiAEGtBiAAGxEAAAALEJQLAAsgAiADQYSUwwAoAgAiAEGtBiAAGxEAAAAL8BYDDH8Bfgh9IwBBgAFrIgQkAAJAAkACQCACQQhqKAIAIgUEQCACKAIAIQNBBCELQSBBBBDICiIGBEAgBEEcakIANwIAIARBEGpC////+////79/NwMAIARBJGpCADcCACAEQTBqQQg2AgAgBEEsaiAGNgIAIARBOGpCADcDACAEQSBqQQA2AgAgBEGcv8EAKAIANgIYIARC////+/f//79/NwMIIARC////+/f//7//ADcDACAEQZS/wQAoAgA2AjQCQCAFQQxsIgZBDE8EQCAFIglBAnQiB0EEEMgKIgtFDQELIARB0ABqIgdBEGpC////+////79/NwMAIARC////+/f//79/NwNYIARC////+/f//7//ADcDUCAEQUBrIAcgBRC7BCAFQX9MDQQgBkEEEMgKIgcEQCAEQTRqIQwgBEEANgJ4IAQgBTYCdCAEIAc2AnAgBEF/NgJYIARBADoAVCAEQX82AlAgBEHwAGogBSAEQdAAahCXBAJAIAQoAjgiBUUNACAEKAI0IgdFDQAgBUEMbEUNACAHEMwBCyADIAZqIQ4gDCAEKQNwNwIAIAxBCGogBEH4AGooAgA2AgAgA0EMaiEHQQAhBgJAAkADQAJAAkACQAJAIAEoAggiBSADKAIAIghLBEAgBSADKAIEIgpNDQEgBSADKAIIIgNNBEAgAyAFQZCYwgAQ8wcACyABKAIAIgUgCEEMbGoiCCoCBCERIApBDGwgBWoiCioCBCETIANBDGwgBWoiAyoCACEUIAgqAggiEiAKKgIIIhVdIQUgAyoCCCIQIBAgFSAVIBIgBRsgEiASXBsiFiAWIBBdGyAWIBZcGyEWIBIgEiAVIAUbIBUgFVwbIhIgEiAQIBIgEF0bIBAgEFwbIRUgAyoCBCIQIBAgEyATIBEgESATXSIDGyARIBFcGyISIBIgEF0bIBIgElwbIRIgESARIBMgAxsgEyATXBsiESARIBAgESAQXRsgECAQXBshFyAIKgIAIhEgCioCACITXSEDIBQgFCATIBMgESADGyARIBFcGyIQIBAgFF0bIBAgEFwbIRAgESARIBMgAxsgEyATXBsiESARIBQgESAUXRsgFCAUXBshFCAGIAQoAjwiBUkNBCAEQX82AlggBEEAOgBUIARBfzYCUCAMIAZBAWoiAyAFayAEQdAAahCXBCAGIAQoAkgiBUkNAyAEKAJEIgggBWsgAyAFayIKTwRAIAQoAkAhAwwDCyAFIApqIgMgBUkNDSAIQQF0Ig0gAyANIANLGyIDQQQgA0EESxutQhh+Ig9CIIinRUECdCEDIA+nIQ0CQCAIRQRAIARBADYCUAwBCyAEQQQ2AlggBCAEKAJANgJQIAQgCEEYbDYCVAsgBEHwAGogDSADIARB0ABqEMUGIAQoAnQhAyAEKAJ4IQggBCgCcEEBRwRAIAQgAzYCQCAEIAhBGG42AkQMAwsgCEUNDSADIAhBhJTDACgCACIAQa0GIAAbEQAAAAsgCCAFQfCXwgAQ8wcACyAKIAVBgJjCABDzBwALIAVBGGwgA2ohAyAKQQJPBEADQCADQv////v3//+//wA3AgAgA0EQakL////7////v383AgAgA0EIakL////79///v383AgAgA0EYaiEDIAYgBUEBaiIFRw0ACyAGIQULIApFBEAgBSEDDAELIANC////+/f//79/NwIIIANC////+/f//7//ADcCACADQRBqQv////v///+/fzcCACAFQQFqIQMLIAQgAzYCSAsgBCgCPCIDIAZNDQEgBCgCNCAGQQxsaiAGNgIIIAQoAkgiAyAGTQ0CIAQoAkAgBkEYbGoiAyAQOAIMIAMgFTgCCCADIBc4AgQgAyAUOAIAIANBFGogFjgCACADQRBqIBI4AgACQCAGIAlGBEAgCUEBaiIDIAlJDQogCUEBdCIFIAMgBSADSxsiA0EEIANBBEsbIgMgA0H/////A3FGQQJ0IQUgA0ECdCEDAkAgCUUEQCAEQQA2AlAMAQsgBEEENgJYIAQgCzYCUCAEIAlBAnQ2AlQLIARB8ABqIAMgBSAEQdAAahDFBiAEKAJ0IQsgBCgCeCEDIAQoAnBBAUYNASADQQJ2IQkLIAZBAnQgC2ogBjYCACAGQQFqIQYgByAORiAHIgNBDGohBw0IDAELCyADRQ0HIAsgA0GElMMAKAIAIgBBrQYgABsRAAAACyAGIANBwM7BABDzBwALIAYgA0HQzsEAEPMHAAsgBkEEQYSUwwAoAgAiAEGtBiAAGxEAAAALIAdBBEGElMMAKAIAIgBBrQYgABsRAAAAC0EgQQRBhJTDACgCACIAQa0GIAAbEQAAAAtByJbCAEEzQeCXwgAQ/wkACyAEKAIgIgUgBCgCHEcEQCAEKAIYIQMMAgsgBUEBaiIDIAVJDQAgBUEBdCIHIAMgByADSxsiA0EEIANBBEsbIgMgA0H///8PcUZBBHQhByADQQd0IQMCQCAFRQRAIARBADYCUAwBCyAEQdgAakEQNgIAIAQgBCgCGDYCUCAEIAVBB3Q2AlQLIARB8ABqIAMgByAEQdAAahDFBiAEQfgAaigCACEHIAQoAnQhAyAEKAJwQQFHBEAgBCADNgIYIAQgB0EHdjYCHAwCCyAHRQ0AIAMgB0GElMMAKAIAIgBBrQYgABsRAAAACxCUCwALIAVBB3QgA2oiA0H0AGpBADoAACADQQE2AmAgA0L////7////v383AzAgA0L////79///v/8ANwMgIANC////+/f//7//ADcDECADQv////v3//+//wA3AwggA0L////79///v/8ANwMAIANB2ABqQv////v///+/fzcDACADQdAAakL////7////v383AwAgA0HIAGpC////+////79/NwMAIANBQGtC////+////79/NwMAIANBOGpC////+////79/NwMAIANBKGpC////+/f//7//ADcDACADQRhqQv////v3//+//wA3AwAgA0HsAGpCfzcCACADQeQAakJ/NwIAIANB9wBqIARB8gBqLQAAOgAAIAMgBC8AcDsAdSADQQA7AXggAyAEKAFQNgF6IANB/gBqIARB1ABqLwEAOwEAIAQgBUEBajYCICAEQdAAaiIDIAQgCyAGIAQoAkAiBSAEKAJIQQBBABBOIAQgA0EYaioCACIUOAIUIAQgBEHkAGoqAgAiETgCECAEIARB4ABqKgIAIhM4AgwgBCAEQdwAaioCACIQOAIIIAQgBEHYAGoqAgAiEjgCBCAEIAQqAlQiFTgCACAEKAIgBEAgBCgCGCIDQf///3s2AlwgA0L////7////v383AlQgAyAUOAJQIANB////ezYCTCADQv////v///+/fzcCRCADIBE4AkAgA0H///97NgI8IANC////+////79/NwI0IAMgEzgCMCADQf////sHNgIsIANC////+/f//7//ADcCJCADIBA4AiAgA0H////7BzYCHCADQv////v3//+//wA3AhQgAyASOAIQIANB////+wc2AgwgA0L////79///v/8ANwIEIAMgFTgCAAJAIAQoAkQiA0UNACADQRhsRQ0AIAUQzAELAkAgCUUNACAJQQJ0RQ0AIAsQzAELIAAgBCkDADcCACAAIAEpAgA3AkAgAEE4aiAEQThqKQMANwIAIABBMGogBEEwaikDADcCACAAQShqIARBKGopAwA3AgAgAEEgaiAEQSBqKQMANwIAIABBGGogBEEYaikDADcCACAAQRBqIARBEGopAwA3AgAgAEEIaiAEQQhqKQMANwIAIABByABqIAFBCGooAgA2AgAgAEHUAGogAkEIaigCADYCACAAIAIpAgA3AkwgBEGAAWokAA8LQQBBAEHgzsEAEPMHAAuZEwIGfw99IwBB8ABrIgkkAEMAAKA1EJ0BIRUgCUEIaiAIEEsCQAJAAkACQAJAAkACQAJAIAkqAggiESARlCAJKgIMIhIgEpSSIAkqAhAiEyATlJJDAAAAAJIiD0MAAAAAXkUEQCAAQQA2AgAMAQsgDxCdASEQAkAgD0MAAMgrXkEBcw0AIBGMIBCVIRQgEowgEJUhFiATjCAQlSEXQ///f38hEEGQzgAhCgJAAkADQCAJIBOMIA8QnQEiD5U4AiAgCSASjCAPlTgCHCAJIBGMIA+VOAIYIA8gEGBBAXNFBEAgBwRAQX8hCgJAIAgoAhwiA0F/RgRAQwAAAAAhEUMAAAAAIRJDAAAAACEPQwAAAAAhBkMAAAAAIRBDAAAAACETDAELQwAAAAAhEyAIIQJDAAAAACEQQwAAAAAhBkMAAAAAIQ9DAAAAACES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JAAPC0Hkr8AAQSZB9LDAABD7CQALIAEgBUGAxsAAEPMHAAvbEAIIfxl+IwBBMGsiBSQAAkACfwJAAkACQAJAAkACQAJAAkAgASkDACIMUEUEQCABKQMIIg1QDQEgASkDECILUA0CIAsgDHwiCyAMVA0DIAwgDX0iDSAMVg0EIAtCgICAgICAgIAgWg0FIAUgAS8BGCIBOwEIIAUgDTcDACABIAFBYGogASALQoCAgIAQVCIEGyIDQXBqIAMgC0IghiALIAQbIgtCgICAgICAwABUIgQbIgNBeGogAyALQhCGIAsgBBsiC0KAgICAgICAgAFUIgQbIgNBfGogAyALQgiGIAsgBBsiC0KAgICAgICAgBBUIgQbIgNBfmogAyALQgSGIAsgBBsiC0KAgICAgICAgMAAVCIEGyALQgKGIAsgBBsiDkI/h6dBf3NqIgRrQRB0QRB1IgNBf0wNBiAFQn8gA61CP4MiEIgiCyANgzcDECANIAtWDQogBSABOwEIIAUgDDcDACAFIAsgDIM3AxAgDCALVg0KQaB/IARrQRB0QRB1QdAAbEGwpwVqQc4QbSIBQdEATw0HIAwgEIYiEUIgiCIcIAFBBHQiAUGg38IAaikDACIPQv////8PgyIMfiELIA9CIIgiDyARQv////8PgyIRfiISQiCIIiIgC0IgiCIjIA8gHH58fCETIAtC/////w+DIAwgEX5CIIh8IBJC/////w+DfEKAgICACHxCIIghHUIBQQAgAUGo38IAai8BACAEamtBP3GtIhKGIhFCf3whFCANIBCGIgtCIIghFSALQv////8PgyINIA9+IQsgDCAVfiIQQv////8PgyAMIA1+QiCIfCALQv////8Pg3xCgICAgAh8QiCIIR4gDyAVfiEWIAtCIIghHyAQQiCIISAgAUGq38IAai8BACEBIAwgDiAOQn+FQj+IhiINQiCIIhd+IQsgDUL/////D4MiDiAPfiENIAtC/////w+DIAwgDn5CIIh8IA1C/////w+DfEKAgICACHxCIIgiGCANQiCIIhkgDyAXfiIhIAtCIIgiGnx8fEIBfCIQIBKIpyIDQY/OAE0EQCADQeQASQRAIANBCUshBkEBQQogA0EKSRsMCwtBAkEDIANB6AdJIgQbIQZB5ABB6AcgBBsMCgsgA0HAhD1JDQggA0H/wdcvTQRA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AwAgBUEYaiABQRhqKQIANwMAIAVBEGogAUEQaikCADcDACAFQQhqIAFBCGopAgA3AwAgBiABKQIANwNoDAELIAYgB0EEaigCACIFNgIEIAYgBygCACAFKAIIQQdqQXhxajYCACAGQegAaiAGKAIAIAFBPGoqAgAgBigCBCgCIBEPAAsgBkEoaiAGQegAaiAKEJkEIARBqAJsIAlqIgFB5AFqIQcgAUHsAWoiCigCACIFIAFB6AFqIgsoAgBHBEAgBygCACEBDAILIAVBAWoiASAFSQ0AIAVBAXQiCCABIAggAUsbIgFBBCABQQRLGyIBIAFB/////wBxRkEDdCEIIAFBBHQhAQJAIAVFBEAgBkEANgJoDAELIAZB8ABqQQg2AgAgBiAFQQR0NgJsIAYgBygCADYCaAsgBkHYAGogASAIIAZB6ABqEMEGIAZB4ABqKAIAIQggBigCXCEBIAYoAlhBAUcEQCAHIAE2AgAgCyAIQQR2NgIADAILIAhFDQAgASAIQYSUwwAoAgAiAEGtBiAAGxEAAAALEJQLAAsgBUEEdCABaiIBIAI2AgggASADNwMAIAogBUEBajYCACAGQegAaiIFQShqIAZBKGoiAUEoaigCADYCACAFQSBqIAFBIGopAwA3AwAgBUEYaiABQRhqKQMANwMAIAVBEGoiCiABQRBqKQMANwMAIAVBCGoiByABQQhqKQMANwMAIAYgBikDKDcDaCAEQagCbCAJaiIBQdgAaiIIIAUQ8gUgBSAIIAwQgQYgAUGMAWogBygCADYCACABQYQBaiAGKQNoNwIAIAFBkAFqIgsgAUHkAGoqAgA4AgAgBSAIIAwQnwIgAUGkAWogCikDADcCACABQZwBaiAHKQMANwIAIAFBlAFqIgUgBikDaDcCACABQaACai0AACIBQQFxBEAgC0EANgIACyABQQJxBEAgBUEANgIAIARBqAJsIAlqQZgBakIANwMACyABQQRxBEAgBEGoAmwgCWoiBUGYAWpBADYCACAFQaABakIANwMACyABQQhxBEAgBEGoAmwgCWoiAUGcAWpBADYCACABQaQBakIANwIACyAAIAI2AgggACADNwMAIAZB8AFqJAAL9hEDDH8BfhB9IwBBsAFrIgkkACAJQfixwAA2AhQgCSAANgIQIAkgATYCHCAJIAQ2AiQgCSADNgIgIAkg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AygCYEEBRg0BIAFBAnYhBgsgBCAJaiAMNgIAIAhBAmohCCAJQQRqIQkgAkEBaiECIAUhAQwBCwsgAUUNBgwIC0EAIQJB2JzAACgCACEECyAAIAY2AgQgACAENgIAIABBCGogAjYCAAwCCyADQSBqIAEQ2AkgAygCICADKAIkEPMIIgFFBEAgAEEANgIADAILIANBOGogARCnAgJAIANBzABqKAIAIgJB/////wNxBEAgAygCRCIBKAIAIQVBDEEEEMgKIgRFDQggAkEMbCABaiELIAQgBTYCACABQQRqIQdBAyEGQQIhCEEEIQlBASECIAFBDGoiCiEBA0ACQCAHIApHBEAgASEFIAchAQwBCyABIAtGDQMgAUEMaiIKIQULIAFBBGohByABKAIAIQwCQCACIAZGBEAgCiAHa0ECdiACakEBaiIBIAJJDQggCCABIAggAUsbIgFBBCABQQRLGyIBIAFB/////wNxRkECdCEGIAFBAnQhAQJAIAJFBEAgA0EANgJgDAELIANBBDYCaCADIAk2AmQgAyAENgJgCyADQdAAaiABIAYgA0HgAGoQwQYgAygCVCEEIAMoAlghASADKAJQQQFGDQEgAUECdiEGCyAEIAlqIAw2AgAgCEECaiEIIAlBBGohCSACQQFqIQIgBSEBDAELCyABRQ0FDAcLQQAhAkHYnMAAKAIAIQQLAkAgAygCPCIBRQ0AIAMoAjgiBUUNACABQQxsRQ0AIAUQzAELAkAgA0HIAGooAgAiAUUNACADKAJEIgVFDQAgAUEMbEUNACAFEMwBCyAAIAY2AgQgACAENgIAIABBCGogAjYCAAwBCyADQShqIAEQ2AkgAygCKCADKAIsEPcIIgFFBEAgAEEANgIADAELIANBOGogARCnAgJAIANBzABqKAIAIgJB/////wNxBEAgAygCRCIBKAIAIQVBDEEEEMgKIgRFDQcgAkEMbCABaiELIAQgBTYCACABQQRqIQdBAyEGQQIhCEEEIQlBASECIAFBDGoiCiEBA0ACQCAHIApHBEAgASEFIAchAQwBCyABIAtGDQMgAUEMaiIKIQULIAFBBGohByABKAIAIQwCQCACIAZGBEAgCiAHa0ECdiACakEBaiIBIAJJDQcgCCABIAggAUsbIgFBBCABQQRLGyIBIAFB/////wNxRkECdCEGIAFBAnQh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AyADQewCajYC+AIgDSADQfACakGoz8AAIAQoAgwRAwALAkAgCkUNACAVQgSDUA0AIAMoAsABIQIgAyAKNgLsAiAKKAIAIQ0gAigCACIEKAIAIAQoAgQhBCADIAIoAiw2ApwDIAMgAikCJDcClAMgAyACKQIcNwKMAyADIAIpAhQ3AoQDIAMgAikCDDcC/AIgAyACKQIENwPwAiADIANB7AJqNgL4AiANIANB8AJqQajPwAAgBCgCDBEDAAsgCUUNACAVQgiDUA0AIAMoAsABIQIgAyAJNgLsAiAJKAIAIQ0gAigCACIEKAIAIAQoAgQhBCADIAIoAiw2ApwDIAMgAikCJDcClAMgAyACKQIcNwKMAyADIAIpAhQ3AoQDIAMgAikCDDcC/AIgAyACKQIENwPwAiADIANB7AJqNgL4AiANIANB8AJqQajPwAAgBCgCDBEDAAsgBkH/AXFBAkYNASASQQJ0IBFBA3RyIAZyIBNBAXRyrSIWQv8BgyEVIAMtAMgCIQICQCAWQgGDUA0AIAJB/wFxDQBBACECIAMoArACIgYgCEsNACAAIBAoAgBGBEAgAUEBEN8FIAEoAgAhByABKAIIIQALIABBAnQgB2ogBjYCACABIABBAWoiADYCCCADLQDIAiECCwJAIBVCAoNQDQAgAkH/AXENAEEAIQIgAygCtAIiBiAISw0AIAAgECgCAEYEQCABQQEQ3wUgASgCCCEACyABKAIAIgcgAEECdGogBjYCACABIABBAWoiADYCCCADLQDIAiECCwJAIBVCBINQDQAgAkH/AXENAEEAIQIgAygCuAIiBiAISw0AIAAgECgCAEYEQCABQQEQ3wUgASgCCCEACyABKAIAIgcgAEECdGogBjYCACABIABBAWoiADYCCCADLQDIAiECCwJAIBVCCINQBEAgACECDAELIAJB/wFxBEAgACECDAELIAMoArwCIgYgCEsEQCAAIQIMAQsgACAQKAIARgRAIAFBARDfBSABKAIIIQALIAEgAEEBaiICNgIIIAEoAgAiByAAQQJ0aiAGNgIACyACDQALCyADQaADaiQADwtB5K/AAEEmQfSwwAAQ+wkACyACIAhBgMbAABDzBwAL0wwCCH8dfgJAIAFBFGooAgAiAyACSwRAIAEoAgAhCQJAIAEoAggiCiABQQxqKAIAIgYgAkHwAWxq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QCASQcgBaiIUQRhqIAlBKGooAgA2AgAgEkHYAWogCUEgaikCADcDACAUQQhqIAlBGGopAgA3AwAgEiAJKQIQNwPIASASQYgCaiIVQQhqIAlB0ABqKAIANgIAIBIgCSkCSDcDiAIgEkHIAGoiE0EIaiAJQZwBaiIWQQhqKAIANgIAIBIgFikCADcDSCASQYgBaiIWQQhqIAlBqAFqIglBCGooAgA2AgAgEiAJKQIANwOIASASQQhqIBQgFSATIBYQigcMAQsgEkHgAWogCUHEAGooAgA2AgAgEkHYAWogCUE8aikCADcDACASQdABaiAJQTRqKQIANwMAIBIgCSkCLDcDyAEgEkEIaiASQcgBahDeBwsCQCAKLQCQAkEgcQRAIBJByAFqIglBGGogCkEoaigCADYCACASQdgBaiAKQSBqKQIANwMAIAlBCGogCkEYaikCADcDACASIAopAhA3A8gBIBJBwAJqIhRBCGogCkHQAGooAgA2AgAgEiAKKQJINwPAAiASQYgCaiIVQQhqIApBnAFqIhNBCGooAgA2AgAgEiATKQIANwOIAiASQYgBaiITQQhqIApBqAFqIgpBCGooAgA2AgAgEiAKKQIANwOIASASQcgAaiAJIBQgFSATEIoHDAELIBJB4AFqIApBxABqKAIANgIAIBJB2AFqIApBPGopAgA3AwAgEkHQAWogCkE0aikCADcDACASIAopAiw3A8gBIBJByABqIBJByAFqEN4HC3IgC0EBRgRAIBJBCGogDBDPBwtBAXEhCyANQQFGBEAgEkHIAGogDhDPBwsgEkHIAWoiCUEYaiAHQdAAaigCADYCACAJQRBqIAdByABqKQIANwMAIAlBCGogB0FAaykCADcDACASIAcpAjg3A8gBIBJBiAFqIg0gEkEIaiAJEPsBIBJBiAJqIgpBGGogCEHQAGooAgA2AgAgCkEQaiAIQcgAaikCADcDACAKQQhqIAhBQGspAgA3AwAgEiAIKQI4NwOIAiAJIBJByABqIAoQ+wEgCiABIA0gGSAXIAkgGiAYIA8gECALIAIoAiQRIwAgEi0AvAJBHXRBHXVBfk4EQCASKgKIAiEMIAAgCzoASCAAQQA2AkQgACAMOAJAIAAgBjYCKCAAIAU3AyAgACAENgIIIAAgAzcDACAAIAgoAgg2AjggACAIKQMANwMwIAAg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QYSUwwAoAgAiAEGtBiAAGxEAAAALQeAAQQRBhJTDACgCACIAQa0GIAAbEQAAAAtBEEEEQYSUwwAoAgAiAEGtBiAAGxEAAAALvAkCB38EfiMAQdAAayIDJAAgAS0AICEHIAFBAjoAIAJAAkACQAJAAkACQCAHQQJHBEAgAUE0aigCACEJIAFBMGooAgAhBiABQSxqKAIAIQUgAUEoaigCACgCACEIIANBCGoiBEEYaiABQRhqKQMANwMAIARBEGogAUEQaikDADcDACAEQQhqIAFBCGopAwA3AwAgBEEkaiABQSRqKAAANgAAIAMgBzoAKCADQQE7ATAgAyABKQMANwMIIAMgASgAITYAKSAFIAggBCACKAIAEPcEIAVBGGoQygMgBUEAOgA0IANBOGoiAUEQaiAGQRBqKQMANwMAIAFBCGogBkEIaikDADcDACADIAYpAwA3AzgCQAJAAkACQAJAIAIgARCOBUEBaw4DAgMAAQsgAy0AMUUEQEEAIQEDQCABIAFBAWogAUEHT0EAIAFBCksbGyEBIAMtADFFDQALCyAAQgI3AwAMAwtB/LPAAEEoQcy4wAAQ5wgACyAJKAIAIgQtADQgBEEBOgA0BEBBACEBA0AgASABQQFqIAFBB09BACABQQpLGxshASAELQA0IARBAToANA0ACwsgBCgCAEF0aiECIARBCGooAgAiBUEMbCEGIAVB/////wNxIQdBACEBA0AgASAHRg0FIAZBdGohBiABQQFqIQEgAkEMaiICKAIAIAhHDQALIAUgAUF/aiIBTQ0DIAJBCGooAgAhASACKQIAIQogAiACQQxqIAYQyAcaIARBCGogBUF/ajYCACABRQ0EIAEgASgCACICQX9qNgIAIAMgATYCQCADIAo3AzggAkEBRgRAIANBQGsQsQgLIARBADoANCADKQMoIQogA0ICNwMoIAqnQf8BcUECRg0FIANBIGopAwAhCyADKQMYIQwgAykDECENIAAgAykDCDcDCCAAQgA3AwAgAEEQaiANNwMAIABBKGogCjcDACAAQRhqIAw3AwAgAEEgaiALNwMADAELIAkoAgAiBC0ANCAEQQE6ADQEQEEAIQEDQCABIAFBAWogAUEHT0EAIAFBCksbGyEBIAQtADQgBEEBOgA0DQALCyAEKAIAQXRqIQIgBEEIaigCACIFQQxsIQYg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EGo2AiggAiACQQhqNgIQIAEgAkEYahD4BwwNCyACIABBBGooAgA2AgggAkEsakEBNgIAIAJCAjcCHCACQdC9wgA2AhggAkGnBjYCFCACIAJBEGo2AiggAiACQQhqNgIQIAEgAkEYahD4BwwMCyACIABBBGopAgA3AwggAkEsakEBNgIAIAJCATcCHCACQby9wgA2AhggAkGoBjYCFCACIAJBEGo2AiggAiACQQhqNgIQIAEgAkEYahD4BwwLCyACQSxqQQA2AgAgAkHgu8IANgIoIAJCATcCHCACQay9wgA2AhggASACQRhqEPgHDAoLIAJBLGpBADYCACACQeC7wgA2AiggAkIBNwIcIAJBpL3CADYCGCABIAJBGGoQ+AcMCQsgAkEsakEANgIAIAJB4LvCADYCKCACQgE3AhwgAkGQvcIANgIYIAEgAkEYahD4BwwICyACQSxqQQA2AgAgAkHgu8IANgIoIAJCATcCHCACQfy8wgA2AhggASACQRhqEPgHDAcLIAJBLGpBADYCACACQeC7wgA2AiggAkIBNwIcIAJB5LzCADYCGCABIAJBGGoQ+AcMBgsgAkEsakEANgIAIAJB4LvCADYCKCACQgE3AhwgAkHUvMIANgIYIAEgAkEYahD4BwwFCyACQSxqQQA2AgAgAkHgu8IANgIoIAJCATcCHCACQci8wgA2AhggASACQRhqEPgHDAQLIAJBLGpBADYCACACQeC7wgA2AiggAkIBNwIcIAJBvLzCADYCGCABIAJBGGoQ+AcMAwsgAkEsakEANgIAIAJB4LvCADYCKCACQgE3AhwgAkGovMIANgIYIAEgAkEYahD4BwwCCyACQSxqQQA2AgAgAkHgu8IANgIoIAJCATcCHCACQZC8wgA2AhggASACQRhqEPgHDAELIAJBLGpBADYCACACQeC7wgA2AiggAkIBNwIcIAJB+LvCADYCGCABIAJBGGoQ+AcLIAJBMGokAAvKCAIEfwF+IwBB0ABrIgEkACABQRBqIABBEGopAgA3AwAgAUEIaiAAQQhqKQIANwMAIAEgACkCADcDACABQQY2AhwgAUHwx8IANgIYIAECfgJAAkACQEGRmMMALQAARQ0AQbCUwwAoAgBBAUcEQEGwlMMAQgE3AwAMAQtBtJTDACgCACEEQbSUwwBBADYCACAERQ0AIAQtAAgh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DJMiBiAMIBOTIgkgBiAJYBsiBkMAAAAAIAZDAAAAAGAbIgYgBpSSQwAAAACSEJ0BOAIMIAAgBDgCCCAAIAU4AgQgACADOAIAC64GAgh/AX4jAEHgAGsiBCQAAkACQAJAAkAgACgCDCIDQX9HBEAgACgCCCICIANNDQEgACAAKAIAIANBOGxqIgAoAjA2AgwgBEEIaiICQTBqIgUgAUEwaikDADcDACACQShqIgYgAUEoaikDADcDACACQSBqIgcgAUEgaikDADcDACACQRhqIgggAUEYaikDADcDACACQRBqIgkgAUEQaikDADcDACACQQhqIgIgAUEIaikDADcDACAEIAEpAwA3AwgCQCAAKAIARQ0AIAAoAgRFDQAgAEEEahDIAwsgACAEKQMINwMAIABBMGogBSkDADcDACAAQShqIAYpAwA3AwAgAEEgaiAHKQMANwMAIABBGGogCCkDADcDACAAQRBqIAkpAwA3AwAgAEEIaiACKQMANwMADAQLIARBCGoiA0EwaiABQTBqKQMANwMAIANBKGogAUEoaikDADcDACADQSBqIAFBIGopAwA3AwAgA0EYaiABQRhqKQMANwMAIANBEGogAUEQaikDADcDACADQQhqIAFBCGopAwA3AwAgBCABKQMANwMIIAAoAggiAyAAQQRqKAIARwRAIAAoAgAhAQwDCyADQQFqIgEgA0kNASADQQF0IgIgASACIAFLGyIBQQQgAUEESxutQjh+IgpCIIinRUEDdCEBIAqnIQICQCADRQRAIARBADYCUAwBCyAEQdgAakEINgIAIAQgA0E4bDYCVCAEIAAoAgA2AlALIARBQGsgAiABIARB0ABqEMEGIARByABqKAIAIQIgBCgCRCEBIAQoAkBBAUcEQCAAIAE2AgAgAEEEaiACQThuNgIADAMLIAJFDQEgASACQYSUwwAoAgAiAEGtBiAAGxEAAAALIAMgAkHYpMEAEPMHAAsQlAsACyADQThsIAFqIgEgBCkDCDcDACABQTBqIARBCGoiAkEwaikDADcDACABQShqIAJBKGopAwA3AwAgAUEgaiACQSBqKQMANwMAIAFBGGogAkEYaikDADcDACABQRBqIAJBEGopAwA3AwAgAUEIaiACQQhqKQMANwMAIAAgA0EBajYCCAsgBEHgAGokACADC+0FAgV/Fn0jAEHQ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XQRAQQAhASAMQ///f/9eDQFD//9//yEMDAELQ///f/8hDEEAIQEgE0P//3//XkUNAEEBIQEgEyEMCyAPIA1dDQFBACAPIAxeQQFzDQIaQQEhASAPIQxBAQwCCyAAQQE6AAwgACAEKQMANwIQIAAgAikCADcCACAAQQhqIAJBCGooAgA2AgAMAgtBACANIAxeQQFzDQAaQQAhASANIQxBAQshBQJAIBAgDl1FBEAgECAMXkEBcw0BQQIhBUEBIQEgECEMDAELIA4gDF5BAXMNAEEAIQFBAiEFIA4hDAsgBEEYaiICQQA2AgAgBEIANwMQIARBEGogBUECdGogDCAMjCABGzgCACAAQQE6AAwgACAEKQMQNwIQIABBGGogAigCADYCACAAIBIgAioCAJI4AgggACARIAQqAhSSOAIEIAAgFCAEKgIQkjgCAA8LIABBGGogBEEIaigCADYCAAvXBQEHfyMAQaAFayITJAAgE0EoaiIUQRBqIhYgASkCADcDACAUQQhqIhcgAkEIaikCADcDACAUQRhqIhggAUEIaigCADYCACATIAIpAgA3AyggE0H4AGoiFEEIaiIVIAZBCGooAgA2AgAgEyAGKQIANwN4IBNBgAJqIgFBCGogCUEIaiIZKAIANgIAIBMgCSkCADcDgAIgE0GIA2oiAkEIaiAKQQhqKQIANwMAIBMgCikCADcDiAMgE0HIAGoiBiAUIAQgASACEL8GIAIgEBCsByAUQRhqIgogGCgCADYCACAUQRBqIhAgFikDADcDACAVIBcpAwA3AwAgEyATKQMoNwN4IAEgAiAUENgIIAEgAzgCRCACIAFBiAEQogkaIAJB0ABqQwAAAABDAACAPyAElSAEQwAAAABbGzgCDCABIAJBiAEQogkaIBUgGSgCADYCACATIAkpAgA3A3ggAiABIBQQjQcgASACIAsgDCANEJkJIBRBKGogBkEoaigCADYCACAUQSBqIAZBIGopAwA3AwAgCiAGQRhqKQMANwMAIBAgBkEQaikDADcDACAVIAZBCGopAwA3AwAgEyATKQNINwN4IAIgASAUEOwHIAEgAiAHKgIAIAcqAgQgByoCCBD9CSAVIAhBCGooAgA2AgAgEyAIKQIANwN4IAIgASAUEI4KIAIgDjgCSCABIAJBiAEQogkaIAEgDzgCTCACIAFBiAEQogka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AhwiCEF/aiEGIAIoAhghAyACKAIUIQELIAFBAnQgA2ogCTYCACACIAFBAWogBnEiATYCFCAEQXxqIQQgBQ0ACyACKAIQIQQLIAJBCGogAkEQakEEciIBQQhqKAIAIgM2AgAgAiABKQIAIgo3AwAgACAENgIEIABBCGogCjcCACAAQRBqIAM2AgAgAEEANgIADAYLQfSawABBEUGMnMAAEOcIAAsQlAsACyAEIAFBhJTDACgCACIAQa0GIAAbEQAAAAtBjJnAAEEjQaiawAAQ5wgACyAAQQA2AgAgAEEMakEANgIADAELIABBATYCACAAIAU2AgQLIAJBIGokAAv/BAEDfyMAQcAIayIBJAACQCAABEAgACgCAA0BIABBADYCACABQaAEaiICIABBoAQQogkaIAFBCGogAkEIakGYBBCiCRogABDMASABQZwDaigCAEECRwRAIAFBgANqEJQECwJAIAFBlARqKAIAQQJGDQAgASgC0AMiAigCACEAIAIgAEF/ajYCACAAQQFGBEAgASgC0AMgAUHUA2ooAgAQrwcLAkAgAUHcA2ooAgAiAEUNACABQdgDaigCACICRQ0AIABBGGxFDQAgAhDMAQsgAUHkA2ooAgAhAiABQewDaigCACIABEAgAEHIAGwhAyACIQADQCAAELUFIABByABqIQAgA0G4f2oiAw0ACwsCQCABQegDaigCACIARQ0AIABByABsRQ0AIAIQzAELAkAgAUH0A2ooAgAiAEUNACABQfADaigCACICRQ0AIABBGGxFDQAgAhDMAQsCQCABQYAEaigCACIARQ0AIAFB/ANqKAIAIgJFDQAgAEEUbEUNACACEMwBCyABQYwEaigCACIARQ0AIAFBiARqKAIAIgJFDQAgAEEEdEUNACACEMwBCyABKAIcQQJHBEAgAUEIahCZAwsgAUGcAWooAgBBAkcEQCABQYgBahCUAwsCQCABQYQCaigCAEECRg0AAkAgAUH8AWooAgAiAEUNACABQfgBaigCACICRQ0AIABBBHRFDQAgAhDMAQsCQCABQZQCaigCACIARQ0AIAFBkAJqKAIAIgJFDQAgAEEYbEUNACACEMwBCyABQaACaigCACIARQ0AIAFBnAJqKAIAIgJFDQAgAEHwAWxFDQAgAhDMAQsgAUHACGokAA8LEKELAAsQogsAC50FAgN/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KAIAIgMgAUEYaigCACIFTQ0CIAEoAgggBUGYAWxqIgMoAgBBAUcNAUGQ4MAAQRFBpODAABD7CQALIAQgBCgCACIAQX9qNgIAIABBAUYEQCAEIAgQrwcLIAkEQCAHEMwBC0G04MAAQT4gBkEIakHsvcAAQfTgwAAQtwcACyACKAIIIQogAikDACELIANBATYCACABIAEoAhxBAWo2AhwgASADKQIENwIUIANBGGogCjYCACADQRBqIAs3AwAgA0EIaiABKQMAIgs3AwAgA0EcaiACKQIMNwIAIANBJGogAkEUaikCADcCACADQSxqIAJBHGooAgA2AgAgA0EwaiAENgIAIANBNGogCDYCACADQThqIAk2AgAgA0E8aiAHNgIAIANBQGsgAkEwakHYABCiCRogACAFNgIIIAAgCzcDACAGQRBqJAAPCyAFIANBgODAABDzBwALhAMBC38jAEEwayICJAAgAUEIaigCACEIIAJBCGogACgCACABQQxqKAIAQX9qIgkgASgCBCIHIAEoAgAiBWtxEPEEAn8gAigCDCIBIAIoAggNABpBACAFIAdGDQAaIAEoAgAiBkEEaiIKKAIAIQQgBkEIaiILKAIAIQEDQCAFQQJ0IAhqKAIAIQwCQCAEIAFrQQRPBEAgAUEEaiEAIAYoAgAhAwwBCwJAIAFBBGoiACABSQ0AIARBAXQiAyAAIAMgAEsbIgNBCCADQQhLGyEDAkAgBEUEQCACQQA2AiAMAQsgAkEBNgIoIAIgBDYCJCACIAYoAgA2AiALIAJBEGogA0EBIAJBIGoQwQYgAigCFCEDIAIoAhghBCACKAIQQQFHBEAgBiADNgIAIAogBDYCAAwCCyAERQ0AIAMgBEGElMMAKAIAIgBBrQYgABsRAAAACxCUCwALIAsgADYCACABIANqIAw2AAAgACEBIAcgBUEBaiAJcSIFRw0AC0EACyACQTBqJAALhwMCBn8CfiMAQYABayIBQThqIgNBEGogAEEQaikCADcDACADQQhqIABBCGoiBSkCADcDACABIAApAgA3AzggAUH8AGogA0EUaigCACIENgIAIAFB0ABqIgNBFGogBDYCACADQRhqIAEpAkQiCTcDACADQSBqIgYgBDYCACADQQhqIgQgBSgCADYCACABIAk3AnQgASAJNwJcIAEgACkCACIKNwNQIAFB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IANBADYCACACQQA2AgAgAEEANgIAIARBsAJqJAAPCxChCwALEKILAAv1AQEDfyMAQTBrIgQkACAEQQhqIgVBCGoiBiABQQhqKAIANgIAIARBHGogAkEIaigCADYCACAFQSBqIgUgA0EIaigCADYCACAEIAEpAgA3AwggBCACKQIANwIUIAQgAykCADcDIEEsQQQQyAoiAUUEQEEsQQRBhJTDACgCACIAQa0GIAAbEQAAAAsgASAEKQMINwIIIAFCgYCAgBA3AgAgAUEoaiAFKAIANgIAIAFBIGogBEEIaiICQRhqKQMANwIAIAFBGGogAkEQaikDADcCACABQRBqIAYpAwA3AgAgAEGU/cEANgIEIAAgATYCACAEQTBqJAAL4gEBA38jAEEQayIEJAACQAJAIAEEQCABKAIAIgNBf0YNASABIANBAWo2AgAgBCABQQhqIAIQwgUgASABKAIAQX9qNgIAAkAgBCgCACIBRQRAQQAhAkEAIQEMAQsgBCgCBCIDIARBCGooAgAiAk0NACADQQJ0IQMgAkECdCIFRQRAIANFBEBBBCEBDAILIAEQzAFBBCEBDAELIAEgA0EEIAUQuAoiAUUNAwsgACACNgIEIAAgATYCACAEQRBqJAAPCxChCwALEKILAAsgBUEEQYSUwwAoAgAiAEGtBiAAGxEAAAAL4gEBA38jAEEQayIEJAACQAJAIAEEQCABKAIAIgNBf0YNASABIANBAWo2AgAgBCABQQhqIAIQggEgASABKAIAQX9qNgIAAkAgBCgCACIBRQRAQQAhAkEAIQEMAQsgBCgCBCIDIARBCGooAgAiAk0NACADQQJ0IQMgAkECdCIFRQRAIANFBEBBBCEBDAILIAEQzAFBBCEBDAELIAEgA0EEIAUQuAoiAUUNAwsgACACNgIEIAAgATYCACAEQRBqJAAPCxChCwALEKILAAsgBUEEQYSUwwAoAgAiAEGtBiAAGxEAAAAL4gEBA38jAEEQayIEJAACQAJAIAEEQCABKAIAIgNBf0YNASABIANBAWo2AgAgBCABQQhqIAIQmAUgASABKAIAQX9qNgIAAkAgBCgCACIBRQRAQQAhAkEAIQEMAQsgBCgCBCIDIARBCGooAgAiAk0NACADQQJ0IQMgAkECdCIFRQRAIANFBEBBBCEBDAILIAEQzAFBBCEBDAELIAEg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AAsQogsAC0GIqcAAQc0AQYCqwAAQuAgAC0EUQQRBhJTDACgCACIAQa0GIAAbEQAAAAvfAQECfyMAQSBrIgIkAAJAAkACQCAABEAgACgCACIDQX9GDQEgACADQQFqNgIAIAJBCGogAEEIaiABEKwIIAIoAggiAUUNAiACQRBqIAFBnAFqIgFBCGooAgA2AgAgAiABKQIANwMIIAAgACgCAEF/ajYCAEEQQQQQyAoiAEUNAyAAQQA2AgAgACACKQMINwIEIABBDGogAkEQaigCADYCACACQSBqJAAgAA8LEKELAAsQogsAC0GIqcAAQc0AQYCqwAAQuAgAC0EQQQRBhJTDACgCACIAQa0GIAAbEQAAAAvfAQECfyMAQSBrIgIkAAJAAkACQCAABEAgACgCACIDQX9GDQEgACADQQFqNgIAIAJBCGogAEEIaiABEKwIIAIoAggiAUUNAiACQRBqIAFBqAFqIgFBCGooAgA2AgAgAiABKQIANwMIIAAgACgCAEF/ajYCAEEQQQQQyAoiAEUNAyAAQQA2AgAgACACKQMINwIEIABBDGogAkEQaigCADYCACACQSBqJAAgAA8LEKELAAsQogsAC0GIqcAAQc0AQYCqwAAQuAgAC0EQQQRBhJTDACgCACIAQa0GIAAbEQAAAAvfAQECfyMAQSBrIgIkAAJAAkACQCAABEAgACgCACIDQX9GDQEgACADQQFqNgIAIAJBCGogAEEIaiABEK0IIAIoAggiAUUNAiACQRBqIAFB1ABqIgFBGGooAgA2AgAgAiABKQIQNwMIIAAgACgCAEF/ajYCAEEQQQQQyAoiAEUNAyAAQQA2AgAgACACKQMINwIEIABBDGogAkEQaigCADYCACACQSBqJAAgAA8LEKELAAsQogsAC0GgqsAAQcwAQZSrwAAQuAgAC0EQQQRBhJTDACgCACIAQa0GIAAbEQAAAAvfAQECfyMAQSBrIgIkAAJAAkACQCAABEAgACgCACIDQX9GDQEgACADQQFqNgIAIAJBCGogAEEIaiABEK0IIAIoAggiAUUNAiACQRBqIAFB1ABqIgFBCGopAgA3AwAgAiABKQIANwMIIAAgACgCAEF/ajYCAEEUQQQQyAoiAEUNAyAAQQA2AgAgACACKQMINwIEIABBDGogAkEQaikDADcCACACQSBqJAAgAA8LEKEL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An8jAEEwayIDJAACQAJAAkAgAARAIAAoAgAiBEF/Rg0BIAAgBEEBajYCACADQRhqIABBCGogARCsCCADKAIYIgFFDQIgA0EQaiIEIAFB3AFqKAIANgIEIAQgASgC1AE2AgAgAygCFCIBIAJNDQMgAygCECACQQR0aiIBKAIIIQIgAyABKQMANwMIIAMgAjYCACADKAIAIAAgACgCAEF/ajYCACADQTBqJAAPCxChCwALEKILAAtBiKnAAEHNAEGAqsAAELgIAAsgAiABQfSrwAAQ8wcAC4QCAQJ/AkBBCEEEEMgKIgEEQCABQoGAgIAQNwIAQSBBBBDICiICRQ0BIABBADoATCAAQYquj+EDNgJIIABC////+/f//7//ADcCCCAAQcyVwQA2AgQgACABNgIAIABBLGpCADcCACAAQSRqQgA3AgAgAEFAa0IANwIAIABBPGpBiMDAACgCADYCACAAQThqQQg2AgAgAEE0aiACNgIAIABBIGpBkMDAACgCADYCACAAQRhqQv////v///+/fzcCACAAQRBqQv////v3//+/fzcCAA8LQQhBBEGElMMAKAIAIgBBrQYgABsRAAAAC0EgQQRBhJTDACgCACIAQa0GIAAbEQAAAAuEAgECfwJAQQhBBBDICiIBBEAgAUKBgICAEDcCAEEgQQQQyAoiAkUNASAAQQA6AEwgAEL////79///v/8ANwIIIABBzJXBADYCBCAAIAE2AgAgAEGKro/hAzYCSCAAQSxqQgA3AgAgAEEkakIANwIAIABBQGtCADcCACAAQTxqQYjAwAAoAgA2AgAgAEE4akEINgIAIABBNGogAjYCACAAQSBqQZDAwAAoAgA2AgAgAEEYakL////7////v383AgAgAEEQakL////79///v383AgAPC0EIQQRBhJTDACgCACIAQa0GIAAbEQAAAAtBIEEEQYSUwwAoAgAiAEGtBiAAGxEAAAALuwEBAn8jAEEgayIEJAACQAJAAkAgAEUNACAAKAIADQEgAEF/NgIAIAJFDQAgAigCACIFQX9GDQEgAiAFQQFqNgIAIARBCGogAEEIaiABENQHIAQoAggiAUUNAiAEQRBqIAJBDGooAgA2AgAgBCACKQIENwMIIAEgBEEIaiADQQBHEJsIIAIgAigCAEF/ajYCACAAQQA2AgAgBEEgaiQADwsQoQsACxCiCwALQYipwABBzQBBkKrAABC4CAALuwEBAn8jAEEgayIEJAACQAJAAkAgAEUNACAAKAIADQEgAEF/NgIAIAJFDQAgAigCACIFQX9GDQEgAiAFQQFqNgIAIARBCGogAEEIaiABENQHIAQoAggiAUUNAiAEQRBqIAJBDGooAgA2AgAgBCACKQIENwMIIAEgBEEIaiADQQBHEJwIIAIgAigCAEF/ajYCACAAQQA2AgAgBEEgaiQADwsQoQsACxCiCwALQYipwABBzQBBkKrAABC4CAALuwEBAn8jAEEgayIEJAACQAJAAkAgAEUNACAAKAIADQEgAEF/NgIAIAJFDQAgAigCACIFQX9GDQEgAiAFQQFqNgIAIARBCGogAEEIaiABENQHIAQoAggiAUUNAiAEQRBqIAJBDGooAgA2AgAgBCACKQIENwMIIAEgBEEIaiADQQBHEJ0HIAIgAigCAEF/ajYCACAAQQA2AgAgBEEgaiQADwsQoQsACxCiCwALQYipwABBzQBBkKrAABC4CAALuwEBAn8jAEEgayIEJAACQAJAAkAgAEUNACAAKAIADQEgAEF/NgIAIAJFDQAgAigCACIFQX9GDQEgAiAFQQFqNgIAIARBCGogAEEIaiABENQHIAQoAggiAUUNAiAEQRBqIAJBDGooAgA2AgAgBCACKQIENwMIIAEgBEEIaiADQQBHEP4GIAIgAigCAEF/ajYCACAAQQA2AgAgBEEgaiQADwsQoQsACxCiCwALQYipwABBzQBBkKrAABC4CAALuwEBAn8jAEEgayIEJAACQAJAAkAgAEUNACAAKAIADQEgAEF/NgIAIAJFDQAgAigCACIFQX9GDQEgAiAFQQFqNgIAIARBCGogAEEIaiABENQHIAQoAggiAUUNAiAEQRBqIAJBDGooAgA2AgAgBCACKQIENwMIIAEgBEEIaiADQQBHEJ4HIAIgAigCAEF/ajYCACAAQQA2AgAgBEEgaiQADwsQoQsACxCiCwALQYipwABBzQBBkKrAABC4CAALuwEBAn8jAEEgayIEJAACQAJAAkAgAEUNACAAKAIADQEgAEF/NgIAIAJFDQAgAigCACIFQX9GDQEgAiAFQQFqNgIAIARBCGogAEEIaiABENQHIAQoAggiAUUNAiAEQRBqIAJBDGooAgA2AgAgBCACKQIENwMIIAEgBEEIaiADQQBHEIQFIAIgAigCAEF/ajYCACAAQQA2AgAgBEEgaiQADwsQoQsACxCiCwALQYipwABBzQBBkKrAABC4CAALpgEBCX0gAioCACIEIAEqAgAiBpQgAkEEaioCACIFIAFBBGoqAgAiB5SSIAFBCGoqAgAiCCACQQhqKgIAIgOUkiAEIAFBDGoqAgAiCZQgBSABQRBqKgIAIgqUkiADIAFBFGoqAgAiC5SSXiECIAAgCCALIAIbIAMgASoCGCIDlJI4AgggACAHIAogAhsgBSADlJI4AgQgACAGIAkgAhsgBCADlJI4AgALvwEBBH8jAEHQAGsiAiQAAkACQCAABEAgACgCAA0BIAJBDGogAEHQA2pBxAAQogkaIABBADYCACAAQZQEaiIEKAIAIQMgBEECNgIAIANBAkcEQCAAQZgEaigCACEAQdAAQQQQyAoiAUUNAyABQQA2AgAgAUEEaiACQQxqQcQAEKIJGiABIAA2AkwgASADNgJICyACQdAAaiQAIAEPCxChCwALEKILAAtB0ABBBEGElMMAKAIAIgBBrQYgABsRAAAAC58BAQV9AkAgAUEEaioCACIGIAIqAgSMlCACKgIAIAEqAgAiB5STIAIqAgggAUEIaioCACIIlJMiCUMAAAAAXkEBc0VBACAEG0UEQEEAIQEgCSAHIAJBDGoqAgCUIAYgAkEQaioCAJSSIAggAkEUaioCAJSSlSIFQwAAAABgQQFzDQEgBSADX0EBcw0BC0EBIQELIAAgBTgCBCAAIAE2AgALxgEBAn8jAEGAAWsiAyQAIANB2ABqIgRBEGogAUEQaigCADYCACAEQQhqIAFBCGopAgA3AwAgAyABKQIANwNYIANB8ABqIgFBCGogAkEIaigCADYCACADIAIpAgA3A3AgA0EIaiAEIAEQmQJB2ABBBBDICiIBRQRAQdgAQQRBhJTDACgCACIAQa0GIAAbEQAAAAsgAUEIaiADQQhqQdAAEKIJGiABQoGAgIAQNwIAIABBiIPCADYCBCAAIAE2AgAgA0GAAWokAAu1AQEEfyMAQTBrIgIkACABQQRqIQMgASgCBEUEQCABKAIAIQEgAkIANwIMIAJBkMLCACgCADYCCCACIAJBCGoiBTYCFCACQRhqIgRBEGogAUEQaikCADcDACAEQQhqIAFBCGopAgA3AwAgAiABKQIANwMYIAJBFGpB2L7CACAEELkCGiADQQhqIAVBCGooAgA2AgAgAyACKQMINwIACyAAQZjNwgA2AgQgACADNgIAIAJBMGokAAutAQIDfwF9IwBBEGshASAAvCICQRd2Qf8BcSIDQZUBTQR9IANB/QBNBEAgASAAQwAAAEuSOAIMIAEqAgwaIABDAAAAAJQPCwJ9IAAgAIwgAkF/ShsiAEMAAABLkkMAAADLkiAAkyIEQwAAAD9eQQFzRQRAIAAgBJJDAACAv5IMAQsgACAEkiIAIARDAAAAv19BAXMNABogAEMAAIA/kgsiACAAjCACQX9KGwUgAAsLmgEBA38gACgCACIBEIAFAkAgAUHkAGooAgAiAkUNACABQeAAaigCACIDRQ0AIAJBAnRFDQAgAxDMAQsCQCABQfQAaigCACICRQ0AIAFB8ABqKAIAIgNFDQAgAkECdEUNACADEMwBCwJAIAFBgAFqKAIAIgJFDQAgAUH8AGooAgAiAUUNACACQQJ0RQ0AIAEQzAELIAAoAgAQzAELzgEBA30gAyoCABCdASEFIANBBGoqAgAQnQEhBiADQQhqKgIAEJ0BIQcgAEEUakMAAAAAQwAAgD8gBpUgBkMAAAAAWxs4AgAgAEMAAAAAQwAAgD8gBZUgBUMAAAAAWxs4AhAgAEMAAAAAQwAAgD8gApUgAkMAAAAAWxs4AgwgAEEIaiABQQhqKAIANgIAIAAgASkCADcCACAAIAQpAgA3AhwgAEEkaiAEQQhqKQIANwIAIABBGGpDAAAAAEMAAIA/IAeVIAdDAAAAAFsbOAIAC7MBAwJ/AX4DfSMAQdAAayIEJAAgAUEIaiIFKgIAIQcgASoCACEIIAEqAgQhCSAEQRxqIAUoAgA2AgAgBCAHjDgCECAEIAmMOAIMIAQgCIw4AgggBCABKQIANwIUIARBMGoiASAEQQhqIAIgAxCVAiAELQA8IQIgBEEoaiABQQhqKAIAIgE2AgAgBCAEKQMwIgY3AyAgACACOgAMIAAgBjcCACAAQQhqIAE2AgAgBEHQAGokAAusAQECfwJAAkAgAgRAQQEhBCABQQBODQFBACECDAILIAAgATYCBEEBIQRBACECDAELAn8CQAJ/AkACQCADKAIAIgVFBEAgAQ0BDAQLIAMoAgQiAw0BIAFFDQMLIAEgAhDICgwBCyAFIAMgAiABELgKCyEDIAEMAQsgAiEDQQALIANFBEAgACABNgIEDAELIAAgAzYCBEEAIQQhAgsgACAENgIAIABBCGogAjYCAAurAQIBfwF9IwBBQGoiBCQAIARBGGogASABQQxqIAFBGGogAhCKAkEEIQECQCAEKAIoIgJBBEcEQCAEQRBqIgUgBEEkaigCADYCACAEIAQpAhw3AwggACAEKgIYIgYgA19BAXMEf0EEBSAEKAIsIQEgACAGOAIAIAAgBCkDCDcCBCAAIAE2AhQgAEEMaiAFKAIANgIAIAILNgIQDAELIABBBDYCEAsgBEFAayQAC7QBAgJ/AXwjAEEgayIAJAAgABCTCTYCFCAAQcmzwQBBCxADNgIYIABBCGogAEEUaiAAQRhqENoIIAAoAgwhASAAKAIIRQRAIAAgATYCHCAAQRxqKAIAEAQgACgCHCIBQSRPBEAgARABCyAAKAIYIgFBJE8EQCABEAELIAAoAhQiAUEkTwRAIAEQAQsgAEEgaiQADwsgACABNgIcQdSzwQBBLCAAQRxqQeCywQBBgLTBABC3BwALuQEBAX8jAEEQayIGJAACQCABBEAgBiABIAMgBCAFIAIoAgwRCAAgBigCACEBAkAgBigCBCIDIAYoAggiAk0NACABRQ0AIANBAnQhAyACQQJ0IgRFBEAgA0UEQEEEIQEMAgsgARDMAUEEIQEMAQsgASADQQQgBBC4CiIBRQ0CCyAAIAI2AgQgACABNgIAIAZBEGokAA8LQZC0wQBBMBCgCwALIARBBEGElMMAKAIAIgBBrQYgABsRAAAAC6wBAQJ/AkACQCACBEBBASEEIAFBAE4NAUEAIQIMAgsgACABNgIEQQEhBEEAIQIMAQsCfwJ/AkACQAJAIAMoAgAiBUUEQCABRQ0BDAMLIAMoAgQiAw0BIAENAgsgAiEDQQAMAwsgBSADIAIgARC4CgwBCyABIAIQyAoLIQMgAQsgA0UEQCAAIAE2AgQMAQsgACADNgIEQQAhBCECCyAAIAQ2AgAgAEEIaiACNgIAC7QBAQR/IwBBEGsiASQAAkACQCAABEAgACgCAA0BIAFBCGogAEG0AmooAgA2AgAgAEGoAmoiAygCACADQQA2AgAgASAAQawCaikCADcDACAAQQA2AgBBAUYEQEEQQQQQyAoiAkUNAyACQQA2AgAgAiABKQMANwIEIAJBDGogAUEIaigCADYCAAsgAUEQaiQAIAIPCxChCwALEKILAAtBEEEEQYSUwwAoAgAiAEGtBiAAGxEAAAALpgEBB30CQCABKgIAIgUgAioCACIGlCABQQRqKgIAIgcgAkEEaioCACIIlJIgAUEIaioCACIJIAJBCGoqAgAiCpSSIgRDAAAAAF8iAUEBcw0AIANFDQAgACACKQIANwIAIABBCGogAkEIaigCADYCACAAQQE6AAwPCyAAIAogCSAElJM4AgggACAIIAQgB5STOAIEIAAgBiAEIAWUkzgCACAAIAE6AAwLnwEBBX0gACABKgIAIgIgASoCDCIDIAIgA2AbIAEqAhgiBJI4AgwgACACIAMgAiADXxsgBJM4AgAgAEEUaiAEIAEqAggiAiABQRRqKgIAIgMgAiADYBuSOAIAIABBEGogBCABKgIEIgUgAUEQaioCACIGIAUgBmAbkjgCACAAIAIgAyACIANfGyAEkzgCCCAAIAUgBiAFIAZfGyAEkzgCBAusAQEFfSACKgIAIgYgBpQgAioCBCIFIAWUkiACKgIIIgMgA5SSQwAAAACSEJ0BIQQgACADIASVIgcgASoCDCIDlCABKAIIQf////8HcSAHvEGAgICAeHFyvpI4AgggACADIAUgBJUiBZQgASgCBEH/////B3EgBbxBgICAgHhxcr6SOAIEIAAgAyAGIASVIgSUIAEoAgBB/////wdxIAS8QYCAgIB4cXK+kjgCAAuiAQICfwF+IAAoAgAiACgCACABIAIQ0AQiBaciAkH/AXEiA0EERwRAIAVCCIghBSAALQAEQQNGBEAgAEEIaigCACIBKAIAIAEoAgQoAgARBAAgASgCBCIEKAIEBEAgBCgCCBogASgCABDMAQsgARDMAQsgACACOgAEIABBC2ogBUIwiDwAACAAQQlqIAVCIIg9AAAgAEEFaiAFPgAACyADQQRHC6oBAQJ/IwBBIGsiBiQAAkACQCAABEAgACgCAA0BIABBfzYCACAGIABBCGogARDUByAGKAIAIgFFDQIgBkEYaiAEOAIAIAZBFGogAzgCACAGQQhqIAFBEGoiB0EIaikCADcDACAGIAI4AhAgBiAHKQIANwMAIAEgBiAFQQBHEK0GIABBADYCACAGQSBqJAAPCxChCwALEKILAAtBiKnAAEHNAEGQ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DCICEBQhACACQSRPBEAgAhABCyAAIAQgAxAVIABBJE8EQCAAEAELIAFBJE8EQCABEAELDwsQlAsACyABQQFBhJTDACgCACIAQa0GIAAbEQAAAAuhAQEBfyMAQTBrIgMkACADQRhqIAEgAhCtCCADKAIYIgEEQCADQRBqIAEQ2AlBACECAkAgAygCECADKAIUKAIkEQcAQf8BcUEIRw0AIANBCGogARDYCSADKAIIIAMoAgwQ8ggiAUUNAEEBIQIgAUEMaigCAEF/aiEBCyAAIAE2AgQgACACNgIAIANBMGokAA8LQaCqwABBzABBlKvAABC4CAALoQEBAX8jAEEwayIDJAAgA0EYaiABIAIQrQggAygCGCIBBEAgA0EQaiABENgJQQAhAgJAIAMoAhAgAygCFCgCJBEHAEH/AXFBCEcNACADQQhqIAEQ2AkgAygCCCADKAIMEPIIIgFFDQBBASECIAFBEGooAgBBf2ohAQsgACABNgIEIAAgAjYCACADQTBqJAAPC0GgqsAAQcwAQZSrwAAQuAgAC5MBAQN/IwBBgAFrIgMkACAALwEAIQJBACEAA0AgACADakH/AGogAkEPcSIEQTByIARB1wBqIARBCkkbOgAAIABBf2ohACACQQR2Qf8fcSICDQALIABBgAFqIgJBgQFPBEAgAkGAAUHk8sIAEPYHAAsgAUEBQfTywgBBAiAAIANqQYABakEAIABrEIYCIANBgAFqJAALkgEBA38jAEGAAWsiAyQAIAAtAAAhAkEAIQADQCAAIANqQf8AaiACQQ9xIgRBMHIgBEHXAGogBEEKSRs6AAAgAEF/aiEAIAJBBHZBD3EiAg0ACyAAQYABaiICQYEBTwRAIAJBgAFB5PLCABD2BwALIAFBAUH08sIAQQIgACADakGAAWpBACAAaxCGAiADQYABaiQAC5EBAQN/IwBBgAFrIgMkACAALQAAIQJBACEAA0AgACADakH/AGogAkEPcSIEQTByIARBN2ogBEEKSRs6AAAgAEF/aiEAIAJBBHZBD3EiAg0ACyAAQYABaiICQYEBTwRAIAJBgAFB5PLCABD2BwALIAFBAUH08sIAQQIgACADakGAAWpBACAAaxCGAiADQYABaiQAC5IBAQN/IwBBgAFrIgMkACAALwEAIQJBACEAA0AgACADakH/AGogAkEPcSIEQTBy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AkEIaikDADcCACACQRBqJAAgAA8LEKELAAsQogsAC0EUQQRBhJTDACgCACIAQa0GIAAbEQAAAAuSAQICfwF9IwBBIGsiAiQAAkACQCAABEAgACgCACIDQX9GDQEgACADQQFqNgIAIAJBCGogAEEIaiABEIcHIAIoAggiAUUNAiABQagBaioCACABKAIwIQEgACAAKAIAQX9qNgIAIAJBIGokAEP//3//IAFBAkYbDwsQoQsACxCiCwALQYiowABByQBB+KjAABC4CAALkgECAn8BfSMAQSBrIgIkAAJAAkAgAARAIAAoAgAiA0F/Rg0BIAAgA0EBajYCACACQQhqIABBCGogARCHByACKAIIIgFFDQIgAUGsAWoqAgAgASgCMCEBIAAgACgCAEF/ajYCACACQSBqJABD//9/fyABQQJGGw8LEKELAAsQogsAC0GIqMAAQckAQfiowAAQuAgAC5UBAQF/AkACQCAARQ0AIAAoAgANASAAQX82AgAgAUUNACABKAIAIgNBf0YNASABIANBAWo2AgAgAkUNACACKAIAIgNBf0YNASACIANBAWo2AgAgAEEEaiABQQhqIAJBCGpBAEMAAAAAECYgAiACKAIAQX9qNgIAIAEgASgCAEF/ajYCACAAQQA2AgAPCxChCwALEKILAAuSAQAgAEIANwI4IAAgASkCADcCACAAIAIpAgA3AhwgAEFAa0IANwIAIABByABqQgA3AgAgAEEYaiABQRhqKAIANgIAIABBEGogAUEQaikCADcCACAAQQhqIAFBCGopAgA3AgAgAEEkaiACQQhqKQIANwIAIABBLGogAkEQaikCADcCACAAQTRqIAJBGGooAgA2AgALhgEBBX0gAioCACIFIAWUQwAAAACSIAIqAggiAyADlJJDAAAAAJIQnQEiB0MAAAAAXARAIAMgB5UgASoCBCIElCEGIAUgB5UgBJQhBAsgACAGIAMgASoCCCIDlJI4AgggACAEIAUgA5SSOAIAIAAgASoCACACQQRqKgIAIgWYIAUgA5SSOAIEC60BAQJ/IwBB8ABrIgUkACAFQeAAaiIGQQhqIAFBCGooAgA2AgAgBSABKQIANwNgIAUgBiACIAMQNgJAAkAgBSgCAEUEQEEAIQEMAQtB7ABBBBDICiIBRQ0BIAFBCGogBUHgABCiCRogAUKBgICAEDcC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ADYCACACQRhqIAFBGGopAgA3AgAgAkEQaiABQRBqKQIANwIAIAJBCGogAUEIaikCADcCACAAQZT9wQA2AgQgACACNgIAC24BAX8jAEEwayIDJAAgAyACNgIEIAMgATYCACADQRxqQQI2AgAgA0EsakEBNgIAIANCAjcCDCADQYydwAA2AgggA0EENgIkIAMgADYCICADIANBIGo2AhggAyADNgIoIANBCGoQ/AUgA0EwaiQAC2MBA38jAEGwAWsiASQAAkAgAARAIAAoAgANASAAQQA2AgAgAUHYAGoiAiAAQdQAEKIJGiABQQhqIgMgAkEEckHQABCiCRogABDMASADELEFIAFBsAFqJAAPCxChCwALEKILAAtjAQN/IwBBkAJrIgEkAAJAIAAEQCAAKAIADQEgAEEANgIAIAFBiAFqIgIgAEGIARCiCRogAUEIaiIDIAJBCGpBgAEQogkaIAAQzAEgAxCZAyABQZACaiQADwsQoQsACxCiCwALYwEDfyMAQbABayIBJAACQCAABEAgACgCAA0BIABBADYCACABQdgAaiICIABB1AAQogkaIAFBCGoiAyACQQRyQdAAEKIJGiAAEMwBIAMQlAQgAUGwAWokAA8LEKELAAsQogsAC2MBA38jAEHgAWsiASQAAkAgAARAIAAoAgANASAAQQA2AgAgAUHwAGoiAiAAQfAAEKIJGiABQQhqIgMgAkEIakHoABCiCRogABDMASADEJQDIAFB4AFqJAAPCxChCwALEKILAAuuAQEBfyMAQRBrIgIkACACIAGtQoCAgIAQQgAgASgCGEHH8sIAQQEgAUEcaigCACgCDBEGABuENwMAIAIgADYCDCACIAJBDGoiAUHAusEAEJcLIAIgAEEEajYCDCACIAFBwLrBABCXCyACIABBCGo2AgwgAiABQcC6wQAQlwsgAi0ABAR/QQEFIAIoAgAiACgCGEHI8sIAQQEgAEEcaigCACgCDBEGAAsgAkEQaiQAC2sAIABCADcCHCAAIAEpAgA3AgAgAEEkakIANwIAIABBLGpCADcCACAAQTRqQgA3AgAgAEE8akEANgIAIABBGGogAUEYaigCADYCACAAQRBqIAFBEGopAgA3AgAgAEEIaiABQQhqKQIANwIAC38CA38CfSAAKAIIIgFFBEBD//9/fw8LIAFBJGwhASAAKAIAQSBqIQBD//9/fyEEA0AgACgCACECIABBfGohAyAAQSRqIQAgBCAEIAMoAgAgAigCCEEHakF4cWogAigCLBEKACIFIAQgBV0bIAUgBVwbIQQgAUFcaiIBDQALIAQLewIDfwJ9IAAoAggiAUUEQEP//39/DwsgAUEkbCEBIAAoAgBBIGohAEP//39/IQQDQCAAKAIAIQIgAEF8aiAAQSRqIQAoAgAgAigCCEEHakF4cWogAigCMBEKACIFIAUgBCAEIAVdGyAEIARcGyEEIAFBXGoiAQ0ACyAEC2YBA38gACAAKQMAQgh8NwMAIAEoAghBJGwhAiABKAIAIQEDQCACRQRAQQAPCyAAIAApAwBCLHw3AwAgAkFcaiECIAFBIGohAyABKAIcIAFBJGohASADKAIAIAAQ2AEiA0UNAAsgAwtfAQJ/IwBBIGsiAiQAAkAgAARAIAAoAgAiA0F/Rg0BIAAgA0EBajYCACACQQhqIABBCGogARCHByACKAIIIAAgACgCAEF/ajYCACACQSBqJABBAEcPCxChCwALEKILAAtsAQF/IwBBIGsiAiQAAkACQCAABEAgACgCAA0BIABBfzYCACACQQhqIABBCGogARDUByACKAIIIgFFDQIgARC6CCAAQQA2AgAgAkEgaiQADwsQoQsACxCiCwALQYipwABBzQBBkKrAABC4CAALbwEBfyMAQSBrIgMkAAJAAkAgAARAIAAoAgANASAAQX82AgAgA0EIaiAAQQhqIAEQ1AcgAygCCCIBRQ0CIAEgAjgCtAEgAEEANgIAIANBIGokAA8LEKELAAsQogsAC0GIqcAAQc0AQZCqwAAQuAgAC28BAX8jAEEgayIDJAACQAJAIAAEQCAAKAIADQEgAEF/NgIAIANBCGogAEEIaiABENQHIAMoAggiAUUNAiABIAI4ArgBIABBADYCACADQSBqJAAPCxChCwALEKILAAtBiKnAAEHNAEGQqsAAELgIAAtfAQJ/IwBBIGsiAiQAAkAgAARAIAAoAgAiA0F/Rg0BIAAgA0EBajYCACACQQhqIABBCGogARCsCCACKAIIIAAgACgCAEF/ajYCACACQSBqJABBAEcPCxChCwALEKILAAtfAQJ/IwBBIGsiAiQAAkAgAARAIAAoAgAiA0F/Rg0BIAAgA0EBajYCACACQQhqIABBCGogARCtCCACKAIIIAAgACgCAEF/ajYCACACQSBqJABBAEcPCxChCwALEKILAAthAQF9IwBBMGsiBCQAIARBCGogASABQQxqIAFBGGogAhCKAgJ/IAQoAhhBBEcEQEEBIAQqAggiBSADX0EBc0UNARpBAAwBC0EACyEBIAAgBTgCBCAAIAE2AgAgBEEwaiQAC9QBACAAQv////v///+/fzcDMCAAQv////v3//+//wA3AyAgAEL////79///v/8ANwMQIABC////+/f//7//ADcDCCAAQv////v3//+//wA3AwAgAEHYAGpC////+////79/NwMAIABB0ABqQv////v///+/fzcDACAAQcgAakL////7////v383AwAgAEFAa0L////7////v383AwAgAEE4akL////7////v383AwAgAEEoakL////79///v/8ANwMAIABBGGpC////+/f//7//ADcDAAtpAQJ/IwBBIGsiAiQAIAIgATYCBEEBIQMCQCAAKAIAIAFGDQBBAiEDIAAoAgQgAUYNAEEAIQMgACgCCCABRg0AIAJBADYCCCAAQQhqIAJBBGogAkEIakHc4cEAEP8HAAsgAkEgaiQAIAMLbAEBfyMAQSBrIgIkAAJAAkAgAARAIAAoAgANASAAQX82AgAgAkEIaiAAQQhqIAEQ1AcgAigCCCIBRQ0CIAEQmAkgAEEANgIAIAJBIGokAA8LEKELAAsQogsAC0GIqcAAQc0AQZCqwAAQuAgAC2wAIAEgAikCADcCUCABQfgAaiACQShqKAIANgIAIAFB8ABqIAJBIGopAgA3AgAgAUHoAGogAkEYaikCADcCACABQeAAaiACQRBqKQIANwIAIAFB2ABqIAJBCGopAgA3AgAgACABQYgBEKIJGguAAQAgAEIANwMIIABCADcDACAAQYCAgPgDNgJQIABBADYCICAAQQA2AhggACABNgIQIABCADcCVCAAQv////8PNwN4IABB8ABqQoCAgIBwNwMAIABB6ABqQgA3AwAgAEEUaiACNgIAIABB3ABqQgA3AgAgAEHkAGpBgICA/AM2AgALaAIBfwR9IwBBEGsiAyQAIAIqAgAiBSAFlCACKgIEIgYgBpSSIAIqAggiByAHlJJDAAAAAJIQnQEhBCADIAcgBJU4AgggAyAGIASVOAIEIAMgBSAElTgCACAAIAEgAxCLBSADQRBqJAALaQAgAEIANwIAIABCADcCMCAAQgA3AkAgAEEoakIANwIAIABBIGpCADcCACAAQRhqQgA3AgAgAEEQakIANwIAIABBCGpCADcCACAAQThqQgA3AgAgAEHIAGpCADcCACAAQdAAakIANwIAC6sBAQJ/IwBBEGsiAiQAIAAoAgAiACgCCCEDIAAoAgAhACACIAGtQoCAgIAQQgAgASgCGEHH8sIAQQEgAUEcaigCACgCDBEGABuENwMAIAMEQANAIAIgADYCDCACIAJBDGpBiL/CABCXCyAAQQFqIQAgA0F/aiIDDQALCyACLQAEBH9BAQUgAigCACIAKAIYQcjywgBBASAAQRxqKAIAKAIMEQYACyACQRBqJAALcAEBfyMAQTBrIgIkACACIAE2AgQgAiAANgIAIAJBHGpBAjYCACACQSxqQQI2AgAgAkIDNwIMIAJBsNbCADYCCCACQQI2AiQgAiACQSBqNgIYIAIgAkEEajYCKCACIAI2AiAgAkEIakHk1sIAEOIJAAtwAQF/IwBBMGsiAiQAIAIgATYCBCACIAA2AgAgAkEcakECNgIAIAJBLGpBAjYCACACQgM3AgwgAkGI18IANgIIIAJBAjYCJCACIAJBIGo2AhggAiACQQRqNgIoIAIgAjYCICACQQhqQaDXwgAQ4gkAC20BAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakECNgIAIANCAjcCDCADQazwwgA2AgggA0ECNgIkIAMgA0EgajYCGCADIAM2AiggAyADQQRqNgIgIANBCGogAhDiCQALbQEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQQI2AgAgA0ICNwIMIANBpPfCADYCCCADQQI2AiQgAyADQSBqNgIYIAMgA0EEajYCKCADIAM2AiAgA0EIaiACEOIJAAttAQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EcakECNgIAIANBLGpBAjYCACADQgI3AgwgA0HY98IANgIIIANBAjYCJCADIANBIGo2AhggAyADQQRqNgIoIAMgAzYCICADQQhqIAIQ4gkAC20BAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakECNgIAIANCAjcCDCADQYT3wgA2AgggA0ECNgIkIAMgA0EgajYCGCADIANBBGo2AiggAyADNgIgIANBCGogAhDiCQALWQEDfyMAQSBrIgIkACABQRxqKAIAIQMgASgCGCACQQhqIgFBEGogAEEQaikCADcDACABQQhqIABBCGopAgA3AwAgAiAAKQIANwMIIAMgARC5AiACQSBqJAALWQEDfyMAQSBrIgIkACAAQRxqKAIAIQMgACgCGCACQQhqIgBBEGogAUEQaikCADcDACAAQQhqIAFBCGopAgA3AwAgAiABKQIANwMIIAMgABC5AiACQSBqJAALaAECfyMAQRBrIgIkAAJAIAAEQCAAKAIAIgFBf0YNASAAIAFBAWo2AgAgAEEQaigCACEBIAIgACkDCDcDCCACIAE2AgAgAigCACAAIAAoAgBBf2o2AgAgAkEQaiQADwsQoQsACxCiCwALZQEBfyMAQSBrIgUkACAFIAI2AgQgBSABNgIAIAVBCGoiAUEQaiADQRBqKQIANwMAIAFBCGogA0EIaikCADcDACAFIAMpAgA3AwggACAFQfy9wAAgBUEEakH8vcAAIAEgBBC8BAALawEBfyMAQSBrIgIkACACQdzBwAA2AgQgAiAANgIAIAJBCGoiAEEQaiABQRBqKQIANwMAIABBCGogAUEIaikCADcDACACIAEpAgA3AwhBASACQeC7wAAgAkEEakHgu8AAIABBsJjBABC8BAALZQEBfyMAQSBrIgUkACAFIAI2AgQgBSABNgIAIAVBCGoiAUEQaiADQRBqKQIANwMAIAFBCGogA0EIaikCADcDACAFIAMpAgA3AwggACAFQYy+wAAgBUEEakGMvsAAIAEgBBC8BAALawEBfyMAQSBrIgIkACACQZCQwQA2AgQgAiAANgIAIAJBCGoiAEEQaiABQRBqKQIANwMAIABBCGogAUEIaikCADcDACACIAEpAgA3AwhBACACQZy+wAAgAkEEakGcvsAAIABBlJDBABC8BAALVQECfwJAIABBBGooAgAiAUUNACAAKAIAIgJFDQAgAUECdEUNACACEMwBCwJAIABBKGooAgAiAUUNACAAQSRqKAIAIgBFDQAgAUECdEUNACAAEMwBCwtlAQF/IwBBIGsiBCQAIAQgATYCBCAEIAA2AgAgBEEIaiIAQRBqIAJBEGopAgA3AwAgAEEIaiACQQhqKQIANwMAIAQgAikCADcDCEEAIARB0LrBACAEQQRqQdC6wQAgACADELwEAAtbAQJ/IwBBIGsiAiQAIAJBCGoiAyABQci8wQBBABDDCSACIAA2AhggAiAAQQRqNgIcIAMgAkEYakHQusEAEIIFIAMgAkEcakHQusEAEIIFIAMQgQcgAkEgaiQAC1sBAn8jAEEgayICJAAgAkEIaiIDIAFByLzBAEEAEMMJIAIgADYCGCACIABBBGo2AhwgAyACQRhqQcC6wQAQggUgAyACQRxqQcy9wQAQggUgAxCBByACQSBqJAALbgECfSABKgIAIgIgApQgAUEEaioCACICIAKUkiABQQhqKgIAIgIgApSSQwAAAACSEJ0BIQIgASoCDCIDQwAAAABgRQRAQZHIwQBBJkGgy8EAEP8JAAsgAEEANgIIIABCADcCACAAIAIgA5I4AgwLawEBfyMAQSBrIgIkACACQdjDwgA2AgQgAiAANgIAIAJBCGoiAEEQaiABQRBqKQIANwMAIABBCGogAUEIaikCADcDACACIAEpAgA3AwhBACACQfjBwgAgAkEEakH4wcIAIABB0NLCABC8BAALaAEBfyMAQSBrIgMkACADQYjKwgA2AgQgAyAANgIAIANBCGoiAEEQaiABQRBqKQIANwMAIABBCGogAUEIaikCADcDACADIAEpAgA3AwhBACADQejBwgAgA0EEakHowcIAIAAgAhC8BAALaAEBfyMAQSBrIgMkACADIAE2AgQgAyAANgIAIANBCGoiAEEQaiACQRBqKQIANwMAIABBCGogAkEIaikCADcDACADIAIpAgA3AwhBACADQbzwwgAgA0EEakG88MIAIABBgNjCABC8BAALXAEBfyMAQSBrIgIkACACIAAoAgA2AgQgAkEIaiIAQRBqIAFBEGopAgA3AwAgAEEIaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQfSYwAAgABC5AiACQSBqJAALcQECfyMAQZACayIAJAAgAEEIaiIBEMoFIABBkAFqIAFBgAEQogkaQYgBQQgQyAoiAUUEQEGIAUEIQYSUwwAoAgAiAEGtBiAAGxEAAAALIAFBADYCACABQQRqIABBjAFqQYQBEKIJGiAAQZACaiQAIAELcQECfyMAQeABayIAJAAgAEEIaiIBEJkFIABB+ABqIAFB6AAQogkaQfAAQQgQyAoiAUUEQEHwAEEIQYSUwwAoAgAiAEGtBiAAGxEAAAALIAFBADYCACABQQRqIABB9ABqQewAEKIJGiAAQeABaiQAIAELcQECfyMAQbAIayIAJAAgAEEIaiIBELcCIABBoARqIAFBkAQQogkaQZgEQQgQyAoiAUUEQEGYBEEIQYSUwwAoAgAiAEGtBiAAGxEAAAALIAFBADYCACABQQRqIABBnARqQZQEEKIJGiAAQbAIaiQAIAELSQEBfyAAKAIAIgEEQCAAKAIEIAFBAnRBBGprEMwBCwJAIABBFGooAgAiAUUNACAAQRBqKAIAIgBFDQAgAUEEdEUNACAAEMwBCwtJAQF/IAAoAgAiAQRAIAAoAgQgAUECdEEEamsQzAELAkAgAEEUaigCACIBRQ0AIABBEGooAgAiAEUNACABQRRsRQ0AIAAQzAELC2oAIAAgASkCADcCDCAAIAIpAgA3AhggACABKgIEIAIqAgSTOAIEIAAgASoCACACKgIAkzgCACAAQRRqIAFBCGoiASgCADYCACAAQSBqIAJBCGoiAigCADYCACAAIAEqAgAgAioCAJM4AggLXAEBfyMAQSBrIgIkACACIAAoAgA2AgQgAkEIaiIAQRBqIAFBEGopAgA3AwAgAEEIaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQcC+wgAgABC5AiACQSBqJAALXAEBfyMAQSBrIgIkACACIAAoAgA2AgQgAkEIaiIAQRBqIAFBEGopAgA3AwAgAEEIaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQdi+wgAgABC5AiACQSBqJAALXAEBfyMAQSBrIgIkACACIAAoAgA2AgQgAkEIaiIAQRBqIAFBEGopAgA3AwAgAEEIaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQfC+wgAgABC5AiACQSBqJAALXAEBfyMAQSBrIgIkACACIAAoAgA2AgQgAkEIaiIAQRBqIAFBEGopAgA3AwAgAEEIaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQeDTwgAgABC5AiACQSBqJAALXAEBfyMAQSBrIgIkACACIAAoAgA2AgQgAkEIaiIAQRBqIAFBEGopAgA3AwAgAEEIaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQcD0wgAgABC5AiACQSBqJAALXAECfyMAQRBrIgIkAAJAIAAEQCAAKAIAIgNBf0YNASAAIANBAWo2AgAgAiABNgIMIABBCGogAkEMahCSBiAAIAAoAgBBf2o2AgAgAkEQaiQADwsQoQsACxCiCwALXAECfyMAQRBrIgIkAAJAIAAEQCAAKAIAIgNBf0YNASAAIANBAWo2AgAgAiABNgIMIABBCGogAkEMahDnBSAAIAAoAgBBf2o2AgAgAkEQaiQADwsQoQsACxCiCwALXAECfyMAQRBrIgIkAAJAIAAEQCAAKAIAIgNBf0YNASAAIANBAWo2AgAgAiABNgIMIABBCGogAkEMahCHBSAAIAAoAgBBf2o2AgAgAkEQaiQADwsQoQsACxCiCwALXAECfyMAQRBrIgIkAAJAIAAEQCAAKAIAIgNBf0YNASAAIANBAWo2AgAgAiABNgIMIABBCGogAkEMahDpBSAAIAAoAgBBf2o2AgAgAkEQaiQADwsQoQsACxCiCwALYAEDfSAAIAEqAgAiAyACKgIQIgSSOAIMIAAgBCADkzgCACAAQRRqIAMgAkEYaioCACIEkjgCACAAQRBqIAMgAkEUaioCACIFkjgCACAAIAQgA5M4AgggACAFIAOTOAIEC1kBAX8jAEEgayICJAAgAiAANgIEIAJBCGoiAEEQaiABQRBqKQIANwMAIABBCGogAUEIaikCADcDACACIAEpAgA3AwggAkEEakHAvsIAIAAQuQIgAkEgaiQAC1kBAX8jAEEgayICJAAgAiAANgIEIAJBCGoiAEEQaiABQRBqKQIANwMAIABBCGogAUEIaikCADcDACACIAEpAgA3AwggAkEEakHwvsIAIAAQuQIgAkEgaiQAC1kBAX8jAEEgayICJAAgAiAANgIEIAJBCGoiAEEQaiABQRBqKQIANwMAIABBCGogAUEIaikCADcDACACIAEpAgA3AwggAkEEakHA9MIAIAAQuQIgAkEgaiQAC2QCAX8CfUMAAKBAIQNDAACgQEMAAIA/IABBAXEbIQIgAEEBakEDTwRAIAAhAQNAIAIgAyADlCIDlCACIAFBAm0iAUEBcRshAiABQQFqQQJLDQALC0MAAIA/IAKVIAIgAEEASBsLaAEBfSAAIAEpAgA3ApwBIABBpAFqIAFBCGooAgA2AgACQCAALQCRAg0AIAJFDQAgAEHsAWotAAAEQCAAQQA6AOwBIAAgACgChAJBBHI2AoQCCyAAQegBaiAAKgLkAYsiAyADkjgCAAsLaAEBfSAAIAEpAgA3AqgBIABBsAFqIAFBCGooAgA2AgACQCAALQCRAg0AIAJFDQAgAEHsAWotAAAEQCAAQQA6AOwBIAAgACgChAJBBHI2AoQCCyAAQegBaiAAKgLkAYsiAyADkjgCAAsLbAIDfwF+IwBBEGsiACQAQdiNwwApAwBQBEAgABCZCjYCDCAAQQxqKAIAKQMIIQMgACgCDCICKAIAIQEgAiABQX9qNgIAIAFBAUYEQCAAKAIMENIHC0HYjcMAIAM3AwALIABBEGokAEHYjcMAC1sBBH0gAioCACIFIAWUIAIqAgQiBiAGlJIgAioCCCIDIAOUkkMAAAAAkhCdASEEIAAgAyAElSABKgIAIgOUOAIIIAAgAyAGIASVlDgCBCAAIAMgBSAElZQ4AgALdAEBf0EcQQQQyAoiAkUEQEEcQQRBhJTDACgCACIAQa0GIAAbEQAAAAsgAiABKQIANwIAIAJBGGogAUEYaigCADYCACACQRBqIAFBEGopAgA3AgAgAkEIaiABQQhqKQIANwIAIABBwPvBADYCBCAAIAI2AgALXQECfyMAQSBrIgMkACADQQhqIAFBCGooAgA2AgAgAyABKQIANwMAIANBEGoiBEEIaiABQRRqKAIANgIAIAMgASkCDDcDECAAIAIgAyAEIAEqAhgQjAMgA0EgaiQAC3sBAX8CQCACvCABvHJBf0oEQEEUQQQQyAoiBEUNASAEIAM4AhAgBCACOAIMIAQgATgCCCAEQoGAgIAQNwIAIABBkJvCADYCBCAAIAQ2AgAPC0H0kcIAQc0AQaSTwgAQ5wgAC0EUQQRBhJTDACgCACIAQa0GIAAbEQAAAAtaACAAIAEtAANBAEcgAi0AA0EAR3E6AAMgACABLQACQQBHIAItAAJBAEdxOgACIAAgAS0AAUEARyACLQABQQBHcToAASAAIAEtAABBAEcgAi0AAEEAR3E6AAALVwECfwJAIAAEQCAAKAIADQEgAEEANgIAIABBCGooAgAhAiAAKAIEIQEgABDMASABIAEoAgAiAEF/ajYCACAAQQFGBEAgASACEK8HCw8LEKELAAsQogsAC24BBH8jAEEQayIEJAAgBEEIaiAAIAEgAiADEOYIIAQoAgwhBiAEKAIIIQdBDEEEEMgKIgVFBEBBDEEEQYSUwwAoAgAiBEGtBiAEGxEAAAALIAUgBjYCCCAFIAc2AgQgBUEANgIAIARBEGokACAFC04BAX8jAEEwayIDJAAgA0EIaiAAIABBDGogAEEYaiABEIoCAn8gAygCGEEERwRAQQAgAyoCCCACX0EBcw0BGkEBDAELQQALIANBMGokAAtbAQF/IwBBIGsiAyQAIAMgASACENoCIABBCGogA0EIaikDADcCACAAIAMpAwA3AgAgAEEUakEAIANBFGooAgAgAygCECIBGzYCACAAIAFBAEc2AhAgA0EgaiQAC10BAXwCQCAAQwAAAD+SIAGVjiIAIAJBf2qzIgEgACABXRtDAAAAACAAQwAAAABeGyIAQwAAAABgIgJBAXMNACAAuyIDRAAA4P///+9BZUUNACADqw8LQX9BACACGwthAAJAIAEgA3wiAyABVA0AAkAgAiAEaiICQYCU69wDSQRAIAMhAQwBCyADQgF8IgEgA1QNASACQYDslKN8aiECCyAAIAI2AgggACABNwMADwtB+MrCAEEoQaDLwgAQuAgAC2wBBH8jAEEQayIDJAAgA0EIaiAAIAEgAhCQCSADKAIMIQUgAygCCCEGQQxBBBDICiIERQRAQQxBBEGElMMAKAIAIgNBrQYgAxsRAAAACyAEIAU2AgggBCAGNgIEIARBADYCACADQRBqJAAgBAtsAQR/IwBBEGsiAyQAIANBCGogACABIAIQoQggAygCDCEFIAMoAgghBkEMQQQQyAoiBEUEQEEMQQRBhJTDACgCACIDQa0GIAMbEQAAAAsgBCAFNgIIIAQgBjYCBCAEQQA2AgAgA0EQaiQAIAQLbAEEfyMAQRBrIgMkACADQQhqIAAgASACEI8JIAMoAgwhBSADKAIIIQZBDEEEEMgKIgRFBEBBDEEEQYSUwwAoAgAiA0GtBiADGxEAAAALIAQgBTYCCCAEIAY2AgQgBEEANgIAIANBEGokACAEC1UAAkAgAUEQaigCACACSwRAIAEoAgggAkGoAmxqIgEoAgBBAUYNAQsgAEEANgIADwsgAEEQaiACNgIAIAAgAUEQajYCACAAQQhqIAFBCGopAwA3AwALVQACQCABQRBqKAIAIAJLBEAgASgCCCACQZgBbGoiASgCAEEBRg0BCyAAQQA2AgAPCyAAQRBqIAI2AgAgACABQRBqNgIAIABBCGogAUEIaikDADcDAAtLAQJ/AkAgAEEEaigCACIBRQ0AIAAoAgAiAkUNACABQQJ0RQ0AIAIQzAELAkAgAEE8aigCACIBRQ0AIABBQGsoAgBFDQAgARDMAQsLWwAgAEEANgIcIABBADYCvAEgACABKQIANwIgIABBKGogAUEIaikCADcCACAAQTBqIAFBEGopAgA3AgAgAEE4aiABQRhqKQIANwIAIABBQGsgAUEgaigCADYCAAtbAAJAIAEgA30iAyABVg0AAkAgAiAETwRAIAMhAQwBCyADQn98IgEgA1YNASACQYCU69wDaiECCyAAIAE3AwAgACACIARrNgIIDwtBrMrCAEEjQejKwgAQuAgAC1kBA38gACgCACICKAIYIgMoAgAhASADIAFBf2o2AgAgAUEBRgRAIAIoAhgQ0gcLAkAgACgCACIAQX9GDQAgACAAKAIEIgFBf2o2AgQgAUEBRw0AIAAQzAELC2oBBH8jAEEQayICJAAgAkEIaiAAIAEQtQggAigCDCEEIAIoAgghBUEMQQQQyAoiA0UEQEEMQQRBhJTDACgCACICQa0GIAIbEQAAAAsgAyAENgIIIAMgBTYCBCADQQA2AgAgAkEQaiQAIAMLagEEfyMAQRBrIgIkACACQQhqIAAgARChCSACKAIMIQQgAigCCCEFQQxBBBDICiIDRQRAQQxBBEGElMMAKAIAIgJBrQYgAhsRAAAACyADIAQ2AgggAyAFNgIEIANBADYCACACQRBqJAAgAwtaAQF8AkAgAEMAAAA/kiABlY0iACACsyIBIAAgAV0bQwAAAAAgAEMAAAAAXhsiAEMAAAAAYCICQQFzDQAgALsiA0QAAOD////vQWVFDQAgA6sPC0F/QQAgAhsLdAEBfwJAIAK8IAG8ckF/SgRAQRBBBBDICiIDRQ0BIAMgAjgCDCADIAE4AgggA0KBgICAEDcCACAAQfSFwgA2AgQgACADNgIADwtB9JHCAEHNAEGkk8IAEOcIAAtBEEEEQYSUwwAoAgAiAEGtBiAAGxEAAAALcQEBfyMAQfAAayICJAAgAkEIaiABELwBIAIgASoCYDgCaEHkAEEEEMgKIgFFBEBB5ABBBEGElMMAKAIAIgBBrQYgABsRAAAACyABIAJBCGpB5AAQogkhASAAQfiZwgA2AgQgACABNgIAIAJB8ABqJAALUAEBfwJAIAAoAhAiAUUNACABQQA6AAAgAEEUaigCAEUNACAAKAIQEMwBCwJAIABBf0YNACAAIAAoAgQiAUF/ajYCBCABQQFHDQAgABDMAQsLXQEBfyMAQTBrIgMkACADIAE2AgwgAyAANgIIIANBJGpBATYCACADQgE3AhQgA0HM78IANgIQIANB2wY2AiwgAyADQShqNgIgIAMgA0EIajYCKCADQRBqIAIQ4gkAC2gBBH8jAEEQayIBJAAgAUEIaiAAEMEJIAEoAgwhAyABKAIIIQRBDEEEEMgKIgJFBEBBDEEEQYSUwwAoAgAiAUGtBiABGxEAAAALIAIgAzYCCCACIAQ2AgQgAkEANgIAIAFBEGokACACC0YBAX0gAEHsAWotAAAEQCAAQQA6AOwBIAAgACgChAJBBHI2AoQCCyAALQCRAkUEQCAAQegBaiAAKgLkAYsiASABkjgCAAsLTgEDfSABKgIAIgIgApQgAUEIaioCACICIAKUkkMAAAAAkhCdASABKgIEIgMgACoCACIEjGBBAXNFQQAgAyAEXxtFBEBBAA8LIAAqAgRfC1UBAX8jAEEQayICJAAgAiABQczNwgBBCBDDCSACIAA2AgwgAiACQQxqIgFB6MHCABCCBSACIABBBGo2AgwgAiABQdTNwgAQggUgAhCBByACQRBqJAALZgECfyABKAIAIQIgAUEANgIAAkAgAgRAIAEoAgQhA0EIQQQQyAoiAUUNASABIAM2AgQgASACNgIAIABBtKbAADYCBCAAIAE2AgAPCwALQQhBBEGElMMAKAIAIgBBrQYgABsRAAAAC2YBAn8gASgCACECIAFBADYCAAJAIAIEQCABKAIEIQNBCEEEEMgKIgFFDQEgASADNgIEIAEgAjYCACAAQZDfwAA2AgQgACABNgIADwsAC0EIQQRBhJTDACgCACIAQa0GIAAbEQAAAAuDAQEBfyMAQRBrIgYkACABKAIAIAIoAgAgAygCACAEKAIAIAUoAgAQCiEBQbCNwwAoAgAhAkG0jcMAKAIAIQNBsI3DAEIANwIAIAZBCGoiBCADNgIEIAQgAkEBRjYCACAAIAYoAggiAkEARzYCACAAIAYoAgwgASACGzYCBCAGQRBqJAALZgECfyABKAIAIQIgAUEANgIAAkAgAgRAIAEoAgQhA0EIQQQQyAoiAUUNASABIAM2AgQgASACNgIAIABB0MXBADYCBCAAIAE2AgAPCwALQQhBBEGElMMAKAIAIgBBrQYgABsRAAAAC04BAX8jAEEQayICJAACQCAABEAgACgCAA0BIABBfzYCACACIAE2AgwgAEEEaiACQQxqENIDIABBADYCACACQRBqJAAPCxChCwALEKILAAtOAQF/IwBBEGsiAiQAAkAgAARAIAAoAgANASAAQX82AgAgAiABNgIMIABBBGogAkEMahDXBCAAQQA2AgAgAkEQaiQADwsQoQsACxCiCwALWgECfSABKgIAIgIgApQgAUEEaioCACICIAKUkhCdASECIAEqAggiA0MAAAAAYEUEQEGRyMEAQSZBoMvBABD/CQALIABBADYCCCAAQgA3AgAgACACIAOSOAIMC2YBAn8gASgCACECIAFBADYCAAJAIAIEQCABKAIEIQNBCEEEEMgKIgFFDQEgASADNgIEIAEgAjYCACAAQajNwgA2AgQgACABNgIADwsAC0EIQQRBhJTDACgCACIAQa0GIAAbEQAAAAtGAQF/AkAgACgCDCIBRQ0AIABBEGooAgBFDQAgARDMAQsCQCAAQX9GDQAgACAAKAIEIgFBf2o2AgQgAUEBRw0AIAAQzAELC18BAn8jAEHQAGsiACQAIABBCGoQkglByABBBBDICiIBRQRAQcgAQQRBhJTDACgCACIAQa0GIAAbEQAAAAsgAUEANgIAIAFBBGogAEEIakHEABCiCRogAEHQAGokACABC0YBAX8CQCAABEAgACgCACICQX9GDQEgACACQQFqNgIAIABBCGogARD1BSAAIAAoAgBBf2o2AgBB/wFxDwsQoQsACxCiCwALUQEBfyMAQSBrIgEkACABQRRqQQE2AgAgAUICNwIEIAFB2MvBADYCACABQQI2AhwgAUHoy8EANgIYIAEgAUEYajYCECAAIAEQ+AcgAUEgaiQAC04BAX1DAAAAACABKgIAIgMgA5QgAUEEaioCACIDIAOUkiABQQhqKgIAIgMgA5SSQwAAAACSEJ0BIAAqAgCTIgMgAhsgAyADQwAAAABdGwtkAQF/QRhBBBDICiICRQRAQRhBBEGElMMAKAIAIgBBrQYgABsRAAAACyACIAEpAgA3AgAgAkEQaiABQRBqKQIANwIAIAJBCGogAUEIaikCADcCACAAQaT3wQA2AgQgACACNgIAC1AAIAAgASoCFCAClDgCFCAAIAEqAhAgApQ4AhAgACABKgIMIAKUOAIMIAAgASoCCCAClDgCCCAAIAEqAgQgApQ4AgQgACABKgIAIAKUOAIAC2cBA30gAUEEaioCACECIAEqAgghAyABKgIAIQRBDEEEEMgKIgFFBEBBDEEEQYSUwwAoAgAiAEGtBiAAGxEAAAALIAEgAzgCCCABIAI4AgQgASAEOAIAIABBkJvCADYCBCAAIAE2AgALZwEDfSABQQRqKgIAIQIgASoCCCEDIAEqAgAhBEEMQQQQyAoiAUUEQEEMQQRBhJTDACgCACIAQa0GIAAbEQAAAAsgASADOAIIIAEgAjgCBCABIAQ4AgAgAEHAncIANgIEIAAgATYCAAt5AQJ/IwBBEGsiBCQAIAEoAgAgAigCACADKAIAEAkhAUGwjcMAKAIAIQJBtI3DACgCACEDQbCNwwBCADcCACAEQQhqIgUgAzYCBCAFIAJBAUY2AgAgACAEKAIIIgJBAEc2AgAgACAEKAIMIAEgAhs2AgQgBEEQaiQAC0sBAX0gACoCDCAAKgIAkyIBIAGUIABBEGoqAgAgACoCBJMiASABlJIgAEEUaioCACAAKgIIkyIBIAGUkkMAAAAAkhCdAUMAAAA/lAtKAQJ/IAAtAARBA0YEQCAAQQhqKAIAIgEoAgAgASgCBCgCABEEACABKAIEIgIoAgQEQCACKAIIGiABKAIAEMwBCyAAKAIIEMwBCwtKAAJ/IAFBgIDEAEcEQEEBIAAoAhggASAAQRxqKAIAKAIQEQIADQEaCyACRQRAQQAPCyAAKAIYIAIgAyAAQRxqKAIAKAIMEQYACwtJACAALQCRAkECRgRAIAAgASkCADcCLCAAQcQAaiABQRhqKAIANgIAIABBPGogAUEQaikCADcCACAAQTRqIAFBCGopAgA3AgALC0EBAX8CQCAAQRBqKAIAIAJNDQAgACgCCCACQZgBbGoiACgCAEEBRw0AIABBEGpBACAAQQhqKQMAIAFRGyEDCyADC0gBAX1DAAAAACAAKgIAIAEqAgCUIABBBGoqAgAgAUEEaioCAJSSIABBCGoqAgAgAUEIaioCAJSSIgMgAhsgAyADQwAAAABdGwtkAgF/AX0gASoCDCEDQRBBBBDICiICRQRAQRBBBEGElMMAKAIAIgBBrQYgABsRAAAACyACIAM4AgwgAiABKQIANwIAIAJBCGogAUEIaigCADYCACAAQeCYwgA2AgQgACACNgIAC0ABAX8CQCAABEAgACgCACIBQX9GDQEgACABQQFqNgIAIABBPGooAgAgACAAKAIAQX9qNgIADwsQoQsACxCiCwALQAEBfwJAIAAEQCAAKAIAIgFBf0YNASAAIAFBAWo2AgAgAEEkaigCACAAIAAoAgBBf2o2AgAPCxChCwALEKILAAtHACABIAIpAgA3AhAgAUEoaiACQRhqKAIANgIAIAFBIGogAkEQaikCADcCACABQRhqIAJBCGopAgA3AgAgACABQYgBEKIJGgtKACABIAIpAgA3AlggAUHwAGogAkEYaigCADYCACABQegAaiACQRBqKQIANwIAIAFB4ABqIAJBCGopAgA3AgAgACABQYABEKIJGgt0AQN/IwBBEGsiAyQAIAEoAgAgAigCABAFIQFBsI3DACgCACECQbSNwwAoAgAhBEGwjcMAQgA3AgAgA0EIaiIFIAQ2AgQgBSACQQFGNgIAIAAgAygCCCICQQBHNgIAIAAgAygCDCABIAIbNgIEIANBEGokAAtIAQF9IAAgAkEYaioCACADKgIIIAEqAgAiBJSSOAIIIAAgAkEUaioCACAEIAMqAgSUkjgCBCAAIAIqAhAgBCADKgIAlJI4AgALXAAgACABKAIIQf////8HcSACKAIIQYCAgIB4cXI2AgggACABKAIEQf////8HcSACKAIEQYCAgIB4cXI2AgQgACABKAIAQf////8HcSACKAIAQYCAgIB4cXI2AgALYQEBfyMAQeAAayICJAAgAiABELwBQeAAQQQQyAoiAUUEQEHgAEEEQYSUwwAoAgAiAEGtBiAAGxEAAAALIAEgAkHgABCiCSEBIABBoITCADYCBCAAIAE2AgAgAkHgAGokAAtZAQJ/IwBB0ABrIgAkACAAELAGQdQAQQQQyAoiAUUEQEHUAEEEQYSUwwAoAgAiAEGtBiAAGxEAAAALIAFBADYCACABQQRqIABB0AAQogkaIABB0ABqJAAgAQtZAQJ/IwBB0ABrIgAkACAAEI8HQdQAQQQQyAoiAUUEQEHUAEEEQYSUwwAoAgAiAEGt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QRBrIgEkACAAKAIMIgJFBEBB0MDCAEErQdDMwgAQ5wgACyAAKAIIIgNFBEBB0MDCAEErQeDMwgAQ5wgACyABIAI2AgggASAANgIEIAEgAzYCACABEOAJAAs1ACMAQSBrIgMkACADIAEgAhDaAiAAQQhqIANBCGopAwA3AgAgACADKQMANwIAIANBIGokAAs3AQF/IwBBEGsiAyQAIANBCGogAkEIaigCADYCACADIAIpAgA3AwAgACABIAMQygEgA0EQaiQACzcBAX8jAEEQayIDJAAgA0EIaiABQQhqKAIANgIAIAMgASkCADcDACACIAAgAxDKASADQRBqJAALUwEBf0EQQQQQyAoiA0UEQEEQQQRBhJTDACgCACIAQa0GIAAbEQAAAAsgAyACOAIMIAMgATgCCCADQoGAgIAQNwIAIABByIfCADYCBCAAIAM2AgALMwEBfyACBEAgACEDA0AgAyABLQAAOgAAIAFBAWohASADQQFqIQMgAkF/aiICDQALCyAACzwAIAAoAgAhACABLQAAQRBxQQR2BEAgACABEPAGDwsgAS0AAEEgcUEFdgRAIAAgARDxBg8LIAAgARCWCws8ACAAKAIAIQAgAS0AAEEQcUEEdgRAIAAgARDjBg8LIAEtAABBIHFBBXYEQCAAIAEQ5gYPCyAAIAEQqAkLQQAgACgCACEAIAEtAABBEHFBBHYEQCAAIAEQ5AYPCyABLQAAQSBxQQV2BEAgACABEOUGDwsgADEAAEEBIAEQ7gQLLQACQCAAQXxNBEAgAEUEQEEEIQAMAgsgACAAQX1JQQJ0EMgKIgANAQsACyAACzYAIAAgASkCADcCACAAIAIpAgA3AgwgAEEIaiABQQhqKAIANgIAIABBFGogAkEIaigCADYCAAsxAQF/IAAuAQAiAEF/SiECIACtQv//A4MgAEF/c61CMIZCMIdCAXwgAhsgAiABEO4EC0cBAX9BEEEEEMgKIgNFBEBBEEEEQYSUwwAoAgAiA0GtBiADGxEAAAALIAMgAjgCDCADIAE4AgggAyAAOAIEIANBADYCACADCyoBAn8QGSICEAwiAyAAIAEQEiACQSRPBEAgAhABCyADQSRPBEAgAxABCwssAQF/IwBBIGsiAyQAIANBCGogACABIAJBARDaASADKAIYIANBIGokAEEERwsrAQF/IwBBEGsiAyQAIANBCGogACABIAJBARB1IAMoAgggA0EQaiQAQQFGCywBAX8jAEEgayIDJAAgA0EIaiAAIAEgAkEBENsBIAMoAhggA0EgaiQAQQRHCywBAX8jAEEgayIDJAAgA0EIaiAAIAEgAkEBEOoBIAMoAhggA0EgaiQAQQRHCywBAX8jAEEgayIDJAAgA0EIaiAAIAEgAkEBEPYBIAMoAhggA0EgaiQAQQRHCywBAX8jAEEgayIDJAAgA0EIaiAAIAEgAkEBEPABIAMoAhggA0EgaiQAQQRHCywBAX8jAEEgayIDJAAgA0EIaiAAIAEgAkEBEMcBIAMoAhggA0EgaiQAQQRHCywBAX8jAEEgayIDJAAgA0EIaiAAIAEgAkEBEKkBIAMoAhggA0EgaiQAQQRHCysBAX8jAEEQayIDJAAgA0EIaiAAIAEgAkEBEGwgAygCCCADQRBqJABBAUYLLAEBfyMAQRBrIgMkACADQQhqIAAgASACQQEQhQEgAygCCCADQRBqJABBAUYLLAEBfyMAQSBrIgMkACADQQhqIAAgASACQQEQjAEgAygCGCADQSBqJABBBEcLLAEBfyMAQSBrIgMkACADQQhqIAAgASACQQEQwgEgAygCGCADQSBqJABBBEcLLAEBfyMAQSBrIgMkACADQQhqIAAgASACQQEQvgEgAygCGCADQSBqJABBBEcLLAEBfyMAQSBrIgMkACADQQhqIAAgASACQQEQ5gEgAygCGCADQSBqJABBBEcLMAECfSAAKgIMIAAqAgAiASAAKgIEIgIgASACXxsiASAAQQhqKgIAIgIgASACXxuSC0cBAX9BFEEEEMgKIgBFBEBBFEEEQYSUwwAoAgAiAEGtBiAAGxEAAAALIABCADcCACAAQYCAgPwDNgIQIABBCGpCADcCACAACykBAX8jAEEwayICJAAgAkEIaiAAIAFBARBCIAItABQgAkEwaiQAQQBHCzUAAkAgAkUNACAAQewBai0AAEUNACAAQQA6AOwBIAAgACgChAJBBHI2AoQCCyAAIAE4AuABCykBAX8jAEEwayICJAAgAkEIaiAAIAFBARBMIAItABQgAkEwaiQAQQBHC0gBAX0gASoCACECQQRBBBDICiIBRQRAQQRBBEGElMMAKAIAIgBBrQYgABsRAAAACyABIAI4AgAgAEG07MEANgIEIAAgATYCAAsyAQF9IAAgASoCACICIAKUIAFBBGoqAgAiAiAClJIQnQE4AgwgAEEANgIIIABCADcCAAtMAQJ9IAAqAgQgACoCABD8BCIBQwAAAABgRQRAQeCIwgBBKEHoicIAEOcIAAtD2w/JPyABkyICIAIgASABkiIBIAIgAV0bIAEgAVwbC0wBAX9BDEEEEMgKIgJFBEBBDEEEQYSUwwAoAgAiAEGtBiAAGxEAAAALIAIgATgCCCACQoGAgIAQNwIAIABBtOzBADYCBCAAIAI2AgALKwACQCAAIAEQswQiAUUNACABQXhqLQAEQQNxRQ0AIAFBACAAEOMJGgsgAQs0ACAAIAEoAhggAiADIAFBHGooAgAoAgwRBgA6AAggACABNgIAIAAgA0U6AAkgAEEANgIECysAAkAgAARAIAAoAgANASAAQQA2AgAgAEEMaiABOAIADwsQoQsACxCiCwALKwACQCAABEAgACgCAA0BIABBADYCACAAQRBqIAE4AgAPCxChCwALEKILAAsrAAJAIAAEQCAAKAIADQEgAEEANgIAIABBFGogATgCAA8LEKELAAsQogsACysAAkAgAARAIAAoAgANASAAQQA2AgAgAEEkaiABOAIADwsQoQsACxCiCwALKwACQCAABEAgACgCAA0BIABBADYCACAAQShqIAE4AgAPCxChCwALEKILAAsrAAJAIAAEQCAAKAIADQEgAEEANgIAIABBLGogATgCAA8LEKELAAsQogsACysAAkAgAARAIAAoAgANASAAQQA2AgAgAEEwaiABOAIADwsQoQsACxCiCwALKwACQCAABEAgACgCAA0BIABBADYCACAAQTRqIAE4AgAPCxChCwALEKILAAsrAAJAIAAEQCAAKAIADQEgAEEANgIAIABBOGogATYCAA8LEKELAAsQogsACysAAkAgAARAIAAoAgANASAAQQA2AgAgAEE8aiABNgIADwsQoQsACxCiCwALKwACQCAABEAgACgCAA0BIABBADYCACAAQUBrIAE2AgAPCxChCwALEKILAAssAAJAIAAEQCAAKAIADQEgAEEANgIAIABBxABqIAE2AgAPCxChCwALEKILAAsrAAJAIAAEQCAAKAIADQEgAEEANgIAIABBCGogATgCAA8LEKELAAsQogsACzUAIAEtAABBEHFBBHYEQCAAIAEQ8AYPCyABLQAAQSBxQQV2BEAgACABEPEGDwsgACABEJYLC0YAIwBBEGsiACQAIAAgAa1CgICAgBBCACABKAIYQZjCwgBBCyABQRxqKAIAKAIMEQYAG4Q3AwggAEEIahC4ByAAQRBqJAALNQEBfyMAQRBrIgIkACACIAE2AgwgAiAANgIIIAJBwL/CADYCBCACQZi/wgA2AgAgAhCdCQALLQEBfyMAQRBrIgEkACABQQhqIABBCGooAgA2AgAgASAAKQIANwMAIAEQ+QkACykBAX8CQCAAQX9GDQAgACAAKAIEIgFBf2o2AgQgAUEBRw0AIAAQzAELCyYAAkAgAARAIAAoAgANASAAQQA2AgAgABDMAQ8LEKELAAsQogsACy0BAX8jAEEQayIBJAAgAUEIaiAAQQhqKAIANgIAIAEgACkCADcDACABEPwJAAssAQF/IAAgAUEkaigCACICNgIEIAAgAUEgaigCACACKAIIQQdqQXhxajYCAAstAQF/IwBBEGsiASQAIAFBCGogAEEIaigCADYCACABIAApAgA3AwAgARD+CQALLAEBfyMAQRBrIgQkACAEIAApAgA3AwggBEEIaiABIAIgAxCQASAEQRBqJAALMAEBfSAAIAIqAgggASoCACIDlDgCCCAAIAMgAioCBJQ4AgQgACADIAIqAgCUOAIACyoBAn0gACoCACIBIAAqAgQiAiABIAJfGyIBIABBCGoqAgAiAiABIAJfGwsuACAAIAEpAlg3AgAgAEEQaiABQegAaikCADcCACAAQQhqIAFB4ABqKQIANwIACywAIAAgASkCADcCACAAQRBqIAFBEGopAgA3AgAgAEEIaiABQQhqKQIANwIACywAIAAgASkCIDcCACAAQRBqIAFBMGopAgA3AgAgAEEIaiABQShqKQIANwIACy0BAX8jAEEQayIBJAAgAUEIaiAAQQhqKAIANgIAIAEgACkCADcDACABEIUHAAstAQF/IwBBEGsiASQAIAFBCGogAEEIaigCADYCACABIAApAgA3AwAgARCKCgALNQEBfyMAQRBrIgIkACACIAE2AgwgAiAANgIIIAJB6O/CADYCBCACQbDXwgA2AgAgAhCdCQALKQEBfyACBEAgACEDA0AgAyABOgAAIANBAWohAyACQX9qIgINAAsLIAALJQACQCAABEAgACgCAEF/Rg0BIABBDGoqAgAPCxChCwALEKILAAslAAJAIAAEQCAAKAIAQX9GDQEgAEEQaioCAA8LEKELAAsQogsACyUAAkAgAARAIAAoAgBBf0YNASAAQRRqKgIADwsQoQsACxCiCwALJQACQCAABEAgACgCAEF/Rg0BIABBJGoqAgAPCxChCwALEKILAAslAAJAIAAEQCAAKAIAQX9GDQEgAEEoaioCAA8LEKELAAsQogsACyUAAkAgAARAIAAoAgBBf0YNASAAQSxqKgIADwsQoQsACxCiCwALJQACQCAABEAgACgCAEF/Rg0BIABBMGoqAgAPCxChCwALEKILAAslAAJAIAAEQCAAKAIAQX9GDQEgAEE0aioCAA8LEKELAAsQogsACyUAAkAgAARAIAAoAgBBf0YNASAAQThqKAIADwsQoQsACxCiCwALJQACQCAABEAgACgCAEF/Rg0BIABBPGooAgAPCxChCwALEKILAAslAAJAIAAEQCAAKAIAQX9GDQEgAEFAaygCAA8LEKELAAsQogsACyYAAkAgAARAIAAoAgBBf0YNASAAQcQAaigCAA8LEKELAAsQogsACygAAkAgAARAIAAoAgANASAAQQA2AgAgACABOAIEDwsQoQsACxCiCwALJQACQCAABEAgACgCAEF/Rg0BIABBJGotAAAPCxChCwALEKILAAslAAJAIAAEQCAAKAIAQX9GDQEgAEEYaioCAA8LEKELAAsQogsACyUAAkAgAARAIAAoAgBBf0YNASAAQQhqKgIADwsQoQsACxCiCwALPAEBf0EQQQQQyAoiAEUEQEEQQQRBhJTDACgCACIAQa0GIAAbEQAAAAsgAEIANwIAIABBCGpCADcCACAAC0UBAX9BCEEEEMgKIgFFBEBBCEEEQYSUwwAoAgAiAEGtBiAAGxEAAAALIAFCgYCAgBA3AgAgAEH4scAANgIEIAAgATYCAAslAQF/IwBBIGsiAiQAIAIgACABENoCIAItAAwgAkEgaiQAQQBHC1gBAX8gACgCACEBAkAgAC0ABA0AQZSUwwAoAgBFDQACf0GImMMAKAIAQQFGBEBBjJjDACgCAEUMAQtBiJjDAEIBNwMAQQELDQAgAUEBOgABCyABQQA6AAALJAEBfwJAIABBBGooAgAiAUUNACAAQQhqKAIARQ0AIAEQzAELCywBAX8jAEEQayIBJAAgASAAKQIANwMIIAFBCGpBnJfAAEEAIAAoAggQowYACygBAX8jAEEQayIDJAAgAyACNgIIIAMgATYCBCADIAA2AgAgAxDUCQALKAEBfyMAQRBrIgMkACADIAI2AgggAyABNgIEIAMgADYCACADENcJAAssAQF/IwBBEGsiASQAIAEgACkCADcDCCABQQhqQbi7wABBACAAKAIIEKMGAAsoACABIAI4AiwgAUE0aiAEOAIAIAFBMGogAzgCACAAIAFBiAEQogkaCywBAX8jAEEQayIBJAAgASAAKQIANwMIIAFBCGpBvLfBAEEAIAAoAggQowYACygBAX8jAEEQayIDJAAgAyACNgIIIAMgATYCBCADIAA2AgAgAxDZCQALKQEBfyAAKAIIIgIgAU0EQCABIAJB2KPCABDzBwALIAAoAgAgAUEMbGoLIwEBfyMAQRBrIgIkACACIAAgAUEBECkgAi0ADCACQRBqJAALIwEBfyMAQRBrIgIkACACIAAgAUEBECsgAi0ADCACQRBqJAALIwEBfyMAQRBrIgIkACACIAAgAUEBECogAi0ADCACQRBqJAALIwEBfyMAQRBrIgIkACACIAAgAUEBECwgAi0ADCACQRBqJAALIwEBfyMAQRBrIgIkACACIAAgAUEBECggAi0ADCACQRBqJAALIwEBfyMAQRBrIgIkACACIAAgAUEBEC0gAi0ADCACQRBqJAALJAEBfyMAQRBrIgIkACACIAAgAUEBELQCIAItAAwgAkEQaiQACygBAX8jAEEQayICJAAgAiAAKAIANgIMIAJBDGogARCfAyACQRBqJAALKAEBfyMAQRBrIgMkACADIAI2AgggAyABNgIEIAMgADYCACADEOEJAAssAQF/IwBBEGsiASQAIAEgACkCADcDCCABQQhqQbjNwgBBACAAKAIIEKMGAAsmAQF/IAAoAgAiAEF/SiECIACtIABBf3OsQgF8IAIbIAIgARDuBAsiAAJAIAAEQCAAKAIAQX9GDQEgACoCBA8LEKELAAsQogsACzoBAX9BEEEEEMgKIgBFBEBBEEEEQYSUwwAoAgAiAEGtBiAAGxEAAAALIABCgSI3AgQgAEEAOgAAIAALJwAgASACKQIANwI4IAFBQGsgAkEIaigCADYCACAAIAFBiAEQogkaCyAAAkAgAUF8Sw0AIAAgAUEEIAIQuAoiAEUNACAADwsACyEBAX8CQCAAKAIAIgFFDQAgAEEEaigCAEUNACABEMwBCwshAQF/AkAgACgCBCIBRQ0AIABBCGooAgBFDQAgARDMAQsLJQAgAEUEQEGQtMEAQTAQoAsACyAAIAIgAyAEIAUgASgCDBEaAAsgAQJ+IAApAwAiAkI/hyIDIAIgA3yFIAJCf1UgARDuBAsyAQF/QQRBBBDICiIARQRAQQRBBEGElMMAKAIAIgBBrQYgABsRAAAACyAAQQA2AgAgAAsjACAARQRAQZC0wQBBMBCgCwALIAAgAiADIAQgASgCDBEVAAsjACAARQRAQZC0wQBBMBCgCwALIAAgAiADIAQgASgCDBEhAAsjACAARQRAQZC0wQBBMBCgCwALIAAgAiADIAQgASgCDBEDAAsjACAARQRAQZC0wQBBMBCgCwALIAAgAiADIAQgASgCDBFfAAsnAEG4lMMAKAIAQQFHBEBBuJTDAEIBNwIAQcCUwwBBADYCAAsQ2AULIwAgAC0AAARAIAFB1PXCAEEEENcBDwsgAUHY9cIAQQUQ1wELIQAgAEUEQEGQtMEAQTAQoAsACyAAIAIgAyABKAIMEQEACx0AIAEoAgBFBEAACyAAQbSmwAA2AgQgACABNgIACx0AIAEoAgBFBEAACyAAQZDfwAA2AgQgACABNgIACx8AIABFBEBBkLTBAEEwEKALAAsgACACIAEoAgwRAgALGABBAUECIAAoAgAQFiIAQQFGG0EAIAAbCx0AIAEoAgBFBEAACyAAQdDFwQA2AgQgACABNgIACyAAIABB9PzBADYCBCAAIAE2AgAgAEEIaiABKgIYOAIACyAAIABBoPvBADYCBCAAIAE2AgAgAEEIaiABKgIMOAIACyAAIABByP7BADYCBCAAIAE2AgAgAEEIaiABKgIkOAIACyAAIABBqIfCADYCBCAAIAE2AgAgAEEIaiABKgIIOAIACyAAIABBlIrCADYCBCAAIAE2AgAgAEEIaiABKgIIOAIACyAAIABB1IXCADYCBCAAIAE2AgAgAEEIaiABKgJgOAIACxIAQbS3wgBBHEGwuMIAEOcIAAsSAEHg0sIAQRxBzNPCABDnCAALHQAgAEGg+8EANgIEIAAgATYCACAAQQhqQQA2AgALHQAgAEHI/sEANgIEIAAgATYCACAAQQhqQQA2AgALHQAgAEH0/MEANgIEIAAgATYCACAAQQhqQQA2AgALHQAgAEHUhcIANgIEIAAgATYCACAAQQhqQQA2AgALHQAgAEGoh8IANgIEIAAgATYCACAAQQhqQQA2AgALHQAgAEGUisIANgIEIAAgATYCACAAQQhqQQA2AgALNAAgAEL////3//////4ANwIIIABC////9/////9+NwIAIABBEGpC////9/f////+ADcCAAs0ACAAQv////f//////gA3AgggAEL////3/////343AgAgAEEQakL////39/////4ANwIACx0AIAEoAgBFBEAACyAAQajNwgA2AgQgACABNgIACxkAIAAoAgAiACgCACAAQQRqKAIAIAEQrAsLGgAgAEEANgIIIABCADcCACAAIAEqAgA4AgwLHAAgASgCGEGI78IAQQsgAUEcaigCACgCDBEGAAscACABKAIYQZPvwgBBDiABQRxqKAIAKAIMEQYACxwAIAEoAhhBsobDAEEFIAFBHGooAgAoAgwRBgALEwAgACgCACIAQSRPBEAgABABCwsNACAAIAEgAiADEPoBCxQAIAEgAjoAfCAAIAFBgAEQogkaCxQAIAEgAjoAfSAAIAFBgAEQogkaCwwAIAEEQCAAEMwBCwsUACAAIAEgAkEAEPQCIABCAjcCEAsTACAAIAEgAkEAEGQgAEEDNgIQCxQAIAAgASACQQAQtAIgAEEDNgIQCxQAIAAgASACQQAQkAIgAEEDNgIQCxMAIAAgASACQQAQKiAAQQM2AhALEwAgACABIAJBABAtIABBAzYCEAsTACAAIAEgAkEAECwgAEEDNgIQCxMAIAAgASACQQAQKCAAQQM2AhALEwAgACABIAJBABArIABBAzYCEAsUACAAIAEqAgAgAUEEaioCABDLAwsTACAAIAIgASgCACABKAIIEIcBCxQAIAAoAgAgASAAKAIEKAIMEQIACwkAIAAgARCzBAsJACAAIAEQwgkLEwAgAEHMu8AANgIEIAAgATYCAAsRACAAKAIAIAAoAgggARCsCwsWAEG0jcMAIAA2AgBBsI3DAEEBNgIACxMAIABB0LfBADYCBCAAIAE2AgALEwAgAEHgt8EANgIEIAAgATYCAAsTACAAQfC3wQA2AgQgACABNgIACxMAIABBgLjBADYCBCAAIAE2AgALEwAgAEGQuMEANgIEIAAgATYCAAsTACAAQaC4wQA2AgQgACABNgIACxMAIABBsLjBADYCBCAAIAE2AgALEwAgAEHAuMEANgIEIAAgATYCAAsTACAAQdC4wQA2AgQgACABNgIACxMAIABB4LjBADYCBCAAIAE2AgALEwAgAEHwuMEANgIEIAAgATYCAAsTACAAQYC5wQA2AgQgACABNgIACxMAIABBkLnBADYCBCAAIAE2AgALEwAgAEGgucEANgIEIAAgATYCAAsTACAAQbC5wQA2AgQgACABNgIACxMAIABBwLnBADYCBCAAIAE2AgALEwAgAEHQucEANgIEIAAgATYCAAsTACAAQeC5wQA2AgQgACABNgIACxMAIABB8LnBADYCBCAAIAE2AgALEwAgAEGAusEANgIEIAAgATYCAAsTACAAQZC6wQA2AgQgACABNgIACxMAIABBoLrBADYCBCAAIAE2AgALEwAgAEGwusEANgIEIAAgATYCAAsLACAArUIghkIDhAsLACAArUIghkIEhAsLACAArUIghkIChAsLACAArUIghkIBhAsTACAAQdD5wQA2AgQgACABNgIACxMAIABBhPvBADYCBCAAIAE2AgALEwAgAEHY/MEANgIEIAAgATYCAAsTACAAQaz+wQA2AgQgACABNgIACxMAIABB6P7BADYCBCAAIAE2AgALCwAgAK1CIIZCCYQLEwAgAEGcgMIANgIEIAAgATYCAAsLACAArUIghkIGhAsTACAAQciBwgA2AgQgACABNgIACwsAIACtQiCGQgWECxMAIABB9ILCADYCBCAAIAE2AgALCwAgAK1CIIZCCIQLCwAgAK1CIIZCCoQLEwAgAEG4hcIANgIEIAAgATYCAAsLACAArUIghkILhAsTACAAQYyHwgA2AgQgACABNgIACwsAIACtQiCGQgyECxMAIABB+InCADYCBCAAIAE2AgALGQAgAEKAgICA8P//v/8ANwIIIABCADcCAAsLACAArUIghkIHhAsLACAArUIghkINhAsTACAAQai2wgA2AgQgACABNgIACwsAIACtQiCGQg6ECxMAIABBxLbCADYCBCAAIAE2AgALCwAgAK1CIIZCD4QLEwAgAEHgtsIANgIEIAAgATYCAAsLACAArUIghkIQhAsTACAAQfy2wgA2AgQgACABNgIACwsAIACtQiCGQhGECxMAIABBmLfCADYCBCAAIAE2AgALEQAgACgCACAAKAIEIAEQ4QELHwAgASgCGCAAKAIAIAAoAgQgAUEcaigCACgCDBEGAAsRACAAKAIAIAAoAgQgARCsCwsTACAAQajNwgA2AgQgACABNgIACxEAIAEgACgCACAAKAIEENcBCwwAIAAgASACIAMQfQsMACAAIAEgAiADEEQLDAAgACABIAIgAxBHCwwAIAAgASACIAMQRQsNACAAIAEgAiADEKcBCw0AIAAgASACIAMQugELDQAgACABIAIgAxDJAQsNACAAKgIEIAAqAgiSCw4AIAAoAgAgARCtAkEACxIAQdzVwgBBEUHw1cIAEOcIAAsOACAAKAIAGgNADAALAAsOACAANQIAQQEgARDuBAsLACAAIAEgAhCgBQsOACAAKAIAIAEgAhCEBAsOACAAKQMAQQEgARDuBAsLACMAIABqJAAjAAscACABKAIYQYCAwABBDiABQRxqKAIAKAIMEQYACxwAIAEoAhhB9IPAAEERIAFBHGooAgAoAgwRBgALHAAgASgCGEHkp8AAQRQgAUEcaigCACgCDBEGAAsMACAAKAIAIAEQ9wcLDgAgAUHcu8AAQQIQ1wELCQAgACABEBgACw0AQdC2wQBBGxCgCwALDgBB67bBAEHPABCgCwALDAAgACgCACABEOgICwgAIACtQiCGCwsAIAAgASACELoCCwsAIAAgASACEOECCwsAIAAgASACEMwCCw0AIAAqAiRDAAAAAJILDAAgACgCACABEJoKCwwAIAAoAgAgARC4BAsOAEGwy8IAQRkgARDhAQsLACACIAAgARDXAQscACABKAIYQbi+wgBBBSABQRxqKAIAKAIMEQYACwcAIAEQyAgLCQAgAEEANgIACwkAIABBADYCAAsJACAAQQA2AgALBwAgAEEMagsHACAAELAECwcAIAAqAgALBwAgACoCGAsHACAAKgIECxIAQajQwgBBJUH80MIAEIkKAAsNAEL0+Z7m7qOq+f4ACw0AQvqAkuzjxN324gALBAAgAAsEAEEACwQAQQALDQBC+fCW3cPU1pvbAAsMAEKaqa6atvve70ALDQBCroil3oaCtpqwfwsMAELlu9CQsJiuwHELDQBCy9fW7pqO+LO3fwsMAELn0OHj4NPFpXwLDQBC9oPNjbCSpO7LAAsNAEK1v6fng/jbo4p/Cw0AQrHIndS7geTEzgALDQBCt+bfxo2y39GCfwsNAEKY7qyP6ZvE96Z/CwwAQrX5+buGn6S4JgsMAEK32MWDg4LuphkLDQBCguLTzMia3piCfwsMAEK23J3o7oy2p0ALDABC9oClhsXjh9ceCw0AQueLh7/jjOCQk38LDABCibDD6Lu84s4RCwwAQvHV4ty7/aWddQsNAEKNlYLfnOjIyaB/Cw0AQuKqjrOxrOvjjn8LDABCy4KizvvG0NxHCwQAQQALBwBD2w9JQAsEAEEBCwQAQQILBwBD2w/JPwsEAEEECwcAQwAAAAALBABBAwsEAEEJCwQAQQYLBABBBQsHAEPbD0k/CwQAQQgLBABBCgsEAEELCwQAQQwLBwBD//9/fwsEAEEHCwQAQQ0LBABBDgsEAEEPCwQAQRALBABBEQsNAELjjv609aqAt4R/CwwAQvGx4Ymc2oubEgsDAAELAwABCwuPjQMIAEGAgMAAC4O7AmEgbWF0cml4IGFycmF5AAAGAAAAAAAAAAEAAAAHAAAABgAAAAAAAAABAAAABwAAAAYAAAAAAAAAAQAAAAcAAAAGAAAAAAAAAAEAAAAHAAAABgAAAAAAAAABAAAABwAAAAYAAAAAAAAAAQAAAAcAAAAGAAAAAAAAAAEAAAAHAAAABgAAAAAAAAABAAAABwAAAE5vIGVsZW1lbnQgYXQgaW5kZXgvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvbmFsZ2VicmEtMC4yNS40L3NyYy9iYXNlL2RlZmF1bHRfYWxsb2NhdG9yLnJzQ2Fubm90IGRlc2VyaWFsaXplIGN1c3RvbSBzaGFwZS4GAAAAAAAAAAEAAAAIAAAABgAAAAAAAAABAAAACQAAAEFsbG9jYXRpb24gZnJvbSBpdGVyYXRvciBlcnJvcjogdGhlIGl0ZXJhdG9yIGRpZCBub3QgeWllbGQgdGhlIGNvcnJlY3QgbnVtYmVyIG9mIGVsZW1lbnRzLgAAowAQAG0AAABmAAAACQAAAHN0cnVjdCBCaXRWZWMgd2l0aCAyIGVsZW1lbnRzAAAAvAEQAB0AAAAGAAAACAAAAAQAAAAKAAAAYSB0dXBsZSBvZiBzaXplIDIAAAAGAAAAAAAAAAEAAAALAAAAc3RydWN0IFRyaU1lc2ggd2l0aCAzIGVsZW1lbnRzAAAYAhAAHgAAAHN0cnVjdCBDb21wb3VuZCB3aXRoIDQgZWxlbWVudHMAQAIQAB8AAABzdHJ1Y3QgUG9seWxpbmUgd2l0aCAzIGVsZW1lbnRzAGgCEAAfAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2Nyb3NzYmVhbS1jaGFubmVsLTAuNS4wL3NyYy93YWtlci5yc5ACEABkAAAAVgAAABQAAACQAhAAZAAAAF0AAAAZAAAAkAIQAGQAAABfAAAAGQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9jcm9zc2JlYW0tY2hhbm5lbC0wLjUuMC9zcmMvZmxhdm9ycy96ZXJvLnJzACQDEABrAAAArAAAADYAAAAkAxAAawAAALMAAAA2AAAAdmFyaWFudCBpbmRleCAwIDw9IGkgPCAysAMQABgAAABzdHJ1Y3QgRWRnZSB3aXRoIDMgZWxlbWVudHMA0AMQABsAAABzdHJ1Y3QgQ29sbGlkZXIgd2l0aCAxNCBlbGVtZW50c/QDEAAgAAAAc3RydWN0IEFyZW5hIHdpdGggNCBlbGVtZW50cxwEEAAcAAAAc3RydWN0IEhlaWdodEZpZWxkIHdpdGggNSBlbGVtZW50cwAAQAQQACIAAABzdHJ1Y3QgUHViU3ViIHdpdGggNSBlbGVtZW50cwAAAGwEEAAdAAAAc3RydWN0IEpvaW50IHdpdGggNCBlbGVtZW50c5QEEAAcAAAAc3RydWN0IFJpZ2lkQm9keSB3aXRoIDI3IGVsZW1lbnRzAAAAuAQQACEAAABzdHJ1Y3QgRWRnZSB3aXRoIDQgZWxlbWVudHMA5AQQABsAAAB2YXJpYW50IGluZGV4IDAgPD0gaSA8IDE5AAAACAUQABkAAABzdHJ1Y3QgQ29hcmVuYSB3aXRoIDEgZWxlbWVudAAAACwFEAAdAAAAc3RydWN0IEdyYXBoIHdpdGggMiBlbGVtZW50c1QFEAAcAAAAdmFyaWFudCBpbmRleCAwIDw9IGkgPCAzeAUQABgAAABzdHJ1Y3QgQ29sbGlkZXJTZXQgd2l0aCA0IGVsZW1lbnRzAACYBRAAIgAAAHN0cnVjdCBDb250YWN0RGF0YSB3aXRoIDMgZWxlbWVudHMAAMQFEAAiAAAAc3RydWN0IENvbnRhY3RQYWlyIHdpdGggNCBlbGVtZW50cwAA8AUQACIAAABzdHJ1Y3QgU29sdmVyQ29udGFjdCB3aXRoIDkgZWxlbWVudHMcBhAAJAAAAHZhcmlhbnQgaW5kZXggMCA8PSBpIDwgNEgGEAAYAAAAc3RydWN0IFJpZ2lkQm9keVNldCB3aXRoIDggZWxlbWVudHMAaAYQACMAAABzdHJ1Y3QgQ29udmV4UG9seWhlZHJvbiB3aXRoIDggZWxlbWVudHMAlAYQACcAAABzdHJ1Y3QgUm91bmRTaGFwZSB3aXRoIDIgZWxlbWVudHMAAADEBhAAIQAAAHN0cnVjdCBCYWxsSm9pbnQgd2l0aCAxMCBlbGVtZW50cwAAAPAGEAAhAAAAc3RydWN0IENvbnRhY3RNYW5pZm9sZERhdGEgd2l0aCA3IGVsZW1lbnRzAAAcBxAAKgAAAHN0cnVjdCBTaW1kUXVhZFRyZWUgd2l0aCA0IGVsZW1lbnRzAFAHEAAjAAAAc3RydWN0IFJldm9sdXRlSm9pbnQgd2l0aCAxNyBlbGVtZW50cwAAAHwHEAAlAAAAc3RydWN0IE1hc3NQcm9wZXJ0aWVzIHdpdGggNCBlbGVtZW50cwAAAKwHEAAlAAAAc3RydWN0IFZlY1N0b3JhZ2Ugd2l0aCAzIGVsZW1lbnRzAAAA3AcQACEAAABzdHJ1Y3QgSXNvbWV0cnkgd2l0aCAyIGVsZW1lbnRzAAgIEAAfAAAAc3RydWN0IFByaXNtYXRpY0pvaW50IHdpdGggMTcgZWxlbWVudHMAADAIEAAmAAAAc3RydWN0IFNBUEF4aXMgd2l0aCAzIGVsZW1lbnRzAABgCBAAHgAAAHN0cnVjdCBTQVBMYXllciB3aXRoIDYgZWxlbWVudHMAiAgQAB8AAABzdHJ1Y3QgU0FQUHJveGllcyB3aXRoIDIgZWxlbWVudHMAAACwCBAAIQAAAHN0cnVjdCBTQVBSZWdpb24gd2l0aCA3IGVsZW1lbnRz3AgQACAAAABzdHJ1Y3QgSW50ZXJhY3Rpb25HcmFwaCB3aXRoIDEgZWxlbWVudAAABAkQACYAAABzdHJ1Y3QgQnJvYWRQaGFzZSB3aXRoIDcgZWxlbWVudHMAAAA0CRAAIQAAAHN0cnVjdCB2YXJpYW50IEVudHJ5OjpGcmVlIHdpdGggMSBlbGVtZW50AAAAYAkQACkAAABzdHJ1Y3QgdmFyaWFudCBFbnRyeTo6T2NjdXBpZWQgd2l0aCAyIGVsZW1lbnRzAACUCRAALgAAAHZhcmlhbnQgaW5kZXggMCA8PSBpIDwgNswJEAAYAAAAc3RydWN0IFRyaU1lc2hTaGFwZUNvbnRhY3RNYW5pZm9sZHNXb3Jrc3BhY2Ugd2l0aCAzIGVsZW1lbnRz7AkQADwAAABzdHJ1Y3QgSGVpZ2h0RmllbGRTaGFwZUNvbnRhY3RNYW5pZm9sZHNXb3Jrc3BhY2Ugd2l0aCAyIGVsZW1lbnRzMAoQAEAAAABzdHJ1Y3QgQ29udGFjdE1hbmlmb2xkIHdpdGggOCBlbGVtZW50cwAAeAoQACYAAABzdHJ1Y3QgQ29tcG9zaXRlU2hhcGVTaGFwZUNvbnRhY3RNYW5pZm9sZHNXb3Jrc3BhY2Ugd2l0aCAyIGVsZW1lbnRzAKgKEABDAAAAc3RydWN0IEhlaWdodEZpZWxkQ29tcG9zaXRlU2hhcGVDb250YWN0TWFuaWZvbGRzV29ya3NwYWNlIHdpdGggMiBlbGVtZW50cwAAAPQKEABJAAAAc3RydWN0IENvbXBvc2l0ZVNoYXBlQ29tcG9zaXRlU2hhcGVDb250YWN0TWFuaWZvbGRzV29ya3NwYWNlIHdpdGggMiBlbGVtZW50c0gLEABMAAAABgAAAAgAAAAEAAAADAAAAA0AAACwCxAAAAAAAGEgRGlzcGxheSBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB1bmV4cGVjdGVkbHkvaG9tZS9zZWJjcm96ZXQvLnJ1c3R1cC90b29sY2hhaW5zL25pZ2h0bHkteDg2XzY0LXVua25vd24tbGludXgtZ251L2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwDvCxAAdAAAAOYIAAAOAAAABgAAAAQAAAAEAAAADgAAAA8AAAAQAAAAYXNzZXJ0aW9uIGZhaWxlZDogbWlkIDw9IHNlbGYubGVuKCkvaG9tZS9zZWJjcm96ZXQvLnJ1c3R1cC90b29sY2hhaW5zL25pZ2h0bHkteDg2XzY0LXVua25vd24tbGludXgtZ251L2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvY29yZS9zcmMvc2xpY2UvbW9kLnJzAAAArwwQAHYAAAD/BQAACQAAAGNhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWUABgAAAAAAAAABAAAAEQAAAGNhcGFjaXR5IG92ZXJmbG93L2hvbWUvc2ViY3JvemV0Ly5ydXN0dXAvdG9vbGNoYWlucy9uaWdodGx5LXg4Nl82NC11bmtub3duLWxpbnV4LWdudS9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9jb2xsZWN0aW9ucy92ZWNfZGVxdWUvbW9kLnJzhQ0QAIcAAADeAQAACQAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuY2FwKCkgPT0gb2xkX2NhcCAqIDIAhQ0QAIcAAAAtCAAADQAAAAQAAAAAAAAACAAAAAAAAAABAAAAAAAAAGludmFsaWQgdmFsdWU6ICwgZXhwZWN0ZWQgAABwDhAADwAAAH8OEAALAAAAaW52YWxpZCBsZW5ndGggAJwOEAAPAAAAfw4QAAsAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjMuMC9zcmMvcGFydGl0aW9uaW5nL3dxdWFkdHJlZS5ycwC8DhAAawAAAKEBAAAYAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2luZGV4bWFwLTEuNi4yL3NyYy9tYXAvY29yZS5ycwAAOA8QAF4AAAAqAAAAIwAAADgPEABeAAAA7gAAAC4AAAA4DxAAXgAAACIAAAAPAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL25hbGdlYnJhLTAuMjUuNC9zcmMvYmFzZS9jb25zdHJ1Y3Rpb24ucnNNYXRyaXggaW5pdC4gZXJyb3I6IHRoZSBzbGljZSBkaWQgbm90IGNvbnRhaW4gdGhlIHJpZ2h0IG51bWJlciBvZiBlbGVtZW50cy4AyA8QAGgAAABmAAAACQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjcuMi9zcmMvZGF0YS9hcmVuYS5yc4wQEABgAAAABwEAAB4AAABjb3JydXB0IGZyZWUgbGlzdAAAAIwQEABgAAAACAEAACsAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC43LjIvc3JjL2RhdGEvZ3JhcGgucnMgERAAYAAAAJIAAAAYAAAAYXNzZXJ0aW9uIGZhaWxlZDogc2VsZi5lZGdlcy5sZW4oKSAhPSBjcmF0ZTo6SU5WQUxJRF9VU0laRQAAIBEQAGAAAADcAAAACQAAAEdyYXBoOjphZGRfZWRnZTogbm9kZSBpbmRpY2VzIG91dCBvZiBib3VuZHMAIBEQAGAAAADkAAAAGwAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYubm9kZXMubGVuKCkgIT0gY3JhdGU6OklOVkFMSURfVVNJWkUAACAREABgAAAAswAAAAkAAABBdHRlbXB0IHRvIGF0dGFjaCBhIGpvaW50IHRvIGEgbm9uLWV4aXN0aW5nIGJvZHkuL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuNy4yL3NyYy9keW5hbWljcy9qb2ludC9qb2ludF9zZXQucnMAlRIQAG4AAAC2AAAAEQAAAJUSEABuAAAAtwAAABEAAACVEhAAbgAAAMoAAAAJAAAABgAAAAgAAAAEAAAAEgAAAC9ob21lL3NlYmNyb3pldC8ucnVzdHVwL3Rvb2xjaGFpbnMvbmlnaHRseS14ODZfNjQtdW5rbm93bi1saW51eC1nbnUvbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9hbGxvYy9zcmMvY29sbGVjdGlvbnMvdmVjX2RlcXVlL3Jpbmdfc2xpY2VzLnJzAEQTEACPAAAAIAAAAA4AAABhbiBhcnJheSBvZiBsZW5ndGggMwYAAAAAAAAAAQAAABMAAABJbnZhbGlkIEpvaW50IHJlZmVyZW5jZS4gSXQgbWF5IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBoeXNpY3MgV29ybGQucmFwaWVyM2QvLi4vc3JjL2R5bmFtaWNzL2pvaW50X3NldC5ycwAAURQQACUAAAANAAAADgAAAEludmFsaWQgUmlnaWRCb2R5IHJlZmVyZW5jZS4gSXQgbWF5IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBoeXNpY3MgV29ybGQucmFwaWVyM2QvLi4vc3JjL2R5bmFtaWNzL3JpZ2lkX2JvZHlfc2V0LnJzANUUEAAqAAAAJwAAADgAAADVFBAAKgAAAC4AAAA8AAAASW52YWxpZCBDb2xsaWRlciByZWZlcmVuY2UuIEl0IG1heSBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwaHlzaWNzIFdvcmxkLnJhcGllcjNkLy4uL3NyYy9nZW9tZXRyeS9jb2xsaWRlcl9zZXQucnNsFRAAKAAAABEAAAAOAAAAMC41LjMAAABRFBAAJQAAACEAAAA5AAAAURQQACUAAAAiAAAAOQAAAHJhcGllcjNkLy4uL3NyYy9keW5hbWljcy9yaWdpZF9ib2R5LnJzAADMFRAAJgAAABYBAAAfAAAAaW52YWxpZCBlbnVtIHZhbHVlIHBhc3NlZE5vdCB5ZXQgaW1wbGVtZW50ZWQucmFwaWVyM2QvLi4vc3JjL2dlb21ldHJ5L2NvbGxpZGVyLnJzAAAAMRYQACQAAAA2AAAAOQAAAHJhcGllcjNkLy4uL3NyYy9nZW9tZXRyeS9zaGFwZS5ycwAAAGgWEAAhAAAAbwAAADoAAABoFhAAIQAAAG8AAABAAAAAaBYQACEAAAB5AAAAOAAAAGgWEAAhAAAAeQAAAD4AAABoFhAAIQAAALgAAABAAAAAaBYQACEAAAC4AAAARgAAAGgWEAAhAAAAwwAAAEAAAABoFhAAIQAAAMMAAABGAAAABgAAAAAAAAABAAAAFAAAABUAAAAWAAAAFwAAAAYAAAAAAAAAAQAAABgAAAAYAAAAGQAAABAAAAAEAAAAGgAAABsAAABzdHJ1Y3QgRGVzZXJpYWxpemFibGVXb3JsZCB3aXRoIDcgZWxlbWVudHMAAFAXEAAqAAAASW52YWxpZCBzaXplIDogc2l6ZXMgbXVzdCBmaXQgaW4gYSB1c2l6ZSAoMCB0byAphBcQAA0AAACRFxAAIgAAALMXEAABAAAA/////091dCBvZiBib3VuZHMgYWNjZXNzVGhlIGxvb3NlbmluZyBtYXJnaW4gbXVzdCBiZSBwb3NpdGl2ZS4vaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjMuMC9zcmMvYm91bmRpbmdfdm9sdW1lL2FhYmIucnMAChgQAGkAAAAhAQAACQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuMy4wL3NyYy9xdWVyeS9kZWZhdWx0X3F1ZXJ5X2Rpc3BhdGNoZXIucnMAHgAAAAAAAAABAAAAHwAAACAAAAAhAAAAIgAAACMAAAAkAAAAJQAAAAAAAAAmAAAAhBgQAHMAAAC5AQAAMQAAAIQYEABzAAAApgEAADEAAACEGBAAcwAAABACAAAvAAAAhBgQAHMAAAAfAgAALwAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9jcm9zc2JlYW0tY2hhbm5lbC0wLjUuMC9zcmMvd2FrZXIucnNoGRAAZAAAAFYAAAAUAAAAaBkQAGQAAABdAAAAGQAAAGgZEABkAAAAXwAAABkAAABpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2Nyb3NzYmVhbS1jaGFubmVsLTAuNS4wL3NyYy9jaGFubmVsLnJzAAAkGhAAZgAAALIBAAAtAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2Nyb3NzYmVhbS1jaGFubmVsLTAuNS4wL3NyYy9jb250ZXh0LnJzAACcGhAAZgAAADEAAAAeAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2Nyb3NzYmVhbS1jaGFubmVsLTAuNS4wL3NyYy9mbGF2b3JzL2xpc3QucnMAFBsQAGsAAAADAQAAQwAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9jcm9zc2JlYW0tY2hhbm5lbC0wLjUuMC9zcmMvZmxhdm9ycy96ZXJvLnJzAJAbEABrAAAA1wAAAC0AAACQGxAAawAAAPUAAABAAAAAkBsQAGsAAAD2AAAARwAAAJAbEABrAAAA8AAAAEAAAACQGxAAawAAAPEAAABHAAAAkBsQAGsAAADuAAAAJgAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9jcm9zc2JlYW0tY2hhbm5lbC0wLjUuMC9zcmMvZmxhdm9ycy9hcnJheS5yc1wcEABsAAAAgQEAADcAAABcHBAAbAAAAH8BAAAqAAAAY2Fubm90IGFjY2VzcyBhIFRocmVhZCBMb2NhbCBTdG9yYWdlIHZhbHVlIGR1cmluZyBvciBhZnRlciBkZXN0cnVjdGlvbi9ob21lL3NlYmNyb3pldC8ucnVzdHVwL3Rvb2xjaGFpbnMvbmlnaHRseS14ODZfNjQtdW5rbm93bi1saW51eC1nbnUvbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9zdGQvc3JjL3RocmVhZC9sb2NhbC5ycwAALh0QAHgAAAD4AAAAGgAAAB4AAAAIAAAABAAAACcAAAAoAAAAHgAAACQAAAAEAAAAKQAAACgpAAAeAAAABAAAAAQAAAAqAAAAYXNzZXJ0aW9uIGZhaWxlZDogbWlkIDw9IHNlbGYubGVuKCkvaG9tZS9zZWJjcm96ZXQvLnJ1c3R1cC90b29sY2hhaW5zL25pZ2h0bHkteDg2XzY0LXVua25vd24tbGludXgtZ251L2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvY29yZS9zcmMvc2xpY2UvbW9kLnJzAAAAEx4QAHYAAAD/BQAACQAAABMeEAB2AAAANQIAACQAAAAAAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZQAeAAAAAAAAAAEAAAArAAAAHgAAAAAAAAABAAAALAAAAB4AAAAEAAAABAAAAC0AAAAeAAAABAAAAAQAAAAuAAAAHgAAAAQAAAAEAAAALwAAAGNhcGFjaXR5IG92ZXJmbG93L2hvbWUvc2ViY3JvemV0Ly5ydXN0dXAvdG9vbGNoYWlucy9uaWdodGx5LXg4Nl82NC11bmtub3duLWxpbnV4LWdudS9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9jb2xsZWN0aW9ucy92ZWNfZGVxdWUvbW9kLnJzYXNzZXJ0aW9uIGZhaWxlZDogc2VsZi5jYXAoKSA9PSBvbGRfY2FwICogMgA9HxAAhwAAAC0IAAANAAAABAAAAAAAAAAIAAAAAAAAABAAAAAAAAAAL2hvbWUvc2ViY3JvemV0Ly5ydXN0dXAvdG9vbGNoYWlucy9uaWdodGx5LXg4Nl82NC11bmtub3duLWxpbnV4LWdudS9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwAYIBAAcwAAADYEAAAVAAAAGCAQAHMAAABEBAAAHgAAABggEABzAAAATQQAABgAAAAYIBAAcwAAAE4EAAAZAAAAGCAQAHMAAABRBAAAGgAAAP8vaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvYml0LXZlYy0wLjYuMy9zcmMvbGliLnJzAAAA3SAQAFgAAADAAQAAGAAAAGluZGV4IG91dCBvZiBib3VuZHM6ICA+PSAAAABIIRAAFQAAAF0hEAAEAAAA3SAQAFgAAAAbAgAACQAAAN0gEABYAAAAHwIAABoAAADdIBAAWAAAACACAAAaAAAA3SAQAFgAAAD5BAAAMwAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuMy4wL3NyYy9wYXJ0aXRpb25pbmcvd3F1YWR0cmVlLnJzALQhEABrAAAAyAAAABcAAAC0IRAAawAAAMkAAAAZAAAAtCEQAGsAAAB5AQAAGAAAALQhEABrAAAABgEAACAAAAC0IRAAawAAAAcBAAARAAAAtCEQAGsAAAAJAQAAEQAAALQhEABrAAAAJQEAABoAAAC0IRAAawAAAGEBAAAJAAAAtCEQAGsAAABiAQAACQAAALQhEABrAAAAYwEAAAkAAAC0IRAAawAAAKoAAAANAAAAtCEQAGsAAACrAAAADQAAALQhEABrAAAAvAAAAAkAAAC0IRAAawAAANsBAAAYAAAAtCEQAGsAAAChAQAAGAAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuMy4wL3NyYy9xdWVyeS9jb250YWN0X21hbmlmb2xkcy9jb250YWN0X21hbmlmb2xkc19oYWxmc3BhY2VfcGZtLnJzECMQAIwAAABAAAAAFAAAAEZvdW5kIGNvbnRhY3RzOiAKAAAArCMQABAAAAC8IxAAAQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuMy4wL3NyYy9xdWVyeS9jb250YWN0X21hbmlmb2xkcy9jb250YWN0X21hbmlmb2xkc190cmltZXNoX3NoYXBlLnJz0CMQAIwAAABaAAAAHAAAANAjEACMAAAAWgAAADYAAADQIxAAjAAAAKkAAAApAAAA0CMQAIwAAACvAAAAHQAAAB4AAAAkAAAABAAAADAAAAAxAAAAMgAAADMAAAA0AAAANQAAADYAAAA3AAAAOAAAADkAAAA6AAAAOwAAADwAAAA9AAAAPgAAAD8AAABAAAAAPwAAAEEAAABCAAAAKQAAAEMAAABEAAAARQAAAEYAAABHAAAASAAAAEkAAABKAAAASwAAAEwAAABNAAAATgAAAE8AAABQAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC4zLjAvc3JjL3F1ZXJ5L2NvbnRhY3RfbWFuaWZvbGRzL2NvbnRhY3RfbWFuaWZvbGRzX2hlaWdodGZpZWxkX3NoYXBlLnJzNCUQAJAAAABrAAAAHAAAADQlEACQAAAAawAAADYAAAA0JRAAkAAAAH8AAAAgAAAANCUQAJAAAACWAAAAHQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuMy4wL3NyYy9xdWVyeS9jb250YWN0X21hbmlmb2xkcy9jb250YWN0X21hbmlmb2xkc19jb21wb3NpdGVfc2hhcGVfc2hhcGUucnMEJhAAlAAAAEUAAAAcAAAABCYQAJQAAABFAAAANgAAAB4AAAAsAAAABAAAAFEAAABSAAAABCYQAJQAAABZAAAAJAAAAAQmEACUAAAAdgAAACEAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjMuMC9zcmMvcXVlcnkvY29udGFjdF9tYW5pZm9sZHMvY29udGFjdF9tYW5pZm9sZHNfaGVpZ2h0ZmllbGRfY29tcG9zaXRlX3NoYXBlLnJzAADsJhAAmgAAAEgAAAAcAAAA7CYQAJoAAABIAAAANgAAAB4AAAAwAAAABAAAAFMAAABUAAAA7CYQAJoAAABjAAAAKAAAAOwmEACaAAAAgAAAACUAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjMuMC9zcmMvcXVlcnkvY29udGFjdF9tYW5pZm9sZHMvY29udGFjdF9tYW5pZm9sZHNfY29tcG9zaXRlX3NoYXBlX2NvbXBvc2l0ZV9zaGFwZS5ycwAA3CcQAJ4AAABEAAAAHAAAANwnEACeAAAARAAAADYAAAAeAAAAMAAAAAQAAABVAAAAVgAAAB4AAAAwAAAABAAAAFcAAABYAAAA3CcQAJ4AAAByAAAALAAAANwnEACeAAAAkQAAACkAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjMuMC9zcmMvcXVlcnkvZXBhL2VwYTMucnMA5CgQAGMAAAAoAQAAGwAAAOQoEABjAAAA9wAAABcAAADkKBAAYwAAAPgAAAAXAAAA5CgQAGMAAAD5AAAAFwAAAOQoEABjAAAAFAEAAB0AAADkKBAAYwAAABQBAAA3AAAA5CgQAGMAAAAZAQAAHQAAAOQoEABjAAAAGQEAADcAAADkKBAAYwAAAB4BAAAdAAAA5CgQAGMAAAAeAQAANwAAAOQoEABjAAAAIwEAAB0AAADkKBAAYwAAACMBAAA3AAAA5CgQAGMAAABEAQAAMgAAAOQoEABjAAAAqgEAABoAAADkKBAAYwAAAEsBAAAYAAAA5CgQAGMAAABfAQAAIgAAAOQoEABjAAAAZAEAAA0AAADkKBAAYwAAAGYBAAAiAAAA5CgQAGMAAABnAQAAIgAAAOQoEABjAAAAaAEAACIAAADkKBAAYwAAAHYBAAAVAAAA5CgQAGMAAACKAQAAMAAAAOQoEABjAAAAigEAACIAAADkKBAAYwAAAJ4BAAANAAAA5CgQAGMAAACfAQAAIwAAAGFzc2VydGlvbiBmYWlsZWQ6IG1pbl9ib3VuZCA9PSBtaW5fYm91bmQvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjMuMC9zcmMvcXVlcnkvZ2prL2dqay5ycwAAACsQAGIAAACMAAAACQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuMy4wL3NyYy9zaGFwZS9oZWlnaHRmaWVsZDMucnMAdCsQAGcAAACGAQAAHgAAAHQrEABnAAAAkgEAABsAAAB0KxAAZwAAAJMBAAAbAAAAdCsQAGcAAACUAQAAGwAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuMy4wL3NyYy9zaGFwZS9wb2x5Z29uYWxfZmVhdHVyZTNkLnJzAAAcLBAAbgAAABYBAAAeAAAAHCwQAG4AAAAYAQAAOgAAABwsEABuAAAAGwEAACkAAAAcLBAAbgAAAEIBAAAeAAAAHCwQAG4AAABEAQAAOgAAABwsEABuAAAARwEAACkAAAAcLBAAbgAAAGsBAAARAAAAHCwQAG4AAABsAQAAEQAAABwsEABuAAAAcQEAABUAAAAcLBAAbgAAAHIBAAAVAAAAaW5kZXggb3V0IG9mIGJvdW5kcy9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9pbmRleG1hcC0xLjYuMi9zcmMvbWFwLnJzPy0QAFkAAACGAQAAGgAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9pbmRleG1hcC0xLjYuMi9zcmMvbWFwL2NvcmUucnMAAKgtEABeAAAAKgAAACMAAABpbmRleCBub3QgZm91bmQAqC0QAF4AAAA2AAAACgAAAKgtEABeAAAAdwIAAA4AAACoLRAAXgAAAO4AAAAuAAAAqC0QAF4AAACSAQAAIgAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9pbmRleG1hcC0xLjYuMi9zcmMvbWFwL2NvcmUvcmF3LnJzAABoLhAAYgAAAHYAAAAKAAAAqC0QAF4AAAAiAAAADwAAAE1hdHJpeCBpbmRleCBvdXQgb2YgYm91bmRzLkluZGV4IG91dCBvZiBib3VuZHMuL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL25hbGdlYnJhLTAuMjUuNC9zcmMvYmFzZS9pbmRleGluZy5ycwAbLxAAZAAAAGQBAAAaAAAAHgAAAAgAAAAEAAAAWQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjcuMi9zcmMvZGF0YS9hcmVuYS5yc6AvEABgAAAABwEAAB4AAABjb3JydXB0IGZyZWUgbGlzdAAAAKAvEABgAAAACAEAACsAAABpbnNlcnRpbmcgd2lsbCBhbHdheXMgc3VjY2VlZCBhZnRlciByZXNlcnZpbmcgYWRkaXRpb25hbCBzcGFjZQAAoC8QAGAAAABJAQAADgAAAGFzc2VydGlvbiBmYWlsZWQ6IGkxLmdlbmVyYXRpb24gIT0gaTIuZ2VuZXJhdGlvbqAvEABgAAAAFAIAAA0AAACgLxAAYAAAACUCAAAqAAAAoC8QAGAAAAAnAgAAFwAAAKAvEABgAAAAJwIAACMAAABObyBlbGVtZW50IGF0IGluZGV4Q2Fubm90IGluZGV4IHRoZSBzYW1lIG9iamVjdCB0d2ljZS4AAAcxEAAjAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuNy4yL3NyYy9kYXRhL2NvYXJlbmEucnMAADQxEABiAAAAOAAAAAkAAAA0MRAAYgAAAEAAAAATAAAANDEQAGIAAABAAAAAIgAAADQxEABiAAAASAAAABMAAAA0MRAAYgAAAEgAAAAiAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuNy4yL3NyYy9kYXRhL2dyYXBoLnJz6DEQAGAAAACSAAAAGAAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYubm9kZXMubGVuKCkgIT0gY3JhdGU6OklOVkFMSURfVVNJWkUAAOgxEABgAAAAswAAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmVkZ2VzLmxlbigpICE9IGNyYXRlOjpJTlZBTElEX1VTSVpFAADoMRAAYAAAANwAAAAJAAAAR3JhcGg6OmFkZF9lZGdlOiBub2RlIGluZGljZXMgb3V0IG9mIGJvdW5kcwDoMRAAYAAAAOQAAAAbAAAA6DEQAGAAAAAPAQAAHAAA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AHQAAAAeAAAAFgAAALw5EAB0AAAAHwAAABQAAAC8ORAAdAAAACAAAAAUAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuNy4yL3NyYy9keW5hbWljcy9zb2x2ZXIvam9pbnRfY29uc3RyYWludC9iYWxsX3Bvc2l0aW9uX2NvbnN0cmFpbnQucnMAcDoQAI8AAAAqAAAAHQAAAHA6EACPAAAAKwAAAB0AAABwOhAAjwAAAIkAAAAdAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuNy4yL3NyYy9keW5hbWljcy9zb2x2ZXIvam9pbnRfY29uc3RyYWludC9iYWxsX3ZlbG9jaXR5X2NvbnN0cmFpbnQucnMAMDsQAI8AAACtAAAAHgAAADA7EACPAAAArgAAAB4AAAAwOxAAjwAAAOYAAAAeAAAAMDsQAI8AAADnAAAAHgAAADA7EACPAAAA7AAAAAkAAAAwOxAAjwAAAO0AAAAJAAAAMDsQAI8AAADxAAAAGgAAADA7EACPAAAAkgEAAB4AAAAwOxAAjwAAALsBAAAeAAAAMDsQAI8AAADAAQAACQAAADA7EACPAAAAxQEAABoAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC43LjIvc3JjL2R5bmFtaWNzL3NvbHZlci9qb2ludF9jb25zdHJhaW50L2ZpeGVkX3Bvc2l0aW9uX2NvbnN0cmFpbnQucnNwPBAAkAAAADAAAAAdAAAAcDwQAJAAAAAxAAAAHQAAAHA8EACQAAAATAAAAAkAAABwPBAAkAAAAE0AAAAJAAAAcDwQAJAAAAB6AAAAHQAAAFNpbmd1bGFyIHN5c3RlbS4vaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC43LjIvc3JjL2R5bmFtaWNzL3NvbHZlci9qb2ludF9jb25zdHJhaW50L2ZpeGVkX3ZlbG9jaXR5X2NvbnN0cmFpbnQucnNgPRAAkAAAAGQAAAAmAAAAYD0QAJAAAACZAAAAHgAAAGA9EACQAAAAmgAAAB4AAABgPRAAkAAAALEAAAAeAAAAYD0QAJAAAACyAAAAHgAAAGA9EACQAAAA2gAAABoAAABgPRAAkAAAADcBAAAmAAAAYD0QAJAAAABmAQAAHgAAAGA9EACQAAAAdwEAAB4AAABgPRAAkAAAAJcBAAAaAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuNy4yL3NyYy9keW5hbWljcy9zb2x2ZXIvam9pbnRfY29uc3RyYWludC9qb2ludF9jb25zdHJhaW50LnJzAJA+EACHAAAATgAAABQAAACQPhAAhwAAAE8AAAAUAAAAkD4QAIcAAACaAAAAGAAAAJA+EACHAAAAmwAAABgAAACQPhAAhwAAACEBAAAyAAAAkD4QAIcAAABJAQAAMgAAAJA+EACHAAAAhQEAADIAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC43LjIvc3JjL2R5bmFtaWNzL3NvbHZlci9qb2ludF9jb25zdHJhaW50L2pvaW50X3Bvc2l0aW9uX2NvbnN0cmFpbnQucnOIPxAAkAAAADwAAAAUAAAAiD8QAJAAAAA9AAAAFAAAAIg/EACQAAAAfgAAABgAAACIPxAAkAAAAH8AAAAYAAAAiD8QAJAAAADwAAAAMgAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjcuMi9zcmMvZHluYW1pY3Mvc29sdmVyL2pvaW50X2NvbnN0cmFpbnQvcHJpc21hdGljX3Bvc2l0aW9uX2NvbnN0cmFpbnQucnNoQBAAlAAAADgAAAAdAAAAaEAQAJQAAAA5AAAAHQAAAGhAEACUAAAAXgAAAAkAAABoQBAAlAAAAF8AAAAJAAAAaEAQAJQAAACQAAAAHQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjcuMi9zcmMvZHluYW1pY3Mvc29sdmVyL2pvaW50X2NvbnN0cmFpbnQvcHJpc21hdGljX3ZlbG9jaXR5X2NvbnN0cmFpbnQucnNMQRAAlAAAABwBAAAeAAAATEEQAJQAAAAdAQAAHgAAAExBEACUAAAAkgEAAB4AAABMQRAAlAAAAJMBAAAeAAAATEEQAJQAAACeAQAAGgAAAExBEACUAAAAwgIAAB4AAABMQRAAlAAAABIDAAAeAAAATEEQAJQAAAAdAwAAGgAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjcuMi9zcmMvZHluYW1pY3Mvc29sdmVyL2pvaW50X2NvbnN0cmFpbnQvcmV2b2x1dGVfcG9zaXRpb25fY29uc3RyYWludC5ycwBgQhAAkwAAADsAAAAdAAAAYEIQAJMAAAA8AAAAHQAAAGBCEACTAAAAUgAAAC0AAABgQhAAkwAAAHEAAAAJAAAAYEIQAJMAAAByAAAACQAAAGBCEACTAAAAuAAAAB0AAABgQhAAkwAAAMcAAAAtAAAAYEIQAJMAAADdAAAACQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjcuMi9zcmMvZHluYW1pY3Mvc29sdmVyL2pvaW50X2NvbnN0cmFpbnQvcmV2b2x1dGVfdmVsb2NpdHlfY29uc3RyYWludC5ycwB0QxAAkwAAAMYAAAAeAAAAdEMQAJMAAADHAAAAHgAAAHRDEACTAAAAGAEAAB4AAAB0QxAAkwAAABkBAAAeAAAAdEMQAJMAAAAjAQAAGgAAAHRDEACTAAAA4wEAAB4AAAB0QxAAkwAAAB4CAAAeAAAAdEMQAJMAAAAoAgAAGgAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjcuMi9zcmMvZHluYW1pY3Mvc29sdmVyL3Bvc2l0aW9uX2NvbnN0cmFpbnQucnMAAACIRBAAeQAAAB8AAAAtAAAAiEQQAHkAAAA9AAAAFAAAAIhEEAB5AAAAPgAAABQAAACIRBAAeQAAAHAAAAAYAAAAiEQQAHkAAABxAAAAGAAAAIhEEAB5AAAAdQAAACAAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC43LjIvc3JjL2R5bmFtaWNzL3NvbHZlci9wb3NpdGlvbl9ncm91bmRfY29uc3RyYWludC5yc2RFEACAAAAAHwAAABgAAABkRRAAgAAAACAAAAAYAAAAZEUQAIAAAABVAAAAGAAAAGRFEACAAAAAWQAAACAAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC43LjIvc3JjL2R5bmFtaWNzL3NvbHZlci9wb3NpdGlvbl9zb2x2ZXIucnMAAAAkRhAAdQAAAC8AAAAiAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuNy4yL3NyYy9keW5hbWljcy9zb2x2ZXIvc29sdmVyX2NvbnN0cmFpbnRzLnJzrEYQAHgAAACfAAAAHQAAAKxGEAB4AAAA2QAAAB0AAACsRhAAeAAAAC4BAAAaAAAArEYQAHgAAABWAQAAGgAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjcuMi9zcmMvZHluYW1pY3Mvc29sdmVyL3ZlbG9jaXR5X2NvbnN0cmFpbnQucnMAAABkRxAAeQAAADMAAAAtAAAAZEcQAHkAAAA/AAAALQAAAGRHEAB5AAAASwAAAC0AAAAAAAAAZEcQAHkAAABxAAAACQAAAGRHEAB5AAAAdgAAABQAAABkRxAAeQAAAHcAAAAUAAAAZEcQAHkAAACyAAAAFgAA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X211bHRpX3NhcC9zYXBfcmVnaW9uLnJzAHhSEAB/AAAARgAAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBvbGQudG9faW5zZXJ0LmlzX2VtcHR5KCkAAHhSEAB/AAAARwAAAAkAAAB4UhAAfwAAAF0AAAAMAAAAeFIQAH8AAAB9AAAADQAAAHhSEAB/AAAAhQAAAAkAAAB4UhAAfwAAAKUAAAANAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuNy4yL3NyYy9nZW9tZXRyeS9icm9hZF9waGFzZV9tdWx0aV9zYXAvc2FwX3V0aWxzLnJzAACEUxAAfgAAAA0AAAAFAAAAUGFyZW50IHJpZ2lkIGJvZHkgbm90IGZvdW5kLi9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjcuMi9zcmMvZ2VvbWV0cnkvY29sbGlkZXJfc2V0LnJzADBUEABrAAAAqQAAAA4AAAAwVBAAawAAAK4AAAAxAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuNy4yL3NyYy9nZW9tZXRyeS9pbnRlcmFjdGlvbl9ncmFwaC5yc7xUEABwAAAAfAAAAD8AAAC8VBAAcAAAAH0AAAAOAAAAvFQQAHAAAAB9AAAAJwAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjcuMi9zcmMvZ2VvbWV0cnkvbmFycm93X3BoYXNlLnJzAFxVEABrAAAAugAAADQAAABcVRAAawAAAEIBAAAiAAAAXFUQAGsAAABCAQAAQQAAAFxVEABrAAAA/AEAABsAAABcVRAAawAAAP0BAAAbAAAAXFUQAGsAAAD+AQAAGAAAAFxVEABrAAAA/wEAABgAAABcVRAAawAAAAgCAAAYAAAAXFUQAGsAAAAJAgAAGAAAAFxVEABrAAAAUwIAABgAAABcVRAAawAAAFQCAAAYAAAAXFUQAGsAAABdAgAAGAAAAFxVEABrAAAAXgIAABgAAABBIGNvbnRhY3QgbWFuaWZvbGQgY2Fubm90IGNvbnRhaW4gbW9yZSB0aGFuIDI1NSBjb250YWN0cyBjdXJyZW50bHkuAFxVEABrAAAAuQIAABUAAABcVRAAawAAAA0DAAAgAAAAXFUQAGsAAAAUAwAAHAAAAFxVEABrAAAAFQMAABwAAABcVRAAawAAACUDAAAVAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuNy4yL3NyYy9waXBlbGluZS9waHlzaWNzX3BpcGVsaW5lLnJzACxXEABvAAAAdgAAABEAAAAsVxAAbwAAAM8AAAARAAAALFcQAG8AAADVAAAAFgAAACxXEABvAAAA1wAAABYAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC43LjIvc3JjL3BpcGVsaW5lL3F1ZXJ5X3BpcGVsaW5lLnJzAAAA3FcQAG0AAACdAAAAHQAAANxXEABtAAAApAAAAC0AAADcVxAAbQAAAL4AAAAeAAAA3FcQAG0AAADFAAAAIwAAANxXEABtAAAAxwAAAB0AAADcVxAAbQAAANAAAAAjAAAA3FcQAG0AAADRAAAALQAAAFVuYWJsZSB0byBpbmRleCB0aGUgc2FtZSBlbGVtZW50IHR3aWNlLi9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjcuMi9zcmMvdXRpbHMucnMAAONYEABbAAAAvQIAAAkAAADjWBAAWwAAAL4CAAAJAAAAWgAAAAQAAAAEAAAAWwAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9pbnN0YW50LTAuMS45L3NyYy93YXNtLnJzcGVyZm9ybWFuY2VmYWlsZWQgdG8gZ2V0IHBlcmZvcm1hbmNlIGZyb20gZ2xvYmFsIG9iamVjdHBZEABZAAAAdgAAAA4AAABjbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgZGVzdHJveWVkIGFscmVhZHljYW5ub3QgYWNjZXNzIGEgVGhyZWFkIExvY2FsIFN0b3JhZ2UgdmFsdWUgZHVyaW5nIG9yIGFmdGVyIGRlc3RydWN0aW9uL2hvbWUvc2ViY3JvemV0Ly5ydXN0dXAvdG9vbGNoYWlucy9uaWdodGx5LXg4Nl82NC11bmtub3duLWxpbnV4LWdudS9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L3N0ZC9zcmMvdGhyZWFkL2xvY2FsLnJzAACGWhAAeAAAAPgAAAAaAAAAZwAAAAAAAAABAAAAKwAAAHJldHVybiB0aGlzAAQAAAAAAAAASnNWYWx1ZSgpAAAANFsQAAgAAAA8WxAAAQAAAG51bGwgcG9pbnRlciBwYXNzZWQgdG8gcnVzdHJlY3Vyc2l2ZSB1c2Ugb2YgYW4gb2JqZWN0IGRldGVjdGVkIHdoaWNoIHdvdWxkIGxlYWQgdG8gdW5zYWZlIGFsaWFzaW5nIGluIHJ1c3QBAG0AAAAIAAAABAAAAG4AAABvAAAAbQAAABgAAAAEAAAAcAAAAHEAAABkAAAABAAAAHIAAABtAAAAEAAAAAQAAABzAAAAdAAAAFgAAAAEAAAAdQAAAG0AAAAMAAAABAAAAHYAAABtAAAADAAAAAQAAAB3AAAAbQAAAAgAAAAEAAAAeAAAAHkAAAAwAAAABAAAAHoAAAB7AAAAYAAAAAQAAAB8AAAAbQAAAAwAAAAEAAAAfQAAAG0AAAAcAAAABAAAAH4AAABtAAAABAAAAAQAAAB/AAAAbQAAAAgAAAAEAAAAgAAAAG0AAAAkAAAABAAAAIEAAACCAAAAcAAAAAQAAACDAAAAhAAAACAAAAAEAAAAhQAAAIYAAABYAAAABAAAAIcAAACEAAAAIAAAAAQAAACIAAAAiQAAACAAAAAEAAAAigAAAIsAAABQAAAABAAAAIwAAACJAAAAIAAAAAQAAACNAAAAbQAAAAwAAAAEAAAAjgAAAG0AAAAoAAAABAAAAI8AAABtAAAABAAAAAQAAACQAAAAbQAAAAQAAAAEAAAAkQAAAGFzc2VydGlvbiBmYWlsZWQ6IG1pZCA8PSBzZWxmLmxlbigpL2hvbWUvc2ViY3JvemV0Ly5ydXN0dXAvdG9vbGNoYWlucy9uaWdodGx5LXg4Nl82NC11bmtub3duLWxpbnV4LWdudS9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2NvcmUvc3JjL3NsaWNlL21vZC5ycwAAAINdEAB2AAAA/wUAAAkAAACDXRAAdgAAADYCAAAkAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZQAvaG9tZS9zZWJjcm96ZXQvLnJ1c3R1cC90b29sY2hhaW5zL25pZ2h0bHkteDg2XzY0LXVua25vd24tbGludXgtZ251L2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3NsaWNlLnJzAEheEABzAAAAxAAAABEAAABtAAAABAAAAAQAAACSAAAAY2FwYWNpdHkgb3ZlcmZsb3cvaG9tZS9zZWJjcm96ZXQvLnJ1c3R1cC90b29sY2hhaW5zL25pZ2h0bHkteDg2XzY0LXVua25vd24tbGludXgtZ251L2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL2NvbGxlY3Rpb25zL3ZlY19kZXF1ZS9tb2QucnPtXhAAhwAAAN4BAAAJAAAA7V4QAIcAAAB8AgAADgAAAAQAAAAAAAAAEAAAAAAAAAB7AAAApF8QAAEAAABIXhAAAAAAACwgAAC4XxAAAgAAAH0AAADEXxAAAQAAAE1hdHJpeGRhdGEAAG0AAAAMAAAABAAAAJMAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvaW5kZXhtYXAtMS42LjIvc3JjL21hcC9jb3JlLnJzAADsXxAAXgAAACoAAAAjAAAA7F8QAF4AAAB3AgAADgAAAOxfEABeAAAAIgAAAA8AAABNYXRyaXggaW5kZXggb3V0IG9mIGJvdW5kcy5Eb3QgcHJvZHVjdCBkaW1lbnNpb25zIG1pc21hdGNoIGZvciBzaGFwZXMgIGFuZCA6IGxlZnQgcm93cyAhPSByaWdodCByb3dzLgAAAJdgEAArAAAAwmAQAAUAAADHYBAAGgAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9uYWxnZWJyYS0wLjI1LjQvc3JjL2Jhc2UvYmxhcy5yc/xgEABgAAAAIgAAAAkAAABJbmRleCBvdXQgb2YgYm91bmRzLi9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9uYWxnZWJyYS0wLjI1LjQvc3JjL2xpbmFsZy9zeW1tZXRyaWNfZWlnZW4ucnMAAACAYRAAbQAAAIwAAAAVAAAAgGEQAG0AAACMAAAAMwAAAIBhEABtAAAAjAAAADwAAACAYRAAbQAAAIwAAABFAAAAgGEQAG0AAACNAAAAFQAAAIBhEABtAAAAlgAAAB0AAACAYRAAbQAAAJoAAAAjAAAAgGEQAG0AAACpAAAALgAAAIBhEABtAAAAuwAAABUAAACAYRAAbQAAALwAAAAVAAAAgGEQAG0AAADAAAAALwAAAIBhEABtAAAA8AAAABAAAACAYRAAbQAAAEAAAAA+AAAAgGEQAG0AAABUAAAAIAAAAG0AAAAIAAAABAAAAJQAAAAvaG9tZS9zZWJjcm96ZXQvLnJ1c3R1cC90b29sY2hhaW5zL25pZ2h0bHkteDg2XzY0LXVua25vd24tbGludXgtZ251L2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL2NvbGxlY3Rpb25zL3ZlY19kZXF1ZS9yaW5nX3NsaWNlcy5ycwDgYhAAjwAAACAAAAAOAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZS9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuMy4wL3NyYy9ib3VuZGluZ192b2x1bWUvYWFiYi5yc1RoZSBsb29zZW5pbmcgbWFyZ2luIG11c3QgYmUgcG9zaXRpdmUuAKhjEABpAAAAIQEAAAkAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjMuMC9zcmMvYm91bmRpbmdfdm9sdW1lL2FhYmJfdXRpbHMucnNQb2ludCBjbG91ZCBBQUJCIGNvbnN0cnVjdGlvbjogdGhlIGlucHV0IGl0ZXJhdG9yIHNob3VsZCB5aWVsZCBhdCBsZWFzdCBvbmUgcG9pbnQuAAAASGQQAG8AAABAAAAAGAAAAEhkEABvAAAAVwAAABgAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjMuMC9zcmMvYm91bmRpbmdfdm9sdW1lL2JvdW5kaW5nX3NwaGVyZS5ycyxlEAB0AAAAcwAAAAkAAAB0d28gYXJyYXlzIGNvbnRhaW5pbmcgYXQgbGVhc3QgIGZsb2F0cwAAsGUQAB8AAADPZRAABwAAABgAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjMuMC9zcmMvbWFzc19wcm9wZXJ0aWVzL21hc3NfcHJvcGVydGllc19jb252ZXhfcG9seWhlZHJvbi5ycwAA7GUQAIYAAAAXAAAAFwAAAOxlEACGAAAAGAAAABcAAADsZRAAhgAAABkAAAAXAAAA7GUQAIYAAAClAAAAEgAAAOxlEACGAAAApgAAABIAAADsZRAAhgAAAKcAAAASAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC4zLjAvc3JjL3BhcnRpdGlvbmluZy93cXVhZHRyZWUucnMA1GYQAGsAAACqAAAADQAAANRmEABrAAAAqwAAAA0AAADUZhAAawAAALwAAAAJAAAA1GYQAGsAAAAGAQAAIAAAANRmEABrAAAABwEAABEAAADUZhAAawAAAAkBAAARAAAA1GYQAGsAAAAlAQAAGgAAANRmEABrAAAAYQEAAAkAAADUZhAAawAAAGIBAAAJAAAA1GYQAGsAAABjAQAACQAAANRmEABrAAAAoQEAABgAAADUZhAAawAAANsBAAAYAAAA1GYQAGsAAACyAgAAEQAAANRmEABrAAAAswIAABYAAADUZhAAawAAALUCAAAMAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC4zLjAvc3JjL3F1ZXJ5L2NsaXAvY2xpcF9hYWJiX2xpbmUucnMAADBoEABuAAAAjQAAAA0AAAAwaBAAbgAAAJsAAAANAAAAVGhlIHByb3hpbWl0eSBtYXJnaW4gbXVzdCBiZSBwb3NpdGl2ZSBvciBudWxsLi9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuMy4wL3NyYy9xdWVyeS9jbG9zZXN0X3BvaW50cy9jbG9zZXN0X3BvaW50c19iYWxsX2JhbGwucnPuaBAAggAAAA8AAAAFAAAAVGhlIGNvbXBvc2l0ZSBzaGFwZSBtdXN0IG5vdCBiZSBlbXB0eS4vaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjMuMC9zcmMvcXVlcnkvY2xvc2VzdF9wb2ludHMvY2xvc2VzdF9wb2ludHNfY29tcG9zaXRlX3NoYXBlX3NoYXBlLnJzpmkQAI4AAAAbAAAACgAAAKZpEACOAAAAgQAAACEAAACmaRAAjgAAAIIAAAAhAAAApmkQAI4AAACDAAAAIQAAAEFBOiAKAAAAdGoQAAQAAAB4ahAAAQAAAEJCOiCMahAABAAAAHhqEAABAAAALCBCQjogLCBDQzogdGoQAAQAAACgahAABgAAAKZqEAAGAAAAeGoQAAEAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjMuMC9zcmMvcXVlcnkvY2xvc2VzdF9wb2ludHMvY2xvc2VzdF9wb2ludHNfY3Vib2lkX2N1Ym9pZC5ycwAAzGoQAIYAAABRAAAABQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuMy4wL3NyYy9xdWVyeS9jbG9zZXN0X3BvaW50cy9jbG9zZXN0X3BvaW50c19jdWJvaWRfdHJpYW5nbGUucnNkaxAAiAAAAE0AAAAFAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC4zLjAvc3JjL3F1ZXJ5L2Nsb3Nlc3RfcG9pbnRzL2Nsb3Nlc3RfcG9pbnRzX2hhbGZzcGFjZV9zdXBwb3J0X21hcC5ycwAA/GsQAI4AAAANAAAABQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuMy4wL3NyYy9xdWVyeS9jbG9zZXN0X3BvaW50cy9jbG9zZXN0X3BvaW50c19zdXBwb3J0X21hcF9zdXBwb3J0X21hcC5yc5xsEACQAAAAIAAAACQAAABtAAAAFAAAAAQAAACVAAAAlgAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuMy4wL3NyYy9xdWVyeS9jb250YWN0L2NvbnRhY3Rfc3VwcG9ydF9tYXBfc3VwcG9ydF9tYXAucnMAAFBtEACCAAAAHgAAACQAAACJAAAAIAAAAAQAAACXAAAAmAAAAJkAAACaAAAAmQAAAJsAAACcAAAAigAAAIQAAAAgAAAABAAAAJ0AAACeAAAAnwAAAKAAAACfAAAAoQAAAKIAAACFAAAAiQAAACAAAAAEAAAAowAAAKQAAAClAAAApgAAAKUAAACnAAAAqAAAAI0AAACEAAAAIAAAAAQAAACpAAAAqgAAAKsAAACsAAAAqwAAAK0AAACuAAAAiAAAAHkAAAAwAAAABAAAAK8AAACwAAAAsQAAALIAAACxAAAAswAAALQAAAB6AAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC4zLjAvc3JjL3F1ZXJ5L2Rpc3RhbmNlL2Rpc3RhbmNlX2NvbXBvc2l0ZV9zaGFwZV9zaGFwZS5ycwAAwG4QAIIAAAAXAAAACgAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuMy4wL3NyYy9xdWVyeS9kaXN0YW5jZS9kaXN0YW5jZV9zdXBwb3J0X21hcF9zdXBwb3J0X21hcC5yc1RvEACEAAAANAAAACQAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjMuMC9zcmMvcXVlcnkvZXBhL2VwYTMucnMA6G8QAGMAAABIAAAADgAAAOhvEABjAAAASQAAAA4AAADobxAAYwAAAEoAAAAOAAAA6G8QAGMAAABhAAAADQAAAOhvEABjAAAAYgAAAA0AAADobxAAYwAAAGMAAAANAAAA6G8QAGMAAAB1AAAADQAAAOhvEABjAAAAdgAAABMAAADobxAAYwAAAHcAAAATAAAA6G8QAGMAAACIAAAADQAAAOhvEABjAAAAjgAAABwAAADobxAAYwAAAI4AAAATAAAA6G8QAGMAAACPAAAAEwAAAOhvEABjAAAAkAAAABMAAADobxAAYwAAAJEAAAATAAAA6G8QAGMAAAD4AAAAFwAAAOhvEABjAAAAFAEAAB0AAADobxAAYwAAABQBAAA3AAAA6G8QAGMAAAAZAQAAHQAAAOhvEABjAAAAGQEAADcAAADobxAAYwAAAB4BAAAdAAAA6G8QAGMAAAAeAQAANwAAAOhvEABjAAAAIwEAAB0AAADobxAAYwAAACMBAAA3AAAA6G8QAGMAAABEAQAAMgAAAOhvEABjAAAAqgEAABoAAADobxAAYwAAAEsBAAAYAAAA6G8QAGMAAABfAQAAIgAAAOhvEABjAAAAZAEAAA0AAADobxAAYwAAAGYBAAAiAAAA6G8QAGMAAABnAQAAIgAAAOhvEABjAAAAaAEAACIAAADobxAAYwAAAHYBAAAVAAAA6G8QAGMAAACKAQAAMAAAAOhvEABjAAAAigEAACIAAADobxAAYwAAAJ4BAAANAAAA6G8QAGMAAACfAQAAIwAAAOhvEABjAAAAsAEAAA0AAADobxAAYwAAALkBAAAcAAAA6G8QAGMAAAC9AQAAFQAAAOhvEABjAAAAvwEAABUAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjMuMC9zcmMvcXVlcnkvZ2prL2dqay5ycwAA3HIQAGIAAABDAAAADgAAAGFzc2VydGlvbiBmYWlsZWQ6IG1pbl9ib3VuZCA9PSBtaW5fYm91bmTcchAAYgAAAIwAAAAJAAAA3HIQAGIAAABPAQAACQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuMy4wL3NyYy9xdWVyeS9namsvdm9yb25vaV9zaW1wbGV4My5ycwCYcxAAbwAAAE0AAAASAAAAmHMQAG8AAABRAAAACQAAAJhzEABvAAAAWAAAAAkAAACYcxAAbwAAAF0AAAAJAAAAmHMQAG8AAABeAAAACgAAAJhzEABvAAAAZAAAAAkAAACYcxAAbwAAAGoAAAAKAAAAYXNzZXJ0aW9uIGZhaWxlZDogc2VsZi5kaW0gPT0gMwCYcxAAbwAAALkAAAANAAAAmHMQAG8AAAAOAQAAHgAAAJhzEABvAAAA5QAAAB4AAACYcxAAbwAAAIsAAAAWAAAAmHMQAG8AAABcAQAAFAAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuMy4wL3NyYy9xdWVyeS9pbnRlcnNlY3Rpb25fdGVzdC9pbnRlcnNlY3Rpb25fdGVzdF9zdXBwb3J0X21hcF9zdXBwb3J0X21hcC5ycwAA6HQQAJYAAAA5AAAAKQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuMy4wL3NyYy9xdWVyeS9ub25saW5lYXJfdGltZV9vZl9pbXBhY3Qvbm9ubGluZWFyX3RpbWVfb2ZfaW1wYWN0X2NvbXBvc2l0ZV9zaGFwZV9zaGFwZS5ycwAAbQAAAAQAAAAEAAAAtQAAALYAAAC3AAAAuAAAALkAAAC6AAAAuwAAALwAAAC9AAAAvgAAAL8AAADAAAAAwQAAAMIAAADDAAAAxAAAAMUAAADEAAAAxgAAAMcAAAB/AAAAyAAAAMkAAADKAAAAywAAAMwAAADNAAAAzgAAAM8AAADQAAAA0QAAANIAAADTAAAA1AAAANUAAACQdRAAogAAAMMAAAAVAAAAkHUQAKIAAACbAAAAKgAAAJB1EACiAAAAvAAAACEAAACQdRAAogAAAL0AAAAhAAAAkHUQAKIAAAC+AAAAIQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuMy4wL3NyYy9xdWVyeS9ub25saW5lYXJfdGltZV9vZl9pbXBhY3Qvbm9ubGluZWFyX3RpbWVfb2ZfaW1wYWN0X3N1cHBvcnRfbWFwX3N1cHBvcnRfbWFwLnJzHHcQAKQAAADMAAAAKAAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuMy4wL3NyYy9xdWVyeS9wb2ludC9wb2ludF9jb21wb3NpdGVfc2hhcGUucnMAANB3EAB2AAAAHQAAAFcAAADQdxAAdgAAADoAAABYAAAA0HcQAHYAAABPAAAADgAAANB3EAB2AAAAbwAAADsAAADQdxAAdgAAAH4AAAA7AAAAYXNzZXJ0aW9uIGZhaWxlZDogc3FuYWIgIT0gMC4wL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC4zLjAvc3JjL3F1ZXJ5L3BvaW50L3BvaW50X3NlZ21lbnQucnO2eBAAbgAAAEgAAAANAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC4zLjAvc3JjL3F1ZXJ5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AH8AAAAVAAAAFAAAACiVEAB/AAAAFQAAACEAAAAolRAAfwAAABYAAAAUAAAAYXNzZXJ0aW9uIGZhaWxlZDogZGlzdGFuY2UgPiBjcmF0ZTo6bWF0aDo6REVGQVVMVF9FUFNJTE9OAAAAKJUQAH8AAAAqAAAACQAAACiVEAB/AAAANQAAACsAAAAolRAAfwAAAEsAAAAJAAAAKJUQAH8AAABYAAAAEgAAACiVEAB/AAAAWQAAABIAAAAolRAAfwAAAHAAAAAWAAAAKJUQAH8AAABxAAAAFgAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuMy4wL3NyYy90cmFuc2Zvcm1hdGlvbi9jb252ZXhfaHVsbDMvdmFsaWRhdGlvbi5ycwCElhAAewAAAAYAAAASAAAAhJYQAHsAAAAJAAAAEQAAAGFzc2VydGlvbiBmYWlsZWQ6IGZhY2V0c1tmYWNldC5hZGpbaV1dLnZhbGlkhJYQAHsAAAAJAAAACQAAAISWEAB7AAAADQAAABoAAACElhAAewAAAA8AAAAUAAAAhJYQAHsAAAAPAAAACQAAAISWEAB7AAAAEAAAAAkAAACElhAAewAAABEAAAAJAAAAhJYQAHsAAAAVAAAACQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuMy4wL3NyYy90cmFuc2Zvcm1hdGlvbi9jb252ZXhfaHVsbF91dGlscy5ycwAAALyXEAB1AAAALwAAACIAAAC8lxAAdQAAAEkAAAAiAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC4zLjAvc3JjL3RyYW5zZm9ybWF0aW9uL3RvX3RyaW1lc2gvY29udmV4X3BvbHloZWRyb25fdG9fdHJpbWVzaC5ycwBUmBAAiwAAAA0AAAAcAAAAVJgQAIsAAAAPAAAAGAAAAENhbm5vdCBjb21wdXRlIHRoZSBjZW50ZXIgb2YgbGVzcyB0aGFuIDEgcG9pbnQu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aWNlL21vZC5yc/OfEABNAAAA4QUAAAkAAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlAC4DAAAAAAAAAQAAADoDAAAuAwAAAAAAAAEAAAA7AwAAPAMAABAAAAAEAAAAPQMAAGNhbGxlZCBgUmVzdWx0Ojp1bndyYXAoKWAgb24gYW4gYEVycmAgdmFsdWUAPgMAAAgAAAAEAAAAPwMAAC4DAAAEAAAABAAAAEADAAAuAwAABAAAAAQAAABBAwAABAAAAAAAAAABAAAAAAAAAEFjY2Vzc0Vycm9ybGlicmFyeS9zdGQvc3JjL3RocmVhZC9tb2QucnNmYWlsZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIHRocmVhZCBJRDogYml0c3BhY2UgZXhoYXVzdGVkACOhEAAdAAAA7AMAABEAAAAjoRAAHQAAAPIDAAAqAAAAdGhyZWFkIG5hbWUgbWF5IG5vdCBjb250YWluIGludGVyaW9yIG51bGwgYnl0ZXMAI6EQAB0AAAAsBAAAKgAAAABsaWJyYXJ5L3N0ZC9zcmMvaW8vYnVmZmVyZWQvYnVmd3JpdGVyLnJzAAAA2aEQACgAAACfAAAAKQAAANmhEAAoAAAA4QAAAB0AAACYnxAAAAAAAHVuZXhwZWN0ZWQgZW5kIG9mIGZpbGVvdGhlciBvcyBlcnJvcm9wZXJhdGlvbiBpbnRlcnJ1cHRlZHdyaXRlIHplcm90aW1lZCBvdXRpbnZhbGlkIGRhdGFpbnZhbGlkIGlucHV0IHBhcmFtZXRlcm9wZXJhdGlvbiB3b3VsZCBibG9ja2VudGl0eSBhbHJlYWR5IGV4aXN0c2Jyb2tlbiBwaXBlYWRkcmVzcyBub3QgYXZhaWxhYmxlYWRkcmVzcyBpbiB1c2Vub3QgY29ubmVjdGVkY29ubmVjdGlvbiBhYm9ydGVkY29ubmVjdGlvbiByZXNldGNvbm5lY3Rpb24gcmVmdXNlZHBlcm1pc3Npb24gZGVuaWVkZW50aXR5IG5vdCBmb3VuZCAob3MgZXJyb3IgKQAAAJifEAAAAAAAVaMQAAsAAABgoxAAAQAAAGxpYnJhcnkvc3RkL3NyYy9pby9zdGRpby5ycwB8oxAAGwAAADQCAAAXAAAAfKMQABsAAACqAgAAFAAAAGZhaWxlZCBwcmludGluZyB0byA6IAAAALijEAATAAAAy6MQAAIAAAB8oxAAGwAAAKwDAAAJAAAAc3Rkb3V0AABCAwAADAAAAAQAAABDAwAARAMAAEUDAABmb3JtYXR0ZXIgZXJyb3IAEKQQAA8AAABCAwAADAAAAAQAAABGAwAARwMAAEgDAABsaWJyYXJ5L3N0ZC9zcmMvc3luYy9vbmNlLnJzLgMAAAQAAAAEAAAASQMAAEoDAABApBAAHAAAAD8BAAAxAAAAYXNzZXJ0aW9uIGZhaWxlZDogc3RhdGVfYW5kX3F1ZXVlICYgU1RBVEVfTUFTSyA9PSBSVU5OSU5HAAAAQKQQABwAAACpAQAAFQAAAE9uY2UgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZAAAQKQQABwAAACIAQAAFQAAAAIAAABApBAAHAAAAO8BAAAJAAAAQKQQABwAAAD7AQAANQAAAHN1cHBsaWVkIGluc3RhbnQgaXMgbGF0ZXIgdGhhbiBzZWxmbGlicmFyeS9zdGQvc3JjL3RpbWUucnMAAE+lEAAXAAAAGQEAADAAAABvdmVyZmxvdyB3aGVuIGFkZGluZyBkdXJhdGlvbiB0byBpbnN0YW50T6UQABcAAAB2AQAAIQAAAFBvaXNvbkVycm9yIHsgaW5uZXI6IC4uIH1saWJyYXJ5L3N0ZC9zcmMvc3lzX2NvbW1vbi90aHJlYWRfaW5mby5ycwAAyaUQACkAAAAVAAAAFgAAAMmlEAApAAAAFgAAABgAAADJpRAAKQAAABkAAAAVAAAALgMAAAAAAAABAAAASwMAAGxpYnJhcnkvc3RkL3NyYy9wYW5pY2tpbmcucnM0phAAHAAAAOsBAAAfAAAANKYQABwAAADsAQAAHgAAAEwDAAAQAAAABAAAAE0DAABOAwAALgMAAAgAAAAEAAAATwMAAFADAABRAwAADAAAAAQAAABSAwAALgMAAAgAAAAEAAAAUwMAAC4DAAAIAAAABAAAAFQDAABVAwAATnVsRXJyb3IuAwAABAAAAAQAAABWAwAAbGlicmFyeS9zdGQvc3JjL3N5c19jb21tb24vdGhyZWFkX3Bhcmtlci9nZW5lcmljLnJzAOSmEAAzAAAAIQAAACYAAABpbmNvbnNpc3RlbnQgcGFyayBzdGF0ZQDkphAAMwAAAC8AAAAXAAAAcGFyayBzdGF0ZSBjaGFuZ2VkIHVuZXhwZWN0ZWRseQBQpxAAHwAAAOSmEAAzAAAALAAAABEAAADkphAAMwAAAEMAAAAiAAAAaW5jb25zaXN0ZW50IHBhcmtfdGltZW91dCBzdGF0ZQDkphAAMwAAAEwAAAAXAAAA5KYQADMAAABJAAAAEQAAAGluY29uc2lzdGVudCBzdGF0ZSBpbiB1bnBhcmvkphAAMwAAAGYAAAASAAAA5KYQADMAAAB0AAAAHwAAAG9wZXJhdGlvbiBzdWNjZXNzZnVsdGltZSBub3QgaW1wbGVtZW50ZWQgb24gdGhpcyBwbGF0Zm9ybWxpYnJhcnkvc3RkL3NyYy9zeXMvd2FzbS8uLi91bnN1cHBvcnRlZC90aW1lLnJzTagQAC8AAAANAAAACQAAAGNvbmR2YXIgd2FpdCBub3Qgc3VwcG9ydGVkbGlicmFyeS9zdGQvc3JjL3N5cy93YXNtLy4uL3Vuc3VwcG9ydGVkL2NvbmR2YXIucnOmqBAAMgAAABcAAAAJAAAApqgQADIAAAAbAAAACQAAAGNhbm5vdCByZWN1cnNpdmVseSBhY3F1aXJlIG11dGV4+KgQACAAAABsaWJyYXJ5L3N0ZC9zcmMvc3lzL3dhc20vLi4vdW5zdXBwb3J0ZWQvbXV0ZXgucnMgqRAAMAAAABcAAAAJAAAASGFzaCB0YWJsZSBjYXBhY2l0eSBvdmVyZmxvdy9jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2hhc2hicm93bi0wLjExLjAvc3JjL3Jhdy9tb2QucnMAfKkQAE8AAABjAAAAKAAAAP////9XAwAABAAAAAQAAABYAwAAWQMAAFoDAAAvcnVzdGMvMDdlMGUyZWMyNjhjMTQwZTYwN2UxYWM3ZjQ5ZjE0NTYxMmQwZjU5Ny9saWJyYXJ5L2NvcmUvc3JjL2ZtdC9tb2QucnMA+KkQAEsAAABaAQAAEwAAAFcDAAAAAAAAAQAAABEAAABhIGZvcm1hdHRpbmcgdHJhaXQgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3JsaWJyYXJ5L2FsbG9jL3NyYy9mbXQucnMAl6oQABgAAABCAgAAHAAAAGxp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".replace("data:application/wasm;base64,", ""), I4 = Uint8Array.from(atob(A4), function(A5) {
                    return A5.charCodeAt(0);
                  }), [4, v(I4)];
                case 1:
                  return g4.sent(), [2];
              }
            });
          }, new ((g3 = void 0) || (g3 = Promise))(function(B2, Q2) {
            function E2(A4) {
              try {
                D2(C2.next(A4));
              } catch (A5) {
                Q2(A5);
              }
            }
            function i2(A4) {
              try {
                D2(C2.throw(A4));
              } catch (A5) {
                Q2(A5);
              }
            }
            function D2(A4) {
              var I4;
              A4.done ? B2(A4.value) : (I4 = A4.value, I4 instanceof g3 ? I4 : new g3(function(A5) {
                A5(I4);
              })).then(E2, i2);
            }
            D2((C2 = C2.apply(A3, I3 || [])).next());
          });
          var A3, I3, g3, C2;
        }
      }, 271: (A2, I2, g2) => {
        A2.exports = g2.p + "e04886749b9aa5dad4b2.wasm";
      }}, I = {};
      function g(C) {
        if (I[C])
          return I[C].exports;
        var B = I[C] = {exports: {}};
        return A[C](B, B.exports, g), B.exports;
      }
      return g.m = A, g.d = (A2, I2) => {
        for (var C in I2)
          g.o(I2, C) && !g.o(A2, C) && Object.defineProperty(A2, C, {enumerable: true, get: I2[C]});
      }, g.g = function() {
        if (typeof globalThis == "object")
          return globalThis;
        try {
          return this || new Function("return this")();
        } catch (A2) {
          if (typeof window == "object")
            return window;
        }
      }(), g.o = (A2, I2) => Object.prototype.hasOwnProperty.call(A2, I2), g.r = (A2) => {
        typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(A2, Symbol.toStringTag, {value: "Module"}), Object.defineProperty(A2, "__esModule", {value: true});
      }, (() => {
        var A2;
        g.g.importScripts && (A2 = g.g.location + "");
        var I2 = g.g.document;
        if (!A2 && I2 && (I2.currentScript && (A2 = I2.currentScript.src), !A2)) {
          var C = I2.getElementsByTagName("script");
          C.length && (A2 = C[C.length - 1].src);
        }
        if (!A2)
          throw new Error("Automatic publicPath is not supported in this browser");
        A2 = A2.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/"), g.p = A2;
      })(), g.b = document.baseURI || self.location.href, g(384);
    })();
  });
});
export {ACESFilmicToneMapping as A, BoxGeometry as B, Clock as C, DynamicDrawUsage as D, GLTFLoader as G, InstancedMesh as I, MathUtils as M, Object3D as O, PerspectiveCamera as P, Quaternion as Q, RepeatWrapping as R, Scene as S, Types as T, Vector2 as V, WebGLRenderer as W, addComponent as a, defineSystem as b, addEntity as c, defineComponent as d, defineQuery as e, enterQuery as f, removeComponent as g, createWorld as h, rapier as i, Vector3 as j, ArrowHelper as k, Mesh as l, AnimationMixer as m, TextureLoader as n, MeshBasicMaterial as o, pipe as p, SphereGeometry as q, removeEntity as r, sRGBEncoding as s};
