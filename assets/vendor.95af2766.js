var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = "138";
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const FlatShading = 1;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;
const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const CubeUVRefractionMapping = 307;
const RepeatWrapping = 1e3;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedInt248Type = 1020;
const AlphaFormat = 1021;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBAIntegerFormat = 1033;
const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const LoopOnce = 2200;
const LoopRepeat = 2201;
const LoopPingPong = 2202;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const TrianglesDrawMode = 0;
const TriangleStripDrawMode = 1;
const TriangleFanDrawMode = 2;
const LinearEncoding = 3e3;
const sRGBEncoding = 3001;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;
const KeepStencilOp = 7680;
const AlwaysStencilFunc = 519;
const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;
const GLSL3 = "300 es";
const _SRGBAFormat = 1035;
class EventDispatcher {
  addEventListener(type, listener) {
    if (this._listeners === void 0)
      this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }
  hasEventListener(type, listener) {
    if (this._listeners === void 0)
      return false;
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  }
  removeEventListener(type, listener) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  }
  dispatchEvent(event) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i2 = 0, l2 = array.length; i2 < l2; i2++) {
        array[i2].call(this, event);
      }
      event.target = null;
    }
  }
}
const _lut = [];
for (let i2 = 0; i2 < 256; i2++) {
  _lut[i2] = (i2 < 16 ? "0" : "") + i2.toString(16);
}
let _seed = 1234567;
const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toUpperCase();
}
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function euclideanModulo(n2, m2) {
  return (n2 % m2 + m2) % m2;
}
function mapLinear(x2, a1, a2, b1, b2) {
  return b1 + (x2 - a1) * (b2 - b1) / (a2 - a1);
}
function inverseLerp(x2, y2, value) {
  if (x2 !== y2) {
    return (value - x2) / (y2 - x2);
  } else {
    return 0;
  }
}
function lerp(x2, y2, t2) {
  return (1 - t2) * x2 + t2 * y2;
}
function damp(x2, y2, lambda, dt) {
  return lerp(x2, y2, 1 - Math.exp(-lambda * dt));
}
function pingpong(x2, length = 1) {
  return length - Math.abs(euclideanModulo(x2, length * 2) - length);
}
function smoothstep(x2, min, max) {
  if (x2 <= min)
    return 0;
  if (x2 >= max)
    return 1;
  x2 = (x2 - min) / (max - min);
  return x2 * x2 * (3 - 2 * x2);
}
function smootherstep(x2, min, max) {
  if (x2 <= min)
    return 0;
  if (x2 >= max)
    return 1;
  x2 = (x2 - min) / (max - min);
  return x2 * x2 * x2 * (x2 * (x2 * 6 - 15) + 10);
}
function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
}
function randFloat(low, high) {
  return low + Math.random() * (high - low);
}
function randFloatSpread(range) {
  return range * (0.5 - Math.random());
}
function seededRandom(s2) {
  if (s2 !== void 0)
    _seed = s2 % 2147483647;
  _seed = _seed * 16807 % 2147483647;
  return (_seed - 1) / 2147483646;
}
function degToRad(degrees) {
  return degrees * DEG2RAD;
}
function radToDeg(radians) {
  return radians * RAD2DEG;
}
function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}
function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function setQuaternionFromProperEuler(q2, a2, b2, c2, order) {
  const cos = Math.cos;
  const sin = Math.sin;
  const c22 = cos(b2 / 2);
  const s2 = sin(b2 / 2);
  const c13 = cos((a2 + c2) / 2);
  const s13 = sin((a2 + c2) / 2);
  const c1_3 = cos((a2 - c2) / 2);
  const s1_3 = sin((a2 - c2) / 2);
  const c3_1 = cos((c2 - a2) / 2);
  const s3_1 = sin((c2 - a2) / 2);
  switch (order) {
    case "XYX":
      q2.set(c22 * s13, s2 * c1_3, s2 * s1_3, c22 * c13);
      break;
    case "YZY":
      q2.set(s2 * s1_3, c22 * s13, s2 * c1_3, c22 * c13);
      break;
    case "ZXZ":
      q2.set(s2 * c1_3, s2 * s1_3, c22 * s13, c22 * c13);
      break;
    case "XZX":
      q2.set(c22 * s13, s2 * s3_1, s2 * c3_1, c22 * c13);
      break;
    case "YXY":
      q2.set(s2 * c3_1, c22 * s13, s2 * s3_1, c22 * c13);
      break;
    case "ZYZ":
      q2.set(s2 * s3_1, s2 * c3_1, c22 * s13, c22 * c13);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
  }
}
var MathUtils = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DEG2RAD,
  RAD2DEG,
  generateUUID,
  clamp,
  euclideanModulo,
  mapLinear,
  inverseLerp,
  lerp,
  damp,
  pingpong,
  smoothstep,
  smootherstep,
  randInt,
  randFloat,
  randFloatSpread,
  seededRandom,
  degToRad,
  radToDeg,
  isPowerOfTwo,
  ceilPowerOfTwo,
  floorPowerOfTwo,
  setQuaternionFromProperEuler
});
class Vector2 {
  constructor(x2 = 0, y2 = 0) {
    this.x = x2;
    this.y = y2;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x2, y2) {
    this.x = x2;
    this.y = y2;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x2) {
    this.x = x2;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    return this;
  }
  add(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v2, w2);
    }
    this.x += v2.x;
    this.y += v2.y;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    return this;
  }
  addVectors(a2, b2) {
    this.x = a2.x + b2.x;
    this.y = a2.y + b2.y;
    return this;
  }
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    return this;
  }
  sub(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v2, w2);
    }
    this.x -= v2.x;
    this.y -= v2.y;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    return this;
  }
  subVectors(a2, b2) {
    this.x = a2.x - b2.x;
    this.y = a2.y - b2.y;
    return this;
  }
  multiply(v2) {
    this.x *= v2.x;
    this.y *= v2.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v2) {
    this.x /= v2.x;
    this.y /= v2.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m2) {
    const x2 = this.x, y2 = this.y;
    const e2 = m2.elements;
    this.x = e2[0] * x2 + e2[3] * y2 + e2[6];
    this.y = e2[1] * x2 + e2[4] * y2 + e2[7];
    return this;
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y;
  }
  cross(v2) {
    return this.x * v2.y - this.y * v2.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  distanceTo(v2) {
    return Math.sqrt(this.distanceToSquared(v2));
  }
  distanceToSquared(v2) {
    const dx = this.x - v2.x, dy = this.y - v2.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v2) {
    return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  }
  rotateAround(center, angle) {
    const c2 = Math.cos(angle), s2 = Math.sin(angle);
    const x2 = this.x - center.x;
    const y2 = this.y - center.y;
    this.x = x2 * c2 - y2 * s2 + center.x;
    this.y = x2 * s2 + y2 * c2 + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }
}
Vector2.prototype.isVector2 = true;
class Matrix3 {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  }
  copy(m2) {
    const te = this.elements;
    const me = m2.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m2) {
    const me = m2.elements;
    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
    return this;
  }
  multiply(m2) {
    return this.multiplyMatrices(this, m2);
  }
  premultiply(m2) {
    return this.multiplyMatrices(m2, this);
  }
  multiplyMatrices(a2, b2) {
    const ae = a2.elements;
    const be = b2.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[3], a13 = ae[6];
    const a21 = ae[1], a22 = ae[4], a23 = ae[7];
    const a31 = ae[2], a32 = ae[5], a33 = ae[8];
    const b11 = be[0], b12 = be[3], b13 = be[6];
    const b21 = be[1], b22 = be[4], b23 = be[7];
    const b31 = be[2], b32 = be[5], b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s2) {
    const te = this.elements;
    te[0] *= s2;
    te[3] *= s2;
    te[6] *= s2;
    te[1] *= s2;
    te[4] *= s2;
    te[7] *= s2;
    te[2] *= s2;
    te[5] *= s2;
    te[8] *= s2;
    return this;
  }
  determinant() {
    const te = this.elements;
    const a2 = te[0], b2 = te[1], c2 = te[2], d2 = te[3], e2 = te[4], f2 = te[5], g2 = te[6], h2 = te[7], i2 = te[8];
    return a2 * e2 * i2 - a2 * f2 * h2 - b2 * d2 * i2 + b2 * f2 * g2 + c2 * d2 * h2 - c2 * e2 * g2;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp2;
    const m2 = this.elements;
    tmp2 = m2[1];
    m2[1] = m2[3];
    m2[3] = tmp2;
    tmp2 = m2[2];
    m2[2] = m2[6];
    m2[6] = tmp2;
    tmp2 = m2[5];
    m2[5] = m2[7];
    m2[7] = tmp2;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  transposeIntoArray(r2) {
    const m2 = this.elements;
    r2[0] = m2[0];
    r2[1] = m2[3];
    r2[2] = m2[6];
    r2[3] = m2[1];
    r2[4] = m2[4];
    r2[5] = m2[7];
    r2[6] = m2[2];
    r2[7] = m2[5];
    r2[8] = m2[8];
    return this;
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c2 = Math.cos(rotation);
    const s2 = Math.sin(rotation);
    this.set(sx * c2, sx * s2, -sx * (c2 * cx + s2 * cy) + cx + tx, -sy * s2, sy * c2, -sy * (-s2 * cx + c2 * cy) + cy + ty, 0, 0, 1);
    return this;
  }
  scale(sx, sy) {
    const te = this.elements;
    te[0] *= sx;
    te[3] *= sx;
    te[6] *= sx;
    te[1] *= sy;
    te[4] *= sy;
    te[7] *= sy;
    return this;
  }
  rotate(theta) {
    const c2 = Math.cos(theta);
    const s2 = Math.sin(theta);
    const te = this.elements;
    const a11 = te[0], a12 = te[3], a13 = te[6];
    const a21 = te[1], a22 = te[4], a23 = te[7];
    te[0] = c2 * a11 + s2 * a21;
    te[3] = c2 * a12 + s2 * a22;
    te[6] = c2 * a13 + s2 * a23;
    te[1] = -s2 * a11 + c2 * a21;
    te[4] = -s2 * a12 + c2 * a22;
    te[7] = -s2 * a13 + c2 * a23;
    return this;
  }
  translate(tx, ty) {
    const te = this.elements;
    te[0] += tx * te[2];
    te[3] += tx * te[5];
    te[6] += tx * te[8];
    te[1] += ty * te[2];
    te[4] += ty * te[5];
    te[7] += ty * te[8];
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i2 = 0; i2 < 9; i2++) {
      if (te[i2] !== me[i2])
        return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.elements[i2] = array[i2 + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
Matrix3.prototype.isMatrix3 = true;
function arrayNeedsUint32(array) {
  for (let i2 = array.length - 1; i2 >= 0; --i2) {
    if (array[i2] > 65535)
      return true;
  }
  return false;
}
function createElementNS(name) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", name);
}
const _colorKeywords = {
  "aliceblue": 15792383,
  "antiquewhite": 16444375,
  "aqua": 65535,
  "aquamarine": 8388564,
  "azure": 15794175,
  "beige": 16119260,
  "bisque": 16770244,
  "black": 0,
  "blanchedalmond": 16772045,
  "blue": 255,
  "blueviolet": 9055202,
  "brown": 10824234,
  "burlywood": 14596231,
  "cadetblue": 6266528,
  "chartreuse": 8388352,
  "chocolate": 13789470,
  "coral": 16744272,
  "cornflowerblue": 6591981,
  "cornsilk": 16775388,
  "crimson": 14423100,
  "cyan": 65535,
  "darkblue": 139,
  "darkcyan": 35723,
  "darkgoldenrod": 12092939,
  "darkgray": 11119017,
  "darkgreen": 25600,
  "darkgrey": 11119017,
  "darkkhaki": 12433259,
  "darkmagenta": 9109643,
  "darkolivegreen": 5597999,
  "darkorange": 16747520,
  "darkorchid": 10040012,
  "darkred": 9109504,
  "darksalmon": 15308410,
  "darkseagreen": 9419919,
  "darkslateblue": 4734347,
  "darkslategray": 3100495,
  "darkslategrey": 3100495,
  "darkturquoise": 52945,
  "darkviolet": 9699539,
  "deeppink": 16716947,
  "deepskyblue": 49151,
  "dimgray": 6908265,
  "dimgrey": 6908265,
  "dodgerblue": 2003199,
  "firebrick": 11674146,
  "floralwhite": 16775920,
  "forestgreen": 2263842,
  "fuchsia": 16711935,
  "gainsboro": 14474460,
  "ghostwhite": 16316671,
  "gold": 16766720,
  "goldenrod": 14329120,
  "gray": 8421504,
  "green": 32768,
  "greenyellow": 11403055,
  "grey": 8421504,
  "honeydew": 15794160,
  "hotpink": 16738740,
  "indianred": 13458524,
  "indigo": 4915330,
  "ivory": 16777200,
  "khaki": 15787660,
  "lavender": 15132410,
  "lavenderblush": 16773365,
  "lawngreen": 8190976,
  "lemonchiffon": 16775885,
  "lightblue": 11393254,
  "lightcoral": 15761536,
  "lightcyan": 14745599,
  "lightgoldenrodyellow": 16448210,
  "lightgray": 13882323,
  "lightgreen": 9498256,
  "lightgrey": 13882323,
  "lightpink": 16758465,
  "lightsalmon": 16752762,
  "lightseagreen": 2142890,
  "lightskyblue": 8900346,
  "lightslategray": 7833753,
  "lightslategrey": 7833753,
  "lightsteelblue": 11584734,
  "lightyellow": 16777184,
  "lime": 65280,
  "limegreen": 3329330,
  "linen": 16445670,
  "magenta": 16711935,
  "maroon": 8388608,
  "mediumaquamarine": 6737322,
  "mediumblue": 205,
  "mediumorchid": 12211667,
  "mediumpurple": 9662683,
  "mediumseagreen": 3978097,
  "mediumslateblue": 8087790,
  "mediumspringgreen": 64154,
  "mediumturquoise": 4772300,
  "mediumvioletred": 13047173,
  "midnightblue": 1644912,
  "mintcream": 16121850,
  "mistyrose": 16770273,
  "moccasin": 16770229,
  "navajowhite": 16768685,
  "navy": 128,
  "oldlace": 16643558,
  "olive": 8421376,
  "olivedrab": 7048739,
  "orange": 16753920,
  "orangered": 16729344,
  "orchid": 14315734,
  "palegoldenrod": 15657130,
  "palegreen": 10025880,
  "paleturquoise": 11529966,
  "palevioletred": 14381203,
  "papayawhip": 16773077,
  "peachpuff": 16767673,
  "peru": 13468991,
  "pink": 16761035,
  "plum": 14524637,
  "powderblue": 11591910,
  "purple": 8388736,
  "rebeccapurple": 6697881,
  "red": 16711680,
  "rosybrown": 12357519,
  "royalblue": 4286945,
  "saddlebrown": 9127187,
  "salmon": 16416882,
  "sandybrown": 16032864,
  "seagreen": 3050327,
  "seashell": 16774638,
  "sienna": 10506797,
  "silver": 12632256,
  "skyblue": 8900331,
  "slateblue": 6970061,
  "slategray": 7372944,
  "slategrey": 7372944,
  "snow": 16775930,
  "springgreen": 65407,
  "steelblue": 4620980,
  "tan": 13808780,
  "teal": 32896,
  "thistle": 14204888,
  "tomato": 16737095,
  "turquoise": 4251856,
  "violet": 15631086,
  "wheat": 16113331,
  "white": 16777215,
  "whitesmoke": 16119285,
  "yellow": 16776960,
  "yellowgreen": 10145074
};
const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(p2, q2, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p2 + (q2 - p2) * 6 * t2;
  if (t2 < 1 / 2)
    return q2;
  if (t2 < 2 / 3)
    return p2 + (q2 - p2) * 6 * (2 / 3 - t2);
  return p2;
}
function SRGBToLinear(c2) {
  return c2 < 0.04045 ? c2 * 0.0773993808 : Math.pow(c2 * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c2) {
  return c2 < 31308e-7 ? c2 * 12.92 : 1.055 * Math.pow(c2, 0.41666) - 0.055;
}
class Color {
  constructor(r2, g2, b2) {
    if (g2 === void 0 && b2 === void 0) {
      return this.set(r2);
    }
    return this.setRGB(r2, g2, b2);
  }
  set(value) {
    if (value && value.isColor) {
      this.copy(value);
    } else if (typeof value === "number") {
      this.setHex(value);
    } else if (typeof value === "string") {
      this.setStyle(value);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    return this;
  }
  setRGB(r2, g2, b2) {
    this.r = r2;
    this.g = g2;
    this.b = b2;
    return this;
  }
  setHSL(h2, s2, l2) {
    h2 = euclideanModulo(h2, 1);
    s2 = clamp(s2, 0, 1);
    l2 = clamp(l2, 0, 1);
    if (s2 === 0) {
      this.r = this.g = this.b = l2;
    } else {
      const p2 = l2 <= 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
      const q2 = 2 * l2 - p2;
      this.r = hue2rgb(q2, p2, h2 + 1 / 3);
      this.g = hue2rgb(q2, p2, h2);
      this.b = hue2rgb(q2, p2, h2 - 1 / 3);
    }
    return this;
  }
  setStyle(style) {
    function handleAlpha(string) {
      if (string === void 0)
        return;
      if (parseFloat(string) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    let m2;
    if (m2 = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
      let color;
      const name = m2[1];
      const components2 = m2[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components2)) {
            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
            handleAlpha(color[4]);
            return this;
          }
          if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components2)) {
            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
            handleAlpha(color[4]);
            return this;
          }
          break;
        case "hsl":
        case "hsla":
          if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components2)) {
            const h2 = parseFloat(color[1]) / 360;
            const s2 = parseInt(color[2], 10) / 100;
            const l2 = parseInt(color[3], 10) / 100;
            handleAlpha(color[4]);
            return this.setHSL(h2, s2, l2);
          }
          break;
      }
    } else if (m2 = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      const hex = m2[1];
      const size = hex.length;
      if (size === 3) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
        return this;
      } else if (size === 6) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
        return this;
      }
    }
    if (style && style.length > 0) {
      return this.setColorName(style);
    }
    return this;
  }
  setColorName(style) {
    const hex = _colorKeywords[style.toLowerCase()];
    if (hex !== void 0) {
      this.setHex(hex);
    } else {
      console.warn("THREE.Color: Unknown color " + style);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  }
  copySRGBToLinear(color) {
    this.r = SRGBToLinear(color.r);
    this.g = SRGBToLinear(color.g);
    this.b = SRGBToLinear(color.b);
    return this;
  }
  copyLinearToSRGB(color) {
    this.r = LinearToSRGB(color.r);
    this.g = LinearToSRGB(color.g);
    this.b = LinearToSRGB(color.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex() {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  }
  getHexString() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }
  getHSL(target) {
    const r2 = this.r, g2 = this.g, b2 = this.b;
    const max = Math.max(r2, g2, b2);
    const min = Math.min(r2, g2, b2);
    let hue, saturation;
    const lightness = (min + max) / 2;
    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
      switch (max) {
        case r2:
          hue = (g2 - b2) / delta + (g2 < b2 ? 6 : 0);
          break;
        case g2:
          hue = (b2 - r2) / delta + 2;
          break;
        case b2:
          hue = (r2 - g2) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }
  getStyle() {
    return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
  }
  offsetHSL(h2, s2, l2) {
    this.getHSL(_hslA);
    _hslA.h += h2;
    _hslA.s += s2;
    _hslA.l += l2;
    this.setHSL(_hslA.h, _hslA.s, _hslA.l);
    return this;
  }
  add(color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  addScalar(s2) {
    this.r += s2;
    this.g += s2;
    this.b += s2;
    return this;
  }
  sub(color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  }
  multiply(color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  }
  multiplyScalar(s2) {
    this.r *= s2;
    this.g *= s2;
    this.b *= s2;
    return this;
  }
  lerp(color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  }
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  lerpHSL(color, alpha) {
    this.getHSL(_hslA);
    color.getHSL(_hslB);
    const h2 = lerp(_hslA.h, _hslB.h, alpha);
    const s2 = lerp(_hslA.s, _hslB.s, alpha);
    const l2 = lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h2, s2, l2);
    return this;
  }
  equals(c2) {
    return c2.r === this.r && c2.g === this.g && c2.b === this.b;
  }
  fromArray(array, offset = 0) {
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.r = attribute.getX(index);
    this.g = attribute.getY(index);
    this.b = attribute.getZ(index);
    if (attribute.normalized === true) {
      this.r /= 255;
      this.g /= 255;
      this.b /= 255;
    }
    return this;
  }
  toJSON() {
    return this.getHex();
  }
}
Color.NAMES = _colorKeywords;
Color.prototype.isColor = true;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;
let _canvas;
class ImageUtils {
  static getDataURL(image) {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }
    if (typeof HTMLCanvasElement == "undefined") {
      return image.src;
    }
    let canvas;
    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === void 0)
        _canvas = createElementNS("canvas");
      _canvas.width = image.width;
      _canvas.height = image.height;
      const context = _canvas.getContext("2d");
      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas = _canvas;
    }
    if (canvas.width > 2048 || canvas.height > 2048) {
      console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
      return canvas.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas.toDataURL("image/png");
    }
  }
  static sRGBToLinear(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      const canvas = createElementNS("canvas");
      canvas.width = image.width;
      canvas.height = image.height;
      const context = canvas.getContext("2d");
      context.drawImage(image, 0, 0, image.width, image.height);
      const imageData = context.getImageData(0, 0, image.width, image.height);
      const data = imageData.data;
      for (let i2 = 0; i2 < data.length; i2++) {
        data[i2] = SRGBToLinear(data[i2] / 255) * 255;
      }
      context.putImageData(imageData, 0, 0);
      return canvas;
    } else if (image.data) {
      const data = image.data.slice(0);
      for (let i2 = 0; i2 < data.length; i2++) {
        if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
          data[i2] = Math.floor(SRGBToLinear(data[i2] / 255) * 255);
        } else {
          data[i2] = SRGBToLinear(data[i2]);
        }
      }
      return {
        data,
        width: image.width,
        height: image.height
      };
    } else {
      console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
      return image;
    }
  }
}
class Source {
  constructor(data = null) {
    this.uuid = generateUUID();
    this.data = data;
    this.version = 0;
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.images[this.uuid] !== void 0) {
      return meta.images[this.uuid];
    }
    const output = {
      uuid: this.uuid,
      url: ""
    };
    const data = this.data;
    if (data !== null) {
      let url;
      if (Array.isArray(data)) {
        url = [];
        for (let i2 = 0, l2 = data.length; i2 < l2; i2++) {
          if (data[i2].isDataTexture) {
            url.push(serializeImage(data[i2].image));
          } else {
            url.push(serializeImage(data[i2]));
          }
        }
      } else {
        url = serializeImage(data);
      }
      output.url = url;
    }
    if (!isRootObject) {
      meta.images[this.uuid] = output;
    }
    return output;
  }
}
function serializeImage(image) {
  if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.prototype.slice.call(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
Source.prototype.isSource = true;
let textureId = 0;
class Texture extends EventDispatcher {
  constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
    super();
    Object.defineProperty(this, "id", { value: textureId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.source = new Source(image);
    this.mipmaps = [];
    this.mapping = mapping;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.encoding = encoding;
    this.userData = {};
    this.version = 0;
    this.onUpdate = null;
    this.isRenderTargetTexture = false;
    this.needsPMREMUpdate = false;
  }
  get image() {
    return this.source.data;
  }
  set image(value) {
    this.source.data = value;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.source = source.source;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.encoding = source.encoding;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(meta).uuid,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (JSON.stringify(this.userData) !== "{}")
      output.userData = this.userData;
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(uv) {
    if (this.mapping !== UVMapping)
      return uv;
    uv.applyMatrix3(this.matrix);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }
          break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
    return uv;
  }
  set needsUpdate(value) {
    if (value === true) {
      this.version++;
      this.source.needsUpdate = true;
    }
  }
}
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype.isTexture = true;
class Vector4 {
  constructor(x2 = 0, y2 = 0, z2 = 0, w2 = 1) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
    this.w = w2;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x2, y2, z2, w2) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
    this.w = w2;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  setX(x2) {
    this.x = x2;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setZ(z2) {
    this.z = z2;
    return this;
  }
  setW(w2) {
    this.w = w2;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    this.z = v2.z;
    this.w = v2.w !== void 0 ? v2.w : 1;
    return this;
  }
  add(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v2, w2);
    }
    this.x += v2.x;
    this.y += v2.y;
    this.z += v2.z;
    this.w += v2.w;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    this.z += s2;
    this.w += s2;
    return this;
  }
  addVectors(a2, b2) {
    this.x = a2.x + b2.x;
    this.y = a2.y + b2.y;
    this.z = a2.z + b2.z;
    this.w = a2.w + b2.w;
    return this;
  }
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    this.z += v2.z * s2;
    this.w += v2.w * s2;
    return this;
  }
  sub(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v2, w2);
    }
    this.x -= v2.x;
    this.y -= v2.y;
    this.z -= v2.z;
    this.w -= v2.w;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    this.z -= s2;
    this.w -= s2;
    return this;
  }
  subVectors(a2, b2) {
    this.x = a2.x - b2.x;
    this.y = a2.y - b2.y;
    this.z = a2.z - b2.z;
    this.w = a2.w - b2.w;
    return this;
  }
  multiply(v2) {
    this.x *= v2.x;
    this.y *= v2.y;
    this.z *= v2.z;
    this.w *= v2.w;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  applyMatrix4(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z, w2 = this.w;
    const e2 = m2.elements;
    this.x = e2[0] * x2 + e2[4] * y2 + e2[8] * z2 + e2[12] * w2;
    this.y = e2[1] * x2 + e2[5] * y2 + e2[9] * z2 + e2[13] * w2;
    this.z = e2[2] * x2 + e2[6] * y2 + e2[10] * z2 + e2[14] * w2;
    this.w = e2[3] * x2 + e2[7] * y2 + e2[11] * z2 + e2[15] * w2;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  setAxisAngleFromQuaternion(q2) {
    this.w = 2 * Math.acos(q2.w);
    const s2 = Math.sqrt(1 - q2.w * q2.w);
    if (s2 < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q2.x / s2;
      this.y = q2.y / s2;
      this.z = q2.z / s2;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m2) {
    let angle, x2, y2, z2;
    const epsilon = 0.01, epsilon2 = 0.1, te = m2.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x2 = 0;
          y2 = 0.707106781;
          z2 = 0.707106781;
        } else {
          x2 = Math.sqrt(xx);
          y2 = xy / x2;
          z2 = xz / x2;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x2 = 0.707106781;
          y2 = 0;
          z2 = 0.707106781;
        } else {
          y2 = Math.sqrt(yy);
          x2 = xy / y2;
          z2 = yz / y2;
        }
      } else {
        if (zz < epsilon) {
          x2 = 0.707106781;
          y2 = 0.707106781;
          z2 = 0;
        } else {
          z2 = Math.sqrt(zz);
          x2 = xz / z2;
          y2 = yz / z2;
        }
      }
      this.set(x2, y2, z2, angle);
      return this;
    }
    let s2 = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s2) < 1e-3)
      s2 = 1;
    this.x = (m32 - m23) / s2;
    this.y = (m13 - m31) / s2;
    this.z = (m21 - m12) / s2;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    this.z = Math.min(this.z, v2.z);
    this.w = Math.min(this.w, v2.w);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    this.z = Math.max(this.z, v2.z);
    this.w = Math.max(this.w, v2.w);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y + this.z * v2.z + this.w * v2.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    this.z += (v2.z - this.z) * alpha;
    this.w += (v2.w - this.w) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    this.w = v1.w + (v2.w - v1.w) * alpha;
    return this;
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y && v2.z === this.z && v2.w === this.w;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
    yield this.w;
  }
}
Vector4.prototype.isVector4 = true;
class WebGLRenderTarget extends EventDispatcher {
  constructor(width, height, options = {}) {
    super();
    this.width = width;
    this.height = height;
    this.depth = 1;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    const image = { width, height, depth: 1 };
    this.texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.isRenderTargetTexture = true;
    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
    this.texture.internalFormat = options.internalFormat !== void 0 ? options.internalFormat : null;
    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
    this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : false;
    this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;
    this.samples = options.samples !== void 0 ? options.samples : 0;
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.texture.image.width = width;
      this.texture.image.height = height;
      this.texture.image.depth = depth;
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.texture.image = Object.assign({}, source.texture.image);
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    if (source.depthTexture !== null)
      this.depthTexture = source.depthTexture.clone();
    this.samples = source.samples;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
class DataArrayTexture extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
}
DataArrayTexture.prototype.isDataArrayTexture = true;
class WebGLArrayRenderTarget extends WebGLRenderTarget {
  constructor(width, height, depth) {
    super(width, height);
    this.depth = depth;
    this.texture = new DataArrayTexture(null, width, height, depth);
    this.texture.isRenderTargetTexture = true;
  }
}
WebGLArrayRenderTarget.prototype.isWebGLArrayRenderTarget = true;
class Data3DTexture extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
}
Data3DTexture.prototype.isData3DTexture = true;
class WebGL3DRenderTarget extends WebGLRenderTarget {
  constructor(width, height, depth) {
    super(width, height);
    this.depth = depth;
    this.texture = new Data3DTexture(null, width, height, depth);
    this.texture.isRenderTargetTexture = true;
  }
}
WebGL3DRenderTarget.prototype.isWebGL3DRenderTarget = true;
class WebGLMultipleRenderTargets extends WebGLRenderTarget {
  constructor(width, height, count, options = {}) {
    super(width, height, options);
    const texture = this.texture;
    this.texture = [];
    for (let i2 = 0; i2 < count; i2++) {
      this.texture[i2] = texture.clone();
    }
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      for (let i2 = 0, il = this.texture.length; i2 < il; i2++) {
        this.texture[i2].image.width = width;
        this.texture[i2].image.height = height;
        this.texture[i2].image.depth = depth;
      }
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
    return this;
  }
  copy(source) {
    this.dispose();
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.viewport.set(0, 0, this.width, this.height);
    this.scissor.set(0, 0, this.width, this.height);
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    this.texture.length = 0;
    for (let i2 = 0, il = source.texture.length; i2 < il; i2++) {
      this.texture[i2] = source.texture[i2].clone();
    }
    return this;
  }
}
WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;
class Quaternion {
  constructor(x2 = 0, y2 = 0, z2 = 0, w2 = 1) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._w = w2;
  }
  static slerp(qa, qb, qm, t2) {
    console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.");
    return qm.slerpQuaternions(qa, qb, t2);
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t2) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (t2 === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }
    if (t2 === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s2 = 1 - t2;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
        s2 = Math.sin(s2 * len) / sin;
        t2 = Math.sin(t2 * len) / sin;
      }
      const tDir = t2 * dir;
      x0 = x0 * s2 + x1 * tDir;
      y0 = y0 * s2 + y1 * tDir;
      z0 = z0 * s2 + z1 * tDir;
      w0 = w0 * s2 + w1 * tDir;
      if (s2 === 1 - t2) {
        const f2 = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f2;
        y0 *= f2;
        z0 *= f2;
        w0 *= f2;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x2, y2, z2, w2) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._w = w2;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update) {
    if (!(euler && euler.isEuler)) {
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    const x2 = euler._x, y2 = euler._y, z2 = euler._z, order = euler._order;
    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x2 / 2);
    const c2 = cos(y2 / 2);
    const c3 = cos(z2 / 2);
    const s1 = sin(x2 / 2);
    const s2 = sin(y2 / 2);
    const s3 = sin(z2 / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update !== false)
      this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2, s2 = Math.sin(halfAngle);
    this._x = axis.x * s2;
    this._y = axis.y * s2;
    this._z = axis.z * s2;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m2) {
    const te = m2.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s2 = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s2;
      this._x = (m32 - m23) * s2;
      this._y = (m13 - m31) * s2;
      this._z = (m21 - m12) * s2;
    } else if (m11 > m22 && m11 > m33) {
      const s2 = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s2;
      this._x = 0.25 * s2;
      this._y = (m12 + m21) / s2;
      this._z = (m13 + m31) / s2;
    } else if (m22 > m33) {
      const s2 = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s2;
      this._x = (m12 + m21) / s2;
      this._y = 0.25 * s2;
      this._z = (m23 + m32) / s2;
    } else {
      const s2 = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s2;
      this._x = (m13 + m31) / s2;
      this._y = (m23 + m32) / s2;
      this._z = 0.25 * s2;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    let r2 = vFrom.dot(vTo) + 1;
    if (r2 < Number.EPSILON) {
      r2 = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r2;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r2;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r2;
    }
    return this.normalize();
  }
  angleTo(q2) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(q2), -1, 1)));
  }
  rotateTowards(q2, step) {
    const angle = this.angleTo(q2);
    if (angle === 0)
      return this;
    const t2 = Math.min(1, step / angle);
    this.slerp(q2, t2);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v2) {
    return this._x * v2._x + this._y * v2._y + this._z * v2._z + this._w * v2._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l2 = this.length();
    if (l2 === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l2 = 1 / l2;
      this._x = this._x * l2;
      this._y = this._y * l2;
      this._z = this._z * l2;
      this._w = this._w * l2;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q2, p2) {
    if (p2 !== void 0) {
      console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
      return this.multiplyQuaternions(q2, p2);
    }
    return this.multiplyQuaternions(this, q2);
  }
  premultiply(q2) {
    return this.multiplyQuaternions(q2, this);
  }
  multiplyQuaternions(a2, b2) {
    const qax = a2._x, qay = a2._y, qaz = a2._z, qaw = a2._w;
    const qbx = b2._x, qby = b2._y, qbz = b2._z, qbw = b2._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb, t2) {
    if (t2 === 0)
      return this;
    if (t2 === 1)
      return this.copy(qb);
    const x2 = this._x, y2 = this._y, z2 = this._z, w2 = this._w;
    let cosHalfTheta = w2 * qb._w + x2 * qb._x + y2 * qb._y + z2 * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w2;
      this._x = x2;
      this._y = y2;
      this._z = z2;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s2 = 1 - t2;
      this._w = s2 * w2 + t2 * this._w;
      this._x = s2 * x2 + t2 * this._x;
      this._y = s2 * y2 + t2 * this._y;
      this._z = s2 * z2 + t2 * this._z;
      this.normalize();
      this._onChangeCallback();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t2) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t2 * halfTheta) / sinHalfTheta;
    this._w = w2 * ratioA + this._w * ratioB;
    this._x = x2 * ratioA + this._x * ratioB;
    this._y = y2 * ratioA + this._y * ratioB;
    this._z = z2 * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  slerpQuaternions(qa, qb, t2) {
    return this.copy(qa).slerp(qb, t2);
  }
  random() {
    const u1 = Math.random();
    const sqrt1u1 = Math.sqrt(1 - u1);
    const sqrtu1 = Math.sqrt(u1);
    const u2 = 2 * Math.PI * Math.random();
    const u3 = 2 * Math.PI * Math.random();
    return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
  }
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    return this;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
}
Quaternion.prototype.isQuaternion = true;
class Vector3 {
  constructor(x2 = 0, y2 = 0, z2 = 0) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
  }
  set(x2, y2, z2) {
    if (z2 === void 0)
      z2 = this.z;
    this.x = x2;
    this.y = y2;
    this.z = z2;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x2) {
    this.x = x2;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setZ(z2) {
    this.z = z2;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    this.z = v2.z;
    return this;
  }
  add(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v2, w2);
    }
    this.x += v2.x;
    this.y += v2.y;
    this.z += v2.z;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    this.z += s2;
    return this;
  }
  addVectors(a2, b2) {
    this.x = a2.x + b2.x;
    this.y = a2.y + b2.y;
    this.z = a2.z + b2.z;
    return this;
  }
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    this.z += v2.z * s2;
    return this;
  }
  sub(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v2, w2);
    }
    this.x -= v2.x;
    this.y -= v2.y;
    this.z -= v2.z;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    this.z -= s2;
    return this;
  }
  subVectors(a2, b2) {
    this.x = a2.x - b2.x;
    this.y = a2.y - b2.y;
    this.z = a2.z - b2.z;
    return this;
  }
  multiply(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
      return this.multiplyVectors(v2, w2);
    }
    this.x *= v2.x;
    this.y *= v2.y;
    this.z *= v2.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a2, b2) {
    this.x = a2.x * b2.x;
    this.y = a2.y * b2.y;
    this.z = a2.z * b2.z;
    return this;
  }
  applyEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const e2 = m2.elements;
    this.x = e2[0] * x2 + e2[3] * y2 + e2[6] * z2;
    this.y = e2[1] * x2 + e2[4] * y2 + e2[7] * z2;
    this.z = e2[2] * x2 + e2[5] * y2 + e2[8] * z2;
    return this;
  }
  applyNormalMatrix(m2) {
    return this.applyMatrix3(m2).normalize();
  }
  applyMatrix4(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const e2 = m2.elements;
    const w2 = 1 / (e2[3] * x2 + e2[7] * y2 + e2[11] * z2 + e2[15]);
    this.x = (e2[0] * x2 + e2[4] * y2 + e2[8] * z2 + e2[12]) * w2;
    this.y = (e2[1] * x2 + e2[5] * y2 + e2[9] * z2 + e2[13]) * w2;
    this.z = (e2[2] * x2 + e2[6] * y2 + e2[10] * z2 + e2[14]) * w2;
    return this;
  }
  applyQuaternion(q2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const qx = q2.x, qy = q2.y, qz = q2.z, qw = q2.w;
    const ix = qw * x2 + qy * z2 - qz * y2;
    const iy = qw * y2 + qz * x2 - qx * z2;
    const iz = qw * z2 + qx * y2 - qy * x2;
    const iw = -qx * x2 - qy * y2 - qz * z2;
    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  }
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }
  transformDirection(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const e2 = m2.elements;
    this.x = e2[0] * x2 + e2[4] * y2 + e2[8] * z2;
    this.y = e2[1] * x2 + e2[5] * y2 + e2[9] * z2;
    this.z = e2[2] * x2 + e2[6] * y2 + e2[10] * z2;
    return this.normalize();
  }
  divide(v2) {
    this.x /= v2.x;
    this.y /= v2.y;
    this.z /= v2.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    this.z = Math.min(this.z, v2.z);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    this.z = Math.max(this.z, v2.z);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y + this.z * v2.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    this.z += (v2.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }
  cross(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
      return this.crossVectors(v2, w2);
    }
    return this.crossVectors(this, v2);
  }
  crossVectors(a2, b2) {
    const ax = a2.x, ay = a2.y, az = a2.z;
    const bx = b2.x, by = b2.y, bz = b2.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  projectOnVector(v2) {
    const denominator = v2.lengthSq();
    if (denominator === 0)
      return this.set(0, 0, 0);
    const scalar = v2.dot(this) / denominator;
    return this.copy(v2).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector$c.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector$c);
  }
  reflect(normal) {
    return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v2) {
    const denominator = Math.sqrt(this.lengthSq() * v2.lengthSq());
    if (denominator === 0)
      return Math.PI / 2;
    const theta = this.dot(v2) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  distanceTo(v2) {
    return Math.sqrt(this.distanceToSquared(v2));
  }
  distanceToSquared(v2) {
    const dx = this.x - v2.x, dy = this.y - v2.y, dz = this.z - v2.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v2) {
    return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y) + Math.abs(this.z - v2.z);
  }
  setFromSpherical(s2) {
    return this.setFromSphericalCoords(s2.radius, s2.phi, s2.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c2) {
    return this.setFromCylindricalCoords(c2.radius, c2.theta, c2.y);
  }
  setFromCylindricalCoords(radius, theta, y2) {
    this.x = radius * Math.sin(theta);
    this.y = y2;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m2) {
    const e2 = m2.elements;
    this.x = e2[12];
    this.y = e2[13];
    this.z = e2[14];
    return this;
  }
  setFromMatrixScale(m2) {
    const sx = this.setFromMatrixColumn(m2, 0).length();
    const sy = this.setFromMatrixColumn(m2, 1).length();
    const sz = this.setFromMatrixColumn(m2, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m2, index) {
    return this.fromArray(m2.elements, index * 4);
  }
  setFromMatrix3Column(m2, index) {
    return this.fromArray(m2.elements, index * 3);
  }
  setFromEuler(e2) {
    this.x = e2._x;
    this.y = e2._y;
    this.z = e2._z;
    return this;
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y && v2.z === this.z;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
  randomDirection() {
    const u2 = (Math.random() - 0.5) * 2;
    const t2 = Math.random() * Math.PI * 2;
    const f2 = Math.sqrt(1 - u2 ** 2);
    this.x = f2 * Math.cos(t2);
    this.y = f2 * Math.sin(t2);
    this.z = u2;
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }
}
Vector3.prototype.isVector3 = true;
const _vector$c = /* @__PURE__ */ new Vector3();
const _quaternion$4 = /* @__PURE__ */ new Quaternion();
class Box3 {
  constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromArray(array) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i2 = 0, l2 = array.length; i2 < l2; i2 += 3) {
      const x2 = array[i2];
      const y2 = array[i2 + 1];
      const z2 = array[i2 + 2];
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
      if (z2 < minZ)
        minZ = z2;
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
      if (z2 > maxZ)
        maxZ = z2;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromBufferAttribute(attribute) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i2 = 0, l2 = attribute.count; i2 < l2; i2++) {
      const x2 = attribute.getX(i2);
      const y2 = attribute.getY(i2);
      const z2 = attribute.getZ(i2);
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
      if (z2 < minZ)
        minZ = z2;
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
      if (z2 > maxZ)
        maxZ = z2;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i2 = 0, il = points.length; i2 < il; i2++) {
      this.expandByPoint(points[i2]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  setFromObject(object, precise = false) {
    this.makeEmpty();
    return this.expandByObject(object, precise);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  expandByObject(object, precise = false) {
    object.updateWorldMatrix(false, false);
    const geometry = object.geometry;
    if (geometry !== void 0) {
      if (precise && geometry.attributes != void 0 && geometry.attributes.position !== void 0) {
        const position = geometry.attributes.position;
        for (let i2 = 0, l2 = position.count; i2 < l2; i2++) {
          _vector$b.fromBufferAttribute(position, i2).applyMatrix4(object.matrixWorld);
          this.expandByPoint(_vector$b);
        }
      } else {
        if (geometry.boundingBox === null) {
          geometry.computeBoundingBox();
        }
        _box$3.copy(geometry.boundingBox);
        _box$3.applyMatrix4(object.matrixWorld);
        this.union(_box$3);
      }
    }
    const children = object.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      this.expandByObject(children[i2], precise);
    }
    return this;
  }
  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }
  getParameter(point, target) {
    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$b);
    return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  intersectsPlane(plane) {
    let min, max;
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }
    return min <= -plane.constant && max >= -plane.constant;
  }
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0$2.subVectors(triangle.a, _center);
    _v1$7.subVectors(triangle.b, _center);
    _v2$3.subVectors(triangle.c, _center);
    _f0.subVectors(_v1$7, _v0$2);
    _f1.subVectors(_v2$3, _v1$7);
    _f2.subVectors(_v0$2, _v2$3);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
  }
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);
    return clampedPoint.sub(point).length();
  }
  getBoundingSphere(target) {
    this.getCenter(target.center);
    target.radius = this.getSize(_vector$b).length() * 0.5;
    return target;
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty())
      this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty())
      return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
}
Box3.prototype.isBox3 = true;
const _points = [
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3()
];
const _vector$b = /* @__PURE__ */ new Vector3();
const _box$3 = /* @__PURE__ */ new Box3();
const _v0$2 = /* @__PURE__ */ new Vector3();
const _v1$7 = /* @__PURE__ */ new Vector3();
const _v2$3 = /* @__PURE__ */ new Vector3();
const _f0 = /* @__PURE__ */ new Vector3();
const _f1 = /* @__PURE__ */ new Vector3();
const _f2 = /* @__PURE__ */ new Vector3();
const _center = /* @__PURE__ */ new Vector3();
const _extents = /* @__PURE__ */ new Vector3();
const _triangleNormal = /* @__PURE__ */ new Vector3();
const _testAxis = /* @__PURE__ */ new Vector3();
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i2 = 0, j2 = axes.length - 3; i2 <= j2; i2 += 3) {
    _testAxis.fromArray(axes, i2);
    const r2 = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r2) {
      return false;
    }
  }
  return true;
}
const _box$2 = /* @__PURE__ */ new Box3();
const _v1$6 = /* @__PURE__ */ new Vector3();
const _toFarthestPoint = /* @__PURE__ */ new Vector3();
const _toPoint = /* @__PURE__ */ new Vector3();
class Sphere {
  constructor(center = new Vector3(), radius = -1) {
    this.center = center;
    this.radius = radius;
  }
  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }
  setFromPoints(points, optionalCenter) {
    const center = this.center;
    if (optionalCenter !== void 0) {
      center.copy(optionalCenter);
    } else {
      _box$2.setFromPoints(points).getCenter(center);
    }
    let maxRadiusSq = 0;
    for (let i2 = 0, il = points.length; i2 < il; i2++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    target.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  }
  getBoundingBox(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
      return target;
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  translate(offset) {
    this.center.add(offset);
    return this;
  }
  expandByPoint(point) {
    _toPoint.subVectors(point, this.center);
    const lengthSq = _toPoint.lengthSq();
    if (lengthSq > this.radius * this.radius) {
      const length = Math.sqrt(lengthSq);
      const missingRadiusHalf = (length - this.radius) * 0.5;
      this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
      this.radius += missingRadiusHalf;
    }
    return this;
  }
  union(sphere) {
    if (this.center.equals(sphere.center) === true) {
      _toFarthestPoint.set(0, 0, 1).multiplyScalar(sphere.radius);
    } else {
      _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);
    }
    this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
    this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
    return this;
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$a = /* @__PURE__ */ new Vector3();
const _segCenter = /* @__PURE__ */ new Vector3();
const _segDir = /* @__PURE__ */ new Vector3();
const _diff = /* @__PURE__ */ new Vector3();
const _edge1 = /* @__PURE__ */ new Vector3();
const _edge2 = /* @__PURE__ */ new Vector3();
const _normal$1 = /* @__PURE__ */ new Vector3();
class Ray {
  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction;
  }
  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  at(t2, target) {
    return target.copy(this.direction).multiplyScalar(t2).add(this.origin);
  }
  lookAt(v2) {
    this.direction.copy(v2).sub(this.origin).normalize();
    return this;
  }
  recast(t2) {
    this.origin.copy(this.at(t2, _vector$a));
    return this;
  }
  closestPointToPoint(point, target) {
    target.subVectors(point, this.origin);
    const directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  }
  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }
  distanceSqToPoint(point) {
    const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }
    _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    return _vector$a.distanceToSquared(point);
  }
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
    _segDir.copy(v1).sub(v0).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b0 = _diff.dot(this.direction);
    const b1 = -_diff.dot(_segDir);
    const c2 = _diff.lengthSq();
    const det = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;
    if (det > 0) {
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            const invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c2;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c2;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
    }
    return sqrDist;
  }
  intersectSphere(sphere, target) {
    _vector$a.subVectors(sphere.center, this.origin);
    const tca = _vector$a.dot(this.direction);
    const d2 = _vector$a.dot(_vector$a) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2)
      return null;
    const thc = Math.sqrt(radius2 - d2);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t0 < 0 && t1 < 0)
      return null;
    if (t0 < 0)
      return this.at(t1, target);
    return this.at(t0, target);
  }
  intersectsSphere(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t2 = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t2 >= 0 ? t2 : null;
  }
  intersectPlane(plane, target) {
    const t2 = this.distanceToPlane(plane);
    if (t2 === null) {
      return null;
    }
    return this.at(t2, target);
  }
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax)
      return null;
    if (tymin > tmin || tmin !== tmin)
      tmin = tymin;
    if (tymax < tmax || tmax !== tmax)
      tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax)
      return null;
    if (tzmin > tmin || tmin !== tmin)
      tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax)
      tmax = tzmax;
    if (tmax < 0)
      return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }
  intersectsBox(box) {
    return this.intersectBox(box, _vector$a) !== null;
  }
  intersectTriangle(a2, b2, c2, backfaceCulling, target) {
    _edge1.subVectors(b2, a2);
    _edge2.subVectors(c2, a2);
    _normal$1.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal$1);
    let sign2;
    if (DdN > 0) {
      if (backfaceCulling)
        return null;
      sign2 = 1;
    } else if (DdN < 0) {
      sign2 = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a2);
    const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign2 * _diff.dot(_normal$1);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target);
  }
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }
  equals(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Matrix4 {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(m2) {
    const te = this.elements;
    const me = m2.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }
  copyPosition(m2) {
    const te = this.elements, me = m2.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }
  setFromMatrix3(m2) {
    const me = m2.elements;
    this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  }
  extractRotation(m2) {
    const te = this.elements;
    const me = m2.elements;
    const scaleX = 1 / _v1$5.setFromMatrixColumn(m2, 0).length();
    const scaleY = 1 / _v1$5.setFromMatrixColumn(m2, 1).length();
    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m2, 2).length();
    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    }
    const te = this.elements;
    const x2 = euler.x, y2 = euler.y, z2 = euler.z;
    const a2 = Math.cos(x2), b2 = Math.sin(x2);
    const c2 = Math.cos(y2), d2 = Math.sin(y2);
    const e2 = Math.cos(z2), f2 = Math.sin(z2);
    if (euler.order === "XYZ") {
      const ae = a2 * e2, af = a2 * f2, be = b2 * e2, bf = b2 * f2;
      te[0] = c2 * e2;
      te[4] = -c2 * f2;
      te[8] = d2;
      te[1] = af + be * d2;
      te[5] = ae - bf * d2;
      te[9] = -b2 * c2;
      te[2] = bf - ae * d2;
      te[6] = be + af * d2;
      te[10] = a2 * c2;
    } else if (euler.order === "YXZ") {
      const ce = c2 * e2, cf = c2 * f2, de = d2 * e2, df = d2 * f2;
      te[0] = ce + df * b2;
      te[4] = de * b2 - cf;
      te[8] = a2 * d2;
      te[1] = a2 * f2;
      te[5] = a2 * e2;
      te[9] = -b2;
      te[2] = cf * b2 - de;
      te[6] = df + ce * b2;
      te[10] = a2 * c2;
    } else if (euler.order === "ZXY") {
      const ce = c2 * e2, cf = c2 * f2, de = d2 * e2, df = d2 * f2;
      te[0] = ce - df * b2;
      te[4] = -a2 * f2;
      te[8] = de + cf * b2;
      te[1] = cf + de * b2;
      te[5] = a2 * e2;
      te[9] = df - ce * b2;
      te[2] = -a2 * d2;
      te[6] = b2;
      te[10] = a2 * c2;
    } else if (euler.order === "ZYX") {
      const ae = a2 * e2, af = a2 * f2, be = b2 * e2, bf = b2 * f2;
      te[0] = c2 * e2;
      te[4] = be * d2 - af;
      te[8] = ae * d2 + bf;
      te[1] = c2 * f2;
      te[5] = bf * d2 + ae;
      te[9] = af * d2 - be;
      te[2] = -d2;
      te[6] = b2 * c2;
      te[10] = a2 * c2;
    } else if (euler.order === "YZX") {
      const ac = a2 * c2, ad = a2 * d2, bc = b2 * c2, bd = b2 * d2;
      te[0] = c2 * e2;
      te[4] = bd - ac * f2;
      te[8] = bc * f2 + ad;
      te[1] = f2;
      te[5] = a2 * e2;
      te[9] = -b2 * e2;
      te[2] = -d2 * e2;
      te[6] = ad * f2 + bc;
      te[10] = ac - bd * f2;
    } else if (euler.order === "XZY") {
      const ac = a2 * c2, ad = a2 * d2, bc = b2 * c2, bd = b2 * d2;
      te[0] = c2 * e2;
      te[4] = -f2;
      te[8] = d2 * e2;
      te[1] = ac * f2 + bd;
      te[5] = a2 * e2;
      te[9] = ad * f2 - bc;
      te[2] = bc * f2 - ad;
      te[6] = b2 * e2;
      te[10] = bd * f2 + ac;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q2) {
    return this.compose(_zero, q2, _one);
  }
  lookAt(eye, target, up) {
    const te = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }
  multiply(m2, n2) {
    if (n2 !== void 0) {
      console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
      return this.multiplyMatrices(m2, n2);
    }
    return this.multiplyMatrices(this, m2);
  }
  premultiply(m2) {
    return this.multiplyMatrices(m2, this);
  }
  multiplyMatrices(a2, b2) {
    const ae = a2.elements;
    const be = b2.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s2) {
    const te = this.elements;
    te[0] *= s2;
    te[4] *= s2;
    te[8] *= s2;
    te[12] *= s2;
    te[1] *= s2;
    te[5] *= s2;
    te[9] *= s2;
    te[13] *= s2;
    te[2] *= s2;
    te[6] *= s2;
    te[10] *= s2;
    te[14] *= s2;
    te[3] *= s2;
    te[7] *= s2;
    te[11] *= s2;
    te[15] *= s2;
    return this;
  }
  determinant() {
    const te = this.elements;
    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te = this.elements;
    let tmp2;
    tmp2 = te[1];
    te[1] = te[4];
    te[4] = tmp2;
    tmp2 = te[2];
    te[2] = te[8];
    te[8] = tmp2;
    tmp2 = te[6];
    te[6] = te[9];
    te[9] = tmp2;
    tmp2 = te[3];
    te[3] = te[12];
    te[12] = tmp2;
    tmp2 = te[7];
    te[7] = te[13];
    te[13] = tmp2;
    tmp2 = te[11];
    te[11] = te[14];
    te[14] = tmp2;
    return this;
  }
  setPosition(x2, y2, z2) {
    const te = this.elements;
    if (x2.isVector3) {
      te[12] = x2.x;
      te[13] = x2.y;
      te[14] = x2.z;
    } else {
      te[12] = x2;
      te[13] = y2;
      te[14] = z2;
    }
    return this;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v2) {
    const te = this.elements;
    const x2 = v2.x, y2 = v2.y, z2 = v2.z;
    te[0] *= x2;
    te[4] *= y2;
    te[8] *= z2;
    te[1] *= x2;
    te[5] *= y2;
    te[9] *= z2;
    te[2] *= x2;
    te[6] *= y2;
    te[10] *= z2;
    te[3] *= x2;
    te[7] *= y2;
    te[11] *= z2;
    return this;
  }
  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x2, y2, z2) {
    this.set(1, 0, 0, x2, 0, 1, 0, y2, 0, 0, 1, z2, 0, 0, 0, 1);
    return this;
  }
  makeRotationX(theta) {
    const c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c2, -s2, 0, 0, s2, c2, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationY(theta) {
    const c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(c2, 0, s2, 0, 0, 1, 0, 0, -s2, 0, c2, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationZ(theta) {
    const c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(c2, -s2, 0, 0, s2, c2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationAxis(axis, angle) {
    const c2 = Math.cos(angle);
    const s2 = Math.sin(angle);
    const t2 = 1 - c2;
    const x2 = axis.x, y2 = axis.y, z2 = axis.z;
    const tx = t2 * x2, ty = t2 * y2;
    this.set(tx * x2 + c2, tx * y2 - s2 * z2, tx * z2 + s2 * y2, 0, tx * y2 + s2 * z2, ty * y2 + c2, ty * z2 - s2 * x2, 0, tx * z2 - s2 * y2, ty * z2 + s2 * x2, t2 * z2 * z2 + c2, 0, 0, 0, 0, 1);
    return this;
  }
  makeScale(x2, y2, z2) {
    this.set(x2, 0, 0, 0, 0, y2, 0, 0, 0, 0, z2, 0, 0, 0, 0, 1);
    return this;
  }
  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
    return this;
  }
  compose(position, quaternion, scale) {
    const te = this.elements;
    const x2 = quaternion._x, y2 = quaternion._y, z2 = quaternion._z, w2 = quaternion._w;
    const x22 = x2 + x2, y22 = y2 + y2, z22 = z2 + z2;
    const xx = x2 * x22, xy = x2 * y22, xz = x2 * z22;
    const yy = y2 * y22, yz = y2 * z22, zz = z2 * z22;
    const wx = w2 * x22, wy = w2 * y22, wz = w2 * z22;
    const sx = scale.x, sy = scale.y, sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }
  decompose(position, quaternion, scale) {
    const te = this.elements;
    let sx = _v1$5.set(te[0], te[1], te[2]).length();
    const sy = _v1$5.set(te[4], te[5], te[6]).length();
    const sz = _v1$5.set(te[8], te[9], te[10]).length();
    const det = this.determinant();
    if (det < 0)
      sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14];
    _m1$2.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1$2.elements[0] *= invSX;
    _m1$2.elements[1] *= invSX;
    _m1$2.elements[2] *= invSX;
    _m1$2.elements[4] *= invSY;
    _m1$2.elements[5] *= invSY;
    _m1$2.elements[6] *= invSY;
    _m1$2.elements[8] *= invSZ;
    _m1$2.elements[9] *= invSZ;
    _m1$2.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1$2);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }
  makePerspective(left, right, top, bottom, near, far) {
    if (far === void 0) {
      console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    }
    const te = this.elements;
    const x2 = 2 * near / (right - left);
    const y2 = 2 * near / (top - bottom);
    const a2 = (right + left) / (right - left);
    const b2 = (top + bottom) / (top - bottom);
    const c2 = -(far + near) / (far - near);
    const d2 = -2 * far * near / (far - near);
    te[0] = x2;
    te[4] = 0;
    te[8] = a2;
    te[12] = 0;
    te[1] = 0;
    te[5] = y2;
    te[9] = b2;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c2;
    te[14] = d2;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far) {
    const te = this.elements;
    const w2 = 1 / (right - left);
    const h2 = 1 / (top - bottom);
    const p2 = 1 / (far - near);
    const x2 = (right + left) * w2;
    const y2 = (top + bottom) * h2;
    const z2 = (far + near) * p2;
    te[0] = 2 * w2;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x2;
    te[1] = 0;
    te[5] = 2 * h2;
    te[9] = 0;
    te[13] = -y2;
    te[2] = 0;
    te[6] = 0;
    te[10] = -2 * p2;
    te[14] = -z2;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i2 = 0; i2 < 16; i2++) {
      if (te[i2] !== me[i2])
        return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i2 = 0; i2 < 16; i2++) {
      this.elements[i2] = array[i2 + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }
}
Matrix4.prototype.isMatrix4 = true;
const _v1$5 = /* @__PURE__ */ new Vector3();
const _m1$2 = /* @__PURE__ */ new Matrix4();
const _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
const _one = /* @__PURE__ */ new Vector3(1, 1, 1);
const _x = /* @__PURE__ */ new Vector3();
const _y = /* @__PURE__ */ new Vector3();
const _z = /* @__PURE__ */ new Vector3();
const _matrix$1 = /* @__PURE__ */ new Matrix4();
const _quaternion$3 = /* @__PURE__ */ new Quaternion();
class Euler {
  constructor(x2 = 0, y2 = 0, z2 = 0, order = Euler.DefaultOrder) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._order = order;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x2, y2, z2, order = this._order) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._order = order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m2, order = this._order, update = true) {
    const te = m2.elements;
    const m11 = te[0], m12 = te[4], m13 = te[8];
    const m21 = te[1], m22 = te[5], m23 = te[9];
    const m31 = te[2], m32 = te[6], m33 = te[10];
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
    }
    this._order = order;
    if (update === true)
      this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q2, order, update) {
    _matrix$1.makeRotationFromQuaternion(q2);
    return this.setFromRotationMatrix(_matrix$1, order, update);
  }
  setFromVector3(v2, order = this._order) {
    return this.set(v2.x, v2.y, v2.z, order);
  }
  reorder(newOrder) {
    _quaternion$3.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$3, newOrder);
  }
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0)
      this._order = array[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
}
Euler.prototype.isEuler = true;
Euler.DefaultOrder = "XYZ";
Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class Layers {
  constructor() {
    this.mask = 1 | 0;
  }
  set(channel) {
    this.mask = (1 << channel | 0) >>> 0;
  }
  enable(channel) {
    this.mask |= 1 << channel | 0;
  }
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }
  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
  isEnabled(channel) {
    return (this.mask & (1 << channel | 0)) !== 0;
  }
}
let _object3DId = 0;
const _v1$4 = /* @__PURE__ */ new Vector3();
const _q1 = /* @__PURE__ */ new Quaternion();
const _m1$1 = /* @__PURE__ */ new Matrix4();
const _target = /* @__PURE__ */ new Vector3();
const _position$3 = /* @__PURE__ */ new Vector3();
const _scale$2 = /* @__PURE__ */ new Vector3();
const _quaternion$2 = /* @__PURE__ */ new Quaternion();
const _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
const _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
const _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
const _addedEvent = { type: "added" };
const _removedEvent = { type: "removed" };
class Object3D extends EventDispatcher {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: _object3DId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = Object3D.DefaultUp.clone();
    const position = new Vector3();
    const rotation = new Euler();
    const quaternion = new Quaternion();
    const scale = new Vector3(1, 1, 1);
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, void 0, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale
      },
      modelViewMatrix: {
        value: new Matrix4()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(q2) {
    this.quaternion.premultiply(q2);
    return this;
  }
  setRotationFromAxisAngle(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  }
  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }
  setRotationFromMatrix(m2) {
    this.quaternion.setFromRotationMatrix(m2);
  }
  setRotationFromQuaternion(q2) {
    this.quaternion.copy(q2);
  }
  rotateOnAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  }
  rotateOnWorldAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  }
  rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  }
  rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  }
  rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  }
  translateOnAxis(axis, distance) {
    _v1$4.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$4.multiplyScalar(distance));
    return this;
  }
  translateX(distance) {
    return this.translateOnAxis(_xAxis, distance);
  }
  translateY(distance) {
    return this.translateOnAxis(_yAxis, distance);
  }
  translateZ(distance) {
    return this.translateOnAxis(_zAxis, distance);
  }
  localToWorld(vector) {
    return vector.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(vector) {
    return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
  }
  lookAt(x2, y2, z2) {
    if (x2.isVector3) {
      _target.copy(x2);
    } else {
      _target.set(x2, y2, z2);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position$3.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$1.lookAt(_position$3, _target, this.up);
    } else {
      _m1$1.lookAt(_target, _position$3, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$1);
    if (parent) {
      _m1$1.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$1);
      this.quaternion.premultiply(_q1.invert());
    }
  }
  add(object) {
    if (arguments.length > 1) {
      for (let i2 = 0; i2 < arguments.length; i2++) {
        this.add(arguments[i2]);
      }
      return this;
    }
    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  }
  remove(object) {
    if (arguments.length > 1) {
      for (let i2 = 0; i2 < arguments.length; i2++) {
        this.remove(arguments[i2]);
      }
      return this;
    }
    const index = this.children.indexOf(object);
    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
    }
    return this;
  }
  removeFromParent() {
    const parent = this.parent;
    if (parent !== null) {
      parent.remove(this);
    }
    return this;
  }
  clear() {
    for (let i2 = 0; i2 < this.children.length; i2++) {
      const object = this.children[i2];
      object.parent = null;
      object.dispatchEvent(_removedEvent);
    }
    this.children.length = 0;
    return this;
  }
  attach(object) {
    this.updateWorldMatrix(true, false);
    _m1$1.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1$1.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1$1);
    this.add(object);
    object.updateWorldMatrix(false, true);
    return this;
  }
  getObjectById(id) {
    return this.getObjectByProperty("id", id);
  }
  getObjectByName(name) {
    return this.getObjectByProperty("name", name);
  }
  getObjectByProperty(name, value) {
    if (this[name] === value)
      return this;
    for (let i2 = 0, l2 = this.children.length; i2 < l2; i2++) {
      const child = this.children[i2];
      const object = child.getObjectByProperty(name, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  }
  getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, target, _scale$2);
    return target;
  }
  getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, _quaternion$2, target);
    return target;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e2 = this.matrixWorld.elements;
    return target.set(e2[8], e2[9], e2[10]).normalize();
  }
  raycast() {
  }
  traverse(callback) {
    callback(this);
    const children = this.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      children[i2].traverse(callback);
    }
  }
  traverseVisible(callback) {
    if (this.visible === false)
      return;
    callback(this);
    const children = this.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      children[i2].traverseVisible(callback);
    }
  }
  traverseAncestors(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      children[i2].updateMatrixWorld(force);
    }
  }
  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    }
    if (updateChildren === true) {
      const children = this.children;
      for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
        children[i2].updateWorldMatrix(false, true);
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      };
      output.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "")
      object.name = this.name;
    if (this.castShadow === true)
      object.castShadow = true;
    if (this.receiveShadow === true)
      object.receiveShadow = true;
    if (this.visible === false)
      object.visible = false;
    if (this.frustumCulled === false)
      object.frustumCulled = false;
    if (this.renderOrder !== 0)
      object.renderOrder = this.renderOrder;
    if (JSON.stringify(this.userData) !== "{}")
      object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    if (this.matrixAutoUpdate === false)
      object.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object.type = "InstancedMesh";
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null)
        object.instanceColor = this.instanceColor.toJSON();
    }
    function serialize(library, element) {
      if (library[element.uuid] === void 0) {
        library[element.uuid] = element.toJSON(meta);
      }
      return element.uuid;
    }
    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object.background = this.background.toJSON(meta).uuid;
        }
      }
      if (this.environment && this.environment.isTexture) {
        object.environment = this.environment.toJSON(meta).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
            const shape = shapes[i2];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i2 = 0, l2 = this.material.length; i2 < l2; i2++) {
          uuids.push(serialize(meta.materials, this.material[i2]));
        }
        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (let i2 = 0; i2 < this.children.length; i2++) {
        object.children.push(this.children[i2].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object.animations = [];
      for (let i2 = 0; i2 < this.animations.length; i2++) {
        const animation = this.animations[i2];
        object.animations.push(serialize(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      const nodes = extractFromCache(meta.nodes);
      if (geometries.length > 0)
        output.geometries = geometries;
      if (materials.length > 0)
        output.materials = materials;
      if (textures.length > 0)
        output.textures = textures;
      if (images.length > 0)
        output.images = images;
      if (shapes.length > 0)
        output.shapes = shapes;
      if (skeletons.length > 0)
        output.skeletons = skeletons;
      if (animations.length > 0)
        output.animations = animations;
      if (nodes.length > 0)
        output.nodes = nodes;
    }
    output.object = object;
    return output;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  }
  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }
  copy(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i2 = 0; i2 < source.children.length; i2++) {
        const child = source.children[i2];
        this.add(child.clone());
      }
    }
    return this;
  }
}
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype.isObject3D = true;
const _v0$1 = /* @__PURE__ */ new Vector3();
const _v1$3 = /* @__PURE__ */ new Vector3();
const _v2$2 = /* @__PURE__ */ new Vector3();
const _v3$1 = /* @__PURE__ */ new Vector3();
const _vab = /* @__PURE__ */ new Vector3();
const _vac = /* @__PURE__ */ new Vector3();
const _vbc = /* @__PURE__ */ new Vector3();
const _vap = /* @__PURE__ */ new Vector3();
const _vbp = /* @__PURE__ */ new Vector3();
const _vcp = /* @__PURE__ */ new Vector3();
class Triangle {
  constructor(a2 = new Vector3(), b2 = new Vector3(), c2 = new Vector3()) {
    this.a = a2;
    this.b = b2;
    this.c = c2;
  }
  static getNormal(a2, b2, c2, target) {
    target.subVectors(c2, b2);
    _v0$1.subVectors(a2, b2);
    target.cross(_v0$1);
    const targetLengthSq = target.lengthSq();
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target.set(0, 0, 0);
  }
  static getBarycoord(point, a2, b2, c2, target) {
    _v0$1.subVectors(c2, a2);
    _v1$3.subVectors(b2, a2);
    _v2$2.subVectors(point, a2);
    const dot00 = _v0$1.dot(_v0$1);
    const dot01 = _v0$1.dot(_v1$3);
    const dot02 = _v0$1.dot(_v2$2);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$2);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (denom === 0) {
      return target.set(-2, -1, -1);
    }
    const invDenom = 1 / denom;
    const u2 = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v2 = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target.set(1 - u2 - v2, v2, u2);
  }
  static containsPoint(point, a2, b2, c2) {
    this.getBarycoord(point, a2, b2, c2, _v3$1);
    return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
  }
  static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
    this.getBarycoord(point, p1, p2, p3, _v3$1);
    target.set(0, 0);
    target.addScaledVector(uv1, _v3$1.x);
    target.addScaledVector(uv2, _v3$1.y);
    target.addScaledVector(uv3, _v3$1.z);
    return target;
  }
  static isFrontFacing(a2, b2, c2, direction) {
    _v0$1.subVectors(c2, b2);
    _v1$3.subVectors(a2, b2);
    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
  }
  set(a2, b2, c2) {
    this.a.copy(a2);
    this.b.copy(b2);
    this.c.copy(c2);
    return this;
  }
  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }
  setFromAttributeAndIndices(attribute, i0, i1, i2) {
    this.a.fromBufferAttribute(attribute, i0);
    this.b.fromBufferAttribute(attribute, i1);
    this.c.fromBufferAttribute(attribute, i2);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }
  getArea() {
    _v0$1.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$1.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(target) {
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }
  getPlane(target) {
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }
  getUV(point, uv1, uv2, uv3, target) {
    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
  }
  containsPoint(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  }
  isFrontFacing(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  closestPointToPoint(p2, target) {
    const a2 = this.a, b2 = this.b, c2 = this.c;
    let v2, w2;
    _vab.subVectors(b2, a2);
    _vac.subVectors(c2, a2);
    _vap.subVectors(p2, a2);
    const d1 = _vab.dot(_vap);
    const d2 = _vac.dot(_vap);
    if (d1 <= 0 && d2 <= 0) {
      return target.copy(a2);
    }
    _vbp.subVectors(p2, b2);
    const d3 = _vab.dot(_vbp);
    const d4 = _vac.dot(_vbp);
    if (d3 >= 0 && d4 <= d3) {
      return target.copy(b2);
    }
    const vc = d1 * d4 - d3 * d2;
    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v2 = d1 / (d1 - d3);
      return target.copy(a2).addScaledVector(_vab, v2);
    }
    _vcp.subVectors(p2, c2);
    const d5 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d5 <= d6) {
      return target.copy(c2);
    }
    const vb = d5 * d2 - d1 * d6;
    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w2 = d2 / (d2 - d6);
      return target.copy(a2).addScaledVector(_vac, w2);
    }
    const va = d3 * d6 - d5 * d4;
    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c2, b2);
      w2 = (d4 - d3) / (d4 - d3 + (d5 - d6));
      return target.copy(b2).addScaledVector(_vbc, w2);
    }
    const denom = 1 / (va + vb + vc);
    v2 = vb * denom;
    w2 = vc * denom;
    return target.copy(a2).addScaledVector(_vab, v2).addScaledVector(_vac, w2);
  }
  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
}
let materialId = 0;
class Material extends EventDispatcher {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: materialId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Material";
    this.fog = true;
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.vertexColors = false;
    this.opacity = 1;
    this.transparent = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaToCoverage = false;
    this.premultipliedAlpha = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
    this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(value) {
    if (this._alphaTest > 0 !== value > 0) {
      this.version++;
    }
    this._alphaTest = value;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(values) {
    if (values === void 0)
      return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        console.warn("THREE.Material: '" + key + "' parameter is undefined.");
        continue;
      }
      if (key === "shading") {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        this.flatShading = newValue === FlatShading ? true : false;
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (isRootObject) {
      meta = {
        textures: {},
        images: {}
      };
    }
    const data = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (this.color && this.color.isColor)
      data.color = this.color.getHex();
    if (this.roughness !== void 0)
      data.roughness = this.roughness;
    if (this.metalness !== void 0)
      data.metalness = this.metalness;
    if (this.sheen !== void 0)
      data.sheen = this.sheen;
    if (this.sheenColor && this.sheenColor.isColor)
      data.sheenColor = this.sheenColor.getHex();
    if (this.sheenRoughness !== void 0)
      data.sheenRoughness = this.sheenRoughness;
    if (this.emissive && this.emissive.isColor)
      data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity && this.emissiveIntensity !== 1)
      data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor)
      data.specular = this.specular.getHex();
    if (this.specularIntensity !== void 0)
      data.specularIntensity = this.specularIntensity;
    if (this.specularColor && this.specularColor.isColor)
      data.specularColor = this.specularColor.getHex();
    if (this.shininess !== void 0)
      data.shininess = this.shininess;
    if (this.clearcoat !== void 0)
      data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== void 0)
      data.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.map && this.map.isTexture)
      data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture)
      data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture)
      data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta).uuid;
      data.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture)
      data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture)
      data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture)
      data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture)
      data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
      data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
    if (this.specularColorMap && this.specularColorMap.isTexture)
      data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      if (this.combine !== void 0)
        data.combine = this.combine;
    }
    if (this.envMapIntensity !== void 0)
      data.envMapIntensity = this.envMapIntensity;
    if (this.reflectivity !== void 0)
      data.reflectivity = this.reflectivity;
    if (this.refractionRatio !== void 0)
      data.refractionRatio = this.refractionRatio;
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.transmission !== void 0)
      data.transmission = this.transmission;
    if (this.transmissionMap && this.transmissionMap.isTexture)
      data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
    if (this.thickness !== void 0)
      data.thickness = this.thickness;
    if (this.thicknessMap && this.thicknessMap.isTexture)
      data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
    if (this.attenuationDistance !== void 0)
      data.attenuationDistance = this.attenuationDistance;
    if (this.attenuationColor !== void 0)
      data.attenuationColor = this.attenuationColor.getHex();
    if (this.size !== void 0)
      data.size = this.size;
    if (this.shadowSide !== null)
      data.shadowSide = this.shadowSide;
    if (this.sizeAttenuation !== void 0)
      data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending)
      data.blending = this.blending;
    if (this.side !== FrontSide)
      data.side = this.side;
    if (this.vertexColors)
      data.vertexColors = true;
    if (this.opacity < 1)
      data.opacity = this.opacity;
    if (this.transparent === true)
      data.transparent = this.transparent;
    data.depthFunc = this.depthFunc;
    data.depthTest = this.depthTest;
    data.depthWrite = this.depthWrite;
    data.colorWrite = this.colorWrite;
    data.stencilWrite = this.stencilWrite;
    data.stencilWriteMask = this.stencilWriteMask;
    data.stencilFunc = this.stencilFunc;
    data.stencilRef = this.stencilRef;
    data.stencilFuncMask = this.stencilFuncMask;
    data.stencilFail = this.stencilFail;
    data.stencilZFail = this.stencilZFail;
    data.stencilZPass = this.stencilZPass;
    if (this.rotation !== void 0 && this.rotation !== 0)
      data.rotation = this.rotation;
    if (this.polygonOffset === true)
      data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0)
      data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0)
      data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth !== void 0 && this.linewidth !== 1)
      data.linewidth = this.linewidth;
    if (this.dashSize !== void 0)
      data.dashSize = this.dashSize;
    if (this.gapSize !== void 0)
      data.gapSize = this.gapSize;
    if (this.scale !== void 0)
      data.scale = this.scale;
    if (this.dithering === true)
      data.dithering = true;
    if (this.alphaTest > 0)
      data.alphaTest = this.alphaTest;
    if (this.alphaToCoverage === true)
      data.alphaToCoverage = this.alphaToCoverage;
    if (this.premultipliedAlpha === true)
      data.premultipliedAlpha = this.premultipliedAlpha;
    if (this.wireframe === true)
      data.wireframe = this.wireframe;
    if (this.wireframeLinewidth > 1)
      data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round")
      data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round")
      data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.flatShading === true)
      data.flatShading = this.flatShading;
    if (this.visible === false)
      data.visible = false;
    if (this.toneMapped === false)
      data.toneMapped = false;
    if (JSON.stringify(this.userData) !== "{}")
      data.userData = this.userData;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRootObject) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.fog = source.fog;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n2 = srcPlanes.length;
      dstPlanes = new Array(n2);
      for (let i2 = 0; i2 !== n2; ++i2) {
        dstPlanes[i2] = srcPlanes[i2].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.alphaToCoverage = source.alphaToCoverage;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
}
Material.prototype.isMaterial = true;
Material.fromType = function() {
  return null;
};
class MeshBasicMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    return this;
  }
}
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
const _vector$9 = /* @__PURE__ */ new Vector3();
const _vector2$1 = /* @__PURE__ */ new Vector2();
class BufferAttribute {
  constructor(array, itemSize, normalized) {
    if (Array.isArray(array)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.name = "";
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== void 0 ? array.length / itemSize : 0;
    this.normalized = normalized === true;
    this.usage = StaticDrawUsage;
    this.updateRange = { offset: 0, count: -1 };
    this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  copy(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (let i2 = 0, l2 = this.itemSize; i2 < l2; i2++) {
      this.array[index1 + i2] = attribute.array[index2 + i2];
    }
    return this;
  }
  copyArray(array) {
    this.array.set(array);
    return this;
  }
  copyColorsArray(colors) {
    const array = this.array;
    let offset = 0;
    for (let i2 = 0, l2 = colors.length; i2 < l2; i2++) {
      let color = colors[i2];
      if (color === void 0) {
        console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i2);
        color = new Color();
      }
      array[offset++] = color.r;
      array[offset++] = color.g;
      array[offset++] = color.b;
    }
    return this;
  }
  copyVector2sArray(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i2 = 0, l2 = vectors.length; i2 < l2; i2++) {
      let vector = vectors[i2];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i2);
        vector = new Vector2();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
    }
    return this;
  }
  copyVector3sArray(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i2 = 0, l2 = vectors.length; i2 < l2; i2++) {
      let vector = vectors[i2];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i2);
        vector = new Vector3();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
    }
    return this;
  }
  copyVector4sArray(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i2 = 0, l2 = vectors.length; i2 < l2; i2++) {
      let vector = vectors[i2];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i2);
        vector = new Vector4();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
      array[offset++] = vector.w;
    }
    return this;
  }
  applyMatrix3(m2) {
    if (this.itemSize === 2) {
      for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
        _vector2$1.fromBufferAttribute(this, i2);
        _vector2$1.applyMatrix3(m2);
        this.setXY(i2, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
        _vector$9.fromBufferAttribute(this, i2);
        _vector$9.applyMatrix3(m2);
        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
      }
    }
    return this;
  }
  applyMatrix4(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$9.x = this.getX(i2);
      _vector$9.y = this.getY(i2);
      _vector$9.z = this.getZ(i2);
      _vector$9.applyMatrix4(m2);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  applyNormalMatrix(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$9.x = this.getX(i2);
      _vector$9.y = this.getY(i2);
      _vector$9.z = this.getZ(i2);
      _vector$9.applyNormalMatrix(m2);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  transformDirection(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$9.x = this.getX(i2);
      _vector$9.y = this.getY(i2);
      _vector$9.z = this.getZ(i2);
      _vector$9.transformDirection(m2);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  getX(index) {
    return this.array[index * this.itemSize];
  }
  setX(index, x2) {
    this.array[index * this.itemSize] = x2;
    return this;
  }
  getY(index) {
    return this.array[index * this.itemSize + 1];
  }
  setY(index, y2) {
    this.array[index * this.itemSize + 1] = y2;
    return this;
  }
  getZ(index) {
    return this.array[index * this.itemSize + 2];
  }
  setZ(index, z2) {
    this.array[index * this.itemSize + 2] = z2;
    return this;
  }
  getW(index) {
    return this.array[index * this.itemSize + 3];
  }
  setW(index, w2) {
    this.array[index * this.itemSize + 3] = w2;
    return this;
  }
  setXY(index, x2, y2) {
    index *= this.itemSize;
    this.array[index + 0] = x2;
    this.array[index + 1] = y2;
    return this;
  }
  setXYZ(index, x2, y2, z2) {
    index *= this.itemSize;
    this.array[index + 0] = x2;
    this.array[index + 1] = y2;
    this.array[index + 2] = z2;
    return this;
  }
  setXYZW(index, x2, y2, z2, w2) {
    index *= this.itemSize;
    this.array[index + 0] = x2;
    this.array[index + 1] = y2;
    this.array[index + 2] = z2;
    this.array[index + 3] = w2;
    return this;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    };
    if (this.name !== "")
      data.name = this.name;
    if (this.usage !== StaticDrawUsage)
      data.usage = this.usage;
    if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
      data.updateRange = this.updateRange;
    return data;
  }
}
BufferAttribute.prototype.isBufferAttribute = true;
class Uint16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }
}
class Uint32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint32Array(array), itemSize, normalized);
  }
}
class Float16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }
}
Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
class Float32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float32Array(array), itemSize, normalized);
  }
}
let _id$1 = 0;
const _m1 = /* @__PURE__ */ new Matrix4();
const _obj = /* @__PURE__ */ new Object3D();
const _offset = /* @__PURE__ */ new Vector3();
const _box$1 = /* @__PURE__ */ new Box3();
const _boxMorphTargets = /* @__PURE__ */ new Box3();
const _vector$8 = /* @__PURE__ */ new Vector3();
class BufferGeometry extends EventDispatcher {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: _id$1++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = { start: 0, count: Infinity };
    this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(index) {
    if (Array.isArray(index)) {
      this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }
    return this;
  }
  getAttribute(name) {
    return this.attributes[name];
  }
  setAttribute(name, attribute) {
    this.attributes[name] = attribute;
    return this;
  }
  deleteAttribute(name) {
    delete this.attributes[name];
    return this;
  }
  hasAttribute(name) {
    return this.attributes[name] !== void 0;
  }
  addGroup(start, count, materialIndex = 0) {
    this.groups.push({
      start,
      count,
      materialIndex
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  }
  applyMatrix4(matrix) {
    const position = this.attributes.position;
    if (position !== void 0) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }
    const normal = this.attributes.normal;
    if (normal !== void 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  applyQuaternion(q2) {
    _m1.makeRotationFromQuaternion(q2);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateX(angle) {
    _m1.makeRotationX(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateY(angle) {
    _m1.makeRotationY(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateZ(angle) {
    _m1.makeRotationZ(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  translate(x2, y2, z2) {
    _m1.makeTranslation(x2, y2, z2);
    this.applyMatrix4(_m1);
    return this;
  }
  scale(x2, y2, z2) {
    _m1.makeScale(x2, y2, z2);
    this.applyMatrix4(_m1);
    return this;
  }
  lookAt(vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  }
  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }
  setFromPoints(points) {
    const position = [];
    for (let i2 = 0, l2 = points.length; i2 < l2; i2++) {
      const point = points[i2];
      position.push(point.x, point.y, point.z || 0);
    }
    this.setAttribute("position", new Float32BufferAttribute(position, 3));
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(Infinity, Infinity, Infinity));
      return;
    }
    if (position !== void 0) {
      this.boundingBox.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          _box$1.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(this.boundingBox.min, _box$1.min);
            this.boundingBox.expandByPoint(_vector$8);
            _vector$8.addVectors(this.boundingBox.max, _box$1.max);
            this.boundingBox.expandByPoint(_vector$8);
          } else {
            this.boundingBox.expandByPoint(_box$1.min);
            this.boundingBox.expandByPoint(_box$1.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingSphere.set(new Vector3(), Infinity);
      return;
    }
    if (position) {
      const center = this.boundingSphere.center;
      _box$1.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);
            _box$1.expandByPoint(_vector$8);
            _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);
            _box$1.expandByPoint(_vector$8);
          } else {
            _box$1.expandByPoint(_boxMorphTargets.min);
            _box$1.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$1.getCenter(center);
      let maxRadiusSq = 0;
      for (let i2 = 0, il = position.count; i2 < il; i2++) {
        _vector$8.fromBufferAttribute(position, i2);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
      }
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j2 = 0, jl = morphAttribute.count; j2 < jl; j2++) {
            _vector$8.fromBufferAttribute(morphAttribute, j2);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j2);
              _vector$8.add(_offset);
            }
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }
  computeTangents() {
    const index = this.index;
    const attributes = this.attributes;
    if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const indices = index.array;
    const positions = attributes.position.array;
    const normals = attributes.normal.array;
    const uvs = attributes.uv.array;
    const nVertices = positions.length / 3;
    if (this.hasAttribute("tangent") === false) {
      this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
    }
    const tangents = this.getAttribute("tangent").array;
    const tan1 = [], tan2 = [];
    for (let i2 = 0; i2 < nVertices; i2++) {
      tan1[i2] = new Vector3();
      tan2[i2] = new Vector3();
    }
    const vA2 = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
    function handleTriangle(a2, b2, c2) {
      vA2.fromArray(positions, a2 * 3);
      vB.fromArray(positions, b2 * 3);
      vC.fromArray(positions, c2 * 3);
      uvA.fromArray(uvs, a2 * 2);
      uvB.fromArray(uvs, b2 * 2);
      uvC.fromArray(uvs, c2 * 2);
      vB.sub(vA2);
      vC.sub(vA2);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r2 = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r2))
        return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r2);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r2);
      tan1[a2].add(sdir);
      tan1[b2].add(sdir);
      tan1[c2].add(sdir);
      tan2[a2].add(tdir);
      tan2[b2].add(tdir);
      tan2[c2].add(tdir);
    }
    let groups = this.groups;
    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: indices.length
      }];
    }
    for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
      const group = groups[i2];
      const start = group.start;
      const count = group.count;
      for (let j2 = start, jl = start + count; j2 < jl; j2 += 3) {
        handleTriangle(indices[j2 + 0], indices[j2 + 1], indices[j2 + 2]);
      }
    }
    const tmp2 = new Vector3(), tmp22 = new Vector3();
    const n2 = new Vector3(), n22 = new Vector3();
    function handleVertex(v2) {
      n2.fromArray(normals, v2 * 3);
      n22.copy(n2);
      const t2 = tan1[v2];
      tmp2.copy(t2);
      tmp2.sub(n2.multiplyScalar(n2.dot(t2))).normalize();
      tmp22.crossVectors(n22, t2);
      const test = tmp22.dot(tan2[v2]);
      const w2 = test < 0 ? -1 : 1;
      tangents[v2 * 4] = tmp2.x;
      tangents[v2 * 4 + 1] = tmp2.y;
      tangents[v2 * 4 + 2] = tmp2.z;
      tangents[v2 * 4 + 3] = w2;
    }
    for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
      const group = groups[i2];
      const start = group.start;
      const count = group.count;
      for (let j2 = start, jl = start + count; j2 < jl; j2 += 3) {
        handleVertex(indices[j2 + 0]);
        handleVertex(indices[j2 + 1]);
        handleVertex(indices[j2 + 2]);
      }
    }
  }
  computeVertexNormals() {
    const index = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i2 = 0, il = normalAttribute.count; i2 < il; i2++) {
          normalAttribute.setXYZ(i2, 0, 0, 0);
        }
      }
      const pA2 = new Vector3(), pB = new Vector3(), pC = new Vector3();
      const nA2 = new Vector3(), nB = new Vector3(), nC = new Vector3();
      const cb = new Vector3(), ab = new Vector3();
      if (index) {
        for (let i2 = 0, il = index.count; i2 < il; i2 += 3) {
          const vA2 = index.getX(i2 + 0);
          const vB = index.getX(i2 + 1);
          const vC = index.getX(i2 + 2);
          pA2.fromBufferAttribute(positionAttribute, vA2);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA2, pB);
          cb.cross(ab);
          nA2.fromBufferAttribute(normalAttribute, vA2);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA2.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA2, nA2.x, nA2.y, nA2.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        for (let i2 = 0, il = positionAttribute.count; i2 < il; i2 += 3) {
          pA2.fromBufferAttribute(positionAttribute, i2 + 0);
          pB.fromBufferAttribute(positionAttribute, i2 + 1);
          pC.fromBufferAttribute(positionAttribute, i2 + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA2, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  }
  merge(geometry, offset) {
    if (!(geometry && geometry.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
      return;
    }
    if (offset === void 0) {
      offset = 0;
      console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      if (geometry.attributes[key] === void 0)
        continue;
      const attribute1 = attributes[key];
      const attributeArray1 = attribute1.array;
      const attribute2 = geometry.attributes[key];
      const attributeArray2 = attribute2.array;
      const attributeOffset = attribute2.itemSize * offset;
      const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
      for (let i2 = 0, j2 = attributeOffset; i2 < length; i2++, j2++) {
        attributeArray1[j2] = attributeArray2[i2];
      }
    }
    return this;
  }
  normalizeNormals() {
    const normals = this.attributes.normal;
    for (let i2 = 0, il = normals.count; i2 < il; i2++) {
      _vector$8.fromBufferAttribute(normals, i2);
      _vector$8.normalize();
      normals.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);
    }
  }
  toNonIndexed() {
    function convertBufferAttribute(attribute, indices2) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices2.length * itemSize);
      let index = 0, index2 = 0;
      for (let i2 = 0, l2 = indices2.length; i2 < l2; i2++) {
        if (attribute.isInterleavedBufferAttribute) {
          index = indices2[i2] * attribute.data.stride + attribute.offset;
        } else {
          index = indices2[i2] * itemSize;
        }
        for (let j2 = 0; j2 < itemSize; j2++) {
          array2[index2++] = array[index++];
        }
      }
      return new BufferAttribute(array2, itemSize, normalized);
    }
    if (this.index === null) {
      console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
      return this;
    }
    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name];
      for (let i2 = 0, il = morphAttribute.length; i2 < il; i2++) {
        const attribute = morphAttribute[i2];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups = this.groups;
    for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
      const group = groups[i2];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (Object.keys(this.userData).length > 0)
      data.userData = this.userData;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== void 0)
          data[key] = parameters[key];
      }
      return data;
    }
    data.data = { attributes: {} };
    const index = this.index;
    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      data.data.attributes[key] = attribute.toJSON(data.data);
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];
      for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {
        const attribute = attributeArray[i2];
        array.push(attribute.toJSON(data.data));
      }
      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups = this.groups;
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data = {};
    this.name = source.name;
    const index = source.index;
    if (index !== null) {
      this.setIndex(index.clone(data));
    }
    const attributes = source.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data));
    }
    const morphAttributes = source.morphAttributes;
    for (const name in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name];
      for (let i2 = 0, l2 = morphAttribute.length; i2 < l2; i2++) {
        array.push(morphAttribute[i2].clone(data));
      }
      this.morphAttributes[name] = array;
    }
    this.morphTargetsRelative = source.morphTargetsRelative;
    const groups = source.groups;
    for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
      const group = groups[i2];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    const boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    if (source.parameters !== void 0)
      this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
BufferGeometry.prototype.isBufferGeometry = true;
const _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();
const _ray$2 = /* @__PURE__ */ new Ray();
const _sphere$3 = /* @__PURE__ */ new Sphere();
const _vA$1 = /* @__PURE__ */ new Vector3();
const _vB$1 = /* @__PURE__ */ new Vector3();
const _vC$1 = /* @__PURE__ */ new Vector3();
const _tempA = /* @__PURE__ */ new Vector3();
const _tempB = /* @__PURE__ */ new Vector3();
const _tempC = /* @__PURE__ */ new Vector3();
const _morphA = /* @__PURE__ */ new Vector3();
const _morphB = /* @__PURE__ */ new Vector3();
const _morphC = /* @__PURE__ */ new Vector3();
const _uvA$1 = /* @__PURE__ */ new Vector2();
const _uvB$1 = /* @__PURE__ */ new Vector2();
const _uvC$1 = /* @__PURE__ */ new Vector2();
const _intersectionPoint = /* @__PURE__ */ new Vector3();
const _intersectionPointWorld = /* @__PURE__ */ new Vector3();
class Mesh extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
    super();
    this.type = "Mesh";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source) {
    super.copy(source);
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
            const name = morphAttribute[m2].name || String(m2);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m2;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0)
      return;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$3.copy(geometry.boundingSphere);
    _sphere$3.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere$3) === false)
      return;
    _inverseMatrix$2.copy(matrixWorld).invert();
    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
    if (geometry.boundingBox !== null) {
      if (_ray$2.intersectsBox(geometry.boundingBox) === false)
        return;
    }
    let intersection;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const position = geometry.attributes.position;
      const morphPosition = geometry.morphAttributes.position;
      const morphTargetsRelative = geometry.morphTargetsRelative;
      const uv = geometry.attributes.uv;
      const uv2 = geometry.attributes.uv2;
      const groups = geometry.groups;
      const drawRange = geometry.drawRange;
      if (index !== null) {
        if (Array.isArray(material)) {
          for (let i2 = 0, il = groups.length; i2 < il; i2++) {
            const group = groups[i2];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
            for (let j2 = start, jl = end; j2 < jl; j2 += 3) {
              const a2 = index.getX(j2);
              const b2 = index.getX(j2 + 1);
              const c2 = index.getX(j2 + 2);
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
              if (intersection) {
                intersection.faceIndex = Math.floor(j2 / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects2.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(index.count, drawRange.start + drawRange.count);
          for (let i2 = start, il = end; i2 < il; i2 += 3) {
            const a2 = index.getX(i2);
            const b2 = index.getX(i2 + 1);
            const c2 = index.getX(i2 + 2);
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
            if (intersection) {
              intersection.faceIndex = Math.floor(i2 / 3);
              intersects2.push(intersection);
            }
          }
        }
      } else if (position !== void 0) {
        if (Array.isArray(material)) {
          for (let i2 = 0, il = groups.length; i2 < il; i2++) {
            const group = groups[i2];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
            for (let j2 = start, jl = end; j2 < jl; j2 += 3) {
              const a2 = j2;
              const b2 = j2 + 1;
              const c2 = j2 + 2;
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
              if (intersection) {
                intersection.faceIndex = Math.floor(j2 / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects2.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(position.count, drawRange.start + drawRange.count);
          for (let i2 = start, il = end; i2 < il; i2 += 3) {
            const a2 = i2;
            const b2 = i2 + 1;
            const c2 = i2 + 2;
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
            if (intersection) {
              intersection.faceIndex = Math.floor(i2 / 3);
              intersects2.push(intersection);
            }
          }
        }
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
}
Mesh.prototype.isMesh = true;
function checkIntersection(object, material, raycaster, ray, pA2, pB, pC, point) {
  let intersect;
  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA2, true, point);
  } else {
    intersect = ray.intersectTriangle(pA2, pB, pC, material.side !== DoubleSide, point);
  }
  if (intersect === null)
    return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far)
    return null;
  return {
    distance,
    point: _intersectionPointWorld.clone(),
    object
  };
}
function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2) {
  _vA$1.fromBufferAttribute(position, a2);
  _vB$1.fromBufferAttribute(position, b2);
  _vC$1.fromBufferAttribute(position, c2);
  const morphInfluences = object.morphTargetInfluences;
  if (morphPosition && morphInfluences) {
    _morphA.set(0, 0, 0);
    _morphB.set(0, 0, 0);
    _morphC.set(0, 0, 0);
    for (let i2 = 0, il = morphPosition.length; i2 < il; i2++) {
      const influence = morphInfluences[i2];
      const morphAttribute = morphPosition[i2];
      if (influence === 0)
        continue;
      _tempA.fromBufferAttribute(morphAttribute, a2);
      _tempB.fromBufferAttribute(morphAttribute, b2);
      _tempC.fromBufferAttribute(morphAttribute, c2);
      if (morphTargetsRelative) {
        _morphA.addScaledVector(_tempA, influence);
        _morphB.addScaledVector(_tempB, influence);
        _morphC.addScaledVector(_tempC, influence);
      } else {
        _morphA.addScaledVector(_tempA.sub(_vA$1), influence);
        _morphB.addScaledVector(_tempB.sub(_vB$1), influence);
        _morphC.addScaledVector(_tempC.sub(_vC$1), influence);
      }
    }
    _vA$1.add(_morphA);
    _vB$1.add(_morphB);
    _vC$1.add(_morphC);
  }
  if (object.isSkinnedMesh) {
    object.boneTransform(a2, _vA$1);
    object.boneTransform(b2, _vB$1);
    object.boneTransform(c2, _vC$1);
  }
  const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (intersection) {
    if (uv) {
      _uvA$1.fromBufferAttribute(uv, a2);
      _uvB$1.fromBufferAttribute(uv, b2);
      _uvC$1.fromBufferAttribute(uv, c2);
      intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    if (uv2) {
      _uvA$1.fromBufferAttribute(uv2, a2);
      _uvB$1.fromBufferAttribute(uv2, b2);
      _uvC$1.fromBufferAttribute(uv2, c2);
      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    const face = {
      a: a2,
      b: b2,
      c: c2,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
    intersection.face = face;
  }
  return intersection;
}
class BoxGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      depthSegments
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
    buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
    buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
    buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
    buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
    buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(u2, v2, w2, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
      const segmentWidth = width2 / gridX;
      const segmentHeight = height2 / gridY;
      const widthHalf = width2 / 2;
      const heightHalf = height2 / 2;
      const depthHalf = depth2 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3();
      for (let iy = 0; iy < gridY1; iy++) {
        const y2 = iy * segmentHeight - heightHalf;
        for (let ix = 0; ix < gridX1; ix++) {
          const x2 = ix * segmentWidth - widthHalf;
          vector[u2] = x2 * udir;
          vector[v2] = y2 * vdir;
          vector[w2] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u2] = 0;
          vector[v2] = 0;
          vector[w2] = depth2 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a2 = numberOfVertices + ix + gridX1 * iy;
          const b2 = numberOfVertices + ix + gridX1 * (iy + 1);
          const c2 = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d2 = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices.push(a2, b2, d2);
          indices.push(b2, c2, d2);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
  static fromJSON(data) {
    return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
  }
}
function cloneUniforms(src) {
  const dst = {};
  for (const u2 in src) {
    dst[u2] = {};
    for (const p2 in src[u2]) {
      const property = src[u2][p2];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        dst[u2][p2] = property.clone();
      } else if (Array.isArray(property)) {
        dst[u2][p2] = property.slice();
      } else {
        dst[u2][p2] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u2 = 0; u2 < uniforms.length; u2++) {
    const tmp2 = cloneUniforms(uniforms[u2]);
    for (const p2 in tmp2) {
      merged[p2] = tmp2[p2];
    }
  }
  return merged;
}
const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
class ShaderMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.clipping = false;
    this.extensions = {
      derivatives: false,
      fragDepth: false,
      drawBuffers: false,
      shaderTextureLOD: false
    };
    this.defaultAttributeValues = {
      "color": [1, 1, 1],
      "uv": [0, 0],
      "uv2": [0, 0]
    };
    this.index0AttributeName = void 0;
    this.uniformsNeedUpdate = false;
    this.glslVersion = null;
    if (parameters !== void 0) {
      if (parameters.attributes !== void 0) {
        console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
      }
      this.setValues(parameters);
    }
  }
  copy(source) {
    super.copy(source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.defines = Object.assign({}, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.extensions = Object.assign({}, source.extensions);
    this.glslVersion = source.glslVersion;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.glslVersion = this.glslVersion;
    data.uniforms = {};
    for (const name in this.uniforms) {
      const uniform = this.uniforms[name];
      const value = uniform.value;
      if (value && value.isTexture) {
        data.uniforms[name] = {
          type: "t",
          value: value.toJSON(meta).uuid
        };
      } else if (value && value.isColor) {
        data.uniforms[name] = {
          type: "c",
          value: value.getHex()
        };
      } else if (value && value.isVector2) {
        data.uniforms[name] = {
          type: "v2",
          value: value.toArray()
        };
      } else if (value && value.isVector3) {
        data.uniforms[name] = {
          type: "v3",
          value: value.toArray()
        };
      } else if (value && value.isVector4) {
        data.uniforms[name] = {
          type: "v4",
          value: value.toArray()
        };
      } else if (value && value.isMatrix3) {
        data.uniforms[name] = {
          type: "m3",
          value: value.toArray()
        };
      } else if (value && value.isMatrix4) {
        data.uniforms[name] = {
          type: "m4",
          value: value.toArray()
        };
      } else {
        data.uniforms[name] = {
          value
        };
      }
    }
    if (Object.keys(this.defines).length > 0)
      data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    const extensions = {};
    for (const key in this.extensions) {
      if (this.extensions[key] === true)
        extensions[key] = true;
    }
    if (Object.keys(extensions).length > 0)
      data.extensions = extensions;
    return data;
  }
}
ShaderMaterial.prototype.isShaderMaterial = true;
class Camera extends Object3D {
  constructor() {
    super();
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    return this;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e2 = this.matrixWorld.elements;
    return target.set(-e2[8], -e2[9], -e2[10]).normalize();
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(updateParents, updateChildren) {
    super.updateWorldMatrix(updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
Camera.prototype.isCamera = true;
class PerspectiveCamera extends Camera {
  constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
    super();
    this.type = "PerspectiveCamera";
    this.fov = fov2;
    this.zoom = 1;
    this.near = near;
    this.far = far;
    this.focus = 10;
    this.aspect = aspect2;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  }
  setFocalLength(focalLength) {
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  }
  getFocalLength() {
    const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  }
  getEffectiveFOV() {
    return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(fullWidth, fullHeight, x2, y2, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x2;
    this.view.offsetY = y2;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const near = this.near;
    let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0)
      left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
}
PerspectiveCamera.prototype.isPerspectiveCamera = true;
const fov = 90, aspect = 1;
class CubeCamera extends Object3D {
  constructor(near, far, renderTarget) {
    super();
    this.type = "CubeCamera";
    if (renderTarget.isWebGLCubeRenderTarget !== true) {
      console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
      return;
    }
    this.renderTarget = renderTarget;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector3(1, 0, 0));
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector3(-1, 0, 0));
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector3(0, 1, 0));
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector3(0, -1, 0));
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector3(0, 0, 1));
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector3(0, 0, -1));
    this.add(cameraNZ);
  }
  update(renderer, scene) {
    if (this.parent === null)
      this.updateMatrixWorld();
    const renderTarget = this.renderTarget;
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
    const currentXrEnabled = renderer.xr.enabled;
    const currentRenderTarget = renderer.getRenderTarget();
    renderer.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.xr.enabled = currentXrEnabled;
    renderTarget.texture.needsPMREMUpdate = true;
  }
}
class CubeTexture extends Texture {
  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    images = images !== void 0 ? images : [];
    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
}
CubeTexture.prototype.isCubeTexture = true;
class WebGLCubeRenderTarget extends WebGLRenderTarget {
  constructor(size, options = {}) {
    super(size, size, options);
    const image = { width: size, height: size, depth: 1 };
    const images = [image, image, image, image, image, image];
    this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.isRenderTargetTexture = true;
    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
  }
  fromEquirectangularTexture(renderer, texture) {
    this.texture.type = texture.type;
    this.texture.format = RGBAFormat;
    this.texture.encoding = texture.encoding;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
      fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
    };
    const geometry = new BoxGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh(geometry, material);
    const currentMinFilter = texture.minFilter;
    if (texture.minFilter === LinearMipmapLinearFilter)
      texture.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
  clear(renderer, color, depth, stencil) {
    const currentRenderTarget = renderer.getRenderTarget();
    for (let i2 = 0; i2 < 6; i2++) {
      renderer.setRenderTarget(this, i2);
      renderer.clear(color, depth, stencil);
    }
    renderer.setRenderTarget(currentRenderTarget);
  }
}
WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
const _vector1 = /* @__PURE__ */ new Vector3();
const _vector2 = /* @__PURE__ */ new Vector3();
const _normalMatrix = /* @__PURE__ */ new Matrix3();
class Plane {
  constructor(normal = new Vector3(1, 0, 0), constant = 0) {
    this.normal = normal;
    this.constant = constant;
  }
  set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  }
  setComponents(x2, y2, z2, w2) {
    this.normal.set(x2, y2, z2);
    this.constant = w2;
    return this;
  }
  setFromNormalAndCoplanarPoint(normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  }
  setFromCoplanarPoints(a2, b2, c2) {
    const normal = _vector1.subVectors(c2, b2).cross(_vector2.subVectors(a2, b2)).normalize();
    this.setFromNormalAndCoplanarPoint(normal, a2);
    return this;
  }
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  projectPoint(point, target) {
    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
  }
  intersectLine(line, target) {
    const direction = line.delta(_vector1);
    const denominator = this.normal.dot(direction);
    if (denominator === 0) {
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      }
      return null;
    }
    const t2 = -(line.start.dot(this.normal) + this.constant) / denominator;
    if (t2 < 0 || t2 > 1) {
      return null;
    }
    return target.copy(direction).multiplyScalar(t2).add(line.start);
  }
  intersectsLine(line) {
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  coplanarPoint(target) {
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }
  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
Plane.prototype.isPlane = true;
const _sphere$2 = /* @__PURE__ */ new Sphere();
const _vector$7 = /* @__PURE__ */ new Vector3();
class Frustum {
  constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
    this.planes = [p0, p1, p2, p3, p4, p5];
  }
  set(p0, p1, p2, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  }
  copy(frustum) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      planes[i2].copy(frustum.planes[i2]);
    }
    return this;
  }
  setFromProjectionMatrix(m2) {
    const planes = this.planes;
    const me = m2.elements;
    const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
    const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
    const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
    const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  }
  intersectsObject(object) {
    const geometry = object.geometry;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
    return this.intersectsSphere(_sphere$2);
  }
  intersectsSprite(sprite) {
    _sphere$2.center.set(0, 0, 0);
    _sphere$2.radius = 0.7071067811865476;
    _sphere$2.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(_sphere$2);
  }
  intersectsSphere(sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;
    for (let i2 = 0; i2 < 6; i2++) {
      const distance = planes[i2].distanceToPoint(center);
      if (distance < negRadius) {
        return false;
      }
    }
    return true;
  }
  intersectsBox(box) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      const plane = planes[i2];
      _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
      if (plane.distanceToPoint(_vector$7) < 0) {
        return false;
      }
    }
    return true;
  }
  containsPoint(point) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      if (planes[i2].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating === true)
        return;
      if (animationLoop === null)
        return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context = value;
    }
  };
}
function WebGLAttributes(gl, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  const buffers = /* @__PURE__ */ new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type;
    if (array instanceof Float32Array) {
      type = 5126;
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        if (isWebGL2) {
          type = 5131;
        } else {
          throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
        }
      } else {
        type = 5123;
      }
    } else if (array instanceof Int16Array) {
      type = 5122;
    } else if (array instanceof Uint32Array) {
      type = 5125;
    } else if (array instanceof Int32Array) {
      type = 5124;
    } else if (array instanceof Int8Array) {
      type = 5120;
    } else if (array instanceof Uint8Array) {
      type = 5121;
    } else if (array instanceof Uint8ClampedArray) {
      type = 5121;
    } else {
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + array);
    }
    return {
      buffer,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }
  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer);
    if (updateRange.count === -1) {
      gl.bufferSubData(bufferType, 0, array);
    } else {
      if (isWebGL2) {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
      } else {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
      }
      updateRange.count = -1;
    }
  }
  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  function update(attribute, bufferType) {
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get,
    remove,
    update
  };
}
class PlaneGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = "PlaneGeometry";
    this.parameters = {
      width,
      height,
      widthSegments,
      heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy < gridY1; iy++) {
      const y2 = iy * segment_height - height_half;
      for (let ix = 0; ix < gridX1; ix++) {
        const x2 = ix * segment_width - width_half;
        vertices.push(x2, -y2, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a2 = ix + gridX1 * iy;
        const b2 = ix + gridX1 * (iy + 1);
        const c2 = ix + 1 + gridX1 * (iy + 1);
        const d2 = ix + 1 + gridX1 * iy;
        indices.push(a2, b2, d2);
        indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
  }
}
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif";
var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		lightMapIrradiance *= PI;\n	#endif\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec;\n			#ifdef ENVMAP_MODE_REFLECTION\n				reflectVec = reflect( - viewDir, normal );\n				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			#else\n				reflectVec = refract( - viewDir, normal, refractionRatio );\n			#endif\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ]\n		#endif\n	}\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform vec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			float texelIndex = float( vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset );\n			float y = floor( texelIndex / morphTargetsTextureSize.x );\n			float x = texelIndex - y * morphTargetsTextureSize.x;\n			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n			return texture( morphTargetsTexture, morphUV );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmission_fragment = "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";
var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef texture2DLodEXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif";
var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
var uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
var uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
const vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
const fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	gl_FragColor = texture2D( t2D, vUv );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
const fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
const vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
const fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
const vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}";
const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
const vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
const ShaderChunk = {
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  alphatest_pars_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  encodings_fragment,
  encodings_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_fragment,
  lightmap_pars_fragment,
  lights_lambert_vertex,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphcolor_vertex,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normal_pars_fragment,
  normal_pars_vertex,
  normal_vertex,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  output_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmission_fragment,
  transmission_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  uv2_pars_fragment,
  uv2_pars_vertex,
  uv2_vertex,
  worldpos_vertex,
  background_vert: vertex$g,
  background_frag: fragment$g,
  cube_vert: vertex$f,
  cube_frag: fragment$f,
  depth_vert: vertex$e,
  depth_frag: fragment$e,
  distanceRGBA_vert: vertex$d,
  distanceRGBA_frag: fragment$d,
  equirect_vert: vertex$c,
  equirect_frag: fragment$c,
  linedashed_vert: vertex$b,
  linedashed_frag: fragment$b,
  meshbasic_vert: vertex$a,
  meshbasic_frag: fragment$a,
  meshlambert_vert: vertex$9,
  meshlambert_frag: fragment$9,
  meshmatcap_vert: vertex$8,
  meshmatcap_frag: fragment$8,
  meshnormal_vert: vertex$7,
  meshnormal_frag: fragment$7,
  meshphong_vert: vertex$6,
  meshphong_frag: fragment$6,
  meshphysical_vert: vertex$5,
  meshphysical_frag: fragment$5,
  meshtoon_vert: vertex$4,
  meshtoon_frag: fragment$4,
  points_vert: vertex$3,
  points_frag: fragment$3,
  shadow_vert: vertex$2,
  shadow_frag: fragment$2,
  sprite_vert: vertex$1,
  sprite_frag: fragment$1
};
const UniformsLib = {
  common: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: new Matrix3() },
    uv2Transform: { value: new Matrix3() },
    alphaMap: { value: null },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    ior: { value: 1.5 },
    refractionRatio: { value: 0.98 }
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 }
  },
  emissivemap: {
    emissiveMap: { value: null }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalScale: { value: new Vector2(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  roughnessmap: {
    roughnessMap: { value: null }
  },
  metalnessmap: {
    metalnessMap: { value: null }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: new Color(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotShadowMap: { value: [] },
    spotShadowMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: new Matrix3() }
  },
  sprite: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    center: { value: new Vector2(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: new Matrix3() }
  }
};
const ShaderLib = {
  basic: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        specular: { value: new Color(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshnormal_vert,
    fragmentShader: ShaderChunk.meshnormal_frag
  },
  sprite: {
    uniforms: mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: new Matrix3() },
      t2D: { value: null }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  cube: {
    uniforms: mergeUniforms([
      UniformsLib.envmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: { value: new Vector3() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: { value: new Color(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: new Vector2(1, 1) },
      clearcoatNormalMap: { value: null },
      sheen: { value: 0 },
      sheenColor: { value: new Color(0) },
      sheenColorMap: { value: null },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionSamplerSize: { value: new Vector2() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Color(0) },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularColor: { value: new Color(1, 1, 1) },
      specularColorMap: { value: null }
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
function WebGLBackground(renderer, cubemaps, state, objects, alpha, premultipliedAlpha) {
  const clearColor = new Color(0);
  let clearAlpha = alpha === true ? 0 : 1;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function render(renderList, scene) {
    let forceClear = false;
    let background = scene.isScene === true ? scene.background : null;
    if (background && background.isTexture) {
      background = cubemaps.get(background);
    }
    const xr = renderer.xr;
    const session = xr.getSession && xr.getSession();
    if (session && session.environmentBlendMode === "additive") {
      background = null;
    }
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
          name: "BackgroundCubeMaterial",
          uniforms: cloneUniforms(ShaderLib.cube.uniforms),
          vertexShader: ShaderLib.cube.vertexShader,
          fragmentShader: ShaderLib.cube.fragmentShader,
          side: BackSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
          name: "BackgroundMaterial",
          uniforms: cloneUniforms(ShaderLib.background.uniforms),
          vertexShader: ShaderLib.background.vertexShader,
          fragmentShader: ShaderLib.background.fragmentShader,
          side: FrontSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color, alpha2) {
    state.buffers.color.setClear(color.r, color.g, color.b, alpha2, premultipliedAlpha);
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color, alpha2 = 1) {
      clearColor.set(color);
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha2) {
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    render
  };
}
function WebGLBindingStates(gl, extensions, attributes, capabilities) {
  const maxVertexAttributes = gl.getParameter(34921);
  const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
  const vaoAvailable = capabilities.isWebGL2 || extension !== null;
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  function setup(object, material, program, geometry, index) {
    let updateBuffers = false;
    if (vaoAvailable) {
      const state = getBindingState(geometry, program, material);
      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }
      updateBuffers = needsUpdate(geometry, index);
      if (updateBuffers)
        saveCache(geometry, index);
    } else {
      const wireframe = material.wireframe === true;
      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
        currentState.geometry = geometry.id;
        currentState.program = program.id;
        currentState.wireframe = wireframe;
        updateBuffers = true;
      }
    }
    if (object.isInstancedMesh === true) {
      updateBuffers = true;
    }
    if (index !== null) {
      attributes.update(index, 34963);
    }
    if (updateBuffers) {
      setupVertexAttributes(object, material, program, geometry);
      if (index !== null) {
        gl.bindBuffer(34963, attributes.get(index).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    if (capabilities.isWebGL2)
      return gl.createVertexArray();
    return extension.createVertexArrayOES();
  }
  function bindVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.bindVertexArray(vao);
    return extension.bindVertexArrayOES(vao);
  }
  function deleteVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.deleteVertexArray(vao);
    return extension.deleteVertexArrayOES(vao);
  }
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === void 0) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === void 0) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i2 = 0; i2 < maxVertexAttributes; i2++) {
      newAttributes[i2] = 0;
      enabledAttributes[i2] = 0;
      attributeDivisors[i2] = 0;
    }
    return {
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  function needsUpdate(geometry, index) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;
    for (const key in geometryAttributes) {
      const cachedAttribute = cachedAttributes[key];
      const geometryAttribute = geometryAttributes[key];
      if (cachedAttribute === void 0)
        return true;
      if (cachedAttribute.attribute !== geometryAttribute)
        return true;
      if (cachedAttribute.data !== geometryAttribute.data)
        return true;
      attributesNum++;
    }
    if (currentState.attributesNum !== attributesNum)
      return true;
    if (currentState.index !== index)
      return true;
    return false;
  }
  function saveCache(geometry, index) {
    const cache = {};
    const attributes2 = geometry.attributes;
    let attributesNum = 0;
    for (const key in attributes2) {
      const attribute = attributes2[key];
      const data = {};
      data.attribute = attribute;
      if (attribute.data) {
        data.data = attribute.data;
      }
      cache[key] = data;
      attributesNum++;
    }
    currentState.attributes = cache;
    currentState.attributesNum = attributesNum;
    currentState.index = index;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i2 = 0, il = newAttributes.length; i2 < il; i2++) {
      newAttributes[i2] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      const extension2 = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
      extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i2 = 0, il = enabledAttributes.length; i2 < il; i2++) {
      if (enabledAttributes[i2] !== newAttributes[i2]) {
        gl.disableVertexAttribArray(i2);
        enabledAttributes[i2] = 0;
      }
    }
  }
  function vertexAttribPointer(index, size, type, normalized, stride, offset) {
    if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
      gl.vertexAttribIPointer(index, size, type, stride, offset);
    } else {
      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
  }
  function setupVertexAttributes(object, material, program, geometry) {
    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
      if (extensions.get("ANGLE_instanced_arrays") === null)
        return;
    }
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix)
            geometryAttribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor)
            geometryAttribute = object.instanceColor;
        }
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset = geometryAttribute.offset;
            if (data.isInstancedInterleavedBuffer) {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttributeAndDivisor(programAttribute.location + i2, data.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttribute(programAttribute.location + i2);
              }
            }
            gl.bindBuffer(34962, buffer);
            for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
              vertexAttribPointer(programAttribute.location + i2, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + size / programAttribute.locationSize * i2) * bytesPerElement);
            }
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttributeAndDivisor(programAttribute.location + i2, geometryAttribute.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttribute(programAttribute.location + i2);
              }
            }
            gl.bindBuffer(34962, buffer);
            for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
              vertexAttribPointer(programAttribute.location + i2, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * i2 * bytesPerElement);
            }
          }
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute.location, value);
                break;
              case 3:
                gl.vertexAttrib3fv(programAttribute.location, value);
                break;
              case 4:
                gl.vertexAttrib4fv(programAttribute.location, value);
                break;
              default:
                gl.vertexAttrib1fv(programAttribute.location, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose() {
    reset();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === void 0)
      return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === void 0)
        continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset() {
    resetDefaultState();
    if (currentState === defaultState)
      return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup,
    reset,
    resetDefaultState,
    dispose,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes
  };
}
function WebGLBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  function render(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawArraysInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawArraysInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, start, count, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLCapabilities(gl, extensions, parameters) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0)
      return maxAnisotropy;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
  let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  const drawBuffers = isWebGL2 || extensions.has("WEBGL_draw_buffers");
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const maxTextures = gl.getParameter(34930);
  const maxVertexTextures = gl.getParameter(35660);
  const maxTextureSize = gl.getParameter(3379);
  const maxCubemapSize = gl.getParameter(34076);
  const maxAttributes = gl.getParameter(34921);
  const maxVertexUniforms = gl.getParameter(36347);
  const maxVaryings = gl.getParameter(36348);
  const maxFragmentUniforms = gl.getParameter(36349);
  const vertexTextures = maxVertexTextures > 0;
  const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
  const floatVertexTextures = vertexTextures && floatFragmentTextures;
  const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
  return {
    isWebGL2,
    drawBuffers,
    getMaxAnisotropy,
    getMaxPrecision,
    precision,
    logarithmicDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    floatFragmentTextures,
    floatVertexTextures,
    maxSamples
  };
}
function WebGLClipping(properties) {
  const scope = this;
  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
  const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping, camera) {
    const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
    resetGlobalState();
  };
  this.setState = function(material, camera, useCache) {
    const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, useCache);
      for (let i2 = 0; i2 !== lGlobal; ++i2) {
        dstArray[i2] = globalState[i2];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i2 = 0, i4 = dstOffset; i2 !== nPlanes; ++i2, i4 += 4) {
          plane.copy(planes[i2]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLCubeMaps(renderer) {
  let cubemaps = /* @__PURE__ */ new WeakMap();
  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }
    return texture;
  }
  function get(texture) {
    if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
      const mapping = texture.mapping;
      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image = texture.image;
          if (image && image.height > 0) {
            const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            cubemaps.set(texture, renderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemap = cubemaps.get(texture);
    if (cubemap !== void 0) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }
  function dispose() {
    cubemaps = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
class OrthographicCamera extends Camera {
  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
    super();
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  }
  setViewOffset(fullWidth, fullHeight, x2, y2, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x2;
    this.view.offsetY = y2;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    return data;
  }
}
OrthographicCamera.prototype.isOrthographicCamera = true;
const LOD_MIN = 4;
const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
const MAX_SAMPLES = 20;
const _flatCamera = /* @__PURE__ */ new OrthographicCamera();
const _clearColor = /* @__PURE__ */ new Color();
let _oldTarget = null;
const PHI = (1 + Math.sqrt(5)) / 2;
const INV_PHI = 1 / PHI;
const _axisDirections = [
  /* @__PURE__ */ new Vector3(1, 1, 1),
  /* @__PURE__ */ new Vector3(-1, 1, 1),
  /* @__PURE__ */ new Vector3(1, 1, -1),
  /* @__PURE__ */ new Vector3(-1, 1, -1),
  /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
  /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
  /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
  /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)
];
class PMREMGenerator {
  constructor(renderer) {
    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._lodMax = 0;
    this._cubeSize = 0;
    this._lodPlanes = [];
    this._sizeLods = [];
    this._sigmas = [];
    this._blurMaterial = null;
    this._cubemapMaterial = null;
    this._equirectMaterial = null;
    this._compileMaterial(this._blurMaterial);
  }
  fromScene(scene, sigma = 0, near = 0.1, far = 100) {
    _oldTarget = this._renderer.getRenderTarget();
    this._setSize(256);
    const cubeUVRenderTarget = this._allocateTargets();
    cubeUVRenderTarget.depthBuffer = true;
    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  fromEquirectangular(equirectangular, renderTarget = null) {
    return this._fromTexture(equirectangular, renderTarget);
  }
  fromCubemap(cubemap, renderTarget = null) {
    return this._fromTexture(cubemap, renderTarget);
  }
  compileCubemapShader() {
    if (this._cubemapMaterial === null) {
      this._cubemapMaterial = _getCubemapMaterial();
      this._compileMaterial(this._cubemapMaterial);
    }
  }
  compileEquirectangularShader() {
    if (this._equirectMaterial === null) {
      this._equirectMaterial = _getEquirectMaterial();
      this._compileMaterial(this._equirectMaterial);
    }
  }
  dispose() {
    this._dispose();
    if (this._cubemapMaterial !== null)
      this._cubemapMaterial.dispose();
    if (this._equirectMaterial !== null)
      this._equirectMaterial.dispose();
  }
  _setSize(cubeSize) {
    this._lodMax = Math.floor(Math.log2(cubeSize));
    this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial.dispose();
    if (this._pingPongRenderTarget !== null)
      this._pingPongRenderTarget.dispose();
    for (let i2 = 0; i2 < this._lodPlanes.length; i2++) {
      this._lodPlanes[i2].dispose();
    }
  }
  _cleanup(outputTarget) {
    this._renderer.setRenderTarget(_oldTarget);
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture, renderTarget) {
    if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
      this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);
    } else {
      this._setSize(texture.image.width / 4);
    }
    _oldTarget = this._renderer.getRenderTarget();
    const cubeUVRenderTarget = renderTarget || this._allocateTargets();
    this._textureToCubeUV(texture, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTargets() {
    const width = 3 * Math.max(this._cubeSize, 16 * 7);
    const height = 4 * this._cubeSize - 32;
    const params = {
      magFilter: LinearFilter,
      minFilter: LinearFilter,
      generateMipmaps: false,
      type: HalfFloatType,
      format: RGBAFormat,
      encoding: LinearEncoding,
      depthBuffer: false
    };
    const cubeUVRenderTarget = _createRenderTarget(width, height, params);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width) {
      if (this._pingPongRenderTarget !== null) {
        this._dispose();
      }
      this._pingPongRenderTarget = _createRenderTarget(width, height, params);
      const { _lodMax } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes(_lodMax));
      this._blurMaterial = _getBlurShader(_lodMax, width, height);
    }
    return cubeUVRenderTarget;
  }
  _compileMaterial(material) {
    const tmpMesh = new Mesh(this._lodPlanes[0], material);
    this._renderer.compile(tmpMesh, _flatCamera);
  }
  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
    const fov2 = 90;
    const aspect2 = 1;
    const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
    const upSign = [1, -1, 1, 1, 1, 1];
    const forwardSign = [1, 1, 1, -1, -1, -1];
    const renderer = this._renderer;
    const originalAutoClear = renderer.autoClear;
    const toneMapping = renderer.toneMapping;
    renderer.getClearColor(_clearColor);
    renderer.toneMapping = NoToneMapping;
    renderer.autoClear = false;
    const backgroundMaterial = new MeshBasicMaterial({
      name: "PMREM.Background",
      side: BackSide,
      depthWrite: false,
      depthTest: false
    });
    const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
    let useSolidColor = false;
    const background = scene.background;
    if (background) {
      if (background.isColor) {
        backgroundMaterial.color.copy(background);
        scene.background = null;
        useSolidColor = true;
      }
    } else {
      backgroundMaterial.color.copy(_clearColor);
      useSolidColor = true;
    }
    for (let i2 = 0; i2 < 6; i2++) {
      const col = i2 % 3;
      if (col === 0) {
        cubeCamera.up.set(0, upSign[i2], 0);
        cubeCamera.lookAt(forwardSign[i2], 0, 0);
      } else if (col === 1) {
        cubeCamera.up.set(0, 0, upSign[i2]);
        cubeCamera.lookAt(0, forwardSign[i2], 0);
      } else {
        cubeCamera.up.set(0, upSign[i2], 0);
        cubeCamera.lookAt(0, 0, forwardSign[i2]);
      }
      const size = this._cubeSize;
      _setViewport(cubeUVRenderTarget, col * size, i2 > 2 ? size : 0, size, size);
      renderer.setRenderTarget(cubeUVRenderTarget);
      if (useSolidColor) {
        renderer.render(backgroundBox, cubeCamera);
      }
      renderer.render(scene, cubeCamera);
    }
    backgroundBox.geometry.dispose();
    backgroundBox.material.dispose();
    renderer.toneMapping = toneMapping;
    renderer.autoClear = originalAutoClear;
    scene.background = background;
  }
  _textureToCubeUV(texture, cubeUVRenderTarget) {
    const renderer = this._renderer;
    const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
    if (isCubeTexture) {
      if (this._cubemapMaterial === null) {
        this._cubemapMaterial = _getCubemapMaterial();
      }
      this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
    } else {
      if (this._equirectMaterial === null) {
        this._equirectMaterial = _getEquirectMaterial();
      }
    }
    const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
    const mesh = new Mesh(this._lodPlanes[0], material);
    const uniforms = material.uniforms;
    uniforms["envMap"].value = texture;
    const size = this._cubeSize;
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(mesh, _flatCamera);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer = this._renderer;
    const autoClear = renderer.autoClear;
    renderer.autoClear = false;
    for (let i2 = 1; i2 < this._lodPlanes.length; i2++) {
      const sigma = Math.sqrt(this._sigmas[i2] * this._sigmas[i2] - this._sigmas[i2 - 1] * this._sigmas[i2 - 1]);
      const poleAxis = _axisDirections[(i2 - 1) % _axisDirections.length];
      this._blur(cubeUVRenderTarget, i2 - 1, i2, sigma, poleAxis);
    }
    renderer.autoClear = autoClear;
  }
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, "latitudinal", poleAxis);
    this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, "longitudinal", poleAxis);
  }
  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
    const renderer = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction !== "latitudinal" && direction !== "longitudinal") {
      console.error("blur direction must be either latitudinal or longitudinal!");
    }
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
    const blurUniforms = blurMaterial.uniforms;
    const pixels = this._sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }
    const weights = [];
    let sum = 0;
    for (let i2 = 0; i2 < MAX_SAMPLES; ++i2) {
      const x3 = i2 / sigmaPixels;
      const weight = Math.exp(-x3 * x3 / 2);
      weights.push(weight);
      if (i2 === 0) {
        sum += weight;
      } else if (i2 < samples) {
        sum += 2 * weight;
      }
    }
    for (let i2 = 0; i2 < weights.length; i2++) {
      weights[i2] = weights[i2] / sum;
    }
    blurUniforms["envMap"].value = targetIn.texture;
    blurUniforms["samples"].value = samples;
    blurUniforms["weights"].value = weights;
    blurUniforms["latitudinal"].value = direction === "latitudinal";
    if (poleAxis) {
      blurUniforms["poleAxis"].value = poleAxis;
    }
    const { _lodMax } = this;
    blurUniforms["dTheta"].value = radiansPerPixel;
    blurUniforms["mipInt"].value = _lodMax - lodIn;
    const outputSize = this._sizeLods[lodOut];
    const x2 = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
    const y2 = 4 * (this._cubeSize - outputSize);
    _setViewport(targetOut, x2, y2, 3 * outputSize, 2 * outputSize);
    renderer.setRenderTarget(targetOut);
    renderer.render(blurMesh, _flatCamera);
  }
}
function _createPlanes(lodMax) {
  const lodPlanes = [];
  const sizeLods = [];
  const sigmas = [];
  let lod = lodMax;
  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  for (let i2 = 0; i2 < totalLods; i2++) {
    const sizeLod = Math.pow(2, lod);
    sizeLods.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i2 > lodMax - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i2 - lodMax + LOD_MIN - 1];
    } else if (i2 === 0) {
      sigma = 0;
    }
    sigmas.push(sigma);
    const texelSize = 1 / (sizeLod - 1);
    const min = -texelSize / 2;
    const max = 1 + texelSize / 2;
    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face = 0; face < cubeFaces; face++) {
      const x2 = face % 3 * 2 / 3 - 1;
      const y2 = face > 2 ? 0 : -1;
      const coordinates = [
        x2,
        y2,
        0,
        x2 + 2 / 3,
        y2,
        0,
        x2 + 2 / 3,
        y2 + 1,
        0,
        x2,
        y2,
        0,
        x2 + 2 / 3,
        y2 + 1,
        0,
        x2,
        y2 + 1,
        0
      ];
      position.set(coordinates, positionSize * vertices * face);
      uv.set(uv1, uvSize * vertices * face);
      const fill = [face, face, face, face, face, face];
      faceIndex.set(fill, faceIndexSize * vertices * face);
    }
    const planes = new BufferGeometry();
    planes.setAttribute("position", new BufferAttribute(position, positionSize));
    planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
    lodPlanes.push(planes);
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { lodPlanes, sizeLods, sigmas };
}
function _createRenderTarget(width, height, params) {
  const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x2, y2, width, height) {
  target.viewport.set(x2, y2, width, height);
  target.scissor.set(x2, y2, width, height);
}
function _getBlurShader(lodMax, width, height) {
  const weights = new Float32Array(MAX_SAMPLES);
  const poleAxis = new Vector3(0, 1, 0);
  const shaderMaterial = new ShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: {
      "n": MAX_SAMPLES,
      "CUBEUV_TEXEL_WIDTH": 1 / width,
      "CUBEUV_TEXEL_HEIGHT": 1 / height,
      "CUBEUV_MAX_MIP": `${lodMax}.0`
    },
    uniforms: {
      "envMap": { value: null },
      "samples": { value: 1 },
      "weights": { value: weights },
      "latitudinal": { value: false },
      "dTheta": { value: 0 },
      "mipInt": { value: 0 },
      "poleAxis": { value: poleAxis }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getEquirectMaterial() {
  return new ShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: {
      "envMap": { value: null }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCubemapMaterial() {
  return new ShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: {
      "envMap": { value: null },
      "flipEnvMap": { value: -1 }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCommonVertexShader() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function WebGLCubeUVMaps(renderer) {
  let cubeUVmaps = /* @__PURE__ */ new WeakMap();
  let pmremGenerator = null;
  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;
      const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
      const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
      if (isEquirectMap || isCubeMap) {
        if (texture.isRenderTargetTexture && texture.needsPMREMUpdate === true) {
          texture.needsPMREMUpdate = false;
          let renderTarget = cubeUVmaps.get(texture);
          if (pmremGenerator === null)
            pmremGenerator = new PMREMGenerator(renderer);
          renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
          cubeUVmaps.set(texture, renderTarget);
          return renderTarget.texture;
        } else {
          if (cubeUVmaps.has(texture)) {
            return cubeUVmaps.get(texture).texture;
          } else {
            const image = texture.image;
            if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
              if (pmremGenerator === null)
                pmremGenerator = new PMREMGenerator(renderer);
              const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
              cubeUVmaps.set(texture, renderTarget);
              texture.addEventListener("dispose", onTextureDispose);
              return renderTarget.texture;
            } else {
              return null;
            }
          }
        }
      }
    }
    return texture;
  }
  function isCubeTextureComplete(image) {
    let count = 0;
    const length = 6;
    for (let i2 = 0; i2 < length; i2++) {
      if (image[i2] !== void 0)
        count++;
    }
    return count === length;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemapUV = cubeUVmaps.get(texture);
    if (cubemapUV !== void 0) {
      cubeUVmaps.delete(texture);
      cubemapUV.dispose();
    }
  }
  function dispose() {
    cubeUVmaps = /* @__PURE__ */ new WeakMap();
    if (pmremGenerator !== null) {
      pmremGenerator.dispose();
      pmremGenerator = null;
    }
  }
  return {
    get,
    dispose
  };
}
function WebGLExtensions(gl) {
  const extensions = {};
  function getExtension(name) {
    if (extensions[name] !== void 0) {
      return extensions[name];
    }
    let extension;
    switch (name) {
      case "WEBGL_depth_texture":
        extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        extension = gl.getExtension(name);
    }
    extensions[name] = extension;
    return extension;
  }
  return {
    has: function(name) {
      return getExtension(name) !== null;
    },
    init: function(capabilities) {
      if (capabilities.isWebGL2) {
        getExtension("EXT_color_buffer_float");
      } else {
        getExtension("WEBGL_depth_texture");
        getExtension("OES_texture_float");
        getExtension("OES_texture_half_float");
        getExtension("OES_texture_half_float_linear");
        getExtension("OES_standard_derivatives");
        getExtension("OES_element_index_uint");
        getExtension("OES_vertex_array_object");
        getExtension("ANGLE_instanced_arrays");
      }
      getExtension("OES_texture_float_linear");
      getExtension("EXT_color_buffer_half_float");
      getExtension("WEBGL_multisampled_render_to_texture");
    },
    get: function(name) {
      const extension = getExtension(name);
      if (extension === null) {
        console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
      }
      return extension;
    }
  };
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries = {};
  const wireframeAttributes = /* @__PURE__ */ new WeakMap();
  function onGeometryDispose(event) {
    const geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (const name in geometry.attributes) {
      attributes.remove(geometry.attributes[name]);
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    delete geometries[geometry.id];
    const attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  function get(object, geometry) {
    if (geometries[geometry.id] === true)
      return geometry;
    geometry.addEventListener("dispose", onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  function update(geometry) {
    const geometryAttributes = geometry.attributes;
    for (const name in geometryAttributes) {
      attributes.update(geometryAttributes[name], 34962);
    }
    const morphAttributes = geometry.morphAttributes;
    for (const name in morphAttributes) {
      const array = morphAttributes[name];
      for (let i2 = 0, l2 = array.length; i2 < l2; i2++) {
        attributes.update(array[i2], 34962);
      }
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version = 0;
    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version = geometryIndex.version;
      for (let i2 = 0, l2 = array.length; i2 < l2; i2 += 3) {
        const a2 = array[i2 + 0];
        const b2 = array[i2 + 1];
        const c2 = array[i2 + 2];
        indices.push(a2, b2, b2, c2, c2, a2);
      }
    } else {
      const array = geometryPosition.array;
      version = geometryPosition.version;
      for (let i2 = 0, l2 = array.length / 3 - 1; i2 < l2; i2 += 3) {
        const a2 = i2 + 0;
        const b2 = i2 + 1;
        const c2 = i2 + 2;
        indices.push(a2, b2, b2, c2, c2, a2);
      }
    }
    const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version;
    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute)
      attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get,
    update,
    getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawElementsInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawElementsInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLInfo(gl) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update(count, mode, instanceCount) {
    render.calls++;
    switch (mode) {
      case 4:
        render.triangles += instanceCount * (count / 3);
        break;
      case 1:
        render.lines += instanceCount * (count / 2);
        break;
      case 3:
        render.lines += instanceCount * (count - 1);
        break;
      case 2:
        render.lines += instanceCount * count;
        break;
      case 0:
        render.points += instanceCount * count;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  function reset() {
    render.frame++;
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }
  return {
    memory,
    render,
    programs: null,
    autoReset: true,
    reset,
    update
  };
}
function numericalSort(a2, b2) {
  return a2[0] - b2[0];
}
function absNumericalSort(a2, b2) {
  return Math.abs(b2[1]) - Math.abs(a2[1]);
}
function denormalize(morph, attribute) {
  let denominator = 1;
  const array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;
  if (array instanceof Int8Array)
    denominator = 127;
  else if (array instanceof Int16Array)
    denominator = 32767;
  else if (array instanceof Int32Array)
    denominator = 2147483647;
  else
    console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", array);
  morph.divideScalar(denominator);
}
function WebGLMorphtargets(gl, capabilities, textures) {
  const influencesList = {};
  const morphInfluences = new Float32Array(8);
  const morphTextures = /* @__PURE__ */ new WeakMap();
  const morph = new Vector4();
  const workInfluences = [];
  for (let i2 = 0; i2 < 8; i2++) {
    workInfluences[i2] = [i2, 0];
  }
  function update(object, geometry, material, program) {
    const objectInfluences = object.morphTargetInfluences;
    if (capabilities.isWebGL2 === true) {
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
      let entry = morphTextures.get(geometry);
      if (entry === void 0 || entry.count !== morphTargetsCount) {
        let disposeTexture = function() {
          texture.dispose();
          morphTextures.delete(geometry);
          geometry.removeEventListener("dispose", disposeTexture);
        };
        if (entry !== void 0)
          entry.texture.dispose();
        const hasMorphPosition = geometry.morphAttributes.position !== void 0;
        const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
        const hasMorphColors = geometry.morphAttributes.color !== void 0;
        const morphTargets = geometry.morphAttributes.position || [];
        const morphNormals = geometry.morphAttributes.normal || [];
        const morphColors = geometry.morphAttributes.color || [];
        let vertexDataCount = 0;
        if (hasMorphPosition === true)
          vertexDataCount = 1;
        if (hasMorphNormals === true)
          vertexDataCount = 2;
        if (hasMorphColors === true)
          vertexDataCount = 3;
        let width = geometry.attributes.position.count * vertexDataCount;
        let height = 1;
        if (width > capabilities.maxTextureSize) {
          height = Math.ceil(width / capabilities.maxTextureSize);
          width = capabilities.maxTextureSize;
        }
        const buffer = new Float32Array(width * height * 4 * morphTargetsCount);
        const texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);
        texture.format = RGBAFormat;
        texture.type = FloatType;
        texture.needsUpdate = true;
        const vertexDataStride = vertexDataCount * 4;
        for (let i2 = 0; i2 < morphTargetsCount; i2++) {
          const morphTarget = morphTargets[i2];
          const morphNormal = morphNormals[i2];
          const morphColor = morphColors[i2];
          const offset = width * height * 4 * i2;
          for (let j2 = 0; j2 < morphTarget.count; j2++) {
            const stride = j2 * vertexDataStride;
            if (hasMorphPosition === true) {
              morph.fromBufferAttribute(morphTarget, j2);
              if (morphTarget.normalized === true)
                denormalize(morph, morphTarget);
              buffer[offset + stride + 0] = morph.x;
              buffer[offset + stride + 1] = morph.y;
              buffer[offset + stride + 2] = morph.z;
              buffer[offset + stride + 3] = 0;
            }
            if (hasMorphNormals === true) {
              morph.fromBufferAttribute(morphNormal, j2);
              if (morphNormal.normalized === true)
                denormalize(morph, morphNormal);
              buffer[offset + stride + 4] = morph.x;
              buffer[offset + stride + 5] = morph.y;
              buffer[offset + stride + 6] = morph.z;
              buffer[offset + stride + 7] = 0;
            }
            if (hasMorphColors === true) {
              morph.fromBufferAttribute(morphColor, j2);
              if (morphColor.normalized === true)
                denormalize(morph, morphNormal);
              buffer[offset + stride + 8] = morph.x;
              buffer[offset + stride + 9] = morph.y;
              buffer[offset + stride + 10] = morph.z;
              buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
            }
          }
        }
        entry = {
          count: morphTargetsCount,
          texture,
          size: new Vector2(width, height)
        };
        morphTextures.set(geometry, entry);
        geometry.addEventListener("dispose", disposeTexture);
      }
      let morphInfluencesSum = 0;
      for (let i2 = 0; i2 < objectInfluences.length; i2++) {
        morphInfluencesSum += objectInfluences[i2];
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences);
      program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures);
      program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
    } else {
      const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
      let influences = influencesList[geometry.id];
      if (influences === void 0 || influences.length !== length) {
        influences = [];
        for (let i2 = 0; i2 < length; i2++) {
          influences[i2] = [i2, 0];
        }
        influencesList[geometry.id] = influences;
      }
      for (let i2 = 0; i2 < length; i2++) {
        const influence = influences[i2];
        influence[0] = i2;
        influence[1] = objectInfluences[i2];
      }
      influences.sort(absNumericalSort);
      for (let i2 = 0; i2 < 8; i2++) {
        if (i2 < length && influences[i2][1]) {
          workInfluences[i2][0] = influences[i2][0];
          workInfluences[i2][1] = influences[i2][1];
        } else {
          workInfluences[i2][0] = Number.MAX_SAFE_INTEGER;
          workInfluences[i2][1] = 0;
        }
      }
      workInfluences.sort(numericalSort);
      const morphTargets = geometry.morphAttributes.position;
      const morphNormals = geometry.morphAttributes.normal;
      let morphInfluencesSum = 0;
      for (let i2 = 0; i2 < 8; i2++) {
        const influence = workInfluences[i2];
        const index = influence[0];
        const value = influence[1];
        if (index !== Number.MAX_SAFE_INTEGER && value) {
          if (morphTargets && geometry.getAttribute("morphTarget" + i2) !== morphTargets[index]) {
            geometry.setAttribute("morphTarget" + i2, morphTargets[index]);
          }
          if (morphNormals && geometry.getAttribute("morphNormal" + i2) !== morphNormals[index]) {
            geometry.setAttribute("morphNormal" + i2, morphNormals[index]);
          }
          morphInfluences[i2] = value;
          morphInfluencesSum += value;
        } else {
          if (morphTargets && geometry.hasAttribute("morphTarget" + i2) === true) {
            geometry.deleteAttribute("morphTarget" + i2);
          }
          if (morphNormals && geometry.hasAttribute("morphNormal" + i2) === true) {
            geometry.deleteAttribute("morphNormal" + i2);
          }
          morphInfluences[i2] = 0;
        }
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
    }
  }
  return {
    update
  };
}
function WebGLObjects(gl, geometries, attributes, info) {
  let updateMap = /* @__PURE__ */ new WeakMap();
  function update(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries.get(object, geometry);
    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object.isInstancedMesh) {
      if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
        object.addEventListener("dispose", onInstancedMeshDispose);
      }
      attributes.update(object.instanceMatrix, 34962);
      if (object.instanceColor !== null) {
        attributes.update(object.instanceColor, 34962);
      }
    }
    return buffergeometry;
  }
  function dispose() {
    updateMap = /* @__PURE__ */ new WeakMap();
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null)
      attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update,
    dispose
  };
}
const emptyTexture = new Texture();
const emptyArrayTexture = new DataArrayTexture();
const empty3dTexture = new Data3DTexture();
const emptyCubeTexture = new CubeTexture();
const arrayCacheF32 = [];
const arrayCacheI32 = [];
const mat4array = new Float32Array(16);
const mat3array = new Float32Array(9);
const mat2array = new Float32Array(4);
function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0)
    return array;
  const n2 = nBlocks * blockSize;
  let r2 = arrayCacheF32[n2];
  if (r2 === void 0) {
    r2 = new Float32Array(n2);
    arrayCacheF32[n2] = r2;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r2, 0);
    for (let i2 = 1, offset = 0; i2 !== nBlocks; ++i2) {
      offset += blockSize;
      array[i2].toArray(r2, offset);
    }
  }
  return r2;
}
function arraysEqual(a2, b2) {
  if (a2.length !== b2.length)
    return false;
  for (let i2 = 0, l2 = a2.length; i2 < l2; i2++) {
    if (a2[i2] !== b2[i2])
      return false;
  }
  return true;
}
function copyArray(a2, b2) {
  for (let i2 = 0, l2 = b2.length; i2 < l2; i2++) {
    a2[i2] = b2[i2];
  }
}
function allocTexUnits(textures, n2) {
  let r2 = arrayCacheI32[n2];
  if (r2 === void 0) {
    r2 = new Int32Array(n2);
    arrayCacheI32[n2] = r2;
  }
  for (let i2 = 0; i2 !== n2; ++i2) {
    r2[i2] = textures.allocateTextureUnit();
  }
  return r2;
}
function setValueV1f(gl, v2) {
  const cache = this.cache;
  if (cache[0] === v2)
    return;
  gl.uniform1f(this.addr, v2);
  cache[0] = v2;
}
function setValueV2f(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y) {
      gl.uniform2f(this.addr, v2.x, v2.y);
      cache[0] = v2.x;
      cache[1] = v2.y;
    }
  } else {
    if (arraysEqual(cache, v2))
      return;
    gl.uniform2fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV3f(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z) {
      gl.uniform3f(this.addr, v2.x, v2.y, v2.z);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
    }
  } else if (v2.r !== void 0) {
    if (cache[0] !== v2.r || cache[1] !== v2.g || cache[2] !== v2.b) {
      gl.uniform3f(this.addr, v2.r, v2.g, v2.b);
      cache[0] = v2.r;
      cache[1] = v2.g;
      cache[2] = v2.b;
    }
  } else {
    if (arraysEqual(cache, v2))
      return;
    gl.uniform3fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV4f(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z || cache[3] !== v2.w) {
      gl.uniform4f(this.addr, v2.x, v2.y, v2.z, v2.w);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
      cache[3] = v2.w;
    }
  } else {
    if (arraysEqual(cache, v2))
      return;
    gl.uniform4fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueM2(gl, v2) {
  const cache = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2))
      return;
    gl.uniformMatrix2fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}
function setValueM3(gl, v2) {
  const cache = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2))
      return;
    gl.uniformMatrix3fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}
function setValueM4(gl, v2) {
  const cache = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2))
      return;
    gl.uniformMatrix4fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
}
function setValueV1i(gl, v2) {
  const cache = this.cache;
  if (cache[0] === v2)
    return;
  gl.uniform1i(this.addr, v2);
  cache[0] = v2;
}
function setValueV2i(gl, v2) {
  const cache = this.cache;
  if (arraysEqual(cache, v2))
    return;
  gl.uniform2iv(this.addr, v2);
  copyArray(cache, v2);
}
function setValueV3i(gl, v2) {
  const cache = this.cache;
  if (arraysEqual(cache, v2))
    return;
  gl.uniform3iv(this.addr, v2);
  copyArray(cache, v2);
}
function setValueV4i(gl, v2) {
  const cache = this.cache;
  if (arraysEqual(cache, v2))
    return;
  gl.uniform4iv(this.addr, v2);
  copyArray(cache, v2);
}
function setValueV1ui(gl, v2) {
  const cache = this.cache;
  if (cache[0] === v2)
    return;
  gl.uniform1ui(this.addr, v2);
  cache[0] = v2;
}
function setValueV2ui(gl, v2) {
  const cache = this.cache;
  if (arraysEqual(cache, v2))
    return;
  gl.uniform2uiv(this.addr, v2);
  copyArray(cache, v2);
}
function setValueV3ui(gl, v2) {
  const cache = this.cache;
  if (arraysEqual(cache, v2))
    return;
  gl.uniform3uiv(this.addr, v2);
  copyArray(cache, v2);
}
function setValueV4ui(gl, v2) {
  const cache = this.cache;
  if (arraysEqual(cache, v2))
    return;
  gl.uniform4uiv(this.addr, v2);
  copyArray(cache, v2);
}
function setValueT1(gl, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2D(v2 || emptyTexture, unit);
}
function setValueT3D1(gl, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture3D(v2 || empty3dTexture, unit);
}
function setValueT6(gl, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTextureCube(v2 || emptyCubeTexture, unit);
}
function setValueT2DArray1(gl, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2DArray(v2 || emptyArrayTexture, unit);
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 36294:
      return setValueV2ui;
    case 36295:
      return setValueV3ui;
    case 36296:
      return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(gl, v2) {
  gl.uniform1fv(this.addr, v2);
}
function setValueV2fArray(gl, v2) {
  const data = flatten(v2, this.size, 2);
  gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v2) {
  const data = flatten(v2, this.size, 3);
  gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v2) {
  const data = flatten(v2, this.size, 4);
  gl.uniform4fv(this.addr, data);
}
function setValueM2Array(gl, v2) {
  const data = flatten(v2, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v2) {
  const data = flatten(v2, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v2) {
  const data = flatten(v2, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
}
function setValueV1iArray(gl, v2) {
  gl.uniform1iv(this.addr, v2);
}
function setValueV2iArray(gl, v2) {
  gl.uniform2iv(this.addr, v2);
}
function setValueV3iArray(gl, v2) {
  gl.uniform3iv(this.addr, v2);
}
function setValueV4iArray(gl, v2) {
  gl.uniform4iv(this.addr, v2);
}
function setValueV1uiArray(gl, v2) {
  gl.uniform1uiv(this.addr, v2);
}
function setValueV2uiArray(gl, v2) {
  gl.uniform2uiv(this.addr, v2);
}
function setValueV3uiArray(gl, v2) {
  gl.uniform3uiv(this.addr, v2);
}
function setValueV4uiArray(gl, v2) {
  gl.uniform4uiv(this.addr, v2);
}
function setValueT1Array(gl, v2, textures) {
  const n2 = v2.length;
  const units = allocTexUnits(textures, n2);
  gl.uniform1iv(this.addr, units);
  for (let i2 = 0; i2 !== n2; ++i2) {
    textures.setTexture2D(v2[i2] || emptyTexture, units[i2]);
  }
}
function setValueT3DArray(gl, v2, textures) {
  const n2 = v2.length;
  const units = allocTexUnits(textures, n2);
  gl.uniform1iv(this.addr, units);
  for (let i2 = 0; i2 !== n2; ++i2) {
    textures.setTexture3D(v2[i2] || empty3dTexture, units[i2]);
  }
}
function setValueT6Array(gl, v2, textures) {
  const n2 = v2.length;
  const units = allocTexUnits(textures, n2);
  gl.uniform1iv(this.addr, units);
  for (let i2 = 0; i2 !== n2; ++i2) {
    textures.setTextureCube(v2[i2] || emptyCubeTexture, units[i2]);
  }
}
function setValueT2DArrayArray(gl, v2, textures) {
  const n2 = v2.length;
  const units = allocTexUnits(textures, n2);
  gl.uniform1iv(this.addr, units);
  for (let i2 = 0; i2 !== n2; ++i2) {
    textures.setTexture2DArray(v2[i2] || emptyArrayTexture, units[i2]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 5125:
      return setValueV1uiArray;
    case 36294:
      return setValueV2uiArray;
    case 36295:
      return setValueV3uiArray;
    case 36296:
      return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3DArray;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArrayArray;
  }
}
function SingleUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.setValue = getSingularSetter(activeInfo.type);
}
function PureArrayUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type);
}
PureArrayUniform.prototype.updateCache = function(data) {
  const cache = this.cache;
  if (data instanceof Float32Array && cache.length !== data.length) {
    this.cache = new Float32Array(data.length);
  }
  copyArray(cache, data);
};
function StructuredUniform(id) {
  this.id = id;
  this.seq = [];
  this.map = {};
}
StructuredUniform.prototype.setValue = function(gl, value, textures) {
  const seq = this.seq;
  for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
    const u2 = seq[i2];
    u2.setValue(gl, value[u2.id], textures);
  }
};
const RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
    let id = match[1];
    const idIsIndex = match[2] === "]", subscript = match[3];
    if (idIsIndex)
      id = id | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      const map = container.map;
      let next = map[id];
      if (next === void 0) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }
      container = next;
    }
  }
}
function WebGLUniforms(gl, program) {
  this.seq = [];
  this.map = {};
  const n2 = gl.getProgramParameter(program, 35718);
  for (let i2 = 0; i2 < n2; ++i2) {
    const info = gl.getActiveUniform(program, i2), addr = gl.getUniformLocation(program, info.name);
    parseUniform(info, addr, this);
  }
}
WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
  const u2 = this.map[name];
  if (u2 !== void 0)
    u2.setValue(gl, value, textures);
};
WebGLUniforms.prototype.setOptional = function(gl, object, name) {
  const v2 = object[name];
  if (v2 !== void 0)
    this.setValue(gl, name, v2);
};
WebGLUniforms.upload = function(gl, seq, values, textures) {
  for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
    const u2 = seq[i2], v2 = values[u2.id];
    if (v2.needsUpdate !== false) {
      u2.setValue(gl, v2.value, textures);
    }
  }
};
WebGLUniforms.seqWithValue = function(seq, values) {
  const r2 = [];
  for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
    const u2 = seq[i2];
    if (u2.id in values)
      r2.push(u2);
  }
  return r2;
};
function WebGLShader(gl, type, string) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}
let programIdCount = 0;
function addLineNumbers(string) {
  const lines = string.split("\n");
  for (let i2 = 0; i2 < lines.length; i2++) {
    lines[i2] = i2 + 1 + ": " + lines[i2];
  }
  return lines.join("\n");
}
function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ["Linear", "( value )"];
    case sRGBEncoding:
      return ["sRGB", "( value )"];
    default:
      console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
      return ["Linear", "( value )"];
  }
}
function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, 35713);
  const errors = gl.getShaderInfoLog(shader).trim();
  if (status && errors === "")
    return "";
  return type.toUpperCase() + "\n\n" + errors + "\n\n" + addLineNumbers(gl.getShaderSource(shader));
}
function getTexelEncodingFunction(functionName, encoding) {
  const components2 = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components2[0] + components2[1] + "; }";
}
function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case CineonToneMapping:
      toneMappingName = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    case CustomToneMapping:
      toneMappingName = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
      toneMappingName = "Linear";
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
function generateExtensions(parameters) {
  const chunks = [
    parameters.extensionDerivatives || !!parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  const chunks = [];
  for (const name in defines) {
    const value = defines[name];
    if (value === false)
      continue;
    chunks.push("#define " + name + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl, program) {
  const attributes = {};
  const n2 = gl.getProgramParameter(program, 35721);
  for (let i2 = 0; i2 < n2; i2++) {
    const info = gl.getActiveAttrib(program, i2);
    const name = info.name;
    let locationSize = 1;
    if (info.type === 35674)
      locationSize = 2;
    if (info.type === 35675)
      locationSize = 3;
    if (info.type === 35676)
      locationSize = 4;
    attributes[name] = {
      type: info.type,
      location: gl.getAttribLocation(program, name),
      locationSize
    };
  }
  return attributes;
}
function filterEmptyLine(string) {
  return string !== "";
}
function replaceLightNums(string, parameters) {
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}
function includeReplacer(match, include) {
  const string = ShaderChunk[include];
  if (string === void 0) {
    throw new Error("Can not resolve #include <" + include + ">");
  }
  return resolveIncludes(string);
}
const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}
function deprecatedLoopReplacer(match, start, end, snippet) {
  console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
  return loopReplacer(match, start, end, snippet);
}
function loopReplacer(match, start, end, snippet) {
  let string = "";
  for (let i2 = parseInt(start); i2 < parseInt(end); i2++) {
    string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i2 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i2);
  }
  return string;
}
function generatePrecision(parameters) {
  let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
  }
  return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
      case CubeUVRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  }
  return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
      case CubeUVRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return envMapBlendingDefine;
}
function generateCubeUVSize(parameters) {
  const imageHeight = parameters.envMapCubeUVHeight;
  if (imageHeight === null)
    return null;
  const maxMip = Math.log2(imageHeight / 32 + 1) + 3;
  const texelHeight = 1 / imageHeight;
  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return { texelWidth, texelHeight, maxMip };
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  const gl = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const envMapCubeUVSize = generateCubeUVSize(parameters);
  const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      customExtensions,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
      "#define MAX_BONES " + parameters.maxBones,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.morphColors && parameters.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + parameters.morphTextureStride : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      customExtensions,
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_WIDTH " + envMapCubeUVSize.texelWidth : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_HEIGHT " + envMapCubeUVSize.texelHeight : "",
      envMapCubeUVSize ? "#define CUBEUV_MAX_MIP " + envMapCubeUVSize.maxMip + ".0" : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaTest ? "#define USE_ALPHATEST" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      parameters.opaque ? "#define OPAQUE" : "",
      ShaderChunk["encodings_pars_fragment"],
      getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
      parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
    versionString = "#version 300 es\n";
    prefixVertex = [
      "precision mediump sampler2DArray;",
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "#define varying in",
      parameters.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
      parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader;
  const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== void 0) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, "position");
  }
  gl.linkProgram(program);
  if (renderer.debug.checkShaderErrors) {
    const programLog = gl.getProgramInfoLog(program).trim();
    const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
    const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
    let runnable = true;
    let haveDiagnostics = true;
    if (gl.getProgramParameter(program, 35714) === false) {
      runnable = false;
      const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
      const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
      console.error("THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(program, 35715) + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors);
    } else if (programLog !== "") {
      console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
    } else if (vertexLog === "" || fragmentLog === "") {
      haveDiagnostics = false;
    }
    if (haveDiagnostics) {
      this.diagnostics = {
        runnable,
        programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
  }
  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader);
  let cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      cachedUniforms = new WebGLUniforms(gl, program);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }
    return cachedAttributes;
  };
  this.destroy = function() {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = void 0;
  };
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
let _id = 0;
class WebGLShaderCache {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map();
    this.materialCache = /* @__PURE__ */ new Map();
  }
  update(material) {
    const vertexShader = material.vertexShader;
    const fragmentShader = material.fragmentShader;
    const vertexShaderStage = this._getShaderStage(vertexShader);
    const fragmentShaderStage = this._getShaderStage(fragmentShader);
    const materialShaders = this._getShaderCacheForMaterial(material);
    if (materialShaders.has(vertexShaderStage) === false) {
      materialShaders.add(vertexShaderStage);
      vertexShaderStage.usedTimes++;
    }
    if (materialShaders.has(fragmentShaderStage) === false) {
      materialShaders.add(fragmentShaderStage);
      fragmentShaderStage.usedTimes++;
    }
    return this;
  }
  remove(material) {
    const materialShaders = this.materialCache.get(material);
    for (const shaderStage of materialShaders) {
      shaderStage.usedTimes--;
      if (shaderStage.usedTimes === 0)
        this.shaderCache.delete(shaderStage);
    }
    this.materialCache.delete(material);
    return this;
  }
  getVertexShaderID(material) {
    return this._getShaderStage(material.vertexShader).id;
  }
  getFragmentShaderID(material) {
    return this._getShaderStage(material.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear();
    this.materialCache.clear();
  }
  _getShaderCacheForMaterial(material) {
    const cache = this.materialCache;
    if (cache.has(material) === false) {
      cache.set(material, /* @__PURE__ */ new Set());
    }
    return cache.get(material);
  }
  _getShaderStage(code) {
    const cache = this.shaderCache;
    if (cache.has(code) === false) {
      const stage = new WebGLShaderStage();
      cache.set(code, stage);
    }
    return cache.get(code);
  }
}
class WebGLShaderStage {
  constructor() {
    this.id = _id++;
    this.usedTimes = 0;
  }
}
function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
  const _programLayers = new Layers();
  const _customShaders = new WebGLShaderCache();
  const programs = [];
  const isWebGL2 = capabilities.isWebGL2;
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const floatVertexTextures = capabilities.floatVertexTextures;
  const maxVertexUniforms = capabilities.maxVertexUniforms;
  const vertexTextures = capabilities.vertexTextures;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function getMaxBones(object) {
    const skeleton = object.skeleton;
    const bones = skeleton.bones;
    if (floatVertexTextures) {
      return 1024;
    } else {
      const nVertexUniforms = maxVertexUniforms;
      const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      const maxBones = Math.min(nVertexMatrices, bones.length);
      if (maxBones < bones.length) {
        console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
        return 0;
      }
      return maxBones;
    }
  }
  function getParameters(material, lights, shadows, scene, object) {
    const fog = scene.fog;
    const geometry = object.geometry;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    const envMapCubeUVHeight = !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping) ? envMap.image.height : null;
    const shaderID = shaderIDs[material.type];
    const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
      }
    }
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    let morphTextureStride = 0;
    if (geometry.morphAttributes.position !== void 0)
      morphTextureStride = 1;
    if (geometry.morphAttributes.normal !== void 0)
      morphTextureStride = 2;
    if (geometry.morphAttributes.color !== void 0)
      morphTextureStride = 3;
    let vertexShader, fragmentShader;
    let customVertexShaderID, customFragmentShaderID;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
      _customShaders.update(material);
      customVertexShaderID = _customShaders.getVertexShaderID(material);
      customFragmentShaderID = _customShaders.getFragmentShaderID(material);
    }
    const currentRenderTarget = renderer.getRenderTarget();
    const useAlphaTest = material.alphaTest > 0;
    const useClearcoat = material.clearcoat > 0;
    const parameters = {
      isWebGL2,
      shaderID,
      shaderName: material.type,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      customVertexShaderID,
      customFragmentShaderID,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision,
      instancing: object.isInstancedMesh === true,
      instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
      supportsVertexTextures: vertexTextures,
      outputEncoding: currentRenderTarget === null ? renderer.outputEncoding : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.encoding : LinearEncoding,
      map: !!material.map,
      matcap: !!material.matcap,
      envMap: !!envMap,
      envMapMode: envMap && envMap.mapping,
      envMapCubeUVHeight,
      lightMap: !!material.lightMap,
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
      decodeVideoTexture: !!material.map && material.map.isVideoTexture === true && material.map.encoding === sRGBEncoding,
      clearcoat: useClearcoat,
      clearcoatMap: useClearcoat && !!material.clearcoatMap,
      clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
      clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      specularIntensityMap: !!material.specularIntensityMap,
      specularColorMap: !!material.specularColorMap,
      opaque: material.transparent === false && material.blending === NormalBlending,
      alphaMap: !!material.alphaMap,
      alphaTest: useAlphaTest,
      gradientMap: !!material.gradientMap,
      sheen: material.sheen > 0,
      sheenColorMap: !!material.sheenColorMap,
      sheenRoughnessMap: !!material.sheenRoughnessMap,
      transmission: material.transmission > 0,
      transmissionMap: !!material.transmissionMap,
      thicknessMap: !!material.thicknessMap,
      combine: material.combine,
      vertexTangents: !!material.normalMap && !!geometry.attributes.tangent,
      vertexColors: material.vertexColors,
      vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheenColorMap || !!material.sheenRoughnessMap,
      uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || material.sheen > 0 || !!material.sheenColorMap || !!material.sheenRoughnessMap) && !!material.displacementMap,
      fog: !!fog,
      useFog: material.fog,
      fogExp2: fog && fog.isFogExp2,
      flatShading: !!material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer,
      skinning: object.isSkinnedMesh === true && maxBones > 0,
      maxBones,
      useVertexTexture: floatVertexTextures,
      morphTargets: geometry.morphAttributes.position !== void 0,
      morphNormals: geometry.morphAttributes.normal !== void 0,
      morphColors: geometry.morphAttributes.color !== void 0,
      morphTargetsCount,
      morphTextureStride,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
      physicallyCorrectLights: renderer.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives: material.extensions && material.extensions.derivatives,
      extensionFragDepth: material.extensions && material.extensions.fragDepth,
      extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
      extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.customVertexShaderID);
      array.push(parameters.customFragmentShaderID);
    }
    if (parameters.defines !== void 0) {
      for (const name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      getProgramCacheKeyParameters(array, parameters);
      getProgramCacheKeyBooleans(array, parameters);
      array.push(renderer.outputEncoding);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  function getProgramCacheKeyParameters(array, parameters) {
    array.push(parameters.precision);
    array.push(parameters.outputEncoding);
    array.push(parameters.envMapMode);
    array.push(parameters.envMapCubeUVHeight);
    array.push(parameters.combine);
    array.push(parameters.vertexUvs);
    array.push(parameters.fogExp2);
    array.push(parameters.sizeAttenuation);
    array.push(parameters.maxBones);
    array.push(parameters.morphTargetsCount);
    array.push(parameters.morphAttributeCount);
    array.push(parameters.numDirLights);
    array.push(parameters.numPointLights);
    array.push(parameters.numSpotLights);
    array.push(parameters.numHemiLights);
    array.push(parameters.numRectAreaLights);
    array.push(parameters.numDirLightShadows);
    array.push(parameters.numPointLightShadows);
    array.push(parameters.numSpotLightShadows);
    array.push(parameters.shadowMapType);
    array.push(parameters.toneMapping);
    array.push(parameters.numClippingPlanes);
    array.push(parameters.numClipIntersection);
  }
  function getProgramCacheKeyBooleans(array, parameters) {
    _programLayers.disableAll();
    if (parameters.isWebGL2)
      _programLayers.enable(0);
    if (parameters.supportsVertexTextures)
      _programLayers.enable(1);
    if (parameters.instancing)
      _programLayers.enable(2);
    if (parameters.instancingColor)
      _programLayers.enable(3);
    if (parameters.map)
      _programLayers.enable(4);
    if (parameters.matcap)
      _programLayers.enable(5);
    if (parameters.envMap)
      _programLayers.enable(6);
    if (parameters.lightMap)
      _programLayers.enable(7);
    if (parameters.aoMap)
      _programLayers.enable(8);
    if (parameters.emissiveMap)
      _programLayers.enable(9);
    if (parameters.bumpMap)
      _programLayers.enable(10);
    if (parameters.normalMap)
      _programLayers.enable(11);
    if (parameters.objectSpaceNormalMap)
      _programLayers.enable(12);
    if (parameters.tangentSpaceNormalMap)
      _programLayers.enable(13);
    if (parameters.clearcoat)
      _programLayers.enable(14);
    if (parameters.clearcoatMap)
      _programLayers.enable(15);
    if (parameters.clearcoatRoughnessMap)
      _programLayers.enable(16);
    if (parameters.clearcoatNormalMap)
      _programLayers.enable(17);
    if (parameters.displacementMap)
      _programLayers.enable(18);
    if (parameters.specularMap)
      _programLayers.enable(19);
    if (parameters.roughnessMap)
      _programLayers.enable(20);
    if (parameters.metalnessMap)
      _programLayers.enable(21);
    if (parameters.gradientMap)
      _programLayers.enable(22);
    if (parameters.alphaMap)
      _programLayers.enable(23);
    if (parameters.alphaTest)
      _programLayers.enable(24);
    if (parameters.vertexColors)
      _programLayers.enable(25);
    if (parameters.vertexAlphas)
      _programLayers.enable(26);
    if (parameters.vertexUvs)
      _programLayers.enable(27);
    if (parameters.vertexTangents)
      _programLayers.enable(28);
    if (parameters.uvsVertexOnly)
      _programLayers.enable(29);
    if (parameters.fog)
      _programLayers.enable(30);
    array.push(_programLayers.mask);
    _programLayers.disableAll();
    if (parameters.useFog)
      _programLayers.enable(0);
    if (parameters.flatShading)
      _programLayers.enable(1);
    if (parameters.logarithmicDepthBuffer)
      _programLayers.enable(2);
    if (parameters.skinning)
      _programLayers.enable(3);
    if (parameters.useVertexTexture)
      _programLayers.enable(4);
    if (parameters.morphTargets)
      _programLayers.enable(5);
    if (parameters.morphNormals)
      _programLayers.enable(6);
    if (parameters.morphColors)
      _programLayers.enable(7);
    if (parameters.premultipliedAlpha)
      _programLayers.enable(8);
    if (parameters.shadowMapEnabled)
      _programLayers.enable(9);
    if (parameters.physicallyCorrectLights)
      _programLayers.enable(10);
    if (parameters.doubleSided)
      _programLayers.enable(11);
    if (parameters.flipSided)
      _programLayers.enable(12);
    if (parameters.depthPacking)
      _programLayers.enable(13);
    if (parameters.dithering)
      _programLayers.enable(14);
    if (parameters.specularIntensityMap)
      _programLayers.enable(15);
    if (parameters.specularColorMap)
      _programLayers.enable(16);
    if (parameters.transmission)
      _programLayers.enable(17);
    if (parameters.transmissionMap)
      _programLayers.enable(18);
    if (parameters.thicknessMap)
      _programLayers.enable(19);
    if (parameters.sheen)
      _programLayers.enable(20);
    if (parameters.sheenColorMap)
      _programLayers.enable(21);
    if (parameters.sheenRoughnessMap)
      _programLayers.enable(22);
    if (parameters.decodeVideoTexture)
      _programLayers.enable(23);
    if (parameters.opaque)
      _programLayers.enable(24);
    array.push(_programLayers.mask);
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    let program;
    for (let p2 = 0, pl = programs.length; p2 < pl; p2++) {
      const preexistingProgram = programs[p2];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i2 = programs.indexOf(program);
      programs[i2] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  }
  function releaseShaderCache(material) {
    _customShaders.remove(material);
  }
  function dispose() {
    _customShaders.dispose();
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    releaseShaderCache,
    programs,
    dispose
  };
}
function WebGLProperties() {
  let properties = /* @__PURE__ */ new WeakMap();
  function get(object) {
    let map = properties.get(object);
    if (map === void 0) {
      map = {};
      properties.set(object, map);
    }
    return map;
  }
  function remove(object) {
    properties.delete(object);
  }
  function update(object, key, value) {
    properties.get(object)[key] = value;
  }
  function dispose() {
    properties = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    remove,
    update,
    dispose
  };
}
function painterSortStable(a2, b2) {
  if (a2.groupOrder !== b2.groupOrder) {
    return a2.groupOrder - b2.groupOrder;
  } else if (a2.renderOrder !== b2.renderOrder) {
    return a2.renderOrder - b2.renderOrder;
  } else if (a2.material.id !== b2.material.id) {
    return a2.material.id - b2.material.id;
  } else if (a2.z !== b2.z) {
    return a2.z - b2.z;
  } else {
    return a2.id - b2.id;
  }
}
function reversePainterSortStable(a2, b2) {
  if (a2.groupOrder !== b2.groupOrder) {
    return a2.groupOrder - b2.groupOrder;
  } else if (a2.renderOrder !== b2.renderOrder) {
    return a2.renderOrder - b2.renderOrder;
  } else if (a2.z !== b2.z) {
    return b2.z - a2.z;
  } else {
    return a2.id - b2.id;
  }
}
function WebGLRenderList() {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transmissive = [];
  const transparent = [];
  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transmissive.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry, material, groupOrder, z2, group) {
    let renderItem = renderItems[renderItemsIndex];
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        groupOrder,
        renderOrder: object.renderOrder,
        z: z2,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z2;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object, geometry, material, groupOrder, z2, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z2, group);
    if (material.transmission > 0) {
      transmissive.push(renderItem);
    } else if (material.transparent === true) {
      transparent.push(renderItem);
    } else {
      opaque.push(renderItem);
    }
  }
  function unshift(object, geometry, material, groupOrder, z2, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z2, group);
    if (material.transmission > 0) {
      transmissive.unshift(renderItem);
    } else if (material.transparent === true) {
      transparent.unshift(renderItem);
    } else {
      opaque.unshift(renderItem);
    }
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1)
      opaque.sort(customOpaqueSort || painterSortStable);
    if (transmissive.length > 1)
      transmissive.sort(customTransparentSort || reversePainterSortStable);
    if (transparent.length > 1)
      transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    for (let i2 = renderItemsIndex, il = renderItems.length; i2 < il; i2++) {
      const renderItem = renderItems[i2];
      if (renderItem.id === null)
        break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.group = null;
    }
  }
  return {
    opaque,
    transmissive,
    transparent,
    init,
    push,
    unshift,
    finish,
    sort
  };
}
function WebGLRenderLists() {
  let lists = /* @__PURE__ */ new WeakMap();
  function get(scene, renderCallDepth) {
    let list;
    if (lists.has(scene) === false) {
      list = new WebGLRenderList();
      lists.set(scene, [list]);
    } else {
      if (renderCallDepth >= lists.get(scene).length) {
        list = new WebGLRenderList();
        lists.get(scene).push(list);
      } else {
        list = lists.get(scene)[renderCallDepth];
      }
    }
    return list;
  }
  function dispose() {
    lists = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
function UniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
let nextVersion = 0;
function shadowCastingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}
function WebGLLights(extensions, capabilities) {
  const cache = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  for (let i2 = 0; i2 < 9; i2++)
    state.probe.push(new Vector3());
  const vector3 = new Vector3();
  const matrix4 = new Matrix4();
  const matrix42 = new Matrix4();
  function setup(lights, physicallyCorrectLights) {
    let r2 = 0, g2 = 0, b2 = 0;
    for (let i2 = 0; i2 < 9; i2++)
      state.probe[i2].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    lights.sort(shadowCastingLightsFirst);
    const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;
    for (let i2 = 0, l2 = lights.length; i2 < l2; i2++) {
      const light = lights[i2];
      const color = light.color;
      const intensity = light.intensity;
      const distance = light.distance;
      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r2 += color.r * intensity * scaleFactor;
        g2 += color.g * intensity * scaleFactor;
        b2 += color.b * intensity * scaleFactor;
      } else if (light.isLightProbe) {
        for (let j2 = 0; j2 < 9; j2++) {
          state.probe[j2].addScaledVector(light.sh.coefficients[j2], intensity);
        }
      } else if (light.isDirectionalLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
        uniforms.distance = distance;
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          state.spotShadowMatrix[spotLength] = light.shadow.matrix;
          numSpotShadows++;
        }
        state.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache.get(light);
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (capabilities.isWebGL2) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        if (extensions.has("OES_texture_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else if (extensions.has("OES_texture_half_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
        } else {
          console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
        }
      }
    }
    state.ambient[0] = r2;
    state.ambient[1] = g2;
    state.ambient[2] = b2;
    const hash = state.hash;
    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotShadowMatrix.length = numSpotShadows;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera.matrixWorldInverse;
    for (let i2 = 0, l2 = lights.length; i2 < l2; i2++) {
      const light = lights[i2];
      if (light.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.direction.normalize();
        hemiLength++;
      }
    }
  }
  return {
    setup,
    setupView,
    state
  };
}
function WebGLRenderState(extensions, capabilities) {
  const lights = new WebGLLights(extensions, capabilities);
  const lightsArray = [];
  const shadowsArray = [];
  function init() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights(physicallyCorrectLights) {
    lights.setup(lightsArray, physicallyCorrectLights);
  }
  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }
  const state = {
    lightsArray,
    shadowsArray,
    lights
  };
  return {
    init,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow
  };
}
function WebGLRenderStates(extensions, capabilities) {
  let renderStates = /* @__PURE__ */ new WeakMap();
  function get(scene, renderCallDepth = 0) {
    let renderState;
    if (renderStates.has(scene) === false) {
      renderState = new WebGLRenderState(extensions, capabilities);
      renderStates.set(scene, [renderState]);
    } else {
      if (renderCallDepth >= renderStates.get(scene).length) {
        renderState = new WebGLRenderState(extensions, capabilities);
        renderStates.get(scene).push(renderState);
      } else {
        renderState = renderStates.get(scene)[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose() {
    renderStates = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
class MeshDepthMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshDepthMaterial";
    this.depthPacking = BasicDepthPacking;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.depthPacking = source.depthPacking;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  }
}
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
class MeshDistanceMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshDistanceMaterial";
    this.referencePosition = new Vector3();
    this.nearDistance = 1;
    this.farDistance = 1e3;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.fog = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.referencePosition.copy(source.referencePosition);
    this.nearDistance = source.nearDistance;
    this.farDistance = source.farDistance;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
  }
}
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
const vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
function WebGLShadowMap(_renderer, _objects, _capabilities) {
  let _frustum = new Frustum();
  const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
  const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Vector2() },
      radius: { value: 4 }
    },
    vertexShader: vertex,
    fragmentShader: fragment
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  this.render = function(lights, scene, camera) {
    if (scope.enabled === false)
      return;
    if (scope.autoUpdate === false && scope.needsUpdate === false)
      return;
    if (lights.length === 0)
      return;
    const currentRenderTarget = _renderer.getRenderTarget();
    const activeCubeFace = _renderer.getActiveCubeFace();
    const activeMipmapLevel = _renderer.getActiveMipmapLevel();
    const _state = _renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    for (let i2 = 0, il = lights.length; i2 < il; i2++) {
      const light = lights[i2];
      const shadow = light.shadow;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false)
        continue;
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
        if (_shadowMapSize.x > _maxTextureSize) {
          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > _maxTextureSize) {
          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
        const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.camera.updateProjectionMatrix();
      }
      if (shadow.map === null) {
        const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      const viewportCount = shadow.getViewportCount();
      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp);
        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
        _state.viewport(_viewport);
        shadow.updateMatrices(light, vp);
        _frustum = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      }
      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }
      shadow.needsUpdate = false;
    }
    scope.needsUpdate = false;
    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera) {
    const geometry = _objects.update(fullScreenMesh);
    if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
      shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialVertical.needsUpdate = true;
      shadowMaterialHorizontal.needsUpdate = true;
    }
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.mapPass);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.map);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  function getDepthMaterial(object, material, light, shadowCameraNear, shadowCameraFar, type) {
    let result = null;
    const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
    if (customMaterial !== void 0) {
      result = customMaterial;
    } else {
      result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
    }
    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0) {
      const keyA = result.uuid, keyB = material.uuid;
      let materialsForVariant = _materialCache[keyA];
      if (materialsForVariant === void 0) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }
      let cachedMaterial = materialsForVariant[keyB];
      if (cachedMaterial === void 0) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }
      result = cachedMaterial;
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.alphaMap = material.alphaMap;
    result.alphaTest = material.alphaTest;
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.displacementMap = material.displacementMap;
    result.displacementScale = material.displacementScale;
    result.displacementBias = material.displacementBias;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      result.referencePosition.setFromMatrixPosition(light.matrixWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        const geometry = _objects.update(object);
        const material = object.material;
        if (Array.isArray(material)) {
          const groups = geometry.groups;
          for (let k2 = 0, kl = groups.length; k2 < kl; k2++) {
            const group = groups[k2];
            const groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, material, light, shadowCamera.near, shadowCamera.far, type);
          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
        }
      }
    }
    const children = object.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      renderObject(children[i2], camera, shadowCamera, light, type);
    }
  }
}
function WebGLState(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function ColorBuffer() {
    let locked = false;
    const color = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r2, g2, b2, a2, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r2 *= a2;
          g2 *= a2;
          b2 *= a2;
        }
        color.set(r2, g2, b2, a2);
        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r2, g2, b2, a2);
          currentColorClear.copy(color);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    let locked = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setTest: function(depthTest) {
        if (depthTest) {
          enable(2929);
        } else {
          disable(2929);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(512);
                break;
              case AlwaysDepth:
                gl.depthFunc(519);
                break;
              case LessDepth:
                gl.depthFunc(513);
                break;
              case LessEqualDepth:
                gl.depthFunc(515);
                break;
              case EqualDepth:
                gl.depthFunc(514);
                break;
              case GreaterEqualDepth:
                gl.depthFunc(518);
                break;
              case GreaterDepth:
                gl.depthFunc(516);
                break;
              case NotEqualDepth:
                gl.depthFunc(517);
                break;
              default:
                gl.depthFunc(515);
            }
          } else {
            gl.depthFunc(515);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(2960);
          } else {
            disable(2960);
          }
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  let enabledCapabilities = {};
  let currentBoundFramebuffers = {};
  let currentDrawbuffers = /* @__PURE__ */ new WeakMap();
  let defaultDrawbuffers = [];
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(35661);
  let lineWidthAvailable = false;
  let version = 0;
  const glVersion = gl.getParameter(7938);
  if (glVersion.indexOf("WebGL") !== -1) {
    version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const scissorParam = gl.getParameter(3088);
  const viewportParam = gl.getParameter(2978);
  const currentScissor = new Vector4().fromArray(scissorParam);
  const currentViewport = new Vector4().fromArray(viewportParam);
  function createTexture(type, target, count) {
    const data = new Uint8Array(4);
    const texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, 10241, 9728);
    gl.texParameteri(type, 10240, 9728);
    for (let i2 = 0; i2 < count; i2++) {
      gl.texImage2D(target + i2, 0, 6408, 1, 1, 0, 6408, 5121, data);
    }
    return texture;
  }
  const emptyTextures = {};
  emptyTextures[3553] = createTexture(3553, 3553, 1);
  emptyTextures[34067] = createTexture(34067, 34069, 6);
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(2929);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(2884);
  setBlending(NoBlending);
  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }
  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }
  function bindFramebuffer(target, framebuffer) {
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;
      if (isWebGL2) {
        if (target === 36009) {
          currentBoundFramebuffers[36160] = framebuffer;
        }
        if (target === 36160) {
          currentBoundFramebuffers[36009] = framebuffer;
        }
      }
      return true;
    }
    return false;
  }
  function drawBuffers(renderTarget, framebuffer) {
    let drawBuffers2 = defaultDrawbuffers;
    let needsUpdate = false;
    if (renderTarget) {
      drawBuffers2 = currentDrawbuffers.get(framebuffer);
      if (drawBuffers2 === void 0) {
        drawBuffers2 = [];
        currentDrawbuffers.set(framebuffer, drawBuffers2);
      }
      if (renderTarget.isWebGLMultipleRenderTargets) {
        const textures = renderTarget.texture;
        if (drawBuffers2.length !== textures.length || drawBuffers2[0] !== 36064) {
          for (let i2 = 0, il = textures.length; i2 < il; i2++) {
            drawBuffers2[i2] = 36064 + i2;
          }
          drawBuffers2.length = textures.length;
          needsUpdate = true;
        }
      } else {
        if (drawBuffers2[0] !== 36064) {
          drawBuffers2[0] = 36064;
          needsUpdate = true;
        }
      }
    } else {
      if (drawBuffers2[0] !== 1029) {
        drawBuffers2[0] = 1029;
        needsUpdate = true;
      }
    }
    if (needsUpdate) {
      if (capabilities.isWebGL2) {
        gl.drawBuffers(drawBuffers2);
      } else {
        extensions.get("WEBGL_draw_buffers").drawBuffersWEBGL(drawBuffers2);
      }
    }
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: 32774,
    [SubtractEquation]: 32778,
    [ReverseSubtractEquation]: 32779
  };
  if (isWebGL2) {
    equationToGL[MinEquation] = 32775;
    equationToGL[MaxEquation] = 32776;
  } else {
    const extension = extensions.get("EXT_blend_minmax");
    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT;
      equationToGL[MaxEquation] = extension.MAX_EXT;
    }
  }
  const factorToGL = {
    [ZeroFactor]: 0,
    [OneFactor]: 1,
    [SrcColorFactor]: 768,
    [SrcAlphaFactor]: 770,
    [SrcAlphaSaturateFactor]: 776,
    [DstColorFactor]: 774,
    [DstAlphaFactor]: 772,
    [OneMinusSrcColorFactor]: 769,
    [OneMinusSrcAlphaFactor]: 771,
    [OneMinusDstColorFactor]: 775,
    [OneMinusDstAlphaFactor]: 773
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(3042);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(3042);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(32774);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(1, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(1, 1);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 769, 0, 1);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(770, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(770, 1);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 769, 0, 1);
              break;
            case MultiplyBlending:
              gl.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = null;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(2884) : enable(2884);
    let flipSided = material.side === BackSide;
    if (frontFaceCW)
      flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true ? enable(32926) : disable(32926);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(2304);
      } else {
        gl.frontFace(2305);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(2884);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(1029);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(1028);
        } else {
          gl.cullFace(1032);
        }
      }
    } else {
      disable(2884);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable)
        gl.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(32823);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(32823);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(3089);
    } else {
      disable(3089);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0)
      webglSlot = 33984 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }
    let boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 };
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texSubImage2D() {
    try {
      gl.texSubImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texSubImage3D() {
    try {
      gl.texSubImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexSubImage2D() {
    try {
      gl.compressedTexSubImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texStorage2D() {
    try {
      gl.texStorage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texStorage3D() {
    try {
      gl.texStorage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function reset() {
    gl.disable(3042);
    gl.disable(2884);
    gl.disable(2929);
    gl.disable(32823);
    gl.disable(3089);
    gl.disable(2960);
    gl.disable(32926);
    gl.blendEquation(32774);
    gl.blendFunc(1, 0);
    gl.blendFuncSeparate(1, 0, 1, 0);
    gl.colorMask(true, true, true, true);
    gl.clearColor(0, 0, 0, 0);
    gl.depthMask(true);
    gl.depthFunc(513);
    gl.clearDepth(1);
    gl.stencilMask(4294967295);
    gl.stencilFunc(519, 0, 4294967295);
    gl.stencilOp(7680, 7680, 7680);
    gl.clearStencil(0);
    gl.cullFace(1029);
    gl.frontFace(2305);
    gl.polygonOffset(0, 0);
    gl.activeTexture(33984);
    gl.bindFramebuffer(36160, null);
    if (isWebGL2 === true) {
      gl.bindFramebuffer(36009, null);
      gl.bindFramebuffer(36008, null);
    }
    gl.useProgram(null);
    gl.lineWidth(1);
    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentBoundFramebuffers = {};
    currentDrawbuffers = /* @__PURE__ */ new WeakMap();
    defaultDrawbuffers = [];
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable,
    disable,
    bindFramebuffer,
    drawBuffers,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    texImage2D,
    texImage3D,
    texStorage2D,
    texStorage3D,
    texSubImage2D,
    texSubImage3D,
    compressedTexSubImage2D,
    scissor,
    viewport,
    reset
  };
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  const isWebGL2 = capabilities.isWebGL2;
  const maxTextures = capabilities.maxTextures;
  const maxCubemapSize = capabilities.maxCubemapSize;
  const maxTextureSize = capabilities.maxTextureSize;
  const maxSamples = capabilities.maxSamples;
  const multisampledRTTExt = extensions.has("WEBGL_multisampled_render_to_texture") ? extensions.get("WEBGL_multisampled_render_to_texture") : null;
  const _videoTextures = /* @__PURE__ */ new WeakMap();
  let _canvas2;
  const _sources = /* @__PURE__ */ new WeakMap();
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {
  }
  function createCanvas(width, height) {
    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : createElementNS("canvas");
  }
  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    let scale = 1;
    if (image.width > maxSize || image.height > maxSize) {
      scale = maxSize / Math.max(image.width, image.height);
    }
    if (scale < 1 || needsPowerOfTwo === true) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
        const width = floor(scale * image.width);
        const height = floor(scale * image.height);
        if (_canvas2 === void 0)
          _canvas2 = createCanvas(width, height);
        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0, width, height);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
        return canvas;
      } else {
        if ("data" in image) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
        }
        return image;
      }
    }
    return image;
  }
  function isPowerOfTwo$1(image) {
    return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
  }
  function textureNeedsPowerOfTwo(texture) {
    if (isWebGL2)
      return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function generateMipmap(target) {
    _gl.generateMipmap(target);
  }
  function getInternalFormat(internalFormatName, glFormat, glType, encoding, isVideoTexture = false) {
    if (isWebGL2 === false)
      return glFormat;
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0)
        return _gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === 6403) {
      if (glType === 5126)
        internalFormat = 33326;
      if (glType === 5131)
        internalFormat = 33325;
      if (glType === 5121)
        internalFormat = 33321;
    }
    if (glFormat === 33319) {
      if (glType === 5126)
        internalFormat = 33328;
      if (glType === 5131)
        internalFormat = 33327;
      if (glType === 5121)
        internalFormat = 33323;
    }
    if (glFormat === 6408) {
      if (glType === 5126)
        internalFormat = 34836;
      if (glType === 5131)
        internalFormat = 34842;
      if (glType === 5121)
        internalFormat = encoding === sRGBEncoding && isVideoTexture === false ? 35907 : 32856;
      if (glType === 32819)
        internalFormat = 32854;
      if (glType === 32820)
        internalFormat = 32855;
    }
    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 33327 || internalFormat === 33328 || internalFormat === 34842 || internalFormat === 34836) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  function getMipLevels(texture, image, supportsMips) {
    if (textureNeedsGenerateMipmaps(texture, supportsMips) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
      return Math.log2(Math.max(image.width, image.height)) + 1;
    } else if (texture.mipmaps !== void 0 && texture.mipmaps.length > 0) {
      return texture.mipmaps.length;
    } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
      return image.mipmaps.length;
    } else {
      return 1;
    }
  }
  function filterFallback(f2) {
    if (f2 === NearestFilter || f2 === NearestMipmapNearestFilter || f2 === NearestMipmapLinearFilter) {
      return 9728;
    }
    return 9729;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
  }
  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === void 0)
      return;
    const source = texture.source;
    const webglTextures = _sources.get(source);
    if (webglTextures) {
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      webglTexture.usedTimes--;
      if (webglTexture.usedTimes === 0) {
        deleteTexture(texture);
      }
      if (Object.keys(webglTextures).length === 0) {
        _sources.delete(source);
      }
    }
    properties.remove(texture);
  }
  function deleteTexture(texture) {
    const textureProperties = properties.get(texture);
    _gl.deleteTexture(textureProperties.__webglTexture);
    const source = texture.source;
    const webglTextures = _sources.get(source);
    delete webglTextures[textureProperties.__cacheKey];
    info.memory.textures--;
  }
  function deallocateRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglTexture !== void 0) {
      _gl.deleteTexture(textureProperties.__webglTexture);
      info.memory.textures--;
    }
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i2 = 0; i2 < 6; i2++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i2]);
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i2]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      if (renderTargetProperties.__webglDepthbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer)
        _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
      if (renderTargetProperties.__webglDepthRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    if (renderTarget.isWebGLMultipleRenderTargets) {
      for (let i2 = 0, il = texture.length; i2 < il; i2++) {
        const attachmentProperties = properties.get(texture[i2]);
        if (attachmentProperties.__webglTexture) {
          _gl.deleteTexture(attachmentProperties.__webglTexture);
          info.memory.textures--;
        }
        properties.remove(texture[i2]);
      }
    }
    properties.remove(texture);
    properties.remove(renderTarget);
  }
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= maxTextures) {
      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function getTextureCacheKey(texture) {
    const array = [];
    array.push(texture.wrapS);
    array.push(texture.wrapT);
    array.push(texture.magFilter);
    array.push(texture.minFilter);
    array.push(texture.anisotropy);
    array.push(texture.internalFormat);
    array.push(texture.format);
    array.push(texture.type);
    array.push(texture.generateMipmaps);
    array.push(texture.premultiplyAlpha);
    array.push(texture.flipY);
    array.push(texture.unpackAlignment);
    array.push(texture.encoding);
    return array.join();
  }
  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture)
      updateVideoTexture(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      const image = texture.image;
      if (image === null) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      } else if (image.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(3553, textureProperties.__webglTexture);
  }
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(35866, textureProperties.__webglTexture);
  }
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(32879, textureProperties.__webglTexture);
  }
  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
  }
  const wrappingToGL = {
    [RepeatWrapping]: 10497,
    [ClampToEdgeWrapping]: 33071,
    [MirroredRepeatWrapping]: 33648
  };
  const filterToGL = {
    [NearestFilter]: 9728,
    [NearestMipmapNearestFilter]: 9984,
    [NearestMipmapLinearFilter]: 9986,
    [LinearFilter]: 9729,
    [LinearMipmapNearestFilter]: 9985,
    [LinearMipmapLinearFilter]: 9987
  };
  function setTextureParameters(textureType, texture, supportsMips) {
    if (supportsMips) {
      _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
      _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
      }
      _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
      _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
    } else {
      _gl.texParameteri(textureType, 10242, 33071);
      _gl.texParameteri(textureType, 10243, 33071);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, 33071);
      }
      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
      }
      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
      }
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false)
        return;
      if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false))
        return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    let forceUpload = false;
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
    }
    const source = texture.source;
    let webglTextures = _sources.get(source);
    if (webglTextures === void 0) {
      webglTextures = {};
      _sources.set(source, webglTextures);
    }
    const textureCacheKey = getTextureCacheKey(texture);
    if (textureCacheKey !== textureProperties.__cacheKey) {
      if (webglTextures[textureCacheKey] === void 0) {
        webglTextures[textureCacheKey] = {
          texture: _gl.createTexture(),
          usedTimes: 0
        };
        info.memory.textures++;
        forceUpload = true;
      }
      webglTextures[textureCacheKey].usedTimes++;
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      if (webglTexture !== void 0) {
        webglTextures[textureProperties.__cacheKey].usedTimes--;
        if (webglTexture.usedTimes === 0) {
          deleteTexture(texture);
        }
      }
      textureProperties.__cacheKey = textureCacheKey;
      textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
    }
    return forceUpload;
  }
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = 3553;
    if (texture.isDataArrayTexture)
      textureType = 35866;
    if (texture.isData3DTexture)
      textureType = 32879;
    const forceUpload = initTexture(textureProperties, texture);
    const source = texture.source;
    state.activeTexture(33984 + slot);
    state.bindTexture(textureType, textureProperties.__webglTexture);
    if (source.version !== source.__currentVersion || forceUpload === true) {
      _gl.pixelStorei(37440, texture.flipY);
      _gl.pixelStorei(37441, texture.premultiplyAlpha);
      _gl.pixelStorei(3317, texture.unpackAlignment);
      _gl.pixelStorei(37443, 0);
      const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
      let image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
      image = verifyColorSpace(texture, image);
      const supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format, texture.encoding);
      let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding, texture.isVideoTexture);
      setTextureParameters(textureType, texture, supportsMips);
      let mipmap;
      const mipmaps = texture.mipmaps;
      const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
      const allocateMemory = textureProperties.__version === void 0;
      const levels = getMipLevels(texture, image, supportsMips);
      if (texture.isDepthTexture) {
        glInternalFormat = 6402;
        if (isWebGL2) {
          if (texture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (texture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          } else if (texture.type === UnsignedInt248Type) {
            glInternalFormat = 35056;
          } else {
            glInternalFormat = 33189;
          }
        } else {
          if (texture.type === FloatType) {
            console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
          }
        }
        if (texture.format === DepthFormat && glInternalFormat === 6402) {
          if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
            console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
            texture.type = UnsignedShortType;
            glType = utils.convert(texture.type);
          }
        }
        if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
          glInternalFormat = 34041;
          if (texture.type !== UnsignedInt248Type) {
            console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
            texture.type = UnsignedInt248Type;
            glType = utils.convert(texture.type);
          }
        }
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(3553, 1, glInternalFormat, image.width, image.height);
        } else {
          state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
        }
      } else if (texture.isDataTexture) {
        if (mipmaps.length > 0 && supportsMips) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
            mipmap = mipmaps[i2];
            if (useTexStorage) {
              state.texSubImage2D(3553, i2, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
            } else {
              state.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
            }
            state.texSubImage2D(3553, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
          } else {
            state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
          }
        }
      } else if (texture.isCompressedTexture) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
        }
        for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
          mipmap = mipmaps[i2];
          if (texture.format !== RGBAFormat) {
            if (glFormat !== null) {
              if (useTexStorage) {
                state.compressedTexSubImage2D(3553, i2, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
              } else {
                state.compressedTexImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
              }
            } else {
              console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            }
          } else {
            if (useTexStorage) {
              state.texSubImage2D(3553, i2, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
            } else {
              state.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
        }
      } else if (texture.isDataArrayTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(35866, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          state.texSubImage3D(35866, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
        } else {
          state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isData3DTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(32879, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          state.texSubImage3D(32879, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
        } else {
          state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isFramebufferTexture) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
        } else {
          state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
        }
      } else {
        if (mipmaps.length > 0 && supportsMips) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
            mipmap = mipmaps[i2];
            if (useTexStorage) {
              state.texSubImage2D(3553, i2, 0, 0, glFormat, glType, mipmap);
            } else {
              state.texImage2D(3553, i2, glInternalFormat, glFormat, glType, mipmap);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
            }
            state.texSubImage2D(3553, 0, 0, 0, glFormat, glType, image);
          } else {
            state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(textureType);
      }
      source.__currentVersion = source.version;
      if (texture.onUpdate)
        texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6)
      return;
    const forceUpload = initTexture(textureProperties, texture);
    const source = texture.source;
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
    if (source.version !== source.__currentVersion || forceUpload === true) {
      _gl.pixelStorei(37440, texture.flipY);
      _gl.pixelStorei(37441, texture.premultiplyAlpha);
      _gl.pixelStorei(3317, texture.unpackAlignment);
      _gl.pixelStorei(37443, 0);
      const isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;
      const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
      const cubeImage = [];
      for (let i2 = 0; i2 < 6; i2++) {
        if (!isCompressed && !isDataTexture) {
          cubeImage[i2] = resizeImage(texture.image[i2], false, true, maxCubemapSize);
        } else {
          cubeImage[i2] = isDataTexture ? texture.image[i2].image : texture.image[i2];
        }
        cubeImage[i2] = verifyColorSpace(texture, cubeImage[i2]);
      }
      const image = cubeImage[0], supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format, texture.encoding), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
      const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
      const allocateMemory = textureProperties.__version === void 0;
      let levels = getMipLevels(texture, image, supportsMips);
      setTextureParameters(34067, texture, supportsMips);
      let mipmaps;
      if (isCompressed) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(34067, levels, glInternalFormat, image.width, image.height);
        }
        for (let i2 = 0; i2 < 6; i2++) {
          mipmaps = cubeImage[i2].mipmaps;
          for (let j2 = 0; j2 < mipmaps.length; j2++) {
            const mipmap = mipmaps[j2];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  state.compressedTexSubImage2D(34069 + i2, j2, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                } else {
                  state.compressedTexImage2D(34069 + i2, j2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
              }
            } else {
              if (useTexStorage) {
                state.texSubImage2D(34069 + i2, j2, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              } else {
                state.texImage2D(34069 + i2, j2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else {
        mipmaps = texture.mipmaps;
        if (useTexStorage && allocateMemory) {
          if (mipmaps.length > 0)
            levels++;
          state.texStorage2D(34067, levels, glInternalFormat, cubeImage[0].width, cubeImage[0].height);
        }
        for (let i2 = 0; i2 < 6; i2++) {
          if (isDataTexture) {
            if (useTexStorage) {
              state.texSubImage2D(34069 + i2, 0, 0, 0, cubeImage[i2].width, cubeImage[i2].height, glFormat, glType, cubeImage[i2].data);
            } else {
              state.texImage2D(34069 + i2, 0, glInternalFormat, cubeImage[i2].width, cubeImage[i2].height, 0, glFormat, glType, cubeImage[i2].data);
            }
            for (let j2 = 0; j2 < mipmaps.length; j2++) {
              const mipmap = mipmaps[j2];
              const mipmapImage = mipmap.image[i2].image;
              if (useTexStorage) {
                state.texSubImage2D(34069 + i2, j2 + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
              } else {
                state.texImage2D(34069 + i2, j2 + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
              }
            }
          } else {
            if (useTexStorage) {
              state.texSubImage2D(34069 + i2, 0, 0, 0, glFormat, glType, cubeImage[i2]);
            } else {
              state.texImage2D(34069 + i2, 0, glInternalFormat, glFormat, glType, cubeImage[i2]);
            }
            for (let j2 = 0; j2 < mipmaps.length; j2++) {
              const mipmap = mipmaps[j2];
              if (useTexStorage) {
                state.texSubImage2D(34069 + i2, j2 + 1, 0, 0, glFormat, glType, mipmap.image[i2]);
              } else {
                state.texImage2D(34069 + i2, j2 + 1, glInternalFormat, glFormat, glType, mipmap.image[i2]);
              }
            }
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(34067);
      }
      source.__currentVersion = source.version;
      if (texture.onUpdate)
        texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
    const glFormat = utils.convert(texture.format, texture.encoding);
    const glType = utils.convert(texture.type);
    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
    const renderTargetProperties = properties.get(renderTarget);
    if (!renderTargetProperties.__hasExternalTextures) {
      if (textureTarget === 32879 || textureTarget === 35866) {
        state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
      } else {
        state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
      }
    }
    state.bindFramebuffer(36160, framebuffer);
    if (useMultisampledRTT(renderTarget)) {
      multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
    } else {
      _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
    }
    state.bindFramebuffer(36160, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(36161, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      let glInternalFormat = 33189;
      if (isMultisample || useMultisampledRTT(renderTarget)) {
        const depthTexture = renderTarget.depthTexture;
        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          }
        }
        const samples = getRenderTargetSamples(renderTarget);
        if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      const samples = getRenderTargetSamples(renderTarget);
      if (isMultisample && useMultisampledRTT(renderTarget) === false) {
        _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
      } else if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, 35056, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
    } else {
      const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;
      const glFormat = utils.convert(texture.format, texture.encoding);
      const glType = utils.convert(texture.type);
      const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
      const samples = getRenderTargetSamples(renderTarget);
      if (isMultisample && useMultisampledRTT(renderTarget) === false) {
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
    }
    _gl.bindRenderbuffer(36161, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube)
      throw new Error("Depth Texture with cube render targets is not supported");
    state.bindFramebuffer(36160, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    const samples = getRenderTargetSamples(renderTarget);
    if (renderTarget.depthTexture.format === DepthFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
      }
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
      }
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
      if (isCube)
        throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i2 = 0; i2 < 6; i2++) {
          state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i2]);
          renderTargetProperties.__webglDepthbuffer[i2] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i2], renderTarget, false);
        }
      } else {
        state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
      }
    }
    state.bindFramebuffer(36160, null);
  }
  function rebindTextures(renderTarget, colorTexture, depthTexture) {
    const renderTargetProperties = properties.get(renderTarget);
    if (colorTexture !== void 0) {
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, 36064, 3553);
    }
    if (depthTexture !== void 0) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function setupRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    if (renderTarget.isWebGLMultipleRenderTargets !== true) {
      if (textureProperties.__webglTexture === void 0) {
        textureProperties.__webglTexture = _gl.createTexture();
      }
      textureProperties.__version = texture.version;
      info.memory.textures++;
    }
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i2 = 0; i2 < 6; i2++) {
        renderTargetProperties.__webglFramebuffer[i2] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      if (isMultipleRenderTargets) {
        if (capabilities.drawBuffers) {
          const textures = renderTarget.texture;
          for (let i2 = 0, il = textures.length; i2 < il; i2++) {
            const attachmentProperties = properties.get(textures[i2]);
            if (attachmentProperties.__webglTexture === void 0) {
              attachmentProperties.__webglTexture = _gl.createTexture();
              info.memory.textures++;
            }
          }
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
        }
      } else if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
        renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
        renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
        _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
        const glFormat = utils.convert(texture.format, texture.encoding);
        const glType = utils.convert(texture.type);
        const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
        _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
        _gl.bindRenderbuffer(36161, null);
        if (renderTarget.depthBuffer) {
          renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
        }
        state.bindFramebuffer(36160, null);
      }
    }
    if (isCube) {
      state.bindTexture(34067, textureProperties.__webglTexture);
      setTextureParameters(34067, texture, supportsMips);
      for (let i2 = 0; i2 < 6; i2++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i2], renderTarget, texture, 36064, 34069 + i2);
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(34067);
      }
      state.unbindTexture();
    } else if (isMultipleRenderTargets) {
      const textures = renderTarget.texture;
      for (let i2 = 0, il = textures.length; i2 < il; i2++) {
        const attachment = textures[i2];
        const attachmentProperties = properties.get(attachment);
        state.bindTexture(3553, attachmentProperties.__webglTexture);
        setTextureParameters(3553, attachment, supportsMips);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i2, 3553);
        if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
          generateMipmap(3553);
        }
      }
      state.unbindTexture();
    } else {
      let glTextureType = 3553;
      if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
        if (isWebGL2) {
          glTextureType = renderTarget.isWebGL3DRenderTarget ? 32879 : 35866;
        } else {
          console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.");
        }
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture, supportsMips);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType);
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(glTextureType);
      }
      state.unbindTexture();
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
    for (let i2 = 0, il = textures.length; i2 < il; i2++) {
      const texture = textures[i2];
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
        const webglTexture = properties.get(texture).__webglTexture;
        state.bindTexture(target, webglTexture);
        generateMipmap(target);
        state.unbindTexture();
      }
    }
  }
  function updateMultisampleRenderTarget(renderTarget) {
    if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
      const width = renderTarget.width;
      const height = renderTarget.height;
      let mask = 16384;
      const invalidationArray = [36064];
      const depthStyle = renderTarget.stencilBuffer ? 33306 : 36096;
      if (renderTarget.depthBuffer) {
        invalidationArray.push(depthStyle);
      }
      const renderTargetProperties = properties.get(renderTarget);
      const ignoreDepthValues = renderTargetProperties.__ignoreDepthValues !== void 0 ? renderTargetProperties.__ignoreDepthValues : true;
      if (ignoreDepthValues === false) {
        if (renderTarget.depthBuffer)
          mask |= 256;
        if (renderTarget.stencilBuffer)
          mask |= 1024;
      }
      state.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
      state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
      if (ignoreDepthValues === true) {
        _gl.invalidateFramebuffer(36008, [depthStyle]);
        _gl.invalidateFramebuffer(36009, [depthStyle]);
      }
      _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
      _gl.invalidateFramebuffer(36008, invalidationArray);
      state.bindFramebuffer(36008, null);
      state.bindFramebuffer(36009, renderTargetProperties.__webglMultisampledFramebuffer);
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return Math.min(maxSamples, renderTarget.samples);
  }
  function useMultisampledRTT(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    return isWebGL2 && renderTarget.samples > 0 && extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTargetProperties.__useRenderToTexture !== false;
  }
  function updateVideoTexture(texture) {
    const frame = info.render.frame;
    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);
      texture.update();
    }
  }
  function verifyColorSpace(texture, image) {
    const encoding = texture.encoding;
    const format = texture.format;
    const type = texture.type;
    if (texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === _SRGBAFormat)
      return image;
    if (encoding !== LinearEncoding) {
      if (encoding === sRGBEncoding) {
        if (isWebGL2 === false) {
          if (extensions.has("EXT_sRGB") === true && format === RGBAFormat) {
            texture.format = _SRGBAFormat;
            texture.minFilter = LinearFilter;
            texture.generateMipmaps = false;
          } else {
            image = ImageUtils.sRGBToLinear(image);
          }
        } else {
          if (format !== RGBAFormat || type !== UnsignedByteType) {
            console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.");
          }
        }
      } else {
        console.error("THREE.WebGLTextures: Unsupported texture encoding:", encoding);
      }
    }
    return image;
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.rebindTextures = rebindTextures;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.setupDepthRenderbuffer = setupDepthRenderbuffer;
  this.setupFrameBufferTexture = setupFrameBufferTexture;
  this.useMultisampledRTT = useMultisampledRTT;
}
function WebGLUtils(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function convert(p2, encoding = null) {
    let extension;
    if (p2 === UnsignedByteType)
      return 5121;
    if (p2 === UnsignedShort4444Type)
      return 32819;
    if (p2 === UnsignedShort5551Type)
      return 32820;
    if (p2 === ByteType)
      return 5120;
    if (p2 === ShortType)
      return 5122;
    if (p2 === UnsignedShortType)
      return 5123;
    if (p2 === IntType)
      return 5124;
    if (p2 === UnsignedIntType)
      return 5125;
    if (p2 === FloatType)
      return 5126;
    if (p2 === HalfFloatType) {
      if (isWebGL2)
        return 5131;
      extension = extensions.get("OES_texture_half_float");
      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      } else {
        return null;
      }
    }
    if (p2 === AlphaFormat)
      return 6406;
    if (p2 === RGBAFormat)
      return 6408;
    if (p2 === LuminanceFormat)
      return 6409;
    if (p2 === LuminanceAlphaFormat)
      return 6410;
    if (p2 === DepthFormat)
      return 6402;
    if (p2 === DepthStencilFormat)
      return 34041;
    if (p2 === RedFormat)
      return 6403;
    if (p2 === RGBFormat) {
      console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228");
      return 6408;
    }
    if (p2 === _SRGBAFormat) {
      extension = extensions.get("EXT_sRGB");
      if (extension !== null) {
        return extension.SRGB_ALPHA_EXT;
      } else {
        return null;
      }
    }
    if (p2 === RedIntegerFormat)
      return 36244;
    if (p2 === RGFormat)
      return 33319;
    if (p2 === RGIntegerFormat)
      return 33320;
    if (p2 === RGBAIntegerFormat)
      return 36249;
    if (p2 === RGB_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT3_Format || p2 === RGBA_S3TC_DXT5_Format) {
      if (encoding === sRGBEncoding) {
        extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
        if (extension !== null) {
          if (p2 === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (p2 === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (p2 === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (p2 === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      } else {
        extension = extensions.get("WEBGL_compressed_texture_s3tc");
        if (extension !== null) {
          if (p2 === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p2 === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p2 === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p2 === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      }
    }
    if (p2 === RGB_PVRTC_4BPPV1_Format || p2 === RGB_PVRTC_2BPPV1_Format || p2 === RGBA_PVRTC_4BPPV1_Format || p2 === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p2 === RGB_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p2 === RGB_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p2 === RGBA_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p2 === RGBA_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p2 === RGB_ETC1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc1");
      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    }
    if (p2 === RGB_ETC2_Format || p2 === RGBA_ETC2_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p2 === RGB_ETC2_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
        if (p2 === RGBA_ETC2_EAC_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
      } else {
        return null;
      }
    }
    if (p2 === RGBA_ASTC_4x4_Format || p2 === RGBA_ASTC_5x4_Format || p2 === RGBA_ASTC_5x5_Format || p2 === RGBA_ASTC_6x5_Format || p2 === RGBA_ASTC_6x6_Format || p2 === RGBA_ASTC_8x5_Format || p2 === RGBA_ASTC_8x6_Format || p2 === RGBA_ASTC_8x8_Format || p2 === RGBA_ASTC_10x5_Format || p2 === RGBA_ASTC_10x6_Format || p2 === RGBA_ASTC_10x8_Format || p2 === RGBA_ASTC_10x10_Format || p2 === RGBA_ASTC_12x10_Format || p2 === RGBA_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        if (p2 === RGBA_ASTC_4x4_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (p2 === RGBA_ASTC_5x4_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (p2 === RGBA_ASTC_5x5_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (p2 === RGBA_ASTC_6x5_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (p2 === RGBA_ASTC_6x6_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (p2 === RGBA_ASTC_8x5_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (p2 === RGBA_ASTC_8x6_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (p2 === RGBA_ASTC_8x8_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (p2 === RGBA_ASTC_10x5_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (p2 === RGBA_ASTC_10x6_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (p2 === RGBA_ASTC_10x8_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (p2 === RGBA_ASTC_10x10_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (p2 === RGBA_ASTC_12x10_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (p2 === RGBA_ASTC_12x12_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else {
        return null;
      }
    }
    if (p2 === RGBA_BPTC_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        if (p2 === RGBA_BPTC_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else {
        return null;
      }
    }
    if (p2 === UnsignedInt248Type) {
      if (isWebGL2)
        return 34042;
      extension = extensions.get("WEBGL_depth_texture");
      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      } else {
        return null;
      }
    }
  }
  return { convert };
}
class ArrayCamera extends PerspectiveCamera {
  constructor(array = []) {
    super();
    this.cameras = array;
  }
}
ArrayCamera.prototype.isArrayCamera = true;
class Group extends Object3D {
  constructor() {
    super();
    this.type = "Group";
  }
}
Group.prototype.isGroup = true;
const _moveEvent = { type: "move" };
class WebXRController {
  constructor() {
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
  }
  getHandSpace() {
    if (this._hand === null) {
      this._hand = new Group();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = { pinching: false };
    }
    return this._hand;
  }
  getTargetRaySpace() {
    if (this._targetRay === null) {
      this._targetRay = new Group();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
      this._targetRay.hasLinearVelocity = false;
      this._targetRay.linearVelocity = new Vector3();
      this._targetRay.hasAngularVelocity = false;
      this._targetRay.angularVelocity = new Vector3();
    }
    return this._targetRay;
  }
  getGripSpace() {
    if (this._grip === null) {
      this._grip = new Group();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
      this._grip.hasLinearVelocity = false;
      this._grip.linearVelocity = new Vector3();
      this._grip.hasAngularVelocity = false;
      this._grip.angularVelocity = new Vector3();
    }
    return this._grip;
  }
  dispatchEvent(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }
    return this;
  }
  disconnect(inputSource) {
    this.dispatchEvent({ type: "disconnected", data: inputSource });
    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }
    if (this._grip !== null) {
      this._grip.visible = false;
    }
    if (this._hand !== null) {
      this._hand.visible = false;
    }
    return this;
  }
  update(inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand = this._hand;
    if (inputSource && frame.session.visibilityState !== "visible-blurred") {
      if (targetRay !== null) {
        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
        if (inputPose !== null) {
          targetRay.matrix.fromArray(inputPose.transform.matrix);
          targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
          if (inputPose.linearVelocity) {
            targetRay.hasLinearVelocity = true;
            targetRay.linearVelocity.copy(inputPose.linearVelocity);
          } else {
            targetRay.hasLinearVelocity = false;
          }
          if (inputPose.angularVelocity) {
            targetRay.hasAngularVelocity = true;
            targetRay.angularVelocity.copy(inputPose.angularVelocity);
          } else {
            targetRay.hasAngularVelocity = false;
          }
          this.dispatchEvent(_moveEvent);
        }
      }
      if (hand && inputSource.hand) {
        handPose = true;
        for (const inputjoint of inputSource.hand.values()) {
          const jointPose = frame.getJointPose(inputjoint, referenceSpace);
          if (hand.joints[inputjoint.jointName] === void 0) {
            const joint2 = new Group();
            joint2.matrixAutoUpdate = false;
            joint2.visible = false;
            hand.joints[inputjoint.jointName] = joint2;
            hand.add(joint2);
          }
          const joint = hand.joints[inputjoint.jointName];
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.jointRadius = jointPose.radius;
          }
          joint.visible = jointPose !== null;
        }
        const indexTip = hand.joints["index-finger-tip"];
        const thumbTip = hand.joints["thumb-tip"];
        const distance = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold = 5e-3;
        if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
          hand.inputState.pinching = false;
          this.dispatchEvent({
            type: "pinchend",
            handedness: inputSource.handedness,
            target: this
          });
        } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
          hand.inputState.pinching = true;
          this.dispatchEvent({
            type: "pinchstart",
            handedness: inputSource.handedness,
            target: this
          });
        }
      } else {
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
            if (gripPose.linearVelocity) {
              grip.hasLinearVelocity = true;
              grip.linearVelocity.copy(gripPose.linearVelocity);
            } else {
              grip.hasLinearVelocity = false;
            }
            if (gripPose.angularVelocity) {
              grip.hasAngularVelocity = true;
              grip.angularVelocity.copy(gripPose.angularVelocity);
            } else {
              grip.hasAngularVelocity = false;
            }
          }
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }
    if (grip !== null) {
      grip.visible = gripPose !== null;
    }
    if (hand !== null) {
      hand.visible = handPose !== null;
    }
    return this;
  }
}
class DepthTexture extends Texture {
  constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
    format = format !== void 0 ? format : DepthFormat;
    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    if (type === void 0 && format === DepthFormat)
      type = UnsignedShortType;
    if (type === void 0 && format === DepthStencilFormat)
      type = UnsignedInt248Type;
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.image = { width, height };
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
  }
}
DepthTexture.prototype.isDepthTexture = true;
class WebXRManager extends EventDispatcher {
  constructor(renderer, gl) {
    super();
    const scope = this;
    let session = null;
    let framebufferScaleFactor = 1;
    let referenceSpace = null;
    let referenceSpaceType = "local-floor";
    let pose = null;
    let glBinding = null;
    let glProjLayer = null;
    let glBaseLayer = null;
    let xrFrame = null;
    const attributes = gl.getContextAttributes();
    let initialRenderTarget = null;
    let newRenderTarget = null;
    const controllers = [];
    const inputSourcesMap = /* @__PURE__ */ new Map();
    const cameraL = new PerspectiveCamera();
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector4();
    const cameraR = new PerspectiveCamera();
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector4();
    const cameras = [cameraL, cameraR];
    const cameraVR = new ArrayCamera();
    cameraVR.layers.enable(1);
    cameraVR.layers.enable(2);
    let _currentDepthNear = null;
    let _currentDepthFar = null;
    this.cameraAutoUpdate = true;
    this.enabled = false;
    this.isPresenting = false;
    this.getController = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getTargetRaySpace();
    };
    this.getControllerGrip = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getGripSpace();
    };
    this.getHand = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getHandSpace();
    };
    function onSessionEvent(event) {
      const controller = inputSourcesMap.get(event.inputSource);
      if (controller) {
        controller.dispatchEvent({ type: event.type, data: event.inputSource });
      }
    }
    function onSessionEnd() {
      inputSourcesMap.forEach(function(controller, inputSource) {
        controller.disconnect(inputSource);
      });
      inputSourcesMap.clear();
      _currentDepthNear = null;
      _currentDepthFar = null;
      renderer.setRenderTarget(initialRenderTarget);
      glBaseLayer = null;
      glProjLayer = null;
      glBinding = null;
      session = null;
      newRenderTarget = null;
      animation.stop();
      scope.isPresenting = false;
      scope.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(value) {
      framebufferScaleFactor = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }
    };
    this.setReferenceSpaceType = function(value) {
      referenceSpaceType = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }
    };
    this.getReferenceSpace = function() {
      return referenceSpace;
    };
    this.getBaseLayer = function() {
      return glProjLayer !== null ? glProjLayer : glBaseLayer;
    };
    this.getBinding = function() {
      return glBinding;
    };
    this.getFrame = function() {
      return xrFrame;
    };
    this.getSession = function() {
      return session;
    };
    this.setSession = async function(value) {
      session = value;
      if (session !== null) {
        initialRenderTarget = renderer.getRenderTarget();
        session.addEventListener("select", onSessionEvent);
        session.addEventListener("selectstart", onSessionEvent);
        session.addEventListener("selectend", onSessionEvent);
        session.addEventListener("squeeze", onSessionEvent);
        session.addEventListener("squeezestart", onSessionEvent);
        session.addEventListener("squeezeend", onSessionEvent);
        session.addEventListener("end", onSessionEnd);
        session.addEventListener("inputsourceschange", onInputSourcesChange);
        if (attributes.xrCompatible !== true) {
          await gl.makeXRCompatible();
        }
        if (session.renderState.layers === void 0 || renderer.capabilities.isWebGL2 === false) {
          const layerInit = {
            antialias: session.renderState.layers === void 0 ? attributes.antialias : true,
            alpha: attributes.alpha,
            depth: attributes.depth,
            stencil: attributes.stencil,
            framebufferScaleFactor
          };
          glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
          session.updateRenderState({ baseLayer: glBaseLayer });
          newRenderTarget = new WebGLRenderTarget(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, {
            format: RGBAFormat,
            type: UnsignedByteType,
            encoding: renderer.outputEncoding
          });
        } else {
          let depthFormat = null;
          let depthType = null;
          let glDepthFormat = null;
          if (attributes.depth) {
            glDepthFormat = attributes.stencil ? 35056 : 33190;
            depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
            depthType = attributes.stencil ? UnsignedInt248Type : UnsignedShortType;
          }
          const projectionlayerInit = {
            colorFormat: renderer.outputEncoding === sRGBEncoding ? 35907 : 32856,
            depthFormat: glDepthFormat,
            scaleFactor: framebufferScaleFactor
          };
          glBinding = new XRWebGLBinding(session, gl);
          glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
          session.updateRenderState({ layers: [glProjLayer] });
          newRenderTarget = new WebGLRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {
            format: RGBAFormat,
            type: UnsignedByteType,
            depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
            stencilBuffer: attributes.stencil,
            encoding: renderer.outputEncoding,
            samples: attributes.antialias ? 4 : 0
          });
          const renderTargetProperties = renderer.properties.get(newRenderTarget);
          renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;
        }
        newRenderTarget.isXRRenderTarget = true;
        this.setFoveation(1);
        referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
        animation.setContext(session);
        animation.start();
        scope.isPresenting = true;
        scope.dispatchEvent({ type: "sessionstart" });
      }
    };
    function onInputSourcesChange(event) {
      const inputSources = session.inputSources;
      for (let i2 = 0; i2 < controllers.length; i2++) {
        inputSourcesMap.set(inputSources[i2], controllers[i2]);
      }
      for (let i2 = 0; i2 < event.removed.length; i2++) {
        const inputSource = event.removed[i2];
        const controller = inputSourcesMap.get(inputSource);
        if (controller) {
          controller.dispatchEvent({ type: "disconnected", data: inputSource });
          inputSourcesMap.delete(inputSource);
        }
      }
      for (let i2 = 0; i2 < event.added.length; i2++) {
        const inputSource = event.added[i2];
        const controller = inputSourcesMap.get(inputSource);
        if (controller) {
          controller.dispatchEvent({ type: "connected", data: inputSource });
        }
      }
    }
    const cameraLPos = new Vector3();
    const cameraRPos = new Vector3();
    function setProjectionFromUnion(camera, cameraL2, cameraR2) {
      cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
      cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
      const ipd = cameraLPos.distanceTo(cameraRPos);
      const projL = cameraL2.projectionMatrix.elements;
      const projR = cameraR2.projectionMatrix.elements;
      const near = projL[14] / (projL[10] - 1);
      const far = projL[14] / (projL[10] + 1);
      const topFov = (projL[9] + 1) / projL[5];
      const bottomFov = (projL[9] - 1) / projL[5];
      const leftFov = (projL[8] - 1) / projL[0];
      const rightFov = (projR[8] + 1) / projR[0];
      const left = near * leftFov;
      const right = near * rightFov;
      const zOffset = ipd / (-leftFov + rightFov);
      const xOffset = zOffset * -leftFov;
      cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
      camera.translateX(xOffset);
      camera.translateZ(zOffset);
      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
      const near2 = near + zOffset;
      const far2 = far + zOffset;
      const left2 = left - xOffset;
      const right2 = right + (ipd - xOffset);
      const top2 = topFov * far / far2 * near2;
      const bottom2 = bottomFov * far / far2 * near2;
      camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
    }
    function updateCamera(camera, parent) {
      if (parent === null) {
        camera.matrixWorld.copy(camera.matrix);
      } else {
        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
      }
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    }
    this.updateCamera = function(camera) {
      if (session === null)
        return;
      cameraVR.near = cameraR.near = cameraL.near = camera.near;
      cameraVR.far = cameraR.far = cameraL.far = camera.far;
      if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
        session.updateRenderState({
          depthNear: cameraVR.near,
          depthFar: cameraVR.far
        });
        _currentDepthNear = cameraVR.near;
        _currentDepthFar = cameraVR.far;
      }
      const parent = camera.parent;
      const cameras2 = cameraVR.cameras;
      updateCamera(cameraVR, parent);
      for (let i2 = 0; i2 < cameras2.length; i2++) {
        updateCamera(cameras2[i2], parent);
      }
      cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);
      camera.position.copy(cameraVR.position);
      camera.quaternion.copy(cameraVR.quaternion);
      camera.scale.copy(cameraVR.scale);
      camera.matrix.copy(cameraVR.matrix);
      camera.matrixWorld.copy(cameraVR.matrixWorld);
      const children = camera.children;
      for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
        children[i2].updateMatrixWorld(true);
      }
      if (cameras2.length === 2) {
        setProjectionFromUnion(cameraVR, cameraL, cameraR);
      } else {
        cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
      }
    };
    this.getCamera = function() {
      return cameraVR;
    };
    this.getFoveation = function() {
      if (glProjLayer !== null) {
        return glProjLayer.fixedFoveation;
      }
      if (glBaseLayer !== null) {
        return glBaseLayer.fixedFoveation;
      }
      return void 0;
    };
    this.setFoveation = function(foveation) {
      if (glProjLayer !== null) {
        glProjLayer.fixedFoveation = foveation;
      }
      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
        glBaseLayer.fixedFoveation = foveation;
      }
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time, frame) {
      pose = frame.getViewerPose(referenceSpace);
      xrFrame = frame;
      if (pose !== null) {
        const views = pose.views;
        if (glBaseLayer !== null) {
          renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
          renderer.setRenderTarget(newRenderTarget);
        }
        let cameraVRNeedsUpdate = false;
        if (views.length !== cameraVR.cameras.length) {
          cameraVR.cameras.length = 0;
          cameraVRNeedsUpdate = true;
        }
        for (let i2 = 0; i2 < views.length; i2++) {
          const view = views[i2];
          let viewport = null;
          if (glBaseLayer !== null) {
            viewport = glBaseLayer.getViewport(view);
          } else {
            const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
            viewport = glSubImage.viewport;
            if (i2 === 0) {
              renderer.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture);
              renderer.setRenderTarget(newRenderTarget);
            }
          }
          const camera = cameras[i2];
          camera.matrix.fromArray(view.transform.matrix);
          camera.projectionMatrix.fromArray(view.projectionMatrix);
          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
          if (i2 === 0) {
            cameraVR.matrix.copy(camera.matrix);
          }
          if (cameraVRNeedsUpdate === true) {
            cameraVR.cameras.push(camera);
          }
        }
      }
      const inputSources = session.inputSources;
      for (let i2 = 0; i2 < controllers.length; i2++) {
        const controller = controllers[i2];
        const inputSource = inputSources[i2];
        controller.update(inputSource, frame, referenceSpace);
      }
      if (onAnimationFrameCallback)
        onAnimationFrameCallback(time, frame);
      xrFrame = null;
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
    };
    this.dispose = function() {
    };
  }
}
function WebGLMaterials(properties) {
  function refreshFogUniforms(uniforms, fog) {
    uniforms.fogColor.value.copy(fog.color);
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsLambert(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
      } else {
        refreshUniformsStandard(uniforms, material);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDepth(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsNormal(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false;
    }
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMap.value = envMap;
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.ior.value = material.ior;
      uniforms.refractionRatio.value = material.refractionRatio;
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    } else if (material.clearcoatMap) {
      uvScaleMap = material.clearcoatMap;
    } else if (material.clearcoatNormalMap) {
      uvScaleMap = material.clearcoatNormalMap;
    } else if (material.clearcoatRoughnessMap) {
      uvScaleMap = material.clearcoatRoughnessMap;
    } else if (material.specularIntensityMap) {
      uvScaleMap = material.specularIntensityMap;
    } else if (material.specularColorMap) {
      uvScaleMap = material.specularColorMap;
    } else if (material.transmissionMap) {
      uvScaleMap = material.transmissionMap;
    } else if (material.thicknessMap) {
      uvScaleMap = material.thicknessMap;
    } else if (material.sheenColorMap) {
      uvScaleMap = material.sheenColorMap;
    } else if (material.sheenRoughnessMap) {
      uvScaleMap = material.sheenRoughnessMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
    let uv2ScaleMap;
    if (material.aoMap) {
      uv2ScaleMap = material.aoMap;
    } else if (material.lightMap) {
      uv2ScaleMap = material.lightMap;
    }
    if (uv2ScaleMap !== void 0) {
      if (uv2ScaleMap.isWebGLRenderTarget) {
        uv2ScaleMap = uv2ScaleMap.texture;
      }
      if (uv2ScaleMap.matrixAutoUpdate === true) {
        uv2ScaleMap.updateMatrix();
      }
      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsLambert(uniforms, material) {
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
    refreshUniformsStandard(uniforms, material);
    uniforms.ior.value = material.ior;
    if (material.sheen > 0) {
      uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
      uniforms.sheenRoughness.value = material.sheenRoughness;
      if (material.sheenColorMap) {
        uniforms.sheenColorMap.value = material.sheenColorMap;
      }
      if (material.sheenRoughnessMap) {
        uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
      }
    }
    if (material.clearcoat > 0) {
      uniforms.clearcoat.value = material.clearcoat;
      uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
      if (material.clearcoatMap) {
        uniforms.clearcoatMap.value = material.clearcoatMap;
      }
      if (material.clearcoatRoughnessMap) {
        uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
      }
      if (material.clearcoatNormalMap) {
        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
        if (material.side === BackSide) {
          uniforms.clearcoatNormalScale.value.negate();
        }
      }
    }
    if (material.transmission > 0) {
      uniforms.transmission.value = material.transmission;
      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
      uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
      if (material.transmissionMap) {
        uniforms.transmissionMap.value = material.transmissionMap;
      }
      uniforms.thickness.value = material.thickness;
      if (material.thicknessMap) {
        uniforms.thicknessMap.value = material.thicknessMap;
      }
      uniforms.attenuationDistance.value = material.attenuationDistance;
      uniforms.attenuationColor.value.copy(material.attenuationColor);
    }
    uniforms.specularIntensity.value = material.specularIntensity;
    uniforms.specularColor.value.copy(material.specularColor);
    if (material.specularIntensityMap) {
      uniforms.specularIntensityMap.value = material.specularIntensityMap;
    }
    if (material.specularColorMap) {
      uniforms.specularColorMap.value = material.specularColorMap;
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDepth(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    uniforms.referencePosition.value.copy(material.referencePosition);
    uniforms.nearDistance.value = material.nearDistance;
    uniforms.farDistance.value = material.farDistance;
  }
  function refreshUniformsNormal(uniforms, material) {
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms
  };
}
function createCanvasElement() {
  const canvas = createElementNS("canvas");
  canvas.style.display = "block";
  return canvas;
}
function WebGLRenderer(parameters = {}) {
  const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context2 = parameters.context !== void 0 ? parameters.context : null, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
  let _alpha;
  if (parameters.context !== void 0) {
    _alpha = _context2.getContextAttributes().alpha;
  } else {
    _alpha = parameters.alpha !== void 0 ? parameters.alpha : false;
  }
  let currentRenderList = null;
  let currentRenderState = null;
  const renderListStack = [];
  const renderStateStack = [];
  this.domElement = _canvas2;
  this.debug = {
    checkShaderErrors: true
  };
  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;
  this.sortObjects = true;
  this.clippingPlanes = [];
  this.localClippingEnabled = false;
  this.outputEncoding = LinearEncoding;
  this.physicallyCorrectLights = false;
  this.toneMapping = NoToneMapping;
  this.toneMappingExposure = 1;
  const _this = this;
  let _isContextLost = false;
  let _currentActiveCubeFace = 0;
  let _currentActiveMipmapLevel = 0;
  let _currentRenderTarget = null;
  let _currentMaterialId = -1;
  let _currentCamera = null;
  const _currentViewport = new Vector4();
  const _currentScissor = new Vector4();
  let _currentScissorTest = null;
  let _width = _canvas2.width;
  let _height = _canvas2.height;
  let _pixelRatio = 1;
  let _opaqueSort = null;
  let _transparentSort = null;
  const _viewport = new Vector4(0, 0, _width, _height);
  const _scissor = new Vector4(0, 0, _width, _height);
  let _scissorTest = false;
  const _frustum = new Frustum();
  let _clippingEnabled = false;
  let _localClippingEnabled = false;
  let _transmissionRenderTarget = null;
  const _projScreenMatrix2 = new Matrix4();
  const _vector22 = new Vector2();
  const _vector3 = new Vector3();
  const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  }
  let _gl = _context2;
  function getContext(contextNames, contextAttributes) {
    for (let i2 = 0; i2 < contextNames.length; i2++) {
      const contextName = contextNames[i2];
      const context = _canvas2.getContext(contextName, contextAttributes);
      if (context !== null)
        return context;
    }
    return null;
  }
  try {
    const contextAttributes = {
      alpha: true,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference,
      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
    };
    if ("setAttribute" in _canvas2)
      _canvas2.setAttribute("data-engine", `three.js r${REVISION}`);
    _canvas2.addEventListener("webglcontextlost", onContextLost, false);
    _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
    if (_gl === null) {
      const contextNames = ["webgl2", "webgl", "experimental-webgl"];
      if (_this.isWebGL1Renderer === true) {
        contextNames.shift();
      }
      _gl = getContext(contextNames, contextAttributes);
      if (_gl === null) {
        if (getContext(contextNames)) {
          throw new Error("Error creating WebGL context with your selected attributes.");
        } else {
          throw new Error("Error creating WebGL context.");
        }
      }
    }
    if (_gl.getShaderPrecisionFormat === void 0) {
      _gl.getShaderPrecisionFormat = function() {
        return { "rangeMin": 1, "rangeMax": 1, "precision": 1 };
      };
    }
  } catch (error) {
    console.error("THREE.WebGLRenderer: " + error.message);
    throw error;
  }
  let extensions, capabilities, state, info;
  let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
  let programCache, materials, renderLists, renderStates, clipping, shadowMap;
  let background, morphtargets, bufferRenderer, indexedBufferRenderer;
  let utils, bindingStates;
  function initGLContext() {
    extensions = new WebGLExtensions(_gl);
    capabilities = new WebGLCapabilities(_gl, extensions, parameters);
    extensions.init(capabilities);
    utils = new WebGLUtils(_gl, extensions, capabilities);
    state = new WebGLState(_gl, extensions, capabilities);
    info = new WebGLInfo(_gl);
    properties = new WebGLProperties();
    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
    cubemaps = new WebGLCubeMaps(_this);
    cubeuvmaps = new WebGLCubeUVMaps(_this);
    attributes = new WebGLAttributes(_gl, capabilities);
    bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
    objects = new WebGLObjects(_gl, geometries, attributes, info);
    morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
    clipping = new WebGLClipping(properties);
    programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
    materials = new WebGLMaterials(properties);
    renderLists = new WebGLRenderLists();
    renderStates = new WebGLRenderStates(extensions, capabilities);
    background = new WebGLBackground(_this, cubemaps, state, objects, _alpha, _premultipliedAlpha);
    shadowMap = new WebGLShadowMap(_this, objects, capabilities);
    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
    info.programs = programCache.programs;
    _this.capabilities = capabilities;
    _this.extensions = extensions;
    _this.properties = properties;
    _this.renderLists = renderLists;
    _this.shadowMap = shadowMap;
    _this.state = state;
    _this.info = info;
  }
  initGLContext();
  const xr = new WebXRManager(_this, _gl);
  this.xr = xr;
  this.getContext = function() {
    return _gl;
  };
  this.getContextAttributes = function() {
    return _gl.getContextAttributes();
  };
  this.forceContextLoss = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.loseContext();
  };
  this.forceContextRestore = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.restoreContext();
  };
  this.getPixelRatio = function() {
    return _pixelRatio;
  };
  this.setPixelRatio = function(value) {
    if (value === void 0)
      return;
    _pixelRatio = value;
    this.setSize(_width, _height, false);
  };
  this.getSize = function(target) {
    return target.set(_width, _height);
  };
  this.setSize = function(width, height, updateStyle) {
    if (xr.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    _width = width;
    _height = height;
    _canvas2.width = Math.floor(width * _pixelRatio);
    _canvas2.height = Math.floor(height * _pixelRatio);
    if (updateStyle !== false) {
      _canvas2.style.width = width + "px";
      _canvas2.style.height = height + "px";
    }
    this.setViewport(0, 0, width, height);
  };
  this.getDrawingBufferSize = function(target) {
    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
  };
  this.setDrawingBufferSize = function(width, height, pixelRatio) {
    _width = width;
    _height = height;
    _pixelRatio = pixelRatio;
    _canvas2.width = Math.floor(width * pixelRatio);
    _canvas2.height = Math.floor(height * pixelRatio);
    this.setViewport(0, 0, width, height);
  };
  this.getCurrentViewport = function(target) {
    return target.copy(_currentViewport);
  };
  this.getViewport = function(target) {
    return target.copy(_viewport);
  };
  this.setViewport = function(x2, y2, width, height) {
    if (x2.isVector4) {
      _viewport.set(x2.x, x2.y, x2.z, x2.w);
    } else {
      _viewport.set(x2, y2, width, height);
    }
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissor = function(target) {
    return target.copy(_scissor);
  };
  this.setScissor = function(x2, y2, width, height) {
    if (x2.isVector4) {
      _scissor.set(x2.x, x2.y, x2.z, x2.w);
    } else {
      _scissor.set(x2, y2, width, height);
    }
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissorTest = function() {
    return _scissorTest;
  };
  this.setScissorTest = function(boolean) {
    state.setScissorTest(_scissorTest = boolean);
  };
  this.setOpaqueSort = function(method) {
    _opaqueSort = method;
  };
  this.setTransparentSort = function(method) {
    _transparentSort = method;
  };
  this.getClearColor = function(target) {
    return target.copy(background.getClearColor());
  };
  this.setClearColor = function() {
    background.setClearColor.apply(background, arguments);
  };
  this.getClearAlpha = function() {
    return background.getClearAlpha();
  };
  this.setClearAlpha = function() {
    background.setClearAlpha.apply(background, arguments);
  };
  this.clear = function(color = true, depth = true, stencil = true) {
    let bits = 0;
    if (color)
      bits |= 16384;
    if (depth)
      bits |= 256;
    if (stencil)
      bits |= 1024;
    _gl.clear(bits);
  };
  this.clearColor = function() {
    this.clear(true, false, false);
  };
  this.clearDepth = function() {
    this.clear(false, true, false);
  };
  this.clearStencil = function() {
    this.clear(false, false, true);
  };
  this.dispose = function() {
    _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
    _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
    renderLists.dispose();
    renderStates.dispose();
    properties.dispose();
    cubemaps.dispose();
    cubeuvmaps.dispose();
    objects.dispose();
    bindingStates.dispose();
    programCache.dispose();
    xr.dispose();
    xr.removeEventListener("sessionstart", onXRSessionStart);
    xr.removeEventListener("sessionend", onXRSessionEnd);
    if (_transmissionRenderTarget) {
      _transmissionRenderTarget.dispose();
      _transmissionRenderTarget = null;
    }
    animation.stop();
  };
  function onContextLost(event) {
    event.preventDefault();
    console.log("THREE.WebGLRenderer: Context Lost.");
    _isContextLost = true;
  }
  function onContextRestore() {
    console.log("THREE.WebGLRenderer: Context Restored.");
    _isContextLost = false;
    const infoAutoReset = info.autoReset;
    const shadowMapEnabled = shadowMap.enabled;
    const shadowMapAutoUpdate = shadowMap.autoUpdate;
    const shadowMapNeedsUpdate = shadowMap.needsUpdate;
    const shadowMapType = shadowMap.type;
    initGLContext();
    info.autoReset = infoAutoReset;
    shadowMap.enabled = shadowMapEnabled;
    shadowMap.autoUpdate = shadowMapAutoUpdate;
    shadowMap.needsUpdate = shadowMapNeedsUpdate;
    shadowMap.type = shadowMapType;
  }
  function onMaterialDispose(event) {
    const material = event.target;
    material.removeEventListener("dispose", onMaterialDispose);
    deallocateMaterial(material);
  }
  function deallocateMaterial(material) {
    releaseMaterialProgramReferences(material);
    properties.remove(material);
  }
  function releaseMaterialProgramReferences(material) {
    const programs = properties.get(material).programs;
    if (programs !== void 0) {
      programs.forEach(function(program) {
        programCache.releaseProgram(program);
      });
      if (material.isShaderMaterial) {
        programCache.releaseShaderCache(material);
      }
    }
  }
  this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
    if (scene === null)
      scene = _emptyScene;
    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
    const program = setProgram(camera, scene, geometry, material, object);
    state.setMaterial(material, frontFaceCW);
    let index = geometry.index;
    const position = geometry.attributes.position;
    if (index === null) {
      if (position === void 0 || position.count === 0)
        return;
    } else if (index.count === 0) {
      return;
    }
    let rangeFactor = 1;
    if (material.wireframe === true) {
      index = geometries.getWireframeAttribute(geometry);
      rangeFactor = 2;
    }
    bindingStates.setup(object, material, program, geometry, index);
    let attribute;
    let renderer = bufferRenderer;
    if (index !== null) {
      attribute = attributes.get(index);
      renderer = indexedBufferRenderer;
      renderer.setIndex(attribute);
    }
    const dataCount = index !== null ? index.count : position.count;
    const rangeStart = geometry.drawRange.start * rangeFactor;
    const rangeCount = geometry.drawRange.count * rangeFactor;
    const groupStart = group !== null ? group.start * rangeFactor : 0;
    const groupCount = group !== null ? group.count * rangeFactor : Infinity;
    const drawStart = Math.max(rangeStart, groupStart);
    const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    const drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0)
      return;
    if (object.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer.setMode(1);
      } else {
        renderer.setMode(4);
      }
    } else if (object.isLine) {
      let lineWidth = material.linewidth;
      if (lineWidth === void 0)
        lineWidth = 1;
      state.setLineWidth(lineWidth * getTargetPixelRatio());
      if (object.isLineSegments) {
        renderer.setMode(1);
      } else if (object.isLineLoop) {
        renderer.setMode(2);
      } else {
        renderer.setMode(3);
      }
    } else if (object.isPoints) {
      renderer.setMode(0);
    } else if (object.isSprite) {
      renderer.setMode(4);
    }
    if (object.isInstancedMesh) {
      renderer.renderInstances(drawStart, drawCount, object.count);
    } else if (geometry.isInstancedBufferGeometry) {
      const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
      renderer.renderInstances(drawStart, drawCount, instanceCount);
    } else {
      renderer.render(drawStart, drawCount);
    }
  };
  this.compile = function(scene, camera) {
    currentRenderState = renderStates.get(scene);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);
    scene.traverseVisible(function(object) {
      if (object.isLight && object.layers.test(camera.layers)) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      }
    });
    currentRenderState.setupLights(_this.physicallyCorrectLights);
    scene.traverse(function(object) {
      const material = object.material;
      if (material) {
        if (Array.isArray(material)) {
          for (let i2 = 0; i2 < material.length; i2++) {
            const material2 = material[i2];
            getProgram(material2, scene, object);
          }
        } else {
          getProgram(material, scene, object);
        }
      }
    });
    renderStateStack.pop();
    currentRenderState = null;
  };
  let onAnimationFrameCallback = null;
  function onAnimationFrame(time) {
    if (onAnimationFrameCallback)
      onAnimationFrameCallback(time);
  }
  function onXRSessionStart() {
    animation.stop();
  }
  function onXRSessionEnd() {
    animation.start();
  }
  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  if (typeof window !== "undefined")
    animation.setContext(window);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
    xr.setAnimationLoop(callback);
    callback === null ? animation.stop() : animation.start();
  };
  xr.addEventListener("sessionstart", onXRSessionStart);
  xr.addEventListener("sessionend", onXRSessionEnd);
  this.render = function(scene, camera) {
    if (camera !== void 0 && camera.isCamera !== true) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (_isContextLost === true)
      return;
    if (scene.autoUpdate === true)
      scene.updateMatrixWorld();
    if (camera.parent === null)
      camera.updateMatrixWorld();
    if (xr.enabled === true && xr.isPresenting === true) {
      if (xr.cameraAutoUpdate === true)
        xr.updateCamera(camera);
      camera = xr.getCamera();
    }
    if (scene.isScene === true)
      scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
    currentRenderState = renderStates.get(scene, renderStateStack.length);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);
    _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromProjectionMatrix(_projScreenMatrix2);
    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
    currentRenderList = renderLists.get(scene, renderListStack.length);
    currentRenderList.init();
    renderListStack.push(currentRenderList);
    projectObject(scene, camera, 0, _this.sortObjects);
    currentRenderList.finish();
    if (_this.sortObjects === true) {
      currentRenderList.sort(_opaqueSort, _transparentSort);
    }
    if (_clippingEnabled === true)
      clipping.beginShadows();
    const shadowsArray = currentRenderState.state.shadowsArray;
    shadowMap.render(shadowsArray, scene, camera);
    if (_clippingEnabled === true)
      clipping.endShadows();
    if (this.info.autoReset === true)
      this.info.reset();
    background.render(currentRenderList, scene);
    currentRenderState.setupLights(_this.physicallyCorrectLights);
    if (camera.isArrayCamera) {
      const cameras = camera.cameras;
      for (let i2 = 0, l2 = cameras.length; i2 < l2; i2++) {
        const camera2 = cameras[i2];
        renderScene(currentRenderList, scene, camera2, camera2.viewport);
      }
    } else {
      renderScene(currentRenderList, scene, camera);
    }
    if (_currentRenderTarget !== null) {
      textures.updateMultisampleRenderTarget(_currentRenderTarget);
      textures.updateRenderTargetMipmap(_currentRenderTarget);
    }
    if (scene.isScene === true)
      scene.onAfterRender(_this, scene, camera);
    bindingStates.resetDefaultState();
    _currentMaterialId = -1;
    _currentCamera = null;
    renderStateStack.pop();
    if (renderStateStack.length > 0) {
      currentRenderState = renderStateStack[renderStateStack.length - 1];
    } else {
      currentRenderState = null;
    }
    renderListStack.pop();
    if (renderListStack.length > 0) {
      currentRenderList = renderListStack[renderListStack.length - 1];
    } else {
      currentRenderList = null;
    }
  };
  function projectObject(object, camera, groupOrder, sortObjects) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
      } else if (object.isLOD) {
        if (object.autoUpdate === true)
          object.update(camera);
      } else if (object.isLight) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry = objects.update(object);
          const material = object.material;
          if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (object.isSkinnedMesh) {
          if (object.skeleton.frame !== info.render.frame) {
            object.skeleton.update();
            object.skeleton.frame = info.render.frame;
          }
        }
        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry = objects.update(object);
          const material = object.material;
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
              const group = groups[i2];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      }
    }
    const children = object.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      projectObject(children[i2], camera, groupOrder, sortObjects);
    }
  }
  function renderScene(currentRenderList2, scene, camera, viewport) {
    const opaqueObjects = currentRenderList2.opaque;
    const transmissiveObjects = currentRenderList2.transmissive;
    const transparentObjects = currentRenderList2.transparent;
    currentRenderState.setupLightsView(camera);
    if (transmissiveObjects.length > 0)
      renderTransmissionPass(opaqueObjects, scene, camera);
    if (viewport)
      state.viewport(_currentViewport.copy(viewport));
    if (opaqueObjects.length > 0)
      renderObjects(opaqueObjects, scene, camera);
    if (transmissiveObjects.length > 0)
      renderObjects(transmissiveObjects, scene, camera);
    if (transparentObjects.length > 0)
      renderObjects(transparentObjects, scene, camera);
    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    state.setPolygonOffset(false);
  }
  function renderTransmissionPass(opaqueObjects, scene, camera) {
    const isWebGL2 = capabilities.isWebGL2;
    if (_transmissionRenderTarget === null) {
      _transmissionRenderTarget = new WebGLRenderTarget(1, 1, {
        generateMipmaps: true,
        type: utils.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
        minFilter: LinearMipmapLinearFilter,
        samples: isWebGL2 && _antialias === true ? 4 : 0
      });
    }
    _this.getDrawingBufferSize(_vector22);
    if (isWebGL2) {
      _transmissionRenderTarget.setSize(_vector22.x, _vector22.y);
    } else {
      _transmissionRenderTarget.setSize(floorPowerOfTwo(_vector22.x), floorPowerOfTwo(_vector22.y));
    }
    const currentRenderTarget = _this.getRenderTarget();
    _this.setRenderTarget(_transmissionRenderTarget);
    _this.clear();
    const currentToneMapping = _this.toneMapping;
    _this.toneMapping = NoToneMapping;
    renderObjects(opaqueObjects, scene, camera);
    _this.toneMapping = currentToneMapping;
    textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
    textures.updateRenderTargetMipmap(_transmissionRenderTarget);
    _this.setRenderTarget(currentRenderTarget);
  }
  function renderObjects(renderList, scene, camera) {
    const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
    for (let i2 = 0, l2 = renderList.length; i2 < l2; i2++) {
      const renderItem = renderList[i2];
      const object = renderItem.object;
      const geometry = renderItem.geometry;
      const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
      const group = renderItem.group;
      if (object.layers.test(camera.layers)) {
        renderObject(object, scene, camera, geometry, material, group);
      }
    }
  }
  function renderObject(object, scene, camera, geometry, material, group) {
    object.onBeforeRender(_this, scene, camera, geometry, material, group);
    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
    material.onBeforeRender(_this, scene, camera, geometry, object, group);
    if (material.transparent === true && material.side === DoubleSide) {
      material.side = BackSide;
      material.needsUpdate = true;
      _this.renderBufferDirect(camera, scene, geometry, material, object, group);
      material.side = FrontSide;
      material.needsUpdate = true;
      _this.renderBufferDirect(camera, scene, geometry, material, object, group);
      material.side = DoubleSide;
    } else {
      _this.renderBufferDirect(camera, scene, geometry, material, object, group);
    }
    object.onAfterRender(_this, scene, camera, geometry, material, group);
  }
  function getProgram(material, scene, object) {
    if (scene.isScene !== true)
      scene = _emptyScene;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    const shadowsArray = currentRenderState.state.shadowsArray;
    const lightsStateVersion = lights.state.version;
    const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
    const programCacheKey = programCache.getProgramCacheKey(parameters2);
    let programs = materialProperties.programs;
    materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
    materialProperties.fog = scene.fog;
    materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
    if (programs === void 0) {
      material.addEventListener("dispose", onMaterialDispose);
      programs = /* @__PURE__ */ new Map();
      materialProperties.programs = programs;
    }
    let program = programs.get(programCacheKey);
    if (program !== void 0) {
      if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
        updateCommonMaterialProperties(material, parameters2);
        return program;
      }
    } else {
      parameters2.uniforms = programCache.getUniforms(material);
      material.onBuild(object, parameters2, _this);
      material.onBeforeCompile(parameters2, _this);
      program = programCache.acquireProgram(parameters2, programCacheKey);
      programs.set(programCacheKey, program);
      materialProperties.uniforms = parameters2.uniforms;
    }
    const uniforms = materialProperties.uniforms;
    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
      uniforms.clippingPlanes = clipping.uniform;
    }
    updateCommonMaterialProperties(material, parameters2);
    materialProperties.needsLights = materialNeedsLights(material);
    materialProperties.lightsStateVersion = lightsStateVersion;
    if (materialProperties.needsLights) {
      uniforms.ambientLightColor.value = lights.state.ambient;
      uniforms.lightProbe.value = lights.state.probe;
      uniforms.directionalLights.value = lights.state.directional;
      uniforms.directionalLightShadows.value = lights.state.directionalShadow;
      uniforms.spotLights.value = lights.state.spot;
      uniforms.spotLightShadows.value = lights.state.spotShadow;
      uniforms.rectAreaLights.value = lights.state.rectArea;
      uniforms.ltc_1.value = lights.state.rectAreaLTC1;
      uniforms.ltc_2.value = lights.state.rectAreaLTC2;
      uniforms.pointLights.value = lights.state.point;
      uniforms.pointLightShadows.value = lights.state.pointShadow;
      uniforms.hemisphereLights.value = lights.state.hemi;
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
    }
    const progUniforms = program.getUniforms();
    const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.currentProgram = program;
    materialProperties.uniformsList = uniformsList;
    return program;
  }
  function updateCommonMaterialProperties(material, parameters2) {
    const materialProperties = properties.get(material);
    materialProperties.outputEncoding = parameters2.outputEncoding;
    materialProperties.instancing = parameters2.instancing;
    materialProperties.skinning = parameters2.skinning;
    materialProperties.morphTargets = parameters2.morphTargets;
    materialProperties.morphNormals = parameters2.morphNormals;
    materialProperties.morphColors = parameters2.morphColors;
    materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
    materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
    materialProperties.numIntersection = parameters2.numClipIntersection;
    materialProperties.vertexAlphas = parameters2.vertexAlphas;
    materialProperties.vertexTangents = parameters2.vertexTangents;
    materialProperties.toneMapping = parameters2.toneMapping;
  }
  function setProgram(camera, scene, geometry, material, object) {
    if (scene.isScene !== true)
      scene = _emptyScene;
    textures.resetTextureUnits();
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding;
    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
    const vertexTangents = !!material.normalMap && !!geometry.attributes.tangent;
    const morphTargets = !!geometry.morphAttributes.position;
    const morphNormals = !!geometry.morphAttributes.normal;
    const morphColors = !!geometry.morphAttributes.color;
    const toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    if (_clippingEnabled === true) {
      if (_localClippingEnabled === true || camera !== _currentCamera) {
        const useCache = camera === _currentCamera && material.id === _currentMaterialId;
        clipping.setState(material, camera, useCache);
      }
    }
    let needsProgramChange = false;
    if (material.version === materialProperties.__version) {
      if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
        needsProgramChange = true;
      } else if (materialProperties.outputEncoding !== encoding) {
        needsProgramChange = true;
      } else if (object.isInstancedMesh && materialProperties.instancing === false) {
        needsProgramChange = true;
      } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
        needsProgramChange = true;
      } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
        needsProgramChange = true;
      } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
        needsProgramChange = true;
      } else if (materialProperties.envMap !== envMap) {
        needsProgramChange = true;
      } else if (material.fog && materialProperties.fog !== fog) {
        needsProgramChange = true;
      } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
        needsProgramChange = true;
      } else if (materialProperties.vertexAlphas !== vertexAlphas) {
        needsProgramChange = true;
      } else if (materialProperties.vertexTangents !== vertexTangents) {
        needsProgramChange = true;
      } else if (materialProperties.morphTargets !== morphTargets) {
        needsProgramChange = true;
      } else if (materialProperties.morphNormals !== morphNormals) {
        needsProgramChange = true;
      } else if (materialProperties.morphColors !== morphColors) {
        needsProgramChange = true;
      } else if (materialProperties.toneMapping !== toneMapping) {
        needsProgramChange = true;
      } else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
        needsProgramChange = true;
      }
    } else {
      needsProgramChange = true;
      materialProperties.__version = material.version;
    }
    let program = materialProperties.currentProgram;
    if (needsProgramChange === true) {
      program = getProgram(material, scene, object);
    }
    let refreshProgram = false;
    let refreshMaterial = false;
    let refreshLights = false;
    const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
    if (state.useProgram(program.program)) {
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }
    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }
    if (refreshProgram || _currentCamera !== camera) {
      p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2));
      }
      if (_currentCamera !== camera) {
        _currentCamera = camera;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
        const uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
        }
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
        p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {
        p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
      }
    }
    if (object.isSkinnedMesh) {
      p_uniforms.setOptional(_gl, object, "bindMatrix");
      p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
      const skeleton = object.skeleton;
      if (skeleton) {
        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === null)
            skeleton.computeBoneTexture();
          p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
          p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
        } else {
          p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
        }
      }
    }
    const morphAttributes = geometry.morphAttributes;
    if (morphAttributes.position !== void 0 || morphAttributes.normal !== void 0 || morphAttributes.color !== void 0 && capabilities.isWebGL2 === true) {
      morphtargets.update(object, geometry, material, program);
    }
    if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
      materialProperties.receiveShadow = object.receiveShadow;
      p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
    }
    if (refreshMaterial) {
      p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
      if (materialProperties.needsLights) {
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      }
      if (fog && material.fog) {
        materials.refreshFogUniforms(m_uniforms, fog);
      }
      materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
    }
    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      material.uniformsNeedUpdate = false;
    }
    if (material.isSpriteMaterial) {
      p_uniforms.setValue(_gl, "center", object.center);
    }
    p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
    p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
    p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
    return program;
  }
  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.lightProbe.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.directionalLightShadows.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.pointLightShadows.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.spotLightShadows.needsUpdate = value;
    uniforms.rectAreaLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
    uniforms.directionalShadowMap.needsUpdate = value;
    uniforms.directionalShadowMatrix.needsUpdate = value;
    uniforms.spotShadowMap.needsUpdate = value;
    uniforms.spotShadowMatrix.needsUpdate = value;
    uniforms.pointShadowMap.needsUpdate = value;
    uniforms.pointShadowMatrix.needsUpdate = value;
  }
  function materialNeedsLights(material) {
    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
  }
  this.getActiveCubeFace = function() {
    return _currentActiveCubeFace;
  };
  this.getActiveMipmapLevel = function() {
    return _currentActiveMipmapLevel;
  };
  this.getRenderTarget = function() {
    return _currentRenderTarget;
  };
  this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
    properties.get(renderTarget.texture).__webglTexture = colorTexture;
    properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
    const renderTargetProperties = properties.get(renderTarget);
    renderTargetProperties.__hasExternalTextures = true;
    if (renderTargetProperties.__hasExternalTextures) {
      renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0;
      if (!renderTargetProperties.__autoAllocateDepthBuffer) {
        if (extensions.has("WEBGL_multisampled_render_to_texture") === true) {
          console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided");
          renderTarget.useRenderToTexture = false;
          renderTarget.useRenderbuffer = true;
        }
      }
    }
  };
  this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
    const renderTargetProperties = properties.get(renderTarget);
    renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
    renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
  };
  this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
    _currentRenderTarget = renderTarget;
    _currentActiveCubeFace = activeCubeFace;
    _currentActiveMipmapLevel = activeMipmapLevel;
    let useDefaultFramebuffer = true;
    if (renderTarget) {
      const renderTargetProperties = properties.get(renderTarget);
      if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
        state.bindFramebuffer(36160, null);
        useDefaultFramebuffer = false;
      } else if (renderTargetProperties.__webglFramebuffer === void 0) {
        textures.setupRenderTarget(renderTarget);
      } else if (renderTargetProperties.__hasExternalTextures) {
        textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
      }
    }
    let framebuffer = null;
    let isCube = false;
    let isRenderTarget3D = false;
    if (renderTarget) {
      const texture = renderTarget.texture;
      if (texture.isData3DTexture || texture.isDataArrayTexture) {
        isRenderTarget3D = true;
      }
      const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget) {
        framebuffer = __webglFramebuffer[activeCubeFace];
        isCube = true;
      } else if (capabilities.isWebGL2 && renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {
        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
      } else {
        framebuffer = __webglFramebuffer;
      }
      _currentViewport.copy(renderTarget.viewport);
      _currentScissor.copy(renderTarget.scissor);
      _currentScissorTest = renderTarget.scissorTest;
    } else {
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
      _currentScissorTest = _scissorTest;
    }
    const framebufferBound = state.bindFramebuffer(36160, framebuffer);
    if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {
      state.drawBuffers(renderTarget, framebuffer);
    }
    state.viewport(_currentViewport);
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);
    if (isCube) {
      const textureProperties = properties.get(renderTarget.texture);
      _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
    } else if (isRenderTarget3D) {
      const textureProperties = properties.get(renderTarget.texture);
      const layer = activeCubeFace || 0;
      _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
    }
    _currentMaterialId = -1;
  };
  this.readRenderTargetPixels = function(renderTarget, x2, y2, width, height, buffer, activeCubeFaceIndex) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let framebuffer = properties.get(renderTarget).__webglFramebuffer;
    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
      framebuffer = framebuffer[activeCubeFaceIndex];
    }
    if (framebuffer) {
      state.bindFramebuffer(36160, framebuffer);
      try {
        const texture = renderTarget.texture;
        const textureFormat = texture.format;
        const textureType = texture.type;
        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        if (_gl.checkFramebufferStatus(36160) === 36053) {
          if (x2 >= 0 && x2 <= renderTarget.width - width && (y2 >= 0 && y2 <= renderTarget.height - height)) {
            _gl.readPixels(x2, y2, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } else {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
        }
      } finally {
        const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
        state.bindFramebuffer(36160, framebuffer2);
      }
    }
  };
  this.copyFramebufferToTexture = function(position, texture, level = 0) {
    if (texture.isFramebufferTexture !== true) {
      console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");
      return;
    }
    const levelScale = Math.pow(2, -level);
    const width = Math.floor(texture.image.width * levelScale);
    const height = Math.floor(texture.image.height * levelScale);
    textures.setTexture2D(texture, 0);
    _gl.copyTexSubImage2D(3553, level, 0, 0, position.x, position.y, width, height);
    state.unbindTexture();
  };
  this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
    const width = srcTexture.image.width;
    const height = srcTexture.image.height;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    textures.setTexture2D(dstTexture, 0);
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
      } else {
        _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
      }
    }
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(3553);
    state.unbindTexture();
  };
  this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
    if (_this.isWebGL1Renderer) {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      return;
    }
    const width = sourceBox.max.x - sourceBox.min.x + 1;
    const height = sourceBox.max.y - sourceBox.min.y + 1;
    const depth = sourceBox.max.z - sourceBox.min.z + 1;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    let glTarget;
    if (dstTexture.isData3DTexture) {
      textures.setTexture3D(dstTexture, 0);
      glTarget = 32879;
    } else if (dstTexture.isDataArrayTexture) {
      textures.setTexture2DArray(dstTexture, 0);
      glTarget = 35866;
    } else {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      return;
    }
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    const unpackRowLen = _gl.getParameter(3314);
    const unpackImageHeight = _gl.getParameter(32878);
    const unpackSkipPixels = _gl.getParameter(3316);
    const unpackSkipRows = _gl.getParameter(3315);
    const unpackSkipImages = _gl.getParameter(32877);
    const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
    _gl.pixelStorei(3314, image.width);
    _gl.pixelStorei(32878, image.height);
    _gl.pixelStorei(3316, sourceBox.min.x);
    _gl.pixelStorei(3315, sourceBox.min.y);
    _gl.pixelStorei(32877, sourceBox.min.z);
    if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
      _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");
        _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);
      } else {
        _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);
      }
    }
    _gl.pixelStorei(3314, unpackRowLen);
    _gl.pixelStorei(32878, unpackImageHeight);
    _gl.pixelStorei(3316, unpackSkipPixels);
    _gl.pixelStorei(3315, unpackSkipRows);
    _gl.pixelStorei(32877, unpackSkipImages);
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(glTarget);
    state.unbindTexture();
  };
  this.initTexture = function(texture) {
    textures.setTexture2D(texture, 0);
    state.unbindTexture();
  };
  this.resetState = function() {
    _currentActiveCubeFace = 0;
    _currentActiveMipmapLevel = 0;
    _currentRenderTarget = null;
    state.reset();
    bindingStates.reset();
  };
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
}
WebGLRenderer.prototype.isWebGLRenderer = true;
class WebGL1Renderer extends WebGLRenderer {
}
WebGL1Renderer.prototype.isWebGL1Renderer = true;
class Scene extends Object3D {
  constructor() {
    super();
    this.type = "Scene";
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.overrideMaterial = null;
    this.autoUpdate = true;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null)
      this.background = source.background.clone();
    if (source.environment !== null)
      this.environment = source.environment.clone();
    if (source.fog !== null)
      this.fog = source.fog.clone();
    if (source.overrideMaterial !== null)
      this.overrideMaterial = source.overrideMaterial.clone();
    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.fog !== null)
      data.object.fog = this.fog.toJSON();
    return data;
  }
}
Scene.prototype.isScene = true;
class InterleavedBuffer {
  constructor(array, stride) {
    this.array = array;
    this.stride = stride;
    this.count = array !== void 0 ? array.length / stride : 0;
    this.usage = StaticDrawUsage;
    this.updateRange = { offset: 0, count: -1 };
    this.version = 0;
    this.uuid = generateUUID();
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  copy(source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.usage = source.usage;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;
    for (let i2 = 0, l2 = this.stride; i2 < l2; i2++) {
      this.array[index1 + i2] = attribute.array[index2 + i2];
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  clone(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }
    const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
    const ib = new this.constructor(array, this.stride);
    ib.setUsage(this.usage);
    return ib;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  toJSON(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
    }
    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
InterleavedBuffer.prototype.isInterleavedBuffer = true;
const _vector$6 = /* @__PURE__ */ new Vector3();
class InterleavedBufferAttribute {
  constructor(interleavedBuffer, itemSize, offset, normalized = false) {
    this.name = "";
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized === true;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(value) {
    this.data.needsUpdate = value;
  }
  applyMatrix4(m2) {
    for (let i2 = 0, l2 = this.data.count; i2 < l2; i2++) {
      _vector$6.x = this.getX(i2);
      _vector$6.y = this.getY(i2);
      _vector$6.z = this.getZ(i2);
      _vector$6.applyMatrix4(m2);
      this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  applyNormalMatrix(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$6.x = this.getX(i2);
      _vector$6.y = this.getY(i2);
      _vector$6.z = this.getZ(i2);
      _vector$6.applyNormalMatrix(m2);
      this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  transformDirection(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$6.x = this.getX(i2);
      _vector$6.y = this.getY(i2);
      _vector$6.z = this.getZ(i2);
      _vector$6.transformDirection(m2);
      this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  setX(index, x2) {
    this.data.array[index * this.data.stride + this.offset] = x2;
    return this;
  }
  setY(index, y2) {
    this.data.array[index * this.data.stride + this.offset + 1] = y2;
    return this;
  }
  setZ(index, z2) {
    this.data.array[index * this.data.stride + this.offset + 2] = z2;
    return this;
  }
  setW(index, w2) {
    this.data.array[index * this.data.stride + this.offset + 3] = w2;
    return this;
  }
  getX(index) {
    return this.data.array[index * this.data.stride + this.offset];
  }
  getY(index) {
    return this.data.array[index * this.data.stride + this.offset + 1];
  }
  getZ(index) {
    return this.data.array[index * this.data.stride + this.offset + 2];
  }
  getW(index) {
    return this.data.array[index * this.data.stride + this.offset + 3];
  }
  setXY(index, x2, y2) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x2;
    this.data.array[index + 1] = y2;
    return this;
  }
  setXYZ(index, x2, y2, z2) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x2;
    this.data.array[index + 1] = y2;
    this.data.array[index + 2] = z2;
    return this;
  }
  setXYZW(index, x2, y2, z2, w2) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x2;
    this.data.array[index + 1] = y2;
    this.data.array[index + 2] = z2;
    this.data.array[index + 3] = w2;
    return this;
  }
  clone(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
      const array = [];
      for (let i2 = 0; i2 < this.count; i2++) {
        const index = i2 * this.data.stride + this.offset;
        for (let j2 = 0; j2 < this.itemSize; j2++) {
          array.push(this.data.array[index + j2]);
        }
      }
      return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
      }
      return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  }
  toJSON(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
      const array = [];
      for (let i2 = 0; i2 < this.count; i2++) {
        const index = i2 * this.data.stride + this.offset;
        for (let j2 = 0; j2 < this.itemSize; j2++) {
          array.push(this.data.array[index + j2]);
        }
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array,
        normalized: this.normalized
      };
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
      }
      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
}
InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;
class SpriteMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "SpriteMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.rotation = 0;
    this.sizeAttenuation = true;
    this.transparent = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.rotation = source.rotation;
    this.sizeAttenuation = source.sizeAttenuation;
    return this;
  }
}
SpriteMaterial.prototype.isSpriteMaterial = true;
let _geometry;
const _intersectPoint = /* @__PURE__ */ new Vector3();
const _worldScale = /* @__PURE__ */ new Vector3();
const _mvPosition = /* @__PURE__ */ new Vector3();
const _alignedPosition = /* @__PURE__ */ new Vector2();
const _rotatedPosition = /* @__PURE__ */ new Vector2();
const _viewWorldMatrix = /* @__PURE__ */ new Matrix4();
const _vA = /* @__PURE__ */ new Vector3();
const _vB = /* @__PURE__ */ new Vector3();
const _vC = /* @__PURE__ */ new Vector3();
const _uvA = /* @__PURE__ */ new Vector2();
const _uvB = /* @__PURE__ */ new Vector2();
const _uvC = /* @__PURE__ */ new Vector2();
class Sprite extends Object3D {
  constructor(material) {
    super();
    this.type = "Sprite";
    if (_geometry === void 0) {
      _geometry = new BufferGeometry();
      const float32Array = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]);
      const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
      _geometry.setIndex([0, 1, 2, 0, 2, 3]);
      _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
      _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
    }
    this.geometry = _geometry;
    this.material = material !== void 0 ? material : new SpriteMaterial();
    this.center = new Vector2(0.5, 0.5);
  }
  raycast(raycaster, intersects2) {
    if (raycaster.camera === null) {
      console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
    }
    _worldScale.setFromMatrixScale(this.matrixWorld);
    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
    this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
    if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
      _worldScale.multiplyScalar(-_mvPosition.z);
    }
    const rotation = this.material.rotation;
    let sin, cos;
    if (rotation !== 0) {
      cos = Math.cos(rotation);
      sin = Math.sin(rotation);
    }
    const center = this.center;
    transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    _uvA.set(0, 0);
    _uvB.set(1, 0);
    _uvC.set(1, 1);
    let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
    if (intersect === null) {
      transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      _uvB.set(0, 1);
      intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
      if (intersect === null) {
        return;
      }
    }
    const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far)
      return;
    intersects2.push({
      distance,
      point: _intersectPoint.clone(),
      uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
      face: null,
      object: this
    });
  }
  copy(source) {
    super.copy(source);
    if (source.center !== void 0)
      this.center.copy(source.center);
    this.material = source.material;
    return this;
  }
}
Sprite.prototype.isSprite = true;
function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
  if (sin !== void 0) {
    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
  } else {
    _rotatedPosition.copy(_alignedPosition);
  }
  vertexPosition.copy(mvPosition);
  vertexPosition.x += _rotatedPosition.x;
  vertexPosition.y += _rotatedPosition.y;
  vertexPosition.applyMatrix4(_viewWorldMatrix);
}
const _basePosition = /* @__PURE__ */ new Vector3();
const _skinIndex = /* @__PURE__ */ new Vector4();
const _skinWeight = /* @__PURE__ */ new Vector4();
const _vector$5 = /* @__PURE__ */ new Vector3();
const _matrix = /* @__PURE__ */ new Matrix4();
class SkinnedMesh extends Mesh {
  constructor(geometry, material) {
    super(geometry, material);
    this.type = "SkinnedMesh";
    this.bindMode = "attached";
    this.bindMatrix = new Matrix4();
    this.bindMatrixInverse = new Matrix4();
  }
  copy(source) {
    super.copy(source);
    this.bindMode = source.bindMode;
    this.bindMatrix.copy(source.bindMatrix);
    this.bindMatrixInverse.copy(source.bindMatrixInverse);
    this.skeleton = source.skeleton;
    return this;
  }
  bind(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === void 0) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.copy(bindMatrix).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const vector = new Vector4();
    const skinWeight = this.geometry.attributes.skinWeight;
    for (let i2 = 0, l2 = skinWeight.count; i2 < l2; i2++) {
      vector.x = skinWeight.getX(i2);
      vector.y = skinWeight.getY(i2);
      vector.z = skinWeight.getZ(i2);
      vector.w = skinWeight.getW(i2);
      const scale = 1 / vector.manhattanLength();
      if (scale !== Infinity) {
        vector.multiplyScalar(scale);
      } else {
        vector.set(1, 0, 0, 0);
      }
      skinWeight.setXYZW(i2, vector.x, vector.y, vector.z, vector.w);
    }
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.bindMode === "attached") {
      this.bindMatrixInverse.copy(this.matrixWorld).invert();
    } else if (this.bindMode === "detached") {
      this.bindMatrixInverse.copy(this.bindMatrix).invert();
    } else {
      console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
  }
  boneTransform(index, target) {
    const skeleton = this.skeleton;
    const geometry = this.geometry;
    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
    _basePosition.copy(target).applyMatrix4(this.bindMatrix);
    target.set(0, 0, 0);
    for (let i2 = 0; i2 < 4; i2++) {
      const weight = _skinWeight.getComponent(i2);
      if (weight !== 0) {
        const boneIndex = _skinIndex.getComponent(i2);
        _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
        target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
      }
    }
    return target.applyMatrix4(this.bindMatrixInverse);
  }
}
SkinnedMesh.prototype.isSkinnedMesh = true;
class Bone extends Object3D {
  constructor() {
    super();
    this.type = "Bone";
  }
}
Bone.prototype.isBone = true;
class DataTexture extends Texture {
  constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = { data, width, height };
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
}
DataTexture.prototype.isDataTexture = true;
const _offsetMatrix = /* @__PURE__ */ new Matrix4();
const _identityMatrix = /* @__PURE__ */ new Matrix4();
class Skeleton {
  constructor(bones = [], boneInverses = []) {
    this.uuid = generateUUID();
    this.bones = bones.slice(0);
    this.boneInverses = boneInverses;
    this.boneMatrices = null;
    this.boneTexture = null;
    this.boneTextureSize = 0;
    this.frame = -1;
    this.init();
  }
  init() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    this.boneMatrices = new Float32Array(bones.length * 16);
    if (boneInverses.length === 0) {
      this.calculateInverses();
    } else {
      if (bones.length !== boneInverses.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
        this.boneInverses = [];
        for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
          this.boneInverses.push(new Matrix4());
        }
      }
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const inverse = new Matrix4();
      if (this.bones[i2]) {
        inverse.copy(this.bones[i2].matrixWorld).invert();
      }
      this.boneInverses.push(inverse);
    }
  }
  pose() {
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const bone = this.bones[i2];
      if (bone) {
        bone.matrixWorld.copy(this.boneInverses[i2]).invert();
      }
    }
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const bone = this.bones[i2];
      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.copy(bone.parent.matrixWorld).invert();
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  }
  update() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    const boneMatrices = this.boneMatrices;
    const boneTexture = this.boneTexture;
    for (let i2 = 0, il = bones.length; i2 < il; i2++) {
      const matrix = bones[i2] ? bones[i2].matrixWorld : _identityMatrix;
      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i2]);
      _offsetMatrix.toArray(boneMatrices, i2 * 16);
    }
    if (boneTexture !== null) {
      boneTexture.needsUpdate = true;
    }
  }
  clone() {
    return new Skeleton(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let size = Math.sqrt(this.bones.length * 4);
    size = ceilPowerOfTwo(size);
    size = Math.max(size, 4);
    const boneMatrices = new Float32Array(size * size * 4);
    boneMatrices.set(this.boneMatrices);
    const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
    boneTexture.needsUpdate = true;
    this.boneMatrices = boneMatrices;
    this.boneTexture = boneTexture;
    this.boneTextureSize = size;
    return this;
  }
  getBoneByName(name) {
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const bone = this.bones[i2];
      if (bone.name === name) {
        return bone;
      }
    }
    return void 0;
  }
  dispose() {
    if (this.boneTexture !== null) {
      this.boneTexture.dispose();
      this.boneTexture = null;
    }
  }
  fromJSON(json, bones) {
    this.uuid = json.uuid;
    for (let i2 = 0, l2 = json.bones.length; i2 < l2; i2++) {
      const uuid = json.bones[i2];
      let bone = bones[uuid];
      if (bone === void 0) {
        console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
        bone = new Bone();
      }
      this.bones.push(bone);
      this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i2]));
    }
    this.init();
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    data.uuid = this.uuid;
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    for (let i2 = 0, l2 = bones.length; i2 < l2; i2++) {
      const bone = bones[i2];
      data.bones.push(bone.uuid);
      const boneInverse = boneInverses[i2];
      data.boneInverses.push(boneInverse.toArray());
    }
    return data;
  }
}
class InstancedBufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized, meshPerAttribute = 1) {
    if (typeof normalized === "number") {
      meshPerAttribute = normalized;
      normalized = false;
      console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
    }
    super(array, itemSize, normalized);
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.meshPerAttribute = this.meshPerAttribute;
    data.isInstancedBufferAttribute = true;
    return data;
  }
}
InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;
const _instanceLocalMatrix = /* @__PURE__ */ new Matrix4();
const _instanceWorldMatrix = /* @__PURE__ */ new Matrix4();
const _instanceIntersects = [];
const _mesh = /* @__PURE__ */ new Mesh();
class InstancedMesh extends Mesh {
  constructor(geometry, material, count) {
    super(geometry, material);
    this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
    this.instanceColor = null;
    this.count = count;
    this.frustumCulled = false;
  }
  copy(source) {
    super.copy(source);
    this.instanceMatrix.copy(source.instanceMatrix);
    if (source.instanceColor !== null)
      this.instanceColor = source.instanceColor.clone();
    this.count = source.count;
    return this;
  }
  getColorAt(index, color) {
    color.fromArray(this.instanceColor.array, index * 3);
  }
  getMatrixAt(index, matrix) {
    matrix.fromArray(this.instanceMatrix.array, index * 16);
  }
  raycast(raycaster, intersects2) {
    const matrixWorld = this.matrixWorld;
    const raycastTimes = this.count;
    _mesh.geometry = this.geometry;
    _mesh.material = this.material;
    if (_mesh.material === void 0)
      return;
    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
      this.getMatrixAt(instanceId, _instanceLocalMatrix);
      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
      _mesh.matrixWorld = _instanceWorldMatrix;
      _mesh.raycast(raycaster, _instanceIntersects);
      for (let i2 = 0, l2 = _instanceIntersects.length; i2 < l2; i2++) {
        const intersect = _instanceIntersects[i2];
        intersect.instanceId = instanceId;
        intersect.object = this;
        intersects2.push(intersect);
      }
      _instanceIntersects.length = 0;
    }
  }
  setColorAt(index, color) {
    if (this.instanceColor === null) {
      this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
    }
    color.toArray(this.instanceColor.array, index * 3);
  }
  setMatrixAt(index, matrix) {
    matrix.toArray(this.instanceMatrix.array, index * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
InstancedMesh.prototype.isInstancedMesh = true;
class LineBasicMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "LineBasicMaterial";
    this.color = new Color(16777215);
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    return this;
  }
}
LineBasicMaterial.prototype.isLineBasicMaterial = true;
const _start$1 = /* @__PURE__ */ new Vector3();
const _end$1 = /* @__PURE__ */ new Vector3();
const _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();
const _ray$1 = /* @__PURE__ */ new Ray();
const _sphere$1 = /* @__PURE__ */ new Sphere();
class Line extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
    super();
    this.type = "Line";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source) {
    super.copy(source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [0];
        for (let i2 = 1, l2 = positionAttribute.count; i2 < l2; i2++) {
          _start$1.fromBufferAttribute(positionAttribute, i2 - 1);
          _end$1.fromBufferAttribute(positionAttribute, i2);
          lineDistances[i2] = lineDistances[i2 - 1];
          lineDistances[i2] += _start$1.distanceTo(_end$1);
        }
        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    return this;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Line.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$1.copy(geometry.boundingSphere);
    _sphere$1.applyMatrix4(matrixWorld);
    _sphere$1.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$1) === false)
      return;
    _inverseMatrix$1.copy(matrixWorld).invert();
    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const vStart = new Vector3();
    const vEnd = new Vector3();
    const interSegment = new Vector3();
    const interRay = new Vector3();
    const step = this.isLineSegments ? 2 : 1;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index !== null) {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);
        for (let i2 = start, l2 = end - 1; i2 < l2; i2 += step) {
          const a2 = index.getX(i2);
          const b2 = index.getX(i2 + 1);
          vStart.fromBufferAttribute(positionAttribute, a2);
          vEnd.fromBufferAttribute(positionAttribute, b2);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far)
            continue;
          intersects2.push({
            distance,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i2,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
        for (let i2 = start, l2 = end - 1; i2 < l2; i2 += step) {
          vStart.fromBufferAttribute(positionAttribute, i2);
          vEnd.fromBufferAttribute(positionAttribute, i2 + 1);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far)
            continue;
          intersects2.push({
            distance,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i2,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
            const name = morphAttribute[m2].name || String(m2);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m2;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
}
Line.prototype.isLine = true;
const _start = /* @__PURE__ */ new Vector3();
const _end = /* @__PURE__ */ new Vector3();
class LineSegments extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.type = "LineSegments";
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [];
        for (let i2 = 0, l2 = positionAttribute.count; i2 < l2; i2 += 2) {
          _start.fromBufferAttribute(positionAttribute, i2);
          _end.fromBufferAttribute(positionAttribute, i2 + 1);
          lineDistances[i2] = i2 === 0 ? 0 : lineDistances[i2 - 1];
          lineDistances[i2 + 1] = lineDistances[i2] + _start.distanceTo(_end);
        }
        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    return this;
  }
}
LineSegments.prototype.isLineSegments = true;
class LineLoop extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.type = "LineLoop";
  }
}
LineLoop.prototype.isLineLoop = true;
class PointsMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "PointsMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    return this;
  }
}
PointsMaterial.prototype.isPointsMaterial = true;
const _inverseMatrix = /* @__PURE__ */ new Matrix4();
const _ray = /* @__PURE__ */ new Ray();
const _sphere = /* @__PURE__ */ new Sphere();
const _position$2 = /* @__PURE__ */ new Vector3();
class Points extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
    super();
    this.type = "Points";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source) {
    super.copy(source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Points.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere.copy(geometry.boundingSphere);
    _sphere.applyMatrix4(matrixWorld);
    _sphere.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere) === false)
      return;
    _inverseMatrix.copy(matrixWorld).invert();
    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index !== null) {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);
        for (let i2 = start, il = end; i2 < il; i2++) {
          const a2 = index.getX(i2);
          _position$2.fromBufferAttribute(positionAttribute, a2);
          testPoint(_position$2, a2, localThresholdSq, matrixWorld, raycaster, intersects2, this);
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
        for (let i2 = start, l2 = end; i2 < l2; i2++) {
          _position$2.fromBufferAttribute(positionAttribute, i2);
          testPoint(_position$2, i2, localThresholdSq, matrixWorld, raycaster, intersects2, this);
        }
      }
    } else {
      console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
            const name = morphAttribute[m2].name || String(m2);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m2;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
}
Points.prototype.isPoints = true;
function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects2, object) {
  const rayPointDistanceSq = _ray.distanceSqToPoint(point);
  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3();
    _ray.closestPointToPoint(point, intersectPoint);
    intersectPoint.applyMatrix4(matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far)
      return;
    intersects2.push({
      distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index,
      face: null,
      object
    });
  }
}
class VideoTexture extends Texture {
  constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
    this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
    this.generateMipmaps = false;
    const scope = this;
    function updateVideo() {
      scope.needsUpdate = true;
      video.requestVideoFrameCallback(updateVideo);
    }
    if ("requestVideoFrameCallback" in video) {
      video.requestVideoFrameCallback(updateVideo);
    }
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const video = this.image;
    const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
    if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
      this.needsUpdate = true;
    }
  }
}
VideoTexture.prototype.isVideoTexture = true;
class FramebufferTexture extends Texture {
  constructor(width, height, format) {
    super({ width, height });
    this.format = format;
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.generateMipmaps = false;
    this.needsUpdate = true;
  }
}
FramebufferTexture.prototype.isFramebufferTexture = true;
class CompressedTexture extends Texture {
  constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = { width, height };
    this.mipmaps = mipmaps;
    this.flipY = false;
    this.generateMipmaps = false;
  }
}
CompressedTexture.prototype.isCompressedTexture = true;
class CanvasTexture extends Texture {
  constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.needsUpdate = true;
  }
}
CanvasTexture.prototype.isCanvasTexture = true;
class CircleGeometry extends BufferGeometry {
  constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CircleGeometry";
    this.parameters = {
      radius,
      segments,
      thetaStart,
      thetaLength
    };
    segments = Math.max(3, segments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const vertex2 = new Vector3();
    const uv = new Vector2();
    vertices.push(0, 0, 0);
    normals.push(0, 0, 1);
    uvs.push(0.5, 0.5);
    for (let s2 = 0, i2 = 3; s2 <= segments; s2++, i2 += 3) {
      const segment = thetaStart + s2 / segments * thetaLength;
      vertex2.x = radius * Math.cos(segment);
      vertex2.y = radius * Math.sin(segment);
      vertices.push(vertex2.x, vertex2.y, vertex2.z);
      normals.push(0, 0, 1);
      uv.x = (vertices[i2] / radius + 1) / 2;
      uv.y = (vertices[i2 + 1] / radius + 1) / 2;
      uvs.push(uv.x, uv.y);
    }
    for (let i2 = 1; i2 <= segments; i2++) {
      indices.push(i2, i2 + 1, 0);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
  }
}
class CylinderGeometry extends BufferGeometry {
  constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CylinderGeometry";
    this.parameters = {
      radiusTop,
      radiusBottom,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
    const scope = this;
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let index = 0;
    const indexArray = [];
    const halfHeight = height / 2;
    let groupStart = 0;
    generateTorso();
    if (openEnded === false) {
      if (radiusTop > 0)
        generateCap(true);
      if (radiusBottom > 0)
        generateCap(false);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateTorso() {
      const normal = new Vector3();
      const vertex2 = new Vector3();
      let groupCount = 0;
      const slope = (radiusBottom - radiusTop) / height;
      for (let y2 = 0; y2 <= heightSegments; y2++) {
        const indexRow = [];
        const v2 = y2 / heightSegments;
        const radius = v2 * (radiusBottom - radiusTop) + radiusTop;
        for (let x2 = 0; x2 <= radialSegments; x2++) {
          const u2 = x2 / radialSegments;
          const theta = u2 * thetaLength + thetaStart;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta);
          vertex2.x = radius * sinTheta;
          vertex2.y = -v2 * height + halfHeight;
          vertex2.z = radius * cosTheta;
          vertices.push(vertex2.x, vertex2.y, vertex2.z);
          normal.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(u2, 1 - v2);
          indexRow.push(index++);
        }
        indexArray.push(indexRow);
      }
      for (let x2 = 0; x2 < radialSegments; x2++) {
        for (let y2 = 0; y2 < heightSegments; y2++) {
          const a2 = indexArray[y2][x2];
          const b2 = indexArray[y2 + 1][x2];
          const c2 = indexArray[y2 + 1][x2 + 1];
          const d2 = indexArray[y2][x2 + 1];
          indices.push(a2, b2, d2);
          indices.push(b2, c2, d2);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, 0);
      groupStart += groupCount;
    }
    function generateCap(top) {
      const centerIndexStart = index;
      const uv = new Vector2();
      const vertex2 = new Vector3();
      let groupCount = 0;
      const radius = top === true ? radiusTop : radiusBottom;
      const sign2 = top === true ? 1 : -1;
      for (let x2 = 1; x2 <= radialSegments; x2++) {
        vertices.push(0, halfHeight * sign2, 0);
        normals.push(0, sign2, 0);
        uvs.push(0.5, 0.5);
        index++;
      }
      const centerIndexEnd = index;
      for (let x2 = 0; x2 <= radialSegments; x2++) {
        const u2 = x2 / radialSegments;
        const theta = u2 * thetaLength + thetaStart;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);
        vertex2.x = radius * sinTheta;
        vertex2.y = halfHeight * sign2;
        vertex2.z = radius * cosTheta;
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normals.push(0, sign2, 0);
        uv.x = cosTheta * 0.5 + 0.5;
        uv.y = sinTheta * 0.5 * sign2 + 0.5;
        uvs.push(uv.x, uv.y);
        index++;
      }
      for (let x2 = 0; x2 < radialSegments; x2++) {
        const c2 = centerIndexStart + x2;
        const i2 = centerIndexEnd + x2;
        if (top === true) {
          indices.push(i2, i2 + 1, c2);
        } else {
          indices.push(i2 + 1, i2, c2);
        }
        groupCount += 3;
      }
      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
      groupStart += groupCount;
    }
  }
  static fromJSON(data) {
    return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
  }
}
class ConeGeometry extends CylinderGeometry {
  constructor(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = "ConeGeometry";
    this.parameters = {
      radius,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
  }
  static fromJSON(data) {
    return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
  }
}
class PolyhedronGeometry extends BufferGeometry {
  constructor(vertices = [], indices = [], radius = 1, detail = 0) {
    super();
    this.type = "PolyhedronGeometry";
    this.parameters = {
      vertices,
      indices,
      radius,
      detail
    };
    const vertexBuffer = [];
    const uvBuffer = [];
    subdivide(detail);
    applyRadius(radius);
    generateUVs();
    this.setAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
    this.setAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
    if (detail === 0) {
      this.computeVertexNormals();
    } else {
      this.normalizeNormals();
    }
    function subdivide(detail2) {
      const a2 = new Vector3();
      const b2 = new Vector3();
      const c2 = new Vector3();
      for (let i2 = 0; i2 < indices.length; i2 += 3) {
        getVertexByIndex(indices[i2 + 0], a2);
        getVertexByIndex(indices[i2 + 1], b2);
        getVertexByIndex(indices[i2 + 2], c2);
        subdivideFace(a2, b2, c2, detail2);
      }
    }
    function subdivideFace(a2, b2, c2, detail2) {
      const cols = detail2 + 1;
      const v2 = [];
      for (let i2 = 0; i2 <= cols; i2++) {
        v2[i2] = [];
        const aj = a2.clone().lerp(c2, i2 / cols);
        const bj = b2.clone().lerp(c2, i2 / cols);
        const rows = cols - i2;
        for (let j2 = 0; j2 <= rows; j2++) {
          if (j2 === 0 && i2 === cols) {
            v2[i2][j2] = aj;
          } else {
            v2[i2][j2] = aj.clone().lerp(bj, j2 / rows);
          }
        }
      }
      for (let i2 = 0; i2 < cols; i2++) {
        for (let j2 = 0; j2 < 2 * (cols - i2) - 1; j2++) {
          const k2 = Math.floor(j2 / 2);
          if (j2 % 2 === 0) {
            pushVertex(v2[i2][k2 + 1]);
            pushVertex(v2[i2 + 1][k2]);
            pushVertex(v2[i2][k2]);
          } else {
            pushVertex(v2[i2][k2 + 1]);
            pushVertex(v2[i2 + 1][k2 + 1]);
            pushVertex(v2[i2 + 1][k2]);
          }
        }
      }
    }
    function applyRadius(radius2) {
      const vertex2 = new Vector3();
      for (let i2 = 0; i2 < vertexBuffer.length; i2 += 3) {
        vertex2.x = vertexBuffer[i2 + 0];
        vertex2.y = vertexBuffer[i2 + 1];
        vertex2.z = vertexBuffer[i2 + 2];
        vertex2.normalize().multiplyScalar(radius2);
        vertexBuffer[i2 + 0] = vertex2.x;
        vertexBuffer[i2 + 1] = vertex2.y;
        vertexBuffer[i2 + 2] = vertex2.z;
      }
    }
    function generateUVs() {
      const vertex2 = new Vector3();
      for (let i2 = 0; i2 < vertexBuffer.length; i2 += 3) {
        vertex2.x = vertexBuffer[i2 + 0];
        vertex2.y = vertexBuffer[i2 + 1];
        vertex2.z = vertexBuffer[i2 + 2];
        const u2 = azimuth(vertex2) / 2 / Math.PI + 0.5;
        const v2 = inclination(vertex2) / Math.PI + 0.5;
        uvBuffer.push(u2, 1 - v2);
      }
      correctUVs();
      correctSeam();
    }
    function correctSeam() {
      for (let i2 = 0; i2 < uvBuffer.length; i2 += 6) {
        const x0 = uvBuffer[i2 + 0];
        const x1 = uvBuffer[i2 + 2];
        const x2 = uvBuffer[i2 + 4];
        const max = Math.max(x0, x1, x2);
        const min = Math.min(x0, x1, x2);
        if (max > 0.9 && min < 0.1) {
          if (x0 < 0.2)
            uvBuffer[i2 + 0] += 1;
          if (x1 < 0.2)
            uvBuffer[i2 + 2] += 1;
          if (x2 < 0.2)
            uvBuffer[i2 + 4] += 1;
        }
      }
    }
    function pushVertex(vertex2) {
      vertexBuffer.push(vertex2.x, vertex2.y, vertex2.z);
    }
    function getVertexByIndex(index, vertex2) {
      const stride = index * 3;
      vertex2.x = vertices[stride + 0];
      vertex2.y = vertices[stride + 1];
      vertex2.z = vertices[stride + 2];
    }
    function correctUVs() {
      const a2 = new Vector3();
      const b2 = new Vector3();
      const c2 = new Vector3();
      const centroid = new Vector3();
      const uvA = new Vector2();
      const uvB = new Vector2();
      const uvC = new Vector2();
      for (let i2 = 0, j2 = 0; i2 < vertexBuffer.length; i2 += 9, j2 += 6) {
        a2.set(vertexBuffer[i2 + 0], vertexBuffer[i2 + 1], vertexBuffer[i2 + 2]);
        b2.set(vertexBuffer[i2 + 3], vertexBuffer[i2 + 4], vertexBuffer[i2 + 5]);
        c2.set(vertexBuffer[i2 + 6], vertexBuffer[i2 + 7], vertexBuffer[i2 + 8]);
        uvA.set(uvBuffer[j2 + 0], uvBuffer[j2 + 1]);
        uvB.set(uvBuffer[j2 + 2], uvBuffer[j2 + 3]);
        uvC.set(uvBuffer[j2 + 4], uvBuffer[j2 + 5]);
        centroid.copy(a2).add(b2).add(c2).divideScalar(3);
        const azi = azimuth(centroid);
        correctUV(uvA, j2 + 0, a2, azi);
        correctUV(uvB, j2 + 2, b2, azi);
        correctUV(uvC, j2 + 4, c2, azi);
      }
    }
    function correctUV(uv, stride, vector, azimuth2) {
      if (azimuth2 < 0 && uv.x === 1) {
        uvBuffer[stride] = uv.x - 1;
      }
      if (vector.x === 0 && vector.z === 0) {
        uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
      }
    }
    function azimuth(vector) {
      return Math.atan2(vector.z, -vector.x);
    }
    function inclination(vector) {
      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
    }
  }
  static fromJSON(data) {
    return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
  }
}
class DodecahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t2 = (1 + Math.sqrt(5)) / 2;
    const r2 = 1 / t2;
    const vertices = [
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      0,
      -r2,
      -t2,
      0,
      -r2,
      t2,
      0,
      r2,
      -t2,
      0,
      r2,
      t2,
      -r2,
      -t2,
      0,
      -r2,
      t2,
      0,
      r2,
      -t2,
      0,
      r2,
      t2,
      0,
      -t2,
      0,
      -r2,
      t2,
      0,
      -r2,
      -t2,
      0,
      r2,
      t2,
      0,
      r2
    ];
    const indices = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(vertices, indices, radius, detail);
    this.type = "DodecahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new DodecahedronGeometry(data.radius, data.detail);
  }
}
const _v0 = new Vector3();
const _v1$1 = new Vector3();
const _normal = new Vector3();
const _triangle = new Triangle();
class EdgesGeometry extends BufferGeometry {
  constructor(geometry = null, thresholdAngle = 1) {
    super();
    this.type = "EdgesGeometry";
    this.parameters = {
      geometry,
      thresholdAngle
    };
    if (geometry !== null) {
      const precisionPoints = 4;
      const precision = Math.pow(10, precisionPoints);
      const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
      const indexAttr = geometry.getIndex();
      const positionAttr = geometry.getAttribute("position");
      const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
      const indexArr = [0, 0, 0];
      const vertKeys = ["a", "b", "c"];
      const hashes = new Array(3);
      const edgeData = {};
      const vertices = [];
      for (let i2 = 0; i2 < indexCount; i2 += 3) {
        if (indexAttr) {
          indexArr[0] = indexAttr.getX(i2);
          indexArr[1] = indexAttr.getX(i2 + 1);
          indexArr[2] = indexAttr.getX(i2 + 2);
        } else {
          indexArr[0] = i2;
          indexArr[1] = i2 + 1;
          indexArr[2] = i2 + 2;
        }
        const { a: a2, b: b2, c: c2 } = _triangle;
        a2.fromBufferAttribute(positionAttr, indexArr[0]);
        b2.fromBufferAttribute(positionAttr, indexArr[1]);
        c2.fromBufferAttribute(positionAttr, indexArr[2]);
        _triangle.getNormal(_normal);
        hashes[0] = `${Math.round(a2.x * precision)},${Math.round(a2.y * precision)},${Math.round(a2.z * precision)}`;
        hashes[1] = `${Math.round(b2.x * precision)},${Math.round(b2.y * precision)},${Math.round(b2.z * precision)}`;
        hashes[2] = `${Math.round(c2.x * precision)},${Math.round(c2.y * precision)},${Math.round(c2.z * precision)}`;
        if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
          continue;
        }
        for (let j2 = 0; j2 < 3; j2++) {
          const jNext = (j2 + 1) % 3;
          const vecHash0 = hashes[j2];
          const vecHash1 = hashes[jNext];
          const v0 = _triangle[vertKeys[j2]];
          const v1 = _triangle[vertKeys[jNext]];
          const hash = `${vecHash0}_${vecHash1}`;
          const reverseHash = `${vecHash1}_${vecHash0}`;
          if (reverseHash in edgeData && edgeData[reverseHash]) {
            if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
              vertices.push(v0.x, v0.y, v0.z);
              vertices.push(v1.x, v1.y, v1.z);
            }
            edgeData[reverseHash] = null;
          } else if (!(hash in edgeData)) {
            edgeData[hash] = {
              index0: indexArr[j2],
              index1: indexArr[jNext],
              normal: _normal.clone()
            };
          }
        }
      }
      for (const key in edgeData) {
        if (edgeData[key]) {
          const { index0, index1 } = edgeData[key];
          _v0.fromBufferAttribute(positionAttr, index0);
          _v1$1.fromBufferAttribute(positionAttr, index1);
          vertices.push(_v0.x, _v0.y, _v0.z);
          vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
        }
      }
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    }
  }
}
class Curve {
  constructor() {
    this.type = "Curve";
    this.arcLengthDivisions = 200;
  }
  getPoint() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  }
  getPointAt(u2, optionalTarget) {
    const t2 = this.getUtoTmapping(u2);
    return this.getPoint(t2, optionalTarget);
  }
  getPoints(divisions = 5) {
    const points = [];
    for (let d2 = 0; d2 <= divisions; d2++) {
      points.push(this.getPoint(d2 / divisions));
    }
    return points;
  }
  getSpacedPoints(divisions = 5) {
    const points = [];
    for (let d2 = 0; d2 <= divisions; d2++) {
      points.push(this.getPointAt(d2 / divisions));
    }
    return points;
  }
  getLength() {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  }
  getLengths(divisions = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = false;
    const cache = [];
    let current, last = this.getPoint(0);
    let sum = 0;
    cache.push(0);
    for (let p2 = 1; p2 <= divisions; p2++) {
      current = this.getPoint(p2 / divisions);
      sum += current.distanceTo(last);
      cache.push(sum);
      last = current;
    }
    this.cacheArcLengths = cache;
    return cache;
  }
  updateArcLengths() {
    this.needsUpdate = true;
    this.getLengths();
  }
  getUtoTmapping(u2, distance) {
    const arcLengths = this.getLengths();
    let i2 = 0;
    const il = arcLengths.length;
    let targetArcLength;
    if (distance) {
      targetArcLength = distance;
    } else {
      targetArcLength = u2 * arcLengths[il - 1];
    }
    let low = 0, high = il - 1, comparison;
    while (low <= high) {
      i2 = Math.floor(low + (high - low) / 2);
      comparison = arcLengths[i2] - targetArcLength;
      if (comparison < 0) {
        low = i2 + 1;
      } else if (comparison > 0) {
        high = i2 - 1;
      } else {
        high = i2;
        break;
      }
    }
    i2 = high;
    if (arcLengths[i2] === targetArcLength) {
      return i2 / (il - 1);
    }
    const lengthBefore = arcLengths[i2];
    const lengthAfter = arcLengths[i2 + 1];
    const segmentLength = lengthAfter - lengthBefore;
    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
    const t2 = (i2 + segmentFraction) / (il - 1);
    return t2;
  }
  getTangent(t2, optionalTarget) {
    const delta = 1e-4;
    let t1 = t2 - delta;
    let t22 = t2 + delta;
    if (t1 < 0)
      t1 = 0;
    if (t22 > 1)
      t22 = 1;
    const pt1 = this.getPoint(t1);
    const pt2 = this.getPoint(t22);
    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  }
  getTangentAt(u2, optionalTarget) {
    const t2 = this.getUtoTmapping(u2);
    return this.getTangent(t2, optionalTarget);
  }
  computeFrenetFrames(segments, closed) {
    const normal = new Vector3();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new Vector3();
    const mat = new Matrix4();
    for (let i2 = 0; i2 <= segments; i2++) {
      const u2 = i2 / segments;
      tangents[i2] = this.getTangentAt(u2, new Vector3());
    }
    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    let min = Number.MAX_VALUE;
    const tx = Math.abs(tangents[0].x);
    const ty = Math.abs(tangents[0].y);
    const tz = Math.abs(tangents[0].z);
    if (tx <= min) {
      min = tx;
      normal.set(1, 0, 0);
    }
    if (ty <= min) {
      min = ty;
      normal.set(0, 1, 0);
    }
    if (tz <= min) {
      normal.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
    for (let i2 = 1; i2 <= segments; i2++) {
      normals[i2] = normals[i2 - 1].clone();
      binormals[i2] = binormals[i2 - 1].clone();
      vec.crossVectors(tangents[i2 - 1], tangents[i2]);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(clamp(tangents[i2 - 1].dot(tangents[i2]), -1, 1));
        normals[i2].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }
      binormals[i2].crossVectors(tangents[i2], normals[i2]);
    }
    if (closed === true) {
      let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;
      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }
      for (let i2 = 1; i2 <= segments; i2++) {
        normals[i2].applyMatrix4(mat.makeRotationAxis(tangents[i2], theta * i2));
        binormals[i2].crossVectors(tangents[i2], normals[i2]);
      }
    }
    return {
      tangents,
      normals,
      binormals
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  }
  fromJSON(json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }
}
class EllipseCurve extends Curve {
  constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
    super();
    this.type = "EllipseCurve";
    this.aX = aX;
    this.aY = aY;
    this.xRadius = xRadius;
    this.yRadius = yRadius;
    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;
    this.aClockwise = aClockwise;
    this.aRotation = aRotation;
  }
  getPoint(t2, optionalTarget) {
    const point = optionalTarget || new Vector2();
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    while (deltaAngle < 0)
      deltaAngle += twoPi;
    while (deltaAngle > twoPi)
      deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
      if (samePoints) {
        deltaAngle = 0;
      } else {
        deltaAngle = twoPi;
      }
    }
    if (this.aClockwise === true && !samePoints) {
      if (deltaAngle === twoPi) {
        deltaAngle = -twoPi;
      } else {
        deltaAngle = deltaAngle - twoPi;
      }
    }
    const angle = this.aStartAngle + t2 * deltaAngle;
    let x2 = this.aX + this.xRadius * Math.cos(angle);
    let y2 = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
      const cos = Math.cos(this.aRotation);
      const sin = Math.sin(this.aRotation);
      const tx = x2 - this.aX;
      const ty = y2 - this.aY;
      x2 = tx * cos - ty * sin + this.aX;
      y2 = tx * sin + ty * cos + this.aY;
    }
    return point.set(x2, y2);
  }
  copy(source) {
    super.copy(source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
  }
}
EllipseCurve.prototype.isEllipseCurve = true;
class ArcCurve extends EllipseCurve {
  constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.type = "ArcCurve";
  }
}
ArcCurve.prototype.isArcCurve = true;
function CubicPoly() {
  let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
  function init(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }
  return {
    initCatmullRom: function(x0, x1, x2, x3, tension) {
      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
      t1 *= dt1;
      t2 *= dt1;
      init(x1, x2, t1, t2);
    },
    calc: function(t2) {
      const t22 = t2 * t2;
      const t3 = t22 * t2;
      return c0 + c1 * t2 + c2 * t22 + c3 * t3;
    }
  };
}
const tmp = new Vector3();
const px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
class CatmullRomCurve3 extends Curve {
  constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
    super();
    this.type = "CatmullRomCurve3";
    this.points = points;
    this.closed = closed;
    this.curveType = curveType;
    this.tension = tension;
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const points = this.points;
    const l2 = points.length;
    const p2 = (l2 - (this.closed ? 0 : 1)) * t2;
    let intPoint = Math.floor(p2);
    let weight = p2 - intPoint;
    if (this.closed) {
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l2) + 1) * l2;
    } else if (weight === 0 && intPoint === l2 - 1) {
      intPoint = l2 - 2;
      weight = 1;
    }
    let p0, p3;
    if (this.closed || intPoint > 0) {
      p0 = points[(intPoint - 1) % l2];
    } else {
      tmp.subVectors(points[0], points[1]).add(points[0]);
      p0 = tmp;
    }
    const p1 = points[intPoint % l2];
    const p22 = points[(intPoint + 1) % l2];
    if (this.closed || intPoint + 2 < l2) {
      p3 = points[(intPoint + 2) % l2];
    } else {
      tmp.subVectors(points[l2 - 1], points[l2 - 2]).add(points[l2 - 1]);
      p3 = tmp;
    }
    if (this.curveType === "centripetal" || this.curveType === "chordal") {
      const pow = this.curveType === "chordal" ? 0.5 : 0.25;
      let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
      let dt1 = Math.pow(p1.distanceToSquared(p22), pow);
      let dt2 = Math.pow(p22.distanceToSquared(p3), pow);
      if (dt1 < 1e-4)
        dt1 = 1;
      if (dt0 < 1e-4)
        dt0 = dt1;
      if (dt2 < 1e-4)
        dt2 = dt1;
      px.initNonuniformCatmullRom(p0.x, p1.x, p22.x, p3.x, dt0, dt1, dt2);
      py.initNonuniformCatmullRom(p0.y, p1.y, p22.y, p3.y, dt0, dt1, dt2);
      pz.initNonuniformCatmullRom(p0.z, p1.z, p22.z, p3.z, dt0, dt1, dt2);
    } else if (this.curveType === "catmullrom") {
      px.initCatmullRom(p0.x, p1.x, p22.x, p3.x, this.tension);
      py.initCatmullRom(p0.y, p1.y, p22.y, p3.y, this.tension);
      pz.initCatmullRom(p0.z, p1.z, p22.z, p3.z, this.tension);
    }
    point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i2 = 0, l2 = source.points.length; i2 < l2; i2++) {
      const point = source.points[i2];
      this.points.push(point.clone());
    }
    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i2 = 0, l2 = this.points.length; i2 < l2; i2++) {
      const point = this.points[i2];
      data.points.push(point.toArray());
    }
    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i2 = 0, l2 = json.points.length; i2 < l2; i2++) {
      const point = json.points[i2];
      this.points.push(new Vector3().fromArray(point));
    }
    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
  }
}
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
function CatmullRom(t2, p0, p1, p2, p3) {
  const v0 = (p2 - p0) * 0.5;
  const v1 = (p3 - p1) * 0.5;
  const t22 = t2 * t2;
  const t3 = t2 * t22;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t22 + v0 * t2 + p1;
}
function QuadraticBezierP0(t2, p2) {
  const k2 = 1 - t2;
  return k2 * k2 * p2;
}
function QuadraticBezierP1(t2, p2) {
  return 2 * (1 - t2) * t2 * p2;
}
function QuadraticBezierP2(t2, p2) {
  return t2 * t2 * p2;
}
function QuadraticBezier(t2, p0, p1, p2) {
  return QuadraticBezierP0(t2, p0) + QuadraticBezierP1(t2, p1) + QuadraticBezierP2(t2, p2);
}
function CubicBezierP0(t2, p2) {
  const k2 = 1 - t2;
  return k2 * k2 * k2 * p2;
}
function CubicBezierP1(t2, p2) {
  const k2 = 1 - t2;
  return 3 * k2 * k2 * t2 * p2;
}
function CubicBezierP2(t2, p2) {
  return 3 * (1 - t2) * t2 * t2 * p2;
}
function CubicBezierP3(t2, p2) {
  return t2 * t2 * t2 * p2;
}
function CubicBezier(t2, p0, p1, p2, p3) {
  return CubicBezierP0(t2, p0) + CubicBezierP1(t2, p1) + CubicBezierP2(t2, p2) + CubicBezierP3(t2, p3);
}
class CubicBezierCurve extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
    super();
    this.type = "CubicBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t2, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(CubicBezier(t2, v0.x, v1.x, v2.x, v3.x), CubicBezier(t2, v0.y, v1.y, v2.y, v3.y));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
}
CubicBezierCurve.prototype.isCubicBezierCurve = true;
class CubicBezierCurve3 extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
    super();
    this.type = "CubicBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(CubicBezier(t2, v0.x, v1.x, v2.x, v3.x), CubicBezier(t2, v0.y, v1.y, v2.y, v3.y), CubicBezier(t2, v0.z, v1.z, v2.z, v3.z));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
}
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
class LineCurve extends Curve {
  constructor(v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.type = "LineCurve";
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t2, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    if (t2 === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t2).add(this.v1);
    }
    return point;
  }
  getPointAt(u2, optionalTarget) {
    return this.getPoint(u2, optionalTarget);
  }
  getTangent(t2, optionalTarget) {
    const tangent = optionalTarget || new Vector2();
    tangent.copy(this.v2).sub(this.v1).normalize();
    return tangent;
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
LineCurve.prototype.isLineCurve = true;
class LineCurve3 extends Curve {
  constructor(v1 = new Vector3(), v2 = new Vector3()) {
    super();
    this.type = "LineCurve3";
    this.isLineCurve3 = true;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    if (t2 === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t2).add(this.v1);
    }
    return point;
  }
  getPointAt(u2, optionalTarget) {
    return this.getPoint(u2, optionalTarget);
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
class QuadraticBezierCurve extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.type = "QuadraticBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t2, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(QuadraticBezier(t2, v0.x, v1.x, v2.x), QuadraticBezier(t2, v0.y, v1.y, v2.y));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
class QuadraticBezierCurve3 extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
    super();
    this.type = "QuadraticBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(QuadraticBezier(t2, v0.x, v1.x, v2.x), QuadraticBezier(t2, v0.y, v1.y, v2.y), QuadraticBezier(t2, v0.z, v1.z, v2.z));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
class SplineCurve extends Curve {
  constructor(points = []) {
    super();
    this.type = "SplineCurve";
    this.points = points;
  }
  getPoint(t2, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const points = this.points;
    const p2 = (points.length - 1) * t2;
    const intPoint = Math.floor(p2);
    const weight = p2 - intPoint;
    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    const p1 = points[intPoint];
    const p22 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point.set(CatmullRom(weight, p0.x, p1.x, p22.x, p3.x), CatmullRom(weight, p0.y, p1.y, p22.y, p3.y));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i2 = 0, l2 = source.points.length; i2 < l2; i2++) {
      const point = source.points[i2];
      this.points.push(point.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i2 = 0, l2 = this.points.length; i2 < l2; i2++) {
      const point = this.points[i2];
      data.points.push(point.toArray());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i2 = 0, l2 = json.points.length; i2 < l2; i2++) {
      const point = json.points[i2];
      this.points.push(new Vector2().fromArray(point));
    }
    return this;
  }
}
SplineCurve.prototype.isSplineCurve = true;
var Curves = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve
});
class CurvePath extends Curve {
  constructor() {
    super();
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = false;
  }
  add(curve) {
    this.curves.push(curve);
  }
  closePath() {
    const startPoint = this.curves[0].getPoint(0);
    const endPoint = this.curves[this.curves.length - 1].getPoint(1);
    if (!startPoint.equals(endPoint)) {
      this.curves.push(new LineCurve(endPoint, startPoint));
    }
  }
  getPoint(t2, optionalTarget) {
    const d2 = t2 * this.getLength();
    const curveLengths = this.getCurveLengths();
    let i2 = 0;
    while (i2 < curveLengths.length) {
      if (curveLengths[i2] >= d2) {
        const diff2 = curveLengths[i2] - d2;
        const curve = this.curves[i2];
        const segmentLength = curve.getLength();
        const u2 = segmentLength === 0 ? 0 : 1 - diff2 / segmentLength;
        return curve.getPointAt(u2, optionalTarget);
      }
      i2++;
    }
    return null;
  }
  getLength() {
    const lens = this.getCurveLengths();
    return lens[lens.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    }
    const lengths = [];
    let sums = 0;
    for (let i2 = 0, l2 = this.curves.length; i2 < l2; i2++) {
      sums += this.curves[i2].getLength();
      lengths.push(sums);
    }
    this.cacheLengths = lengths;
    return lengths;
  }
  getSpacedPoints(divisions = 40) {
    const points = [];
    for (let i2 = 0; i2 <= divisions; i2++) {
      points.push(this.getPoint(i2 / divisions));
    }
    if (this.autoClose) {
      points.push(points[0]);
    }
    return points;
  }
  getPoints(divisions = 12) {
    const points = [];
    let last;
    for (let i2 = 0, curves = this.curves; i2 < curves.length; i2++) {
      const curve = curves[i2];
      const resolution = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;
      const pts = curve.getPoints(resolution);
      for (let j2 = 0; j2 < pts.length; j2++) {
        const point = pts[j2];
        if (last && last.equals(point))
          continue;
        points.push(point);
        last = point;
      }
    }
    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }
    return points;
  }
  copy(source) {
    super.copy(source);
    this.curves = [];
    for (let i2 = 0, l2 = source.curves.length; i2 < l2; i2++) {
      const curve = source.curves[i2];
      this.curves.push(curve.clone());
    }
    this.autoClose = source.autoClose;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.autoClose = this.autoClose;
    data.curves = [];
    for (let i2 = 0, l2 = this.curves.length; i2 < l2; i2++) {
      const curve = this.curves[i2];
      data.curves.push(curve.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.autoClose = json.autoClose;
    this.curves = [];
    for (let i2 = 0, l2 = json.curves.length; i2 < l2; i2++) {
      const curve = json.curves[i2];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }
    return this;
  }
}
class Path extends CurvePath {
  constructor(points) {
    super();
    this.type = "Path";
    this.currentPoint = new Vector2();
    if (points) {
      this.setFromPoints(points);
    }
  }
  setFromPoints(points) {
    this.moveTo(points[0].x, points[0].y);
    for (let i2 = 1, l2 = points.length; i2 < l2; i2++) {
      this.lineTo(points[i2].x, points[i2].y);
    }
    return this;
  }
  moveTo(x2, y2) {
    this.currentPoint.set(x2, y2);
    return this;
  }
  lineTo(x2, y2) {
    const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x2, y2));
    this.curves.push(curve);
    this.currentPoint.set(x2, y2);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  splineThru(pts) {
    const npts = [this.currentPoint.clone()].concat(pts);
    const curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
    return this;
  }
  arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    return this;
  }
  absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    if (this.curves.length > 0) {
      const firstPoint = curve.getPoint(0);
      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }
    this.curves.push(curve);
    const lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
    return this;
  }
  copy(source) {
    super.copy(source);
    this.currentPoint.copy(source.currentPoint);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.currentPoint = this.currentPoint.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.currentPoint.fromArray(json.currentPoint);
    return this;
  }
}
class Shape extends Path {
  constructor(points) {
    super(points);
    this.uuid = generateUUID();
    this.type = "Shape";
    this.holes = [];
  }
  getPointsHoles(divisions) {
    const holesPts = [];
    for (let i2 = 0, l2 = this.holes.length; i2 < l2; i2++) {
      holesPts[i2] = this.holes[i2].getPoints(divisions);
    }
    return holesPts;
  }
  extractPoints(divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  }
  copy(source) {
    super.copy(source);
    this.holes = [];
    for (let i2 = 0, l2 = source.holes.length; i2 < l2; i2++) {
      const hole = source.holes[i2];
      this.holes.push(hole.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.uuid = this.uuid;
    data.holes = [];
    for (let i2 = 0, l2 = this.holes.length; i2 < l2; i2++) {
      const hole = this.holes[i2];
      data.holes.push(hole.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.uuid = json.uuid;
    this.holes = [];
    for (let i2 = 0, l2 = json.holes.length; i2 < l2; i2++) {
      const hole = json.holes[i2];
      this.holes.push(new Path().fromJSON(hole));
    }
    return this;
  }
}
const Earcut = {
  triangulate: function(data, holeIndices, dim = 2) {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev)
      return triangles;
    let minX, minY, maxX, maxY, x2, y2, invSize;
    if (hasHoles)
      outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (let i2 = dim; i2 < outerLen; i2 += dim) {
        x2 = data[i2];
        y2 = data[i2 + 1];
        if (x2 < minX)
          minX = x2;
        if (y2 < minY)
          minY = y2;
        if (x2 > maxX)
          maxX = x2;
        if (y2 > maxY)
          maxY = y2;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 1 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
  }
};
function linkedList(data, start, end, dim, clockwise) {
  let i2, last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i2 = start; i2 < end; i2 += dim)
      last = insertNode(i2, data[i2], data[i2 + 1], last);
  } else {
    for (i2 = end - dim; i2 >= start; i2 -= dim)
      last = insertNode(i2, data[i2], data[i2 + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start)
    return start;
  if (!end)
    end = start;
  let p2 = start, again;
  do {
    again = false;
    if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
      removeNode(p2);
      p2 = end = p2.prev;
      if (p2 === p2.next)
        break;
      again = true;
    } else {
      p2 = p2.next;
    }
  } while (again || p2 !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  let stop = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a2 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a2, b2, c2) >= 0)
    return false;
  let p2 = ear.next.next;
  while (p2 !== ear.prev) {
    if (pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a2 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a2, b2, c2) >= 0)
    return false;
  const minTX = a2.x < b2.x ? a2.x < c2.x ? a2.x : c2.x : b2.x < c2.x ? b2.x : c2.x, minTY = a2.y < b2.y ? a2.y < c2.y ? a2.y : c2.y : b2.y < c2.y ? b2.y : c2.y, maxTX = a2.x > b2.x ? a2.x > c2.x ? a2.x : c2.x : b2.x > c2.x ? b2.x : c2.x, maxTY = a2.y > b2.y ? a2.y > c2.y ? a2.y : c2.y : b2.y > c2.y ? b2.y : c2.y;
  const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  let p2 = ear.prevZ, n2 = ear.nextZ;
  while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
    if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.prevZ;
    if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
      return false;
    n2 = n2.nextZ;
  }
  while (p2 && p2.z >= minZ) {
    if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
      return false;
    p2 = p2.prevZ;
  }
  while (n2 && n2.z <= maxZ) {
    if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
      return false;
    n2 = n2.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  let p2 = start;
  do {
    const a2 = p2.prev, b2 = p2.next.next;
    if (!equals(a2, b2) && intersects(a2, p2, p2.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
      triangles.push(a2.i / dim);
      triangles.push(p2.i / dim);
      triangles.push(b2.i / dim);
      removeNode(p2);
      removeNode(p2.next);
      p2 = start = b2;
    }
    p2 = p2.next;
  } while (p2 !== start);
  return filterPoints(p2);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a2 = start;
  do {
    let b2 = a2.next.next;
    while (b2 !== a2.prev) {
      if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
        let c2 = splitPolygon(a2, b2);
        a2 = filterPoints(a2, a2.next);
        c2 = filterPoints(c2, c2.next);
        earcutLinked(a2, triangles, dim, minX, minY, invSize);
        earcutLinked(c2, triangles, dim, minX, minY, invSize);
        return;
      }
      b2 = b2.next;
    }
    a2 = a2.next;
  } while (a2 !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue = [];
  let i2, len, start, end, list;
  for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
    start = holeIndices[i2] * dim;
    end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i2 = 0; i2 < queue.length; i2++) {
    eliminateHole(queue[i2], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }
  return outerNode;
}
function compareX(a2, b2) {
  return a2.x - b2.x;
}
function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);
  if (outerNode) {
    const b2 = splitPolygon(outerNode, hole);
    filterPoints(outerNode, outerNode.next);
    filterPoints(b2, b2.next);
  }
}
function findHoleBridge(hole, outerNode) {
  let p2 = outerNode;
  const hx = hole.x;
  const hy = hole.y;
  let qx = -Infinity, m2;
  do {
    if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
      const x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
      if (x2 <= hx && x2 > qx) {
        qx = x2;
        if (x2 === hx) {
          if (hy === p2.y)
            return p2;
          if (hy === p2.next.y)
            return p2.next;
        }
        m2 = p2.x < p2.next.x ? p2 : p2.next;
      }
    }
    p2 = p2.next;
  } while (p2 !== outerNode);
  if (!m2)
    return null;
  if (hx === qx)
    return m2;
  const stop = m2, mx = m2.x, my = m2.y;
  let tanMin = Infinity, tan;
  p2 = m2;
  do {
    if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
      tan = Math.abs(hy - p2.y) / (hx - p2.x);
      if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
        m2 = p2;
        tanMin = tan;
      }
    }
    p2 = p2.next;
  } while (p2 !== stop);
  return m2;
}
function sectorContainsSector(m2, p2) {
  return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p2 = start;
  do {
    if (p2.z === null)
      p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
    p2.prevZ = p2.prev;
    p2.nextZ = p2.next;
    p2 = p2.next;
  } while (p2 !== start);
  p2.prevZ.nextZ = null;
  p2.prevZ = null;
  sortLinked(p2);
}
function sortLinked(list) {
  let i2, p2, q2, e2, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p2 = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p2) {
      numMerges++;
      q2 = p2;
      pSize = 0;
      for (i2 = 0; i2 < inSize; i2++) {
        pSize++;
        q2 = q2.nextZ;
        if (!q2)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q2) {
        if (pSize !== 0 && (qSize === 0 || !q2 || p2.z <= q2.z)) {
          e2 = p2;
          p2 = p2.nextZ;
          pSize--;
        } else {
          e2 = q2;
          q2 = q2.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e2;
        else
          list = e2;
        e2.prevZ = tail;
        tail = e2;
      }
      p2 = q2;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x2, y2, minX, minY, invSize) {
  x2 = 32767 * (x2 - minX) * invSize;
  y2 = 32767 * (y2 - minY) * invSize;
  x2 = (x2 | x2 << 8) & 16711935;
  x2 = (x2 | x2 << 4) & 252645135;
  x2 = (x2 | x2 << 2) & 858993459;
  x2 = (x2 | x2 << 1) & 1431655765;
  y2 = (y2 | y2 << 8) & 16711935;
  y2 = (y2 | y2 << 4) & 252645135;
  y2 = (y2 | y2 << 2) & 858993459;
  y2 = (y2 | y2 << 1) & 1431655765;
  return x2 | y2 << 1;
}
function getLeftmost(start) {
  let p2 = start, leftmost = start;
  do {
    if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
      leftmost = p2;
    p2 = p2.next;
  } while (p2 !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
  return (cx - px2) * (ay - py2) - (ax - px2) * (cy - py2) >= 0 && (ax - px2) * (by - py2) - (bx - px2) * (ay - py2) >= 0 && (bx - px2) * (cy - py2) - (cx - px2) * (by - py2) >= 0;
}
function isValidDiagonal(a2, b2) {
  return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
}
function area(p2, q2, r2) {
  return (q2.y - p2.y) * (r2.x - q2.x) - (q2.x - p2.x) * (r2.y - q2.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p1, p2, q1))
    return true;
  if (o2 === 0 && onSegment(p1, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p2, p1, q2))
    return true;
  if (o4 === 0 && onSegment(p2, q1, q2))
    return true;
  return false;
}
function onSegment(p2, q2, r2) {
  return q2.x <= Math.max(p2.x, r2.x) && q2.x >= Math.min(p2.x, r2.x) && q2.y <= Math.max(p2.y, r2.y) && q2.y >= Math.min(p2.y, r2.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a2, b2) {
  let p2 = a2;
  do {
    if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a2, b2))
      return true;
    p2 = p2.next;
  } while (p2 !== a2);
  return false;
}
function locallyInside(a2, b2) {
  return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
}
function middleInside(a2, b2) {
  let p2 = a2, inside = false;
  const px2 = (a2.x + b2.x) / 2, py2 = (a2.y + b2.y) / 2;
  do {
    if (p2.y > py2 !== p2.next.y > py2 && p2.next.y !== p2.y && px2 < (p2.next.x - p2.x) * (py2 - p2.y) / (p2.next.y - p2.y) + p2.x)
      inside = !inside;
    p2 = p2.next;
  } while (p2 !== a2);
  return inside;
}
function splitPolygon(a2, b2) {
  const a22 = new Node(a2.i, a2.x, a2.y), b22 = new Node(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
  a2.next = b2;
  b2.prev = a2;
  a22.next = an;
  an.prev = a22;
  b22.next = a22;
  a22.prev = b22;
  bp.next = b22;
  b22.prev = bp;
  return b22;
}
function insertNode(i2, x2, y2, last) {
  const p2 = new Node(i2, x2, y2);
  if (!last) {
    p2.prev = p2;
    p2.next = p2;
  } else {
    p2.next = last.next;
    p2.prev = last;
    last.next.prev = p2;
    last.next = p2;
  }
  return p2;
}
function removeNode(p2) {
  p2.next.prev = p2.prev;
  p2.prev.next = p2.next;
  if (p2.prevZ)
    p2.prevZ.nextZ = p2.nextZ;
  if (p2.nextZ)
    p2.nextZ.prevZ = p2.prevZ;
}
function Node(i2, x2, y2) {
  this.i = i2;
  this.x = x2;
  this.y = y2;
  this.prev = null;
  this.next = null;
  this.z = null;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
function signedArea(data, start, end, dim) {
  let sum = 0;
  for (let i2 = start, j2 = end - dim; i2 < end; i2 += dim) {
    sum += (data[j2] - data[i2]) * (data[i2 + 1] + data[j2 + 1]);
    j2 = i2;
  }
  return sum;
}
class ShapeUtils {
  static area(contour) {
    const n2 = contour.length;
    let a2 = 0;
    for (let p2 = n2 - 1, q2 = 0; q2 < n2; p2 = q2++) {
      a2 += contour[p2].x * contour[q2].y - contour[q2].x * contour[p2].y;
    }
    return a2 * 0.5;
  }
  static isClockWise(pts) {
    return ShapeUtils.area(pts) < 0;
  }
  static triangulateShape(contour, holes) {
    const vertices = [];
    const holeIndices = [];
    const faces = [];
    removeDupEndPts(contour);
    addContour(vertices, contour);
    let holeIndex = contour.length;
    holes.forEach(removeDupEndPts);
    for (let i2 = 0; i2 < holes.length; i2++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i2].length;
      addContour(vertices, holes[i2]);
    }
    const triangles = Earcut.triangulate(vertices, holeIndices);
    for (let i2 = 0; i2 < triangles.length; i2 += 3) {
      faces.push(triangles.slice(i2, i2 + 3));
    }
    return faces;
  }
}
function removeDupEndPts(points) {
  const l2 = points.length;
  if (l2 > 2 && points[l2 - 1].equals(points[0])) {
    points.pop();
  }
}
function addContour(vertices, contour) {
  for (let i2 = 0; i2 < contour.length; i2++) {
    vertices.push(contour[i2].x);
    vertices.push(contour[i2].y);
  }
}
class ExtrudeGeometry extends BufferGeometry {
  constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options = {}) {
    super();
    this.type = "ExtrudeGeometry";
    this.parameters = {
      shapes,
      options
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    const scope = this;
    const verticesArray = [];
    const uvArray = [];
    for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
      const shape = shapes[i2];
      addShape(shape);
    }
    this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
    this.computeVertexNormals();
    function addShape(shape) {
      const placeholder = [];
      const curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
      const steps = options.steps !== void 0 ? options.steps : 1;
      let depth = options.depth !== void 0 ? options.depth : 1;
      let bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
      let bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 0.2;
      let bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 0.1;
      let bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0;
      let bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
      const extrudePath = options.extrudePath;
      const uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator;
      if (options.amount !== void 0) {
        console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
        depth = options.amount;
      }
      let extrudePts, extrudeByPath = false;
      let splineTube, binormal, normal, position2;
      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false;
        splineTube = extrudePath.computeFrenetFrames(steps, false);
        binormal = new Vector3();
        normal = new Vector3();
        position2 = new Vector3();
      }
      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      }
      const shapePoints = shape.extractPoints(curveSegments);
      let vertices = shapePoints.shape;
      const holes = shapePoints.holes;
      const reverse = !ShapeUtils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          if (ShapeUtils.isClockWise(ahole)) {
            holes[h2] = ahole.reverse();
          }
        }
      }
      const faces = ShapeUtils.triangulateShape(vertices, holes);
      const contour = vertices;
      for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
        const ahole = holes[h2];
        vertices = vertices.concat(ahole);
      }
      function scalePt2(pt, vec, size) {
        if (!vec)
          console.error("THREE.ExtrudeGeometry: vec does not exist");
        return vec.clone().multiplyScalar(size).add(pt);
      }
      const vlen = vertices.length, flen = faces.length;
      function getBevelVec(inPt, inPrev, inNext) {
        let v_trans_x, v_trans_y, shrink_by;
        const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
        const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
        if (Math.abs(collinear0) > Number.EPSILON) {
          const v_prev_len = Math.sqrt(v_prev_lensq);
          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          const ptNextShift_x = inNext.x - v_next_y / v_next_len;
          const ptNextShift_y = inNext.y + v_next_x / v_next_len;
          const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
          if (v_trans_lensq <= 2) {
            return new Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          let direction_eq = false;
          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }
          if (direction_eq) {
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }
        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }
      const contourMovements = [];
      for (let i2 = 0, il = contour.length, j2 = il - 1, k2 = i2 + 1; i2 < il; i2++, j2++, k2++) {
        if (j2 === il)
          j2 = 0;
        if (k2 === il)
          k2 = 0;
        contourMovements[i2] = getBevelVec(contour[i2], contour[j2], contour[k2]);
      }
      const holesMovements = [];
      let oneHoleMovements, verticesMovements = contourMovements.concat();
      for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
        const ahole = holes[h2];
        oneHoleMovements = [];
        for (let i2 = 0, il = ahole.length, j2 = il - 1, k2 = i2 + 1; i2 < il; i2++, j2++, k2++) {
          if (j2 === il)
            j2 = 0;
          if (k2 === il)
            k2 = 0;
          oneHoleMovements[i2] = getBevelVec(ahole[i2], ahole[j2], ahole[k2]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      }
      for (let b2 = 0; b2 < bevelSegments; b2++) {
        const t2 = b2 / bevelSegments;
        const z2 = bevelThickness * Math.cos(t2 * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
        for (let i2 = 0, il = contour.length; i2 < il; i2++) {
          const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
          v2(vert.x, vert.y, -z2);
        }
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          oneHoleMovements = holesMovements[h2];
          for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
            const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
            v2(vert.x, vert.y, -z2);
          }
        }
      }
      const bs = bevelSize + bevelOffset;
      for (let i2 = 0; i2 < vlen; i2++) {
        const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
        if (!extrudeByPath) {
          v2(vert.x, vert.y, 0);
        } else {
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v2(position2.x, position2.y, position2.z);
        }
      }
      for (let s2 = 1; s2 <= steps; s2++) {
        for (let i2 = 0; i2 < vlen; i2++) {
          const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
          if (!extrudeByPath) {
            v2(vert.x, vert.y, depth / steps * s2);
          } else {
            normal.copy(splineTube.normals[s2]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s2]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s2]).add(normal).add(binormal);
            v2(position2.x, position2.y, position2.z);
          }
        }
      }
      for (let b2 = bevelSegments - 1; b2 >= 0; b2--) {
        const t2 = b2 / bevelSegments;
        const z2 = bevelThickness * Math.cos(t2 * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
        for (let i2 = 0, il = contour.length; i2 < il; i2++) {
          const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
          v2(vert.x, vert.y, depth + z2);
        }
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          oneHoleMovements = holesMovements[h2];
          for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
            const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
            if (!extrudeByPath) {
              v2(vert.x, vert.y, depth + z2);
            } else {
              v2(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z2);
            }
          }
        }
      }
      buildLidFaces();
      buildSideFaces();
      function buildLidFaces() {
        const start = verticesArray.length / 3;
        if (bevelEnabled) {
          let layer = 0;
          let offset = vlen * layer;
          for (let i2 = 0; i2 < flen; i2++) {
            const face = faces[i2];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
          }
          layer = steps + bevelSegments * 2;
          offset = vlen * layer;
          for (let i2 = 0; i2 < flen; i2++) {
            const face = faces[i2];
            f3(face[0] + offset, face[1] + offset, face[2] + offset);
          }
        } else {
          for (let i2 = 0; i2 < flen; i2++) {
            const face = faces[i2];
            f3(face[2], face[1], face[0]);
          }
          for (let i2 = 0; i2 < flen; i2++) {
            const face = faces[i2];
            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
          }
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 0);
      }
      function buildSideFaces() {
        const start = verticesArray.length / 3;
        let layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          sidewalls(ahole, layeroffset);
          layeroffset += ahole.length;
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 1);
      }
      function sidewalls(contour2, layeroffset) {
        let i2 = contour2.length;
        while (--i2 >= 0) {
          const j2 = i2;
          let k2 = i2 - 1;
          if (k2 < 0)
            k2 = contour2.length - 1;
          for (let s2 = 0, sl = steps + bevelSegments * 2; s2 < sl; s2++) {
            const slen1 = vlen * s2;
            const slen2 = vlen * (s2 + 1);
            const a2 = layeroffset + j2 + slen1, b2 = layeroffset + k2 + slen1, c2 = layeroffset + k2 + slen2, d2 = layeroffset + j2 + slen2;
            f4(a2, b2, c2, d2);
          }
        }
      }
      function v2(x2, y2, z2) {
        placeholder.push(x2);
        placeholder.push(y2);
        placeholder.push(z2);
      }
      function f3(a2, b2, c2) {
        addVertex(a2);
        addVertex(b2);
        addVertex(c2);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }
      function f4(a2, b2, c2, d2) {
        addVertex(a2);
        addVertex(b2);
        addVertex(d2);
        addVertex(b2);
        addVertex(c2);
        addVertex(d2);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }
      function addVertex(index) {
        verticesArray.push(placeholder[index * 3 + 0]);
        verticesArray.push(placeholder[index * 3 + 1]);
        verticesArray.push(placeholder[index * 3 + 2]);
      }
      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    const options = this.parameters.options;
    return toJSON$1(shapes, options, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j2 = 0, jl = data.shapes.length; j2 < jl; j2++) {
      const shape = shapes[data.shapes[j2]];
      geometryShapes.push(shape);
    }
    const extrudePath = data.options.extrudePath;
    if (extrudePath !== void 0) {
      data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
    }
    return new ExtrudeGeometry(geometryShapes, data.options);
  }
}
const WorldUVGenerator = {
  generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    return [
      new Vector2(a_x, a_y),
      new Vector2(b_x, b_y),
      new Vector2(c_x, c_y)
    ];
  },
  generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const a_z = vertices[indexA * 3 + 2];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const b_z = vertices[indexB * 3 + 2];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    const c_z = vertices[indexC * 3 + 2];
    const d_x = vertices[indexD * 3];
    const d_y = vertices[indexD * 3 + 1];
    const d_z = vertices[indexD * 3 + 2];
    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
      return [
        new Vector2(a_x, 1 - a_z),
        new Vector2(b_x, 1 - b_z),
        new Vector2(c_x, 1 - c_z),
        new Vector2(d_x, 1 - d_z)
      ];
    } else {
      return [
        new Vector2(a_y, 1 - a_z),
        new Vector2(b_y, 1 - b_z),
        new Vector2(c_y, 1 - c_z),
        new Vector2(d_y, 1 - d_z)
      ];
    }
  }
};
function toJSON$1(shapes, options, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
      const shape = shapes[i2];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  if (options.extrudePath !== void 0)
    data.options.extrudePath = options.extrudePath.toJSON();
  return data;
}
class IcosahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t2 = (1 + Math.sqrt(5)) / 2;
    const vertices = [
      -1,
      t2,
      0,
      1,
      t2,
      0,
      -1,
      -t2,
      0,
      1,
      -t2,
      0,
      0,
      -1,
      t2,
      0,
      1,
      t2,
      0,
      -1,
      -t2,
      0,
      1,
      -t2,
      t2,
      0,
      -1,
      t2,
      0,
      1,
      -t2,
      0,
      -1,
      -t2,
      0,
      1
    ];
    const indices = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(vertices, indices, radius, detail);
    this.type = "IcosahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new IcosahedronGeometry(data.radius, data.detail);
  }
}
class LatheGeometry extends BufferGeometry {
  constructor(points = [new Vector2(0, 0.5), new Vector2(0.5, 0), new Vector2(0, -0.5)], segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
    super();
    this.type = "LatheGeometry";
    this.parameters = {
      points,
      segments,
      phiStart,
      phiLength
    };
    segments = Math.floor(segments);
    phiLength = clamp(phiLength, 0, Math.PI * 2);
    const indices = [];
    const vertices = [];
    const uvs = [];
    const initNormals = [];
    const normals = [];
    const inverseSegments = 1 / segments;
    const vertex2 = new Vector3();
    const uv = new Vector2();
    const normal = new Vector3();
    const curNormal = new Vector3();
    const prevNormal = new Vector3();
    let dx = 0;
    let dy = 0;
    for (let j2 = 0; j2 <= points.length - 1; j2++) {
      switch (j2) {
        case 0:
          dx = points[j2 + 1].x - points[j2].x;
          dy = points[j2 + 1].y - points[j2].y;
          normal.x = dy * 1;
          normal.y = -dx;
          normal.z = dy * 0;
          prevNormal.copy(normal);
          normal.normalize();
          initNormals.push(normal.x, normal.y, normal.z);
          break;
        case points.length - 1:
          initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);
          break;
        default:
          dx = points[j2 + 1].x - points[j2].x;
          dy = points[j2 + 1].y - points[j2].y;
          normal.x = dy * 1;
          normal.y = -dx;
          normal.z = dy * 0;
          curNormal.copy(normal);
          normal.x += prevNormal.x;
          normal.y += prevNormal.y;
          normal.z += prevNormal.z;
          normal.normalize();
          initNormals.push(normal.x, normal.y, normal.z);
          prevNormal.copy(curNormal);
      }
    }
    for (let i2 = 0; i2 <= segments; i2++) {
      const phi = phiStart + i2 * inverseSegments * phiLength;
      const sin = Math.sin(phi);
      const cos = Math.cos(phi);
      for (let j2 = 0; j2 <= points.length - 1; j2++) {
        vertex2.x = points[j2].x * sin;
        vertex2.y = points[j2].y;
        vertex2.z = points[j2].x * cos;
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        uv.x = i2 / segments;
        uv.y = j2 / (points.length - 1);
        uvs.push(uv.x, uv.y);
        const x2 = initNormals[3 * j2 + 0] * sin;
        const y2 = initNormals[3 * j2 + 1];
        const z2 = initNormals[3 * j2 + 0] * cos;
        normals.push(x2, y2, z2);
      }
    }
    for (let i2 = 0; i2 < segments; i2++) {
      for (let j2 = 0; j2 < points.length - 1; j2++) {
        const base = j2 + i2 * points.length;
        const a2 = base;
        const b2 = base + points.length;
        const c2 = base + points.length + 1;
        const d2 = base + 1;
        indices.push(a2, b2, d2);
        indices.push(c2, d2, b2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  }
  static fromJSON(data) {
    return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
  }
}
class OctahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ];
    const indices = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(vertices, indices, radius, detail);
    this.type = "OctahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new OctahedronGeometry(data.radius, data.detail);
  }
}
class RingGeometry extends BufferGeometry {
  constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "RingGeometry";
    this.parameters = {
      innerRadius,
      outerRadius,
      thetaSegments,
      phiSegments,
      thetaStart,
      thetaLength
    };
    thetaSegments = Math.max(3, thetaSegments);
    phiSegments = Math.max(1, phiSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let radius = innerRadius;
    const radiusStep = (outerRadius - innerRadius) / phiSegments;
    const vertex2 = new Vector3();
    const uv = new Vector2();
    for (let j2 = 0; j2 <= phiSegments; j2++) {
      for (let i2 = 0; i2 <= thetaSegments; i2++) {
        const segment = thetaStart + i2 / thetaSegments * thetaLength;
        vertex2.x = radius * Math.cos(segment);
        vertex2.y = radius * Math.sin(segment);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normals.push(0, 0, 1);
        uv.x = (vertex2.x / outerRadius + 1) / 2;
        uv.y = (vertex2.y / outerRadius + 1) / 2;
        uvs.push(uv.x, uv.y);
      }
      radius += radiusStep;
    }
    for (let j2 = 0; j2 < phiSegments; j2++) {
      const thetaSegmentLevel = j2 * (thetaSegments + 1);
      for (let i2 = 0; i2 < thetaSegments; i2++) {
        const segment = i2 + thetaSegmentLevel;
        const a2 = segment;
        const b2 = segment + thetaSegments + 1;
        const c2 = segment + thetaSegments + 2;
        const d2 = segment + 1;
        indices.push(a2, b2, d2);
        indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
  }
}
class ShapeGeometry extends BufferGeometry {
  constructor(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {
    super();
    this.type = "ShapeGeometry";
    this.parameters = {
      shapes,
      curveSegments
    };
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let groupStart = 0;
    let groupCount = 0;
    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (let i2 = 0; i2 < shapes.length; i2++) {
        addShape(shapes[i2]);
        this.addGroup(groupStart, groupCount, i2);
        groupStart += groupCount;
        groupCount = 0;
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function addShape(shape) {
      const indexOffset = vertices.length / 3;
      const points = shape.extractPoints(curveSegments);
      let shapeVertices = points.shape;
      const shapeHoles = points.holes;
      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }
      for (let i2 = 0, l2 = shapeHoles.length; i2 < l2; i2++) {
        const shapeHole = shapeHoles[i2];
        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i2] = shapeHole.reverse();
        }
      }
      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
      for (let i2 = 0, l2 = shapeHoles.length; i2 < l2; i2++) {
        const shapeHole = shapeHoles[i2];
        shapeVertices = shapeVertices.concat(shapeHole);
      }
      for (let i2 = 0, l2 = shapeVertices.length; i2 < l2; i2++) {
        const vertex2 = shapeVertices[i2];
        vertices.push(vertex2.x, vertex2.y, 0);
        normals.push(0, 0, 1);
        uvs.push(vertex2.x, vertex2.y);
      }
      for (let i2 = 0, l2 = faces.length; i2 < l2; i2++) {
        const face = faces[i2];
        const a2 = face[0] + indexOffset;
        const b2 = face[1] + indexOffset;
        const c2 = face[2] + indexOffset;
        indices.push(a2, b2, c2);
        groupCount += 3;
      }
    }
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    return toJSON(shapes, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j2 = 0, jl = data.shapes.length; j2 < jl; j2++) {
      const shape = shapes[data.shapes[j2]];
      geometryShapes.push(shape);
    }
    return new ShapeGeometry(geometryShapes, data.curveSegments);
  }
}
function toJSON(shapes, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
      const shape = shapes[i2];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  return data;
}
class SphereGeometry extends BufferGeometry {
  constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    super();
    this.type = "SphereGeometry";
    this.parameters = {
      radius,
      widthSegments,
      heightSegments,
      phiStart,
      phiLength,
      thetaStart,
      thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index = 0;
    const grid = [];
    const vertex2 = new Vector3();
    const normal = new Vector3();
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v2 = iy / heightSegments;
      let uOffset = 0;
      if (iy == 0 && thetaStart == 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy == heightSegments && thetaEnd == Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix = 0; ix <= widthSegments; ix++) {
        const u2 = ix / widthSegments;
        vertex2.x = -radius * Math.cos(phiStart + u2 * phiLength) * Math.sin(thetaStart + v2 * thetaLength);
        vertex2.y = radius * Math.cos(thetaStart + v2 * thetaLength);
        vertex2.z = radius * Math.sin(phiStart + u2 * phiLength) * Math.sin(thetaStart + v2 * thetaLength);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normal.copy(vertex2).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u2 + uOffset, 1 - v2);
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a2 = grid[iy][ix + 1];
        const b2 = grid[iy][ix];
        const c2 = grid[iy + 1][ix];
        const d2 = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0)
          indices.push(a2, b2, d2);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
          indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
  }
}
class TetrahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ];
    const indices = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(vertices, indices, radius, detail);
    this.type = "TetrahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new TetrahedronGeometry(data.radius, data.detail);
  }
}
class TorusGeometry extends BufferGeometry {
  constructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {
    super();
    this.type = "TorusGeometry";
    this.parameters = {
      radius,
      tube,
      radialSegments,
      tubularSegments,
      arc
    };
    radialSegments = Math.floor(radialSegments);
    tubularSegments = Math.floor(tubularSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const center = new Vector3();
    const vertex2 = new Vector3();
    const normal = new Vector3();
    for (let j2 = 0; j2 <= radialSegments; j2++) {
      for (let i2 = 0; i2 <= tubularSegments; i2++) {
        const u2 = i2 / tubularSegments * arc;
        const v2 = j2 / radialSegments * Math.PI * 2;
        vertex2.x = (radius + tube * Math.cos(v2)) * Math.cos(u2);
        vertex2.y = (radius + tube * Math.cos(v2)) * Math.sin(u2);
        vertex2.z = tube * Math.sin(v2);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        center.x = radius * Math.cos(u2);
        center.y = radius * Math.sin(u2);
        normal.subVectors(vertex2, center).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i2 / tubularSegments);
        uvs.push(j2 / radialSegments);
      }
    }
    for (let j2 = 1; j2 <= radialSegments; j2++) {
      for (let i2 = 1; i2 <= tubularSegments; i2++) {
        const a2 = (tubularSegments + 1) * j2 + i2 - 1;
        const b2 = (tubularSegments + 1) * (j2 - 1) + i2 - 1;
        const c2 = (tubularSegments + 1) * (j2 - 1) + i2;
        const d2 = (tubularSegments + 1) * j2 + i2;
        indices.push(a2, b2, d2);
        indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  static fromJSON(data) {
    return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
  }
}
class TorusKnotGeometry extends BufferGeometry {
  constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p2 = 2, q2 = 3) {
    super();
    this.type = "TorusKnotGeometry";
    this.parameters = {
      radius,
      tube,
      tubularSegments,
      radialSegments,
      p: p2,
      q: q2
    };
    tubularSegments = Math.floor(tubularSegments);
    radialSegments = Math.floor(radialSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const vertex2 = new Vector3();
    const normal = new Vector3();
    const P1 = new Vector3();
    const P2 = new Vector3();
    const B2 = new Vector3();
    const T2 = new Vector3();
    const N2 = new Vector3();
    for (let i2 = 0; i2 <= tubularSegments; ++i2) {
      const u2 = i2 / tubularSegments * p2 * Math.PI * 2;
      calculatePositionOnCurve(u2, p2, q2, radius, P1);
      calculatePositionOnCurve(u2 + 0.01, p2, q2, radius, P2);
      T2.subVectors(P2, P1);
      N2.addVectors(P2, P1);
      B2.crossVectors(T2, N2);
      N2.crossVectors(B2, T2);
      B2.normalize();
      N2.normalize();
      for (let j2 = 0; j2 <= radialSegments; ++j2) {
        const v2 = j2 / radialSegments * Math.PI * 2;
        const cx = -tube * Math.cos(v2);
        const cy = tube * Math.sin(v2);
        vertex2.x = P1.x + (cx * N2.x + cy * B2.x);
        vertex2.y = P1.y + (cx * N2.y + cy * B2.y);
        vertex2.z = P1.z + (cx * N2.z + cy * B2.z);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normal.subVectors(vertex2, P1).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i2 / tubularSegments);
        uvs.push(j2 / radialSegments);
      }
    }
    for (let j2 = 1; j2 <= tubularSegments; j2++) {
      for (let i2 = 1; i2 <= radialSegments; i2++) {
        const a2 = (radialSegments + 1) * (j2 - 1) + (i2 - 1);
        const b2 = (radialSegments + 1) * j2 + (i2 - 1);
        const c2 = (radialSegments + 1) * j2 + i2;
        const d2 = (radialSegments + 1) * (j2 - 1) + i2;
        indices.push(a2, b2, d2);
        indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function calculatePositionOnCurve(u2, p3, q3, radius2, position) {
      const cu = Math.cos(u2);
      const su = Math.sin(u2);
      const quOverP = q3 / p3 * u2;
      const cs = Math.cos(quOverP);
      position.x = radius2 * (2 + cs) * 0.5 * cu;
      position.y = radius2 * (2 + cs) * su * 0.5;
      position.z = radius2 * Math.sin(quOverP) * 0.5;
    }
  }
  static fromJSON(data) {
    return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
  }
}
class TubeGeometry extends BufferGeometry {
  constructor(path = new QuadraticBezierCurve3(new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
    super();
    this.type = "TubeGeometry";
    this.parameters = {
      path,
      tubularSegments,
      radius,
      radialSegments,
      closed
    };
    const frames = path.computeFrenetFrames(tubularSegments, closed);
    this.tangents = frames.tangents;
    this.normals = frames.normals;
    this.binormals = frames.binormals;
    const vertex2 = new Vector3();
    const normal = new Vector3();
    const uv = new Vector2();
    let P2 = new Vector3();
    const vertices = [];
    const normals = [];
    const uvs = [];
    const indices = [];
    generateBufferData();
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateBufferData() {
      for (let i2 = 0; i2 < tubularSegments; i2++) {
        generateSegment(i2);
      }
      generateSegment(closed === false ? tubularSegments : 0);
      generateUVs();
      generateIndices();
    }
    function generateSegment(i2) {
      P2 = path.getPointAt(i2 / tubularSegments, P2);
      const N2 = frames.normals[i2];
      const B2 = frames.binormals[i2];
      for (let j2 = 0; j2 <= radialSegments; j2++) {
        const v2 = j2 / radialSegments * Math.PI * 2;
        const sin = Math.sin(v2);
        const cos = -Math.cos(v2);
        normal.x = cos * N2.x + sin * B2.x;
        normal.y = cos * N2.y + sin * B2.y;
        normal.z = cos * N2.z + sin * B2.z;
        normal.normalize();
        normals.push(normal.x, normal.y, normal.z);
        vertex2.x = P2.x + radius * normal.x;
        vertex2.y = P2.y + radius * normal.y;
        vertex2.z = P2.z + radius * normal.z;
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
      }
    }
    function generateIndices() {
      for (let j2 = 1; j2 <= tubularSegments; j2++) {
        for (let i2 = 1; i2 <= radialSegments; i2++) {
          const a2 = (radialSegments + 1) * (j2 - 1) + (i2 - 1);
          const b2 = (radialSegments + 1) * j2 + (i2 - 1);
          const c2 = (radialSegments + 1) * j2 + i2;
          const d2 = (radialSegments + 1) * (j2 - 1) + i2;
          indices.push(a2, b2, d2);
          indices.push(b2, c2, d2);
        }
      }
    }
    function generateUVs() {
      for (let i2 = 0; i2 <= tubularSegments; i2++) {
        for (let j2 = 0; j2 <= radialSegments; j2++) {
          uv.x = i2 / tubularSegments;
          uv.y = j2 / radialSegments;
          uvs.push(uv.x, uv.y);
        }
      }
    }
  }
  toJSON() {
    const data = super.toJSON();
    data.path = this.parameters.path.toJSON();
    return data;
  }
  static fromJSON(data) {
    return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
  }
}
class WireframeGeometry extends BufferGeometry {
  constructor(geometry = null) {
    super();
    this.type = "WireframeGeometry";
    this.parameters = {
      geometry
    };
    if (geometry !== null) {
      const vertices = [];
      const edges = /* @__PURE__ */ new Set();
      const start = new Vector3();
      const end = new Vector3();
      if (geometry.index !== null) {
        const position = geometry.attributes.position;
        const indices = geometry.index;
        let groups = geometry.groups;
        if (groups.length === 0) {
          groups = [{ start: 0, count: indices.count, materialIndex: 0 }];
        }
        for (let o2 = 0, ol = groups.length; o2 < ol; ++o2) {
          const group = groups[o2];
          const groupStart = group.start;
          const groupCount = group.count;
          for (let i2 = groupStart, l2 = groupStart + groupCount; i2 < l2; i2 += 3) {
            for (let j2 = 0; j2 < 3; j2++) {
              const index1 = indices.getX(i2 + j2);
              const index2 = indices.getX(i2 + (j2 + 1) % 3);
              start.fromBufferAttribute(position, index1);
              end.fromBufferAttribute(position, index2);
              if (isUniqueEdge(start, end, edges) === true) {
                vertices.push(start.x, start.y, start.z);
                vertices.push(end.x, end.y, end.z);
              }
            }
          }
        }
      } else {
        const position = geometry.attributes.position;
        for (let i2 = 0, l2 = position.count / 3; i2 < l2; i2++) {
          for (let j2 = 0; j2 < 3; j2++) {
            const index1 = 3 * i2 + j2;
            const index2 = 3 * i2 + (j2 + 1) % 3;
            start.fromBufferAttribute(position, index1);
            end.fromBufferAttribute(position, index2);
            if (isUniqueEdge(start, end, edges) === true) {
              vertices.push(start.x, start.y, start.z);
              vertices.push(end.x, end.y, end.z);
            }
          }
        }
      }
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    }
  }
}
function isUniqueEdge(start, end, edges) {
  const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
  const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`;
  if (edges.has(hash1) === true || edges.has(hash2) === true) {
    return false;
  } else {
    edges.add(hash1);
    edges.add(hash2);
    return true;
  }
}
class ShadowMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "ShadowMaterial";
    this.color = new Color(0);
    this.transparent = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    return this;
  }
}
ShadowMaterial.prototype.isShadowMaterial = true;
class RawShaderMaterial extends ShaderMaterial {
  constructor(parameters) {
    super(parameters);
    this.type = "RawShaderMaterial";
  }
}
RawShaderMaterial.prototype.isRawShaderMaterial = true;
class MeshStandardMaterial extends Material {
  constructor(parameters) {
    super();
    this.defines = { "STANDARD": "" };
    this.type = "MeshStandardMaterial";
    this.color = new Color(16777215);
    this.roughness = 1;
    this.metalness = 0;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapIntensity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = { "STANDARD": "" };
    this.color.copy(source.color);
    this.roughness = source.roughness;
    this.metalness = source.metalness;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.roughnessMap = source.roughnessMap;
    this.metalnessMap = source.metalnessMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapIntensity = source.envMapIntensity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    return this;
  }
}
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
class MeshPhysicalMaterial extends MeshStandardMaterial {
  constructor(parameters) {
    super();
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.type = "MeshPhysicalMaterial";
    this.clearcoatMap = null;
    this.clearcoatRoughness = 0;
    this.clearcoatRoughnessMap = null;
    this.clearcoatNormalScale = new Vector2(1, 1);
    this.clearcoatNormalMap = null;
    this.ior = 1.5;
    Object.defineProperty(this, "reflectivity", {
      get: function() {
        return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(reflectivity) {
        this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
      }
    });
    this.sheenColor = new Color(0);
    this.sheenColorMap = null;
    this.sheenRoughness = 1;
    this.sheenRoughnessMap = null;
    this.transmissionMap = null;
    this.thickness = 0;
    this.thicknessMap = null;
    this.attenuationDistance = 0;
    this.attenuationColor = new Color(1, 1, 1);
    this.specularIntensity = 1;
    this.specularIntensityMap = null;
    this.specularColor = new Color(1, 1, 1);
    this.specularColorMap = null;
    this._sheen = 0;
    this._clearcoat = 0;
    this._transmission = 0;
    this.setValues(parameters);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(value) {
    if (this._sheen > 0 !== value > 0) {
      this.version++;
    }
    this._sheen = value;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(value) {
    if (this._clearcoat > 0 !== value > 0) {
      this.version++;
    }
    this._clearcoat = value;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(value) {
    if (this._transmission > 0 !== value > 0) {
      this.version++;
    }
    this._transmission = value;
  }
  copy(source) {
    super.copy(source);
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.clearcoat = source.clearcoat;
    this.clearcoatMap = source.clearcoatMap;
    this.clearcoatRoughness = source.clearcoatRoughness;
    this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
    this.clearcoatNormalMap = source.clearcoatNormalMap;
    this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
    this.ior = source.ior;
    this.sheen = source.sheen;
    this.sheenColor.copy(source.sheenColor);
    this.sheenColorMap = source.sheenColorMap;
    this.sheenRoughness = source.sheenRoughness;
    this.sheenRoughnessMap = source.sheenRoughnessMap;
    this.transmission = source.transmission;
    this.transmissionMap = source.transmissionMap;
    this.thickness = source.thickness;
    this.thicknessMap = source.thicknessMap;
    this.attenuationDistance = source.attenuationDistance;
    this.attenuationColor.copy(source.attenuationColor);
    this.specularIntensity = source.specularIntensity;
    this.specularIntensityMap = source.specularIntensityMap;
    this.specularColor.copy(source.specularColor);
    this.specularColorMap = source.specularColorMap;
    return this;
  }
}
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
class MeshPhongMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshPhongMaterial";
    this.color = new Color(16777215);
    this.specular = new Color(1118481);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    return this;
  }
}
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
class MeshToonMaterial extends Material {
  constructor(parameters) {
    super();
    this.defines = { "TOON": "" };
    this.type = "MeshToonMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.gradientMap = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.gradientMap = source.gradientMap;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    return this;
  }
}
MeshToonMaterial.prototype.isMeshToonMaterial = true;
class MeshNormalMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshNormalMaterial";
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.flatShading = source.flatShading;
    return this;
  }
}
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
class MeshLambertMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshLambertMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    return this;
  }
}
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
class MeshMatcapMaterial extends Material {
  constructor(parameters) {
    super();
    this.defines = { "MATCAP": "" };
    this.type = "MeshMatcapMaterial";
    this.color = new Color(16777215);
    this.matcap = null;
    this.map = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = { "MATCAP": "" };
    this.color.copy(source.color);
    this.matcap = source.matcap;
    this.map = source.map;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.flatShading = source.flatShading;
    return this;
  }
}
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
class LineDashedMaterial extends LineBasicMaterial {
  constructor(parameters) {
    super();
    this.type = "LineDashedMaterial";
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;
    return this;
  }
}
LineDashedMaterial.prototype.isLineDashedMaterial = true;
const materialLib = {
  ShadowMaterial,
  SpriteMaterial,
  RawShaderMaterial,
  ShaderMaterial,
  PointsMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshPhongMaterial,
  MeshToonMaterial,
  MeshNormalMaterial,
  MeshLambertMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshBasicMaterial,
  MeshMatcapMaterial,
  LineDashedMaterial,
  LineBasicMaterial,
  Material
};
Material.fromType = function(type) {
  return new materialLib[type]();
};
const AnimationUtils = {
  arraySlice: function(array, from, to) {
    if (AnimationUtils.isTypedArray(array)) {
      return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));
    }
    return array.slice(from, to);
  },
  convertArray: function(array, type, forceClone) {
    if (!array || !forceClone && array.constructor === type)
      return array;
    if (typeof type.BYTES_PER_ELEMENT === "number") {
      return new type(array);
    }
    return Array.prototype.slice.call(array);
  },
  isTypedArray: function(object) {
    return ArrayBuffer.isView(object) && !(object instanceof DataView);
  },
  getKeyframeOrder: function(times) {
    function compareTime(i2, j2) {
      return times[i2] - times[j2];
    }
    const n2 = times.length;
    const result = new Array(n2);
    for (let i2 = 0; i2 !== n2; ++i2)
      result[i2] = i2;
    result.sort(compareTime);
    return result;
  },
  sortedArray: function(values, stride, order) {
    const nValues = values.length;
    const result = new values.constructor(nValues);
    for (let i2 = 0, dstOffset = 0; dstOffset !== nValues; ++i2) {
      const srcOffset = order[i2] * stride;
      for (let j2 = 0; j2 !== stride; ++j2) {
        result[dstOffset++] = values[srcOffset + j2];
      }
    }
    return result;
  },
  flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
    let i2 = 1, key = jsonKeys[0];
    while (key !== void 0 && key[valuePropertyName] === void 0) {
      key = jsonKeys[i2++];
    }
    if (key === void 0)
      return;
    let value = key[valuePropertyName];
    if (value === void 0)
      return;
    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push.apply(values, value);
        }
        key = jsonKeys[i2++];
      } while (key !== void 0);
    } else if (value.toArray !== void 0) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          value.toArray(values, values.length);
        }
        key = jsonKeys[i2++];
      } while (key !== void 0);
    } else {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push(value);
        }
        key = jsonKeys[i2++];
      } while (key !== void 0);
    }
  },
  subclip: function(sourceClip, name, startFrame, endFrame, fps = 30) {
    const clip = sourceClip.clone();
    clip.name = name;
    const tracks = [];
    for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
      const track = clip.tracks[i2];
      const valueSize = track.getValueSize();
      const times = [];
      const values = [];
      for (let j2 = 0; j2 < track.times.length; ++j2) {
        const frame = track.times[j2] * fps;
        if (frame < startFrame || frame >= endFrame)
          continue;
        times.push(track.times[j2]);
        for (let k2 = 0; k2 < valueSize; ++k2) {
          values.push(track.values[j2 * valueSize + k2]);
        }
      }
      if (times.length === 0)
        continue;
      track.times = AnimationUtils.convertArray(times, track.times.constructor);
      track.values = AnimationUtils.convertArray(values, track.values.constructor);
      tracks.push(track);
    }
    clip.tracks = tracks;
    let minStartTime = Infinity;
    for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
      if (minStartTime > clip.tracks[i2].times[0]) {
        minStartTime = clip.tracks[i2].times[0];
      }
    }
    for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
      clip.tracks[i2].shift(-1 * minStartTime);
    }
    clip.resetDuration();
    return clip;
  },
  makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
    if (fps <= 0)
      fps = 30;
    const numTracks = referenceClip.tracks.length;
    const referenceTime = referenceFrame / fps;
    for (let i2 = 0; i2 < numTracks; ++i2) {
      const referenceTrack = referenceClip.tracks[i2];
      const referenceTrackType = referenceTrack.ValueTypeName;
      if (referenceTrackType === "bool" || referenceTrackType === "string")
        continue;
      const targetTrack = targetClip.tracks.find(function(track) {
        return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
      });
      if (targetTrack === void 0)
        continue;
      let referenceOffset = 0;
      const referenceValueSize = referenceTrack.getValueSize();
      if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        referenceOffset = referenceValueSize / 3;
      }
      let targetOffset = 0;
      const targetValueSize = targetTrack.getValueSize();
      if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        targetOffset = targetValueSize / 3;
      }
      const lastIndex = referenceTrack.times.length - 1;
      let referenceValue;
      if (referenceTime <= referenceTrack.times[0]) {
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else if (referenceTime >= referenceTrack.times[lastIndex]) {
        const startIndex = lastIndex * referenceValueSize + referenceOffset;
        const endIndex = startIndex + referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else {
        const interpolant = referenceTrack.createInterpolant();
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        interpolant.evaluate(referenceTime);
        referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
      }
      if (referenceTrackType === "quaternion") {
        const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
        referenceQuat.toArray(referenceValue);
      }
      const numTimes = targetTrack.times.length;
      for (let j2 = 0; j2 < numTimes; ++j2) {
        const valueStart = j2 * targetValueSize + targetOffset;
        if (referenceTrackType === "quaternion") {
          Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
        } else {
          const valueEnd = targetValueSize - targetOffset * 2;
          for (let k2 = 0; k2 < valueEnd; ++k2) {
            targetTrack.values[valueStart + k2] -= referenceValue[k2];
          }
        }
      }
    }
    targetClip.blendMode = AdditiveAnimationBlendMode;
    return targetClip;
  }
};
class Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
    this.settings = null;
    this.DefaultSettings_ = {};
  }
  evaluate(t2) {
    const pp = this.parameterPositions;
    let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
    validate_interval: {
      seek: {
        let right;
        linear_scan: {
          forward_scan:
            if (!(t2 < t1)) {
              for (let giveUpAt = i1 + 2; ; ) {
                if (t1 === void 0) {
                  if (t2 < t0)
                    break forward_scan;
                  i1 = pp.length;
                  this._cachedIndex = i1;
                  return this.afterEnd_(i1 - 1, t2, t0);
                }
                if (i1 === giveUpAt)
                  break;
                t0 = t1;
                t1 = pp[++i1];
                if (t2 < t1) {
                  break seek;
                }
              }
              right = pp.length;
              break linear_scan;
            }
          if (!(t2 >= t0)) {
            const t1global = pp[1];
            if (t2 < t1global) {
              i1 = 2;
              t0 = t1global;
            }
            for (let giveUpAt = i1 - 2; ; ) {
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.beforeStart_(0, t2, t1);
              }
              if (i1 === giveUpAt)
                break;
              t1 = t0;
              t0 = pp[--i1 - 1];
              if (t2 >= t0) {
                break seek;
              }
            }
            right = i1;
            i1 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i1 < right) {
          const mid = i1 + right >>> 1;
          if (t2 < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }
        t1 = pp[i1];
        t0 = pp[i1 - 1];
        if (t0 === void 0) {
          this._cachedIndex = 0;
          return this.beforeStart_(0, t2, t1);
        }
        if (t1 === void 0) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.afterEnd_(i1 - 1, t0, t2);
        }
      }
      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    }
    return this.interpolate_(i1, t0, t2, t1);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = values[offset + i2];
    }
    return result;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
class CubicInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
    this.DefaultSettings_ = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
  }
  intervalChanged_(i1, t0, t1) {
    const pp = this.parameterPositions;
    let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;
        case WrapAroundEnding:
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;
        default:
          iPrev = i1;
          tPrev = t1;
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;
        default:
          iNext = i1 - 1;
          tNext = t0;
      }
    }
    const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p2 = (t2 - t0) / (t1 - t0), pp = p2 * p2, ppp = pp * p2;
    const sP = -wP * ppp + 2 * wP * pp - wP * p2;
    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p2 + 1;
    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p2;
    const sN = wN * ppp - wN * pp;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = sP * values[oP + i2] + s0 * values[o0 + i2] + s1 * values[o1 + i2] + sN * values[oN + i2];
    }
    return result;
  }
}
class LinearInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t2 - t0) / (t1 - t0), weight0 = 1 - weight1;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = values[offset0 + i2] * weight0 + values[offset1 + i2] * weight1;
    }
    return result;
  }
}
class DiscreteInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1) {
    return this.copySampleValue_(i1 - 1);
  }
}
class KeyframeTrack {
  constructor(name, times, values, interpolation) {
    if (name === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times === void 0 || times.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
    this.name = name;
    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }
  static toJSON(track) {
    const trackType = track.constructor;
    let json;
    if (trackType.toJSON !== this.toJSON) {
      json = trackType.toJSON(track);
    } else {
      json = {
        "name": track.name,
        "times": AnimationUtils.convertArray(track.times, Array),
        "values": AnimationUtils.convertArray(track.values, Array)
      };
      const interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }
    json.type = track.ValueTypeName;
    return json;
  }
  InterpolantFactoryMethodDiscrete(result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodLinear(result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodSmooth(result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  setInterpolation(interpolation) {
    let factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === void 0) {
      const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      console.warn("THREE.KeyframeTrack:", message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(timeOffset) {
    if (timeOffset !== 0) {
      const times = this.times;
      for (let i2 = 0, n2 = times.length; i2 !== n2; ++i2) {
        times[i2] += timeOffset;
      }
    }
    return this;
  }
  scale(timeScale) {
    if (timeScale !== 1) {
      const times = this.times;
      for (let i2 = 0, n2 = times.length; i2 !== n2; ++i2) {
        times[i2] *= timeScale;
      }
    }
    return this;
  }
  trim(startTime, endTime) {
    const times = this.times, nKeys = times.length;
    let from = 0, to = nKeys - 1;
    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }
    while (to !== -1 && times[to] > endTime) {
      --to;
    }
    ++to;
    if (from !== 0 || to !== nKeys) {
      if (from >= to) {
        to = Math.max(to, 1);
        from = to - 1;
      }
      const stride = this.getValueSize();
      this.times = AnimationUtils.arraySlice(times, from, to);
      this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
    }
    return this;
  }
  validate() {
    let valid = true;
    const valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
      valid = false;
    }
    const times = this.times, values = this.values, nKeys = times.length;
    if (nKeys === 0) {
      console.error("THREE.KeyframeTrack: Track is empty.", this);
      valid = false;
    }
    let prevTime = null;
    for (let i2 = 0; i2 !== nKeys; i2++) {
      const currTime = times[i2];
      if (typeof currTime === "number" && isNaN(currTime)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i2, currTime);
        valid = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, i2, currTime, prevTime);
        valid = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== void 0) {
      if (AnimationUtils.isTypedArray(values)) {
        for (let i2 = 0, n2 = values.length; i2 !== n2; ++i2) {
          const value = values[i2];
          if (isNaN(value)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i2, value);
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  }
  optimize() {
    const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
    let writeIndex = 1;
    for (let i2 = 1; i2 < lastIndex; ++i2) {
      let keep = false;
      const time = times[i2];
      const timeNext = times[i2 + 1];
      if (time !== timeNext && (i2 !== 1 || time !== times[0])) {
        if (!smoothInterpolation) {
          const offset = i2 * stride, offsetP = offset - stride, offsetN = offset + stride;
          for (let j2 = 0; j2 !== stride; ++j2) {
            const value = values[offset + j2];
            if (value !== values[offsetP + j2] || value !== values[offsetN + j2]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      }
      if (keep) {
        if (i2 !== writeIndex) {
          times[writeIndex] = times[i2];
          const readOffset = i2 * stride, writeOffset = writeIndex * stride;
          for (let j2 = 0; j2 !== stride; ++j2) {
            values[writeOffset + j2] = values[readOffset + j2];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j2 = 0; j2 !== stride; ++j2) {
        values[writeOffset + j2] = values[readOffset + j2];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }
    return this;
  }
  clone() {
    const times = AnimationUtils.arraySlice(this.times, 0);
    const values = AnimationUtils.arraySlice(this.values, 0);
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times, values);
    track.createInterpolant = this.createInterpolant;
    return track;
  }
}
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
class BooleanKeyframeTrack extends KeyframeTrack {
}
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class ColorKeyframeTrack extends KeyframeTrack {
}
ColorKeyframeTrack.prototype.ValueTypeName = "color";
class NumberKeyframeTrack extends KeyframeTrack {
}
NumberKeyframeTrack.prototype.ValueTypeName = "number";
class QuaternionLinearInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t2 - t0) / (t1 - t0);
    let offset = i1 * stride;
    for (let end = offset + stride; offset !== end; offset += 4) {
      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
    }
    return result;
  }
}
class QuaternionKeyframeTrack extends KeyframeTrack {
  InterpolantFactoryMethodLinear(result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
}
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class StringKeyframeTrack extends KeyframeTrack {
}
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class VectorKeyframeTrack extends KeyframeTrack {
}
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
class AnimationClip {
  constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
    this.name = name;
    this.tracks = tracks;
    this.duration = duration;
    this.blendMode = blendMode;
    this.uuid = generateUUID();
    if (this.duration < 0) {
      this.resetDuration();
    }
  }
  static parse(json) {
    const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
    for (let i2 = 0, n2 = jsonTracks.length; i2 !== n2; ++i2) {
      tracks.push(parseKeyframeTrack(jsonTracks[i2]).scale(frameTime));
    }
    const clip = new this(json.name, json.duration, tracks, json.blendMode);
    clip.uuid = json.uuid;
    return clip;
  }
  static toJSON(clip) {
    const tracks = [], clipTracks = clip.tracks;
    const json = {
      "name": clip.name,
      "duration": clip.duration,
      "tracks": tracks,
      "uuid": clip.uuid,
      "blendMode": clip.blendMode
    };
    for (let i2 = 0, n2 = clipTracks.length; i2 !== n2; ++i2) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i2]));
    }
    return json;
  }
  static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
    const numMorphTargets = morphTargetSequence.length;
    const tracks = [];
    for (let i2 = 0; i2 < numMorphTargets; i2++) {
      let times = [];
      let values = [];
      times.push((i2 + numMorphTargets - 1) % numMorphTargets, i2, (i2 + 1) % numMorphTargets);
      values.push(0, 1, 0);
      const order = AnimationUtils.getKeyframeOrder(times);
      times = AnimationUtils.sortedArray(times, 1, order);
      values = AnimationUtils.sortedArray(values, 1, order);
      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }
      tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i2].name + "]", times, values).scale(1 / fps));
    }
    return new this(name, -1, tracks);
  }
  static findByName(objectOrClipArray, name) {
    let clipArray = objectOrClipArray;
    if (!Array.isArray(objectOrClipArray)) {
      const o2 = objectOrClipArray;
      clipArray = o2.geometry && o2.geometry.animations || o2.animations;
    }
    for (let i2 = 0; i2 < clipArray.length; i2++) {
      if (clipArray[i2].name === name) {
        return clipArray[i2];
      }
    }
    return null;
  }
  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
    const animationToMorphTargets = {};
    const pattern = /^([\w-]*?)([\d]+)$/;
    for (let i2 = 0, il = morphTargets.length; i2 < il; i2++) {
      const morphTarget = morphTargets[i2];
      const parts = morphTarget.name.match(pattern);
      if (parts && parts.length > 1) {
        const name = parts[1];
        let animationMorphTargets = animationToMorphTargets[name];
        if (!animationMorphTargets) {
          animationToMorphTargets[name] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
      }
    }
    const clips = [];
    for (const name in animationToMorphTargets) {
      clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
    }
    return clips;
  }
  static parseAnimation(animation, bones) {
    if (!animation) {
      console.error("THREE.AnimationClip: No animation in JSONLoader data.");
      return null;
    }
    const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
      if (animationKeys.length !== 0) {
        const times = [];
        const values = [];
        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values));
        }
      }
    };
    const tracks = [];
    const clipName = animation.name || "default";
    const fps = animation.fps || 30;
    const blendMode = animation.blendMode;
    let duration = animation.length || -1;
    const hierarchyTracks = animation.hierarchy || [];
    for (let h2 = 0; h2 < hierarchyTracks.length; h2++) {
      const animationKeys = hierarchyTracks[h2].keys;
      if (!animationKeys || animationKeys.length === 0)
        continue;
      if (animationKeys[0].morphTargets) {
        const morphTargetNames = {};
        let k2;
        for (k2 = 0; k2 < animationKeys.length; k2++) {
          if (animationKeys[k2].morphTargets) {
            for (let m2 = 0; m2 < animationKeys[k2].morphTargets.length; m2++) {
              morphTargetNames[animationKeys[k2].morphTargets[m2]] = -1;
            }
          }
        }
        for (const morphTargetName in morphTargetNames) {
          const times = [];
          const values = [];
          for (let m2 = 0; m2 !== animationKeys[k2].morphTargets.length; ++m2) {
            const animationKey = animationKeys[k2];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
        }
        duration = morphTargetNames.length * fps;
      } else {
        const boneName = ".bones[" + bones[h2].name + "]";
        addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
        addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
        addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
      }
    }
    if (tracks.length === 0) {
      return null;
    }
    const clip = new this(clipName, duration, tracks, blendMode);
    return clip;
  }
  resetDuration() {
    const tracks = this.tracks;
    let duration = 0;
    for (let i2 = 0, n2 = tracks.length; i2 !== n2; ++i2) {
      const track = this.tracks[i2];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }
    this.duration = duration;
    return this;
  }
  trim() {
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      this.tracks[i2].trim(0, this.duration);
    }
    return this;
  }
  validate() {
    let valid = true;
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      valid = valid && this.tracks[i2].validate();
    }
    return valid;
  }
  optimize() {
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      this.tracks[i2].optimize();
    }
    return this;
  }
  clone() {
    const tracks = [];
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      tracks.push(this.tracks[i2].clone());
    }
    return new this.constructor(this.name, this.duration, tracks, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json) {
  if (json.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  const trackType = getTrackTypeForValueTypeName(json.type);
  if (json.times === void 0) {
    const times = [], values = [];
    AnimationUtils.flattenJSON(json.keys, times, values, "value");
    json.times = times;
    json.values = values;
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json);
  } else {
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}
const Cache = {
  enabled: false,
  files: {},
  add: function(key, file) {
    if (this.enabled === false)
      return;
    this.files[key] = file;
  },
  get: function(key) {
    if (this.enabled === false)
      return;
    return this.files[key];
  },
  remove: function(key) {
    delete this.files[key];
  },
  clear: function() {
    this.files = {};
  }
};
class LoadingManager {
  constructor(onLoad, onProgress, onError) {
    const scope = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = void 0;
    const handlers = [];
    this.onStart = void 0;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url) {
      itemsTotal++;
      if (isLoading === false) {
        if (scope.onStart !== void 0) {
          scope.onStart(url, itemsLoaded, itemsTotal);
        }
      }
      isLoading = true;
    };
    this.itemEnd = function(url) {
      itemsLoaded++;
      if (scope.onProgress !== void 0) {
        scope.onProgress(url, itemsLoaded, itemsTotal);
      }
      if (itemsLoaded === itemsTotal) {
        isLoading = false;
        if (scope.onLoad !== void 0) {
          scope.onLoad();
        }
      }
    };
    this.itemError = function(url) {
      if (scope.onError !== void 0) {
        scope.onError(url);
      }
    };
    this.resolveURL = function(url) {
      if (urlModifier) {
        return urlModifier(url);
      }
      return url;
    };
    this.setURLModifier = function(transform) {
      urlModifier = transform;
      return this;
    };
    this.addHandler = function(regex, loader) {
      handlers.push(regex, loader);
      return this;
    };
    this.removeHandler = function(regex) {
      const index = handlers.indexOf(regex);
      if (index !== -1) {
        handlers.splice(index, 2);
      }
      return this;
    };
    this.getHandler = function(file) {
      for (let i2 = 0, l2 = handlers.length; i2 < l2; i2 += 2) {
        const regex = handlers[i2];
        const loader = handlers[i2 + 1];
        if (regex.global)
          regex.lastIndex = 0;
        if (regex.test(file)) {
          return loader;
        }
      }
      return null;
    };
  }
}
const DefaultLoadingManager = new LoadingManager();
class Loader {
  constructor(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
    this.crossOrigin = "anonymous";
    this.withCredentials = false;
    this.path = "";
    this.resourcePath = "";
    this.requestHeader = {};
  }
  load() {
  }
  loadAsync(url, onProgress) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.load(url, resolve, onProgress, reject);
    });
  }
  parse() {
  }
  setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  }
  setWithCredentials(value) {
    this.withCredentials = value;
    return this;
  }
  setPath(path) {
    this.path = path;
    return this;
  }
  setResourcePath(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  }
  setRequestHeader(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
}
const loading = {};
class FileLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const cached = Cache.get(url);
    if (cached !== void 0) {
      this.manager.itemStart(url);
      setTimeout(() => {
        if (onLoad)
          onLoad(cached);
        this.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    if (loading[url] !== void 0) {
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      return;
    }
    loading[url] = [];
    loading[url].push({
      onLoad,
      onProgress,
      onError
    });
    const req = new Request(url, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
    });
    const mimeType = this.mimeType;
    const responseType = this.responseType;
    fetch(req).then((response) => {
      if (response.status === 200 || response.status === 0) {
        if (response.status === 0) {
          console.warn("THREE.FileLoader: HTTP Status 0 received.");
        }
        if (typeof ReadableStream === "undefined" || response.body === void 0 || response.body.getReader === void 0) {
          return response;
        }
        const callbacks = loading[url];
        const reader = response.body.getReader();
        const contentLength = response.headers.get("Content-Length");
        const total = contentLength ? parseInt(contentLength) : 0;
        const lengthComputable = total !== 0;
        let loaded = 0;
        const stream = new ReadableStream({
          start(controller) {
            readData();
            function readData() {
              reader.read().then(({ done, value }) => {
                if (done) {
                  controller.close();
                } else {
                  loaded += value.byteLength;
                  const event = new ProgressEvent("progress", { lengthComputable, loaded, total });
                  for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
                    const callback = callbacks[i2];
                    if (callback.onProgress)
                      callback.onProgress(event);
                  }
                  controller.enqueue(value);
                  readData();
                }
              });
            }
          }
        });
        return new Response(stream);
      } else {
        throw Error(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`);
      }
    }).then((response) => {
      switch (responseType) {
        case "arraybuffer":
          return response.arrayBuffer();
        case "blob":
          return response.blob();
        case "document":
          return response.text().then((text) => {
            const parser = new DOMParser();
            return parser.parseFromString(text, mimeType);
          });
        case "json":
          return response.json();
        default:
          if (mimeType === void 0) {
            return response.text();
          } else {
            const re = /charset="?([^;"\s]*)"?/i;
            const exec = re.exec(mimeType);
            const label = exec && exec[1] ? exec[1].toLowerCase() : void 0;
            const decoder = new TextDecoder(label);
            return response.arrayBuffer().then((ab) => decoder.decode(ab));
          }
      }
    }).then((data) => {
      Cache.add(url, data);
      const callbacks = loading[url];
      delete loading[url];
      for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
        const callback = callbacks[i2];
        if (callback.onLoad)
          callback.onLoad(data);
      }
    }).catch((err) => {
      const callbacks = loading[url];
      if (callbacks === void 0) {
        this.manager.itemError(url);
        throw err;
      }
      delete loading[url];
      for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
        const callback = callbacks[i2];
        if (callback.onError)
          callback.onError(err);
      }
      this.manager.itemError(url);
    }).finally(() => {
      this.manager.itemEnd(url);
    });
    this.manager.itemStart(url);
  }
  setResponseType(value) {
    this.responseType = value;
    return this;
  }
  setMimeType(value) {
    this.mimeType = value;
    return this;
  }
}
class ImageLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const image = createElementNS("img");
    function onImageLoad() {
      removeEventListeners();
      Cache.add(url, this);
      if (onLoad)
        onLoad(this);
      scope.manager.itemEnd(url);
    }
    function onImageError(event) {
      removeEventListeners();
      if (onError)
        onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }
    function removeEventListeners() {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
    }
    image.addEventListener("load", onImageLoad, false);
    image.addEventListener("error", onImageError, false);
    if (url.slice(0, 5) !== "data:") {
      if (this.crossOrigin !== void 0)
        image.crossOrigin = this.crossOrigin;
    }
    scope.manager.itemStart(url);
    image.src = url;
    return image;
  }
}
class CubeTextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(urls, onLoad, onProgress, onError) {
    const texture = new CubeTexture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    let loaded = 0;
    function loadTexture(i2) {
      loader.load(urls[i2], function(image) {
        texture.images[i2] = image;
        loaded++;
        if (loaded === 6) {
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }
      }, void 0, onError);
    }
    for (let i2 = 0; i2 < urls.length; ++i2) {
      loadTexture(i2);
    }
    return texture;
  }
}
class TextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const texture = new Texture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function(image) {
      texture.image = image;
      texture.needsUpdate = true;
      if (onLoad !== void 0) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  }
}
class Light extends Object3D {
  constructor(color, intensity = 1) {
    super();
    this.type = "Light";
    this.color = new Color(color);
    this.intensity = intensity;
  }
  dispose() {
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== void 0)
      data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== void 0)
      data.object.distance = this.distance;
    if (this.angle !== void 0)
      data.object.angle = this.angle;
    if (this.decay !== void 0)
      data.object.decay = this.decay;
    if (this.penumbra !== void 0)
      data.object.penumbra = this.penumbra;
    if (this.shadow !== void 0)
      data.object.shadow = this.shadow.toJSON();
    return data;
  }
}
Light.prototype.isLight = true;
class HemisphereLight extends Light {
  constructor(skyColor, groundColor, intensity) {
    super(skyColor, intensity);
    this.type = "HemisphereLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.groundColor = new Color(groundColor);
  }
  copy(source) {
    Light.prototype.copy.call(this, source);
    this.groundColor.copy(source.groundColor);
    return this;
  }
}
HemisphereLight.prototype.isHemisphereLight = true;
const _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
const _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
const _lookTarget$1 = /* @__PURE__ */ new Vector3();
class LightShadow {
  constructor(camera) {
    this.camera = camera;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.blurSamples = 8;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [
      new Vector4(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(light) {
    const shadowCamera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
    shadowCamera.position.copy(_lightPositionWorld$1);
    _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
    shadowCamera.lookAt(_lookTarget$1);
    shadowCamera.updateMatrixWorld();
    _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
    shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
    shadowMatrix.multiply(shadowCamera.projectionMatrix);
    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
  }
  getViewport(viewportIndex) {
    return this._viewports[viewportIndex];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    if (this.map) {
      this.map.dispose();
    }
    if (this.mapPass) {
      this.mapPass.dispose();
    }
  }
  copy(source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const object = {};
    if (this.bias !== 0)
      object.bias = this.bias;
    if (this.normalBias !== 0)
      object.normalBias = this.normalBias;
    if (this.radius !== 1)
      object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
      object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
}
class SpotLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500));
    this.focus = 1;
  }
  updateMatrices(light) {
    const camera = this.camera;
    const fov2 = RAD2DEG * 2 * light.angle * this.focus;
    const aspect2 = this.mapSize.width / this.mapSize.height;
    const far = light.distance || camera.far;
    if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
      camera.fov = fov2;
      camera.aspect = aspect2;
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    super.updateMatrices(light);
  }
  copy(source) {
    super.copy(source);
    this.focus = source.focus;
    return this;
  }
}
SpotLightShadow.prototype.isSpotLightShadow = true;
class SpotLight extends Light {
  constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
    super(color, intensity);
    this.type = "SpotLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.distance = distance;
    this.angle = angle;
    this.penumbra = penumbra;
    this.decay = decay;
    this.shadow = new SpotLightShadow();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(power) {
    this.intensity = power / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source) {
    super.copy(source);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
}
SpotLight.prototype.isSpotLight = true;
const _projScreenMatrix = /* @__PURE__ */ new Matrix4();
const _lightPositionWorld = /* @__PURE__ */ new Vector3();
const _lookTarget = /* @__PURE__ */ new Vector3();
class PointLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500));
    this._frameExtents = new Vector2(4, 2);
    this._viewportCount = 6;
    this._viewports = [
      new Vector4(2, 1, 1, 1),
      new Vector4(0, 1, 1, 1),
      new Vector4(3, 1, 1, 1),
      new Vector4(1, 1, 1, 1),
      new Vector4(3, 0, 1, 1),
      new Vector4(1, 0, 1, 1)
    ];
    this._cubeDirections = [
      new Vector3(1, 0, 0),
      new Vector3(-1, 0, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1),
      new Vector3(0, 1, 0),
      new Vector3(0, -1, 0)
    ];
    this._cubeUps = [
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1)
    ];
  }
  updateMatrices(light, viewportIndex = 0) {
    const camera = this.camera;
    const shadowMatrix = this.matrix;
    const far = light.distance || camera.far;
    if (far !== camera.far) {
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    camera.position.copy(_lightPositionWorld);
    _lookTarget.copy(camera.position);
    _lookTarget.add(this._cubeDirections[viewportIndex]);
    camera.up.copy(this._cubeUps[viewportIndex]);
    camera.lookAt(_lookTarget);
    camera.updateMatrixWorld();
    shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix);
  }
}
PointLightShadow.prototype.isPointLightShadow = true;
class PointLight extends Light {
  constructor(color, intensity, distance = 0, decay = 1) {
    super(color, intensity);
    this.type = "PointLight";
    this.distance = distance;
    this.decay = decay;
    this.shadow = new PointLightShadow();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(power) {
    this.intensity = power / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source) {
    super.copy(source);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
}
PointLight.prototype.isPointLight = true;
class DirectionalLightShadow extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
  }
}
DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
class DirectionalLight extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source) {
    super.copy(source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
}
DirectionalLight.prototype.isDirectionalLight = true;
class AmbientLight extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.type = "AmbientLight";
  }
}
AmbientLight.prototype.isAmbientLight = true;
class RectAreaLight extends Light {
  constructor(color, intensity, width = 10, height = 10) {
    super(color, intensity);
    this.type = "RectAreaLight";
    this.width = width;
    this.height = height;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(power) {
    this.intensity = power / (this.width * this.height * Math.PI);
  }
  copy(source) {
    super.copy(source);
    this.width = source.width;
    this.height = source.height;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.width = this.width;
    data.object.height = this.height;
    return data;
  }
}
RectAreaLight.prototype.isRectAreaLight = true;
class SphericalHarmonics3 {
  constructor() {
    this.coefficients = [];
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients.push(new Vector3());
    }
  }
  set(coefficients) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].copy(coefficients[i2]);
    }
    return this;
  }
  zero() {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].set(0, 0, 0);
    }
    return this;
  }
  getAt(normal, target) {
    const x2 = normal.x, y2 = normal.y, z2 = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.282095);
    target.addScaledVector(coeff[1], 0.488603 * y2);
    target.addScaledVector(coeff[2], 0.488603 * z2);
    target.addScaledVector(coeff[3], 0.488603 * x2);
    target.addScaledVector(coeff[4], 1.092548 * (x2 * y2));
    target.addScaledVector(coeff[5], 1.092548 * (y2 * z2));
    target.addScaledVector(coeff[6], 0.315392 * (3 * z2 * z2 - 1));
    target.addScaledVector(coeff[7], 1.092548 * (x2 * z2));
    target.addScaledVector(coeff[8], 0.546274 * (x2 * x2 - y2 * y2));
    return target;
  }
  getIrradianceAt(normal, target) {
    const x2 = normal.x, y2 = normal.y, z2 = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.886227);
    target.addScaledVector(coeff[1], 2 * 0.511664 * y2);
    target.addScaledVector(coeff[2], 2 * 0.511664 * z2);
    target.addScaledVector(coeff[3], 2 * 0.511664 * x2);
    target.addScaledVector(coeff[4], 2 * 0.429043 * x2 * y2);
    target.addScaledVector(coeff[5], 2 * 0.429043 * y2 * z2);
    target.addScaledVector(coeff[6], 0.743125 * z2 * z2 - 0.247708);
    target.addScaledVector(coeff[7], 2 * 0.429043 * x2 * z2);
    target.addScaledVector(coeff[8], 0.429043 * (x2 * x2 - y2 * y2));
    return target;
  }
  add(sh) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].add(sh.coefficients[i2]);
    }
    return this;
  }
  addScaledSH(sh, s2) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].addScaledVector(sh.coefficients[i2], s2);
    }
    return this;
  }
  scale(s2) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].multiplyScalar(s2);
    }
    return this;
  }
  lerp(sh, alpha) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].lerp(sh.coefficients[i2], alpha);
    }
    return this;
  }
  equals(sh) {
    for (let i2 = 0; i2 < 9; i2++) {
      if (!this.coefficients[i2].equals(sh.coefficients[i2])) {
        return false;
      }
    }
    return true;
  }
  copy(sh) {
    return this.set(sh.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(array, offset = 0) {
    const coefficients = this.coefficients;
    for (let i2 = 0; i2 < 9; i2++) {
      coefficients[i2].fromArray(array, offset + i2 * 3);
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const coefficients = this.coefficients;
    for (let i2 = 0; i2 < 9; i2++) {
      coefficients[i2].toArray(array, offset + i2 * 3);
    }
    return array;
  }
  static getBasisAt(normal, shBasis) {
    const x2 = normal.x, y2 = normal.y, z2 = normal.z;
    shBasis[0] = 0.282095;
    shBasis[1] = 0.488603 * y2;
    shBasis[2] = 0.488603 * z2;
    shBasis[3] = 0.488603 * x2;
    shBasis[4] = 1.092548 * x2 * y2;
    shBasis[5] = 1.092548 * y2 * z2;
    shBasis[6] = 0.315392 * (3 * z2 * z2 - 1);
    shBasis[7] = 1.092548 * x2 * z2;
    shBasis[8] = 0.546274 * (x2 * x2 - y2 * y2);
  }
}
SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;
class LightProbe extends Light {
  constructor(sh = new SphericalHarmonics3(), intensity = 1) {
    super(void 0, intensity);
    this.sh = sh;
  }
  copy(source) {
    super.copy(source);
    this.sh.copy(source.sh);
    return this;
  }
  fromJSON(json) {
    this.intensity = json.intensity;
    this.sh.fromArray(json.sh);
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.sh = this.sh.toArray();
    return data;
  }
}
LightProbe.prototype.isLightProbe = true;
class LoaderUtils {
  static decodeText(array) {
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array);
    }
    let s2 = "";
    for (let i2 = 0, il = array.length; i2 < il; i2++) {
      s2 += String.fromCharCode(array[i2]);
    }
    try {
      return decodeURIComponent(escape(s2));
    } catch (e2) {
      return s2;
    }
  }
  static extractUrlBase(url) {
    const index = url.lastIndexOf("/");
    if (index === -1)
      return "./";
    return url.slice(0, index + 1);
  }
  static resolveURL(url, path) {
    if (typeof url !== "string" || url === "")
      return "";
    if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
      path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
    }
    if (/^(https?:)?\/\//i.test(url))
      return url;
    if (/^data:.*,.*$/i.test(url))
      return url;
    if (/^blob:.*$/i.test(url))
      return url;
    return path + url;
  }
}
class InstancedBufferGeometry extends BufferGeometry {
  constructor() {
    super();
    this.type = "InstancedBufferGeometry";
    this.instanceCount = Infinity;
  }
  copy(source) {
    super.copy(source);
    this.instanceCount = source.instanceCount;
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const data = super.toJSON(this);
    data.instanceCount = this.instanceCount;
    data.isInstancedBufferGeometry = true;
    return data;
  }
}
InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;
class ImageBitmapLoader extends Loader {
  constructor(manager) {
    super(manager);
    if (typeof createImageBitmap === "undefined") {
      console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
    }
    if (typeof fetch === "undefined") {
      console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
    }
    this.options = { premultiplyAlpha: "none" };
  }
  setOptions(options) {
    this.options = options;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const fetchOptions = {};
    fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
    fetchOptions.headers = this.requestHeader;
    fetch(url, fetchOptions).then(function(res) {
      return res.blob();
    }).then(function(blob) {
      return createImageBitmap(blob, Object.assign(scope.options, { colorSpaceConversion: "none" }));
    }).then(function(imageBitmap) {
      Cache.add(url, imageBitmap);
      if (onLoad)
        onLoad(imageBitmap);
      scope.manager.itemEnd(url);
    }).catch(function(e2) {
      if (onError)
        onError(e2);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    });
    scope.manager.itemStart(url);
  }
}
ImageBitmapLoader.prototype.isImageBitmapLoader = true;
let _context;
const AudioContext = {
  getContext: function() {
    if (_context === void 0) {
      _context = new (window.AudioContext || window.webkitAudioContext)();
    }
    return _context;
  },
  setContext: function(value) {
    _context = value;
  }
};
class AudioLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(buffer) {
      try {
        const bufferCopy = buffer.slice(0);
        const context = AudioContext.getContext();
        context.decodeAudioData(bufferCopy, function(audioBuffer) {
          onLoad(audioBuffer);
        });
      } catch (e2) {
        if (onError) {
          onError(e2);
        } else {
          console.error(e2);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
}
class HemisphereLightProbe extends LightProbe {
  constructor(skyColor, groundColor, intensity = 1) {
    super(void 0, intensity);
    const color1 = new Color().set(skyColor);
    const color2 = new Color().set(groundColor);
    const sky = new Vector3(color1.r, color1.g, color1.b);
    const ground = new Vector3(color2.r, color2.g, color2.b);
    const c0 = Math.sqrt(Math.PI);
    const c1 = c0 * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
    this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
  }
}
HemisphereLightProbe.prototype.isHemisphereLightProbe = true;
class AmbientLightProbe extends LightProbe {
  constructor(color, intensity = 1) {
    super(void 0, intensity);
    const color1 = new Color().set(color);
    this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
}
AmbientLightProbe.prototype.isAmbientLightProbe = true;
class Clock {
  constructor(autoStart = true) {
    this.autoStart = autoStart;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
  }
  start() {
    this.startTime = now();
    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
  }
  stop() {
    this.getElapsedTime();
    this.running = false;
    this.autoStart = false;
  }
  getElapsedTime() {
    this.getDelta();
    return this.elapsedTime;
  }
  getDelta() {
    let diff2 = 0;
    if (this.autoStart && !this.running) {
      this.start();
      return 0;
    }
    if (this.running) {
      const newTime = now();
      diff2 = (newTime - this.oldTime) / 1e3;
      this.oldTime = newTime;
      this.elapsedTime += diff2;
    }
    return diff2;
  }
}
function now() {
  return (typeof performance === "undefined" ? Date : performance).now();
}
const _position$1 = /* @__PURE__ */ new Vector3();
const _quaternion$1 = /* @__PURE__ */ new Quaternion();
const _scale$1 = /* @__PURE__ */ new Vector3();
const _orientation$1 = /* @__PURE__ */ new Vector3();
class AudioListener extends Object3D {
  constructor() {
    super();
    this.type = "AudioListener";
    this.context = AudioContext.getContext();
    this.gain = this.context.createGain();
    this.gain.connect(this.context.destination);
    this.filter = null;
    this.timeDelta = 0;
    this._clock = new Clock();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
      this.gain.connect(this.context.destination);
      this.filter = null;
    }
    return this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(value) {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
    } else {
      this.gain.disconnect(this.context.destination);
    }
    this.filter = value;
    this.gain.connect(this.filter);
    this.filter.connect(this.context.destination);
    return this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    const listener = this.context.listener;
    const up = this.up;
    this.timeDelta = this._clock.getDelta();
    this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);
    _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);
    if (listener.positionX) {
      const endTime = this.context.currentTime + this.timeDelta;
      listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
      listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
      listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
      listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
      listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
      listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
      listener.upX.linearRampToValueAtTime(up.x, endTime);
      listener.upY.linearRampToValueAtTime(up.y, endTime);
      listener.upZ.linearRampToValueAtTime(up.z, endTime);
    } else {
      listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
      listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);
    }
  }
}
class Audio extends Object3D {
  constructor(listener) {
    super();
    this.type = "Audio";
    this.listener = listener;
    this.context = listener.context;
    this.gain = this.context.createGain();
    this.gain.connect(listener.getInput());
    this.autoplay = false;
    this.buffer = null;
    this.detune = 0;
    this.loop = false;
    this.loopStart = 0;
    this.loopEnd = 0;
    this.offset = 0;
    this.duration = void 0;
    this.playbackRate = 1;
    this.isPlaying = false;
    this.hasPlaybackControl = true;
    this.source = null;
    this.sourceType = "empty";
    this._startedAt = 0;
    this._progress = 0;
    this._connected = false;
    this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(audioNode) {
    this.hasPlaybackControl = false;
    this.sourceType = "audioNode";
    this.source = audioNode;
    this.connect();
    return this;
  }
  setMediaElementSource(mediaElement) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaNode";
    this.source = this.context.createMediaElementSource(mediaElement);
    this.connect();
    return this;
  }
  setMediaStreamSource(mediaStream) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaStreamNode";
    this.source = this.context.createMediaStreamSource(mediaStream);
    this.connect();
    return this;
  }
  setBuffer(audioBuffer) {
    this.buffer = audioBuffer;
    this.sourceType = "buffer";
    if (this.autoplay)
      this.play();
    return this;
  }
  play(delay = 0) {
    if (this.isPlaying === true) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + delay;
    const source = this.context.createBufferSource();
    source.buffer = this.buffer;
    source.loop = this.loop;
    source.loopStart = this.loopStart;
    source.loopEnd = this.loopEnd;
    source.onended = this.onEnded.bind(this);
    source.start(this._startedAt, this._progress + this.offset, this.duration);
    this.isPlaying = true;
    this.source = source;
    this.setDetune(this.detune);
    this.setPlaybackRate(this.playbackRate);
    return this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    if (this.isPlaying === true) {
      this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
      if (this.loop === true) {
        this._progress = this._progress % (this.duration || this.buffer.duration);
      }
      this.source.stop();
      this.source.onended = null;
      this.isPlaying = false;
    }
    return this;
  }
  stop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._progress = 0;
    this.source.stop();
    this.source.onended = null;
    this.isPlaying = false;
    return this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let i2 = 1, l2 = this.filters.length; i2 < l2; i2++) {
        this.filters[i2 - 1].connect(this.filters[i2]);
      }
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }
    this._connected = true;
    return this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let i2 = 1, l2 = this.filters.length; i2 < l2; i2++) {
        this.filters[i2 - 1].disconnect(this.filters[i2]);
      }
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }
    this._connected = false;
    return this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(value) {
    if (!value)
      value = [];
    if (this._connected === true) {
      this.disconnect();
      this.filters = value.slice();
      this.connect();
    } else {
      this.filters = value.slice();
    }
    return this;
  }
  setDetune(value) {
    this.detune = value;
    if (this.source.detune === void 0)
      return;
    if (this.isPlaying === true) {
      this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
    }
    return this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(filter) {
    return this.setFilters(filter ? [filter] : []);
  }
  setPlaybackRate(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.playbackRate = value;
    if (this.isPlaying === true) {
      this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
    }
    return this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = false;
  }
  getLoop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return false;
    }
    return this.loop;
  }
  setLoop(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.loop = value;
    if (this.isPlaying === true) {
      this.source.loop = this.loop;
    }
    return this;
  }
  setLoopStart(value) {
    this.loopStart = value;
    return this;
  }
  setLoopEnd(value) {
    this.loopEnd = value;
    return this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
}
const _position = /* @__PURE__ */ new Vector3();
const _quaternion = /* @__PURE__ */ new Quaternion();
const _scale = /* @__PURE__ */ new Vector3();
const _orientation = /* @__PURE__ */ new Vector3();
class PositionalAudio extends Audio {
  constructor(listener) {
    super(listener);
    this.panner = this.context.createPanner();
    this.panner.panningModel = "HRTF";
    this.panner.connect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(value) {
    this.panner.refDistance = value;
    return this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(value) {
    this.panner.rolloffFactor = value;
    return this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(value) {
    this.panner.distanceModel = value;
    return this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(value) {
    this.panner.maxDistance = value;
    return this;
  }
  setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
    this.panner.coneInnerAngle = coneInnerAngle;
    this.panner.coneOuterAngle = coneOuterAngle;
    this.panner.coneOuterGain = coneOuterGain;
    return this;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.hasPlaybackControl === true && this.isPlaying === false)
      return;
    this.matrixWorld.decompose(_position, _quaternion, _scale);
    _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
    const panner = this.panner;
    if (panner.positionX) {
      const endTime = this.context.currentTime + this.listener.timeDelta;
      panner.positionX.linearRampToValueAtTime(_position.x, endTime);
      panner.positionY.linearRampToValueAtTime(_position.y, endTime);
      panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
      panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
      panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
      panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
    } else {
      panner.setPosition(_position.x, _position.y, _position.z);
      panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
    }
  }
}
class PropertyMixer {
  constructor(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    let mixFunction, mixFunctionAdditive, setIdentity;
    switch (typeName) {
      case "quaternion":
        mixFunction = this._slerp;
        mixFunctionAdditive = this._slerpAdditive;
        setIdentity = this._setAdditiveIdentityQuaternion;
        this.buffer = new Float64Array(valueSize * 6);
        this._workIndex = 5;
        break;
      case "string":
      case "bool":
        mixFunction = this._select;
        mixFunctionAdditive = this._select;
        setIdentity = this._setAdditiveIdentityOther;
        this.buffer = new Array(valueSize * 5);
        break;
      default:
        mixFunction = this._lerp;
        mixFunctionAdditive = this._lerpAdditive;
        setIdentity = this._setAdditiveIdentityNumeric;
        this.buffer = new Float64Array(valueSize * 5);
    }
    this._mixBufferRegion = mixFunction;
    this._mixBufferRegionAdditive = mixFunctionAdditive;
    this._setIdentity = setIdentity;
    this._origIndex = 3;
    this._addIndex = 4;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    this.useCount = 0;
    this.referenceCount = 0;
  }
  accumulate(accuIndex, weight) {
    const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
    let currentWeight = this.cumulativeWeight;
    if (currentWeight === 0) {
      for (let i2 = 0; i2 !== stride; ++i2) {
        buffer[offset + i2] = buffer[i2];
      }
      currentWeight = weight;
    } else {
      currentWeight += weight;
      const mix = weight / currentWeight;
      this._mixBufferRegion(buffer, offset, 0, mix, stride);
    }
    this.cumulativeWeight = currentWeight;
  }
  accumulateAdditive(weight) {
    const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
    if (this.cumulativeWeightAdditive === 0) {
      this._setIdentity();
    }
    this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
    this.cumulativeWeightAdditive += weight;
  }
  apply(accuIndex) {
    const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    if (weight < 1) {
      const originalValueOffset = stride * this._origIndex;
      this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
    }
    if (weightAdditive > 0) {
      this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
    }
    for (let i2 = stride, e2 = stride + stride; i2 !== e2; ++i2) {
      if (buffer[i2] !== buffer[i2 + stride]) {
        binding.setValue(buffer, offset);
        break;
      }
    }
  }
  saveOriginalState() {
    const binding = this.binding;
    const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
    binding.getValue(buffer, originalValueOffset);
    for (let i2 = stride, e2 = originalValueOffset; i2 !== e2; ++i2) {
      buffer[i2] = buffer[originalValueOffset + i2 % stride];
    }
    this._setIdentity();
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
  }
  restoreOriginalState() {
    const originalValueOffset = this.valueSize * 3;
    this.binding.setValue(this.buffer, originalValueOffset);
  }
  _setAdditiveIdentityNumeric() {
    const startIndex = this._addIndex * this.valueSize;
    const endIndex = startIndex + this.valueSize;
    for (let i2 = startIndex; i2 < endIndex; i2++) {
      this.buffer[i2] = 0;
    }
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric();
    this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const startIndex = this._origIndex * this.valueSize;
    const targetIndex = this._addIndex * this.valueSize;
    for (let i2 = 0; i2 < this.valueSize; i2++) {
      this.buffer[targetIndex + i2] = this.buffer[startIndex + i2];
    }
  }
  _select(buffer, dstOffset, srcOffset, t2, stride) {
    if (t2 >= 0.5) {
      for (let i2 = 0; i2 !== stride; ++i2) {
        buffer[dstOffset + i2] = buffer[srcOffset + i2];
      }
    }
  }
  _slerp(buffer, dstOffset, srcOffset, t2) {
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t2);
  }
  _slerpAdditive(buffer, dstOffset, srcOffset, t2, stride) {
    const workOffset = this._workIndex * stride;
    Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t2);
  }
  _lerp(buffer, dstOffset, srcOffset, t2, stride) {
    const s2 = 1 - t2;
    for (let i2 = 0; i2 !== stride; ++i2) {
      const j2 = dstOffset + i2;
      buffer[j2] = buffer[j2] * s2 + buffer[srcOffset + i2] * t2;
    }
  }
  _lerpAdditive(buffer, dstOffset, srcOffset, t2, stride) {
    for (let i2 = 0; i2 !== stride; ++i2) {
      const j2 = dstOffset + i2;
      buffer[j2] = buffer[j2] + buffer[srcOffset + i2] * t2;
    }
  }
}
const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
const _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
const _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
const _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
const _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
const _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
const _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
const _supportedObjectNames = ["material", "materials", "bones"];
class Composite {
  constructor(targetGroup, path, optionalParsedPath) {
    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path, parsedPath);
  }
  getValue(array, offset) {
    this.bind();
    const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
    if (binding !== void 0)
      binding.getValue(array, offset);
  }
  setValue(array, offset) {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].setValue(array, offset);
    }
  }
  bind() {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].bind();
    }
  }
  unbind() {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].unbind();
    }
  }
}
class PropertyBinding {
  constructor(rootNode, path, parsedPath) {
    this.path = path;
    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
    this.rootNode = rootNode;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
  static create(root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path, parsedPath);
    } else {
      return new PropertyBinding.Composite(root, path, parsedPath);
    }
  }
  static sanitizeNodeName(name) {
    return name.replace(/\s/g, "_").replace(_reservedRe, "");
  }
  static parseTrackName(trackName) {
    const matches = _trackRe.exec(trackName);
    if (matches === null) {
      throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
    }
    const results = {
      nodeName: matches[2],
      objectName: matches[3],
      objectIndex: matches[4],
      propertyName: matches[5],
      propertyIndex: matches[6]
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
    if (lastDot !== void 0 && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1);
      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }
    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
    }
    return results;
  }
  static findNode(root, nodeName) {
    if (nodeName === void 0 || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    }
    if (root.skeleton) {
      const bone = root.skeleton.getBoneByName(nodeName);
      if (bone !== void 0) {
        return bone;
      }
    }
    if (root.children) {
      const searchNodeSubtree = function(children) {
        for (let i2 = 0; i2 < children.length; i2++) {
          const childNode = children[i2];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          const result = searchNodeSubtree(childNode.children);
          if (result)
            return result;
        }
        return null;
      };
      const subTreeNode = searchNodeSubtree(root.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  _getValue_direct(buffer, offset) {
    buffer[offset] = this.targetObject[this.propertyName];
  }
  _getValue_array(buffer, offset) {
    const source = this.resolvedProperty;
    for (let i2 = 0, n2 = source.length; i2 !== n2; ++i2) {
      buffer[offset++] = source[i2];
    }
  }
  _getValue_arrayElement(buffer, offset) {
    buffer[offset] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(buffer, offset) {
    this.resolvedProperty.toArray(buffer, offset);
  }
  _setValue_direct(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
  }
  _setValue_direct_setNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_array(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
      dest[i2] = buffer[offset++];
    }
  }
  _setValue_array_setNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
      dest[i2] = buffer[offset++];
    }
    this.targetObject.needsUpdate = true;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
      dest[i2] = buffer[offset++];
    }
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_arrayElement(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
  }
  _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_fromArray(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
  }
  _setValue_fromArray_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.needsUpdate = true;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset);
  }
  _setValue_unbound(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  }
  bind() {
    let targetObject = this.node;
    const parsedPath = this.parsedPath;
    const objectName = parsedPath.objectName;
    const propertyName = parsedPath.propertyName;
    let propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
      this.node = targetObject;
    }
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (!targetObject) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (objectName) {
      let objectIndex = parsedPath.objectIndex;
      switch (objectName) {
        case "materials":
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case "bones":
          if (!targetObject.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (let i2 = 0; i2 < targetObject.length; i2++) {
            if (targetObject[i2].name === objectIndex) {
              objectIndex = i2;
              break;
            }
          }
          break;
        default:
          if (targetObject[objectName] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== void 0) {
        if (targetObject[objectIndex] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }
    const nodeProperty = targetObject[propertyName];
    if (nodeProperty === void 0) {
      const nodeName = parsedPath.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
      return;
    }
    let versioning = this.Versioning.None;
    this.targetObject = targetObject;
    if (targetObject.needsUpdate !== void 0) {
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    }
    let bindingType = this.BindingType.Direct;
    if (propertyIndex !== void 0) {
      if (propertyName === "morphTargetInfluences") {
        if (!targetObject.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (targetObject.geometry.isBufferGeometry) {
          if (!targetObject.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
          }
        } else {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
          return;
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  }
  unbind() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
}
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [
  PropertyBinding.prototype._getValue_direct,
  PropertyBinding.prototype._getValue_array,
  PropertyBinding.prototype._getValue_arrayElement,
  PropertyBinding.prototype._getValue_toArray
];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
  [
    PropertyBinding.prototype._setValue_direct,
    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    PropertyBinding.prototype._setValue_array,
    PropertyBinding.prototype._setValue_array_setNeedsUpdate,
    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    PropertyBinding.prototype._setValue_arrayElement,
    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    PropertyBinding.prototype._setValue_fromArray,
    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class AnimationAction {
  constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot;
    this.blendMode = blendMode;
    const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
    const interpolantSettings = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
    for (let i2 = 0; i2 !== nTracks; ++i2) {
      const interpolant = tracks[i2].createInterpolant(null);
      interpolants[i2] = interpolant;
      interpolant.settings = interpolantSettings;
    }
    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants;
    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null;
    this._byClipCacheIndex = null;
    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1;
    this._startTime = null;
    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity;
    this.paused = false;
    this.enabled = true;
    this.clampWhenFinished = false;
    this.zeroSlopeAtStart = true;
    this.zeroSlopeAtEnd = true;
  }
  play() {
    this._mixer._activateAction(this);
    return this;
  }
  stop() {
    this._mixer._deactivateAction(this);
    return this.reset();
  }
  reset() {
    this.paused = false;
    this.enabled = true;
    this.time = 0;
    this._loopCount = -1;
    this._startTime = null;
    return this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(time) {
    this._startTime = time;
    return this;
  }
  setLoop(mode, repetitions) {
    this.loop = mode;
    this.repetitions = repetitions;
    return this;
  }
  setEffectiveWeight(weight) {
    this.weight = weight;
    this._effectiveWeight = this.enabled ? weight : 0;
    return this.stopFading();
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(duration) {
    return this._scheduleFading(duration, 0, 1);
  }
  fadeOut(duration) {
    return this._scheduleFading(duration, 1, 0);
  }
  crossFadeFrom(fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration);
    this.fadeIn(duration);
    if (warp) {
      const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
      fadeOutAction.warp(1, startEndRatio, duration);
      this.warp(endStartRatio, 1, duration);
    }
    return this;
  }
  crossFadeTo(fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp);
  }
  stopFading() {
    const weightInterpolant = this._weightInterpolant;
    if (weightInterpolant !== null) {
      this._weightInterpolant = null;
      this._mixer._takeBackControlInterpolant(weightInterpolant);
    }
    return this;
  }
  setEffectiveTimeScale(timeScale) {
    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 : timeScale;
    return this.stopWarping();
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(duration) {
    this.timeScale = this._clip.duration / duration;
    return this.stopWarping();
  }
  syncWith(action) {
    this.time = action.time;
    this.timeScale = action.timeScale;
    return this.stopWarping();
  }
  halt(duration) {
    return this.warp(this._effectiveTimeScale, 0, duration);
  }
  warp(startTimeScale, endTimeScale, duration) {
    const mixer = this._mixer, now2 = mixer.time, timeScale = this.timeScale;
    let interpolant = this._timeScaleInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._timeScaleInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now2;
    times[1] = now2 + duration;
    values[0] = startTimeScale / timeScale;
    values[1] = endTimeScale / timeScale;
    return this;
  }
  stopWarping() {
    const timeScaleInterpolant = this._timeScaleInterpolant;
    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null;
      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
    }
    return this;
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(time, deltaTime, timeDirection, accuIndex) {
    if (!this.enabled) {
      this._updateWeight(time);
      return;
    }
    const startTime = this._startTime;
    if (startTime !== null) {
      const timeRunning = (time - startTime) * timeDirection;
      if (timeRunning < 0 || timeDirection === 0) {
        return;
      }
      this._startTime = null;
      deltaTime = timeDirection * timeRunning;
    }
    deltaTime *= this._updateTimeScale(time);
    const clipTime = this._updateTime(deltaTime);
    const weight = this._updateWeight(time);
    if (weight > 0) {
      const interpolants = this._interpolants;
      const propertyMixers = this._propertyBindings;
      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let j2 = 0, m2 = interpolants.length; j2 !== m2; ++j2) {
            interpolants[j2].evaluate(clipTime);
            propertyMixers[j2].accumulateAdditive(weight);
          }
          break;
        case NormalAnimationBlendMode:
        default:
          for (let j2 = 0, m2 = interpolants.length; j2 !== m2; ++j2) {
            interpolants[j2].evaluate(clipTime);
            propertyMixers[j2].accumulate(accuIndex, weight);
          }
      }
    }
  }
  _updateWeight(time) {
    let weight = 0;
    if (this.enabled) {
      weight = this.weight;
      const interpolant = this._weightInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        weight *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopFading();
          if (interpolantValue === 0) {
            this.enabled = false;
          }
        }
      }
    }
    this._effectiveWeight = weight;
    return weight;
  }
  _updateTimeScale(time) {
    let timeScale = 0;
    if (!this.paused) {
      timeScale = this.timeScale;
      const interpolant = this._timeScaleInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        timeScale *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopWarping();
          if (timeScale === 0) {
            this.paused = true;
          } else {
            this.timeScale = timeScale;
          }
        }
      }
    }
    this._effectiveTimeScale = timeScale;
    return timeScale;
  }
  _updateTime(deltaTime) {
    const duration = this._clip.duration;
    const loop = this.loop;
    let time = this.time + deltaTime;
    let loopCount = this._loopCount;
    const pingPong = loop === LoopPingPong;
    if (deltaTime === 0) {
      if (loopCount === -1)
        return time;
      return pingPong && (loopCount & 1) === 1 ? duration - time : time;
    }
    if (loop === LoopOnce) {
      if (loopCount === -1) {
        this._loopCount = 0;
        this._setEndings(true, true, false);
      }
      handle_stop: {
        if (time >= duration) {
          time = duration;
        } else if (time < 0) {
          time = 0;
        } else {
          this.time = time;
          break handle_stop;
        }
        if (this.clampWhenFinished)
          this.paused = true;
        else
          this.enabled = false;
        this.time = time;
        this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: deltaTime < 0 ? -1 : 1
        });
      }
    } else {
      if (loopCount === -1) {
        if (deltaTime >= 0) {
          loopCount = 0;
          this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
          this._setEndings(this.repetitions === 0, true, pingPong);
        }
      }
      if (time >= duration || time < 0) {
        const loopDelta = Math.floor(time / duration);
        time -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        const pending = this.repetitions - loopCount;
        if (pending <= 0) {
          if (this.clampWhenFinished)
            this.paused = true;
          else
            this.enabled = false;
          time = deltaTime > 0 ? duration : 0;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: deltaTime > 0 ? 1 : -1
          });
        } else {
          if (pending === 1) {
            const atStart = deltaTime < 0;
            this._setEndings(atStart, !atStart, pingPong);
          } else {
            this._setEndings(false, false, pingPong);
          }
          this._loopCount = loopCount;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta
          });
        }
      } else {
        this.time = time;
      }
      if (pingPong && (loopCount & 1) === 1) {
        return duration - time;
      }
    }
    return time;
  }
  _setEndings(atStart, atEnd, pingPong) {
    const settings = this._interpolantSettings;
    if (pingPong) {
      settings.endingStart = ZeroSlopeEnding;
      settings.endingEnd = ZeroSlopeEnding;
    } else {
      if (atStart) {
        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingStart = WrapAroundEnding;
      }
      if (atEnd) {
        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingEnd = WrapAroundEnding;
      }
    }
  }
  _scheduleFading(duration, weightNow, weightThen) {
    const mixer = this._mixer, now2 = mixer.time;
    let interpolant = this._weightInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._weightInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now2;
    values[0] = weightNow;
    times[1] = now2 + duration;
    values[1] = weightThen;
    return this;
  }
}
class AnimationMixer extends EventDispatcher {
  constructor(root) {
    super();
    this._root = root;
    this._initMemoryManager();
    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1;
  }
  _bindAction(action, prototypeAction) {
    const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
    let bindingsByName = bindingsByRoot[rootUuid];
    if (bindingsByName === void 0) {
      bindingsByName = {};
      bindingsByRoot[rootUuid] = bindingsByName;
    }
    for (let i2 = 0; i2 !== nTracks; ++i2) {
      const track = tracks[i2], trackName = track.name;
      let binding = bindingsByName[trackName];
      if (binding !== void 0) {
        ++binding.referenceCount;
        bindings[i2] = binding;
      } else {
        binding = bindings[i2];
        if (binding !== void 0) {
          if (binding._cacheIndex === null) {
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
          }
          continue;
        }
        const path = prototypeAction && prototypeAction._propertyBindings[i2].binding.parsedPath;
        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
        ++binding.referenceCount;
        this._addInactiveBinding(binding, rootUuid, trackName);
        bindings[i2] = binding;
      }
      interpolants[i2].resultBuffer = binding.buffer;
    }
  }
  _activateAction(action) {
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
        this._addInactiveAction(action, clipUuid, rootUuid);
      }
      const bindings = action._propertyBindings;
      for (let i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
        const binding = bindings[i2];
        if (binding.useCount++ === 0) {
          this._lendBinding(binding);
          binding.saveOriginalState();
        }
      }
      this._lendAction(action);
    }
  }
  _deactivateAction(action) {
    if (this._isActiveAction(action)) {
      const bindings = action._propertyBindings;
      for (let i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
        const binding = bindings[i2];
        if (--binding.useCount === 0) {
          binding.restoreOriginalState();
          this._takeBackBinding(binding);
        }
      }
      this._takeBackAction(action);
    }
  }
  _initMemoryManager() {
    this._actions = [];
    this._nActiveActions = 0;
    this._actionsByClip = {};
    this._bindings = [];
    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {};
    this._controlInterpolants = [];
    this._nActiveControlInterpolants = 0;
    const scope = this;
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length;
        },
        get inUse() {
          return scope._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return scope._bindings.length;
        },
        get inUse() {
          return scope._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length;
        },
        get inUse() {
          return scope._nActiveControlInterpolants;
        }
      }
    };
  }
  _isActiveAction(action) {
    const index = action._cacheIndex;
    return index !== null && index < this._nActiveActions;
  }
  _addInactiveAction(action, clipUuid, rootUuid) {
    const actions = this._actions, actionsByClip = this._actionsByClip;
    let actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip === void 0) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {}
      };
      action._byClipCacheIndex = 0;
      actionsByClip[clipUuid] = actionsForClip;
    } else {
      const knownActions = actionsForClip.knownActions;
      action._byClipCacheIndex = knownActions.length;
      knownActions.push(action);
    }
    action._cacheIndex = actions.length;
    actions.push(action);
    actionsForClip.actionByRoot[rootUuid] = action;
  }
  _removeInactiveAction(action) {
    const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
    lastInactiveAction._cacheIndex = cacheIndex;
    actions[cacheIndex] = lastInactiveAction;
    actions.pop();
    action._cacheIndex = null;
    const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
    knownActionsForClip.pop();
    action._byClipCacheIndex = null;
    const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
    delete actionByRoot[rootUuid];
    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid];
    }
    this._removeInactiveBindingsForAction(action);
  }
  _removeInactiveBindingsForAction(action) {
    const bindings = action._propertyBindings;
    for (let i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
      const binding = bindings[i2];
      if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding);
      }
    }
  }
  _lendAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
    action._cacheIndex = lastActiveIndex;
    actions[lastActiveIndex] = action;
    firstInactiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = firstInactiveAction;
  }
  _takeBackAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
    action._cacheIndex = firstInactiveIndex;
    actions[firstInactiveIndex] = action;
    lastActiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = lastActiveAction;
  }
  _addInactiveBinding(binding, rootUuid, trackName) {
    const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
    let bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName === void 0) {
      bindingByName = {};
      bindingsByRoot[rootUuid] = bindingByName;
    }
    bindingByName[trackName] = binding;
    binding._cacheIndex = bindings.length;
    bindings.push(binding);
  }
  _removeInactiveBinding(binding) {
    const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[cacheIndex] = lastInactiveBinding;
    bindings.pop();
    delete bindingByName[trackName];
    if (Object.keys(bindingByName).length === 0) {
      delete bindingsByRoot[rootUuid];
    }
  }
  _lendBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
    binding._cacheIndex = lastActiveIndex;
    bindings[lastActiveIndex] = binding;
    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = firstInactiveBinding;
  }
  _takeBackBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
    binding._cacheIndex = firstInactiveIndex;
    bindings[firstInactiveIndex] = binding;
    lastActiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = lastActiveBinding;
  }
  _lendControlInterpolant() {
    const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
    let interpolant = interpolants[lastActiveIndex];
    if (interpolant === void 0) {
      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[lastActiveIndex] = interpolant;
    }
    return interpolant;
  }
  _takeBackControlInterpolant(interpolant) {
    const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[firstInactiveIndex] = interpolant;
    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[prevIndex] = lastActiveInterpolant;
  }
  clipAction(clip, optionalRoot, blendMode) {
    const root = optionalRoot || this._root, rootUuid = root.uuid;
    let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
    const clipUuid = clipObject !== null ? clipObject.uuid : clip;
    const actionsForClip = this._actionsByClip[clipUuid];
    let prototypeAction = null;
    if (blendMode === void 0) {
      if (clipObject !== null) {
        blendMode = clipObject.blendMode;
      } else {
        blendMode = NormalAnimationBlendMode;
      }
    }
    if (actionsForClip !== void 0) {
      const existingAction = actionsForClip.actionByRoot[rootUuid];
      if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
        return existingAction;
      }
      prototypeAction = actionsForClip.knownActions[0];
      if (clipObject === null)
        clipObject = prototypeAction._clip;
    }
    if (clipObject === null)
      return null;
    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
    this._bindAction(newAction, prototypeAction);
    this._addInactiveAction(newAction, clipUuid, rootUuid);
    return newAction;
  }
  existingAction(clip, optionalRoot) {
    const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      return actionsForClip.actionByRoot[rootUuid] || null;
    }
    return null;
  }
  stopAllAction() {
    const actions = this._actions, nActions = this._nActiveActions;
    for (let i2 = nActions - 1; i2 >= 0; --i2) {
      actions[i2].stop();
    }
    return this;
  }
  update(deltaTime) {
    deltaTime *= this.timeScale;
    const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
    for (let i2 = 0; i2 !== nActions; ++i2) {
      const action = actions[i2];
      action._update(time, deltaTime, timeDirection, accuIndex);
    }
    const bindings = this._bindings, nBindings = this._nActiveBindings;
    for (let i2 = 0; i2 !== nBindings; ++i2) {
      bindings[i2].apply(accuIndex);
    }
    return this;
  }
  setTime(timeInSeconds) {
    this.time = 0;
    for (let i2 = 0; i2 < this._actions.length; i2++) {
      this._actions[i2].time = 0;
    }
    return this.update(timeInSeconds);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(clip) {
    const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      const actionsToRemove = actionsForClip.knownActions;
      for (let i2 = 0, n2 = actionsToRemove.length; i2 !== n2; ++i2) {
        const action = actionsToRemove[i2];
        this._deactivateAction(action);
        const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        this._removeInactiveBindingsForAction(action);
      }
      delete actionsByClip[clipUuid];
    }
  }
  uncacheRoot(root) {
    const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
    for (const clipUuid in actionsByClip) {
      const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
      if (action !== void 0) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
    const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName !== void 0) {
      for (const trackName in bindingByName) {
        const binding = bindingByName[trackName];
        binding.restoreOriginalState();
        this._removeInactiveBinding(binding);
      }
    }
  }
  uncacheAction(clip, optionalRoot) {
    const action = this.existingAction(clip, optionalRoot);
    if (action !== null) {
      this._deactivateAction(action);
      this._removeInactiveAction(action);
    }
  }
}
AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
class InstancedInterleavedBuffer extends InterleavedBuffer {
  constructor(array, stride, meshPerAttribute = 1) {
    super(array, stride);
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
  clone(data) {
    const ib = super.clone(data);
    ib.meshPerAttribute = this.meshPerAttribute;
    return ib;
  }
  toJSON(data) {
    const json = super.toJSON(data);
    json.isInstancedInterleavedBuffer = true;
    json.meshPerAttribute = this.meshPerAttribute;
    return json;
  }
}
InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;
const _vector$2 = /* @__PURE__ */ new Vector3();
const _boneMatrix = /* @__PURE__ */ new Matrix4();
const _matrixWorldInv = /* @__PURE__ */ new Matrix4();
class SkeletonHelper extends LineSegments {
  constructor(object) {
    const bones = getBoneList(object);
    const geometry = new BufferGeometry();
    const vertices = [];
    const colors = [];
    const color1 = new Color(0, 0, 1);
    const color2 = new Color(0, 1, 0);
    for (let i2 = 0; i2 < bones.length; i2++) {
      const bone = bones[i2];
      if (bone.parent && bone.parent.isBone) {
        vertices.push(0, 0, 0);
        vertices.push(0, 0, 0);
        colors.push(color1.r, color1.g, color1.b);
        colors.push(color2.r, color2.g, color2.b);
      }
    }
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true });
    super(geometry, material);
    this.type = "SkeletonHelper";
    this.isSkeletonHelper = true;
    this.root = object;
    this.bones = bones;
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
  }
  updateMatrixWorld(force) {
    const bones = this.bones;
    const geometry = this.geometry;
    const position = geometry.getAttribute("position");
    _matrixWorldInv.copy(this.root.matrixWorld).invert();
    for (let i2 = 0, j2 = 0; i2 < bones.length; i2++) {
      const bone = bones[i2];
      if (bone.parent && bone.parent.isBone) {
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
        _vector$2.setFromMatrixPosition(_boneMatrix);
        position.setXYZ(j2, _vector$2.x, _vector$2.y, _vector$2.z);
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
        _vector$2.setFromMatrixPosition(_boneMatrix);
        position.setXYZ(j2 + 1, _vector$2.x, _vector$2.y, _vector$2.z);
        j2 += 2;
      }
    }
    geometry.getAttribute("position").needsUpdate = true;
    super.updateMatrixWorld(force);
  }
}
function getBoneList(object) {
  const boneList = [];
  if (object.isBone === true) {
    boneList.push(object);
  }
  for (let i2 = 0; i2 < object.children.length; i2++) {
    boneList.push.apply(boneList, getBoneList(object.children[i2]));
  }
  return boneList;
}
class GridHelper extends LineSegments {
  constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
    color1 = new Color(color1);
    color2 = new Color(color2);
    const center = divisions / 2;
    const step = size / divisions;
    const halfSize = size / 2;
    const vertices = [], colors = [];
    for (let i2 = 0, j2 = 0, k2 = -halfSize; i2 <= divisions; i2++, k2 += step) {
      vertices.push(-halfSize, 0, k2, halfSize, 0, k2);
      vertices.push(k2, 0, -halfSize, k2, 0, halfSize);
      const color = i2 === center ? color1 : color2;
      color.toArray(colors, j2);
      j2 += 3;
      color.toArray(colors, j2);
      j2 += 3;
      color.toArray(colors, j2);
      j2 += 3;
      color.toArray(colors, j2);
      j2 += 3;
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
    super(geometry, material);
    this.type = "GridHelper";
  }
}
const _axis = /* @__PURE__ */ new Vector3();
let _lineGeometry, _coneGeometry;
class ArrowHelper extends Object3D {
  constructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 16776960, headLength = length * 0.2, headWidth = headLength * 0.2) {
    super();
    this.type = "ArrowHelper";
    if (_lineGeometry === void 0) {
      _lineGeometry = new BufferGeometry();
      _lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
      _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
      _coneGeometry.translate(0, -0.5, 0);
    }
    this.position.copy(origin);
    this.line = new Line(_lineGeometry, new LineBasicMaterial({ color, toneMapped: false }));
    this.line.matrixAutoUpdate = false;
    this.add(this.line);
    this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({ color, toneMapped: false }));
    this.cone.matrixAutoUpdate = false;
    this.add(this.cone);
    this.setDirection(dir);
    this.setLength(length, headLength, headWidth);
  }
  setDirection(dir) {
    if (dir.y > 0.99999) {
      this.quaternion.set(0, 0, 0, 1);
    } else if (dir.y < -0.99999) {
      this.quaternion.set(1, 0, 0, 0);
    } else {
      _axis.set(dir.z, 0, -dir.x).normalize();
      const radians = Math.acos(dir.y);
      this.quaternion.setFromAxisAngle(_axis, radians);
    }
  }
  setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, length - headLength), 1);
    this.line.updateMatrix();
    this.cone.scale.set(headWidth, headLength, headWidth);
    this.cone.position.y = length;
    this.cone.updateMatrix();
  }
  setColor(color) {
    this.line.material.color.set(color);
    this.cone.material.color.set(color);
  }
  copy(source) {
    super.copy(source, false);
    this.line.copy(source.line);
    this.cone.copy(source.cone);
    return this;
  }
}
const _floatView = new Float32Array(1);
new Int32Array(_floatView.buffer);
Curve.create = function(construct, getPoint) {
  console.log("THREE.Curve.create() has been deprecated");
  construct.prototype = Object.create(Curve.prototype);
  construct.prototype.constructor = construct;
  construct.prototype.getPoint = getPoint;
  return construct;
};
Path.prototype.fromPoints = function(points) {
  console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
  return this.setFromPoints(points);
};
GridHelper.prototype.setColors = function() {
  console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
};
SkeletonHelper.prototype.update = function() {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
Loader.prototype.extractUrlBase = function(url) {
  console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
  return LoaderUtils.extractUrlBase(url);
};
Loader.Handlers = {
  add: function() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  },
  get: function() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  }
};
Box3.prototype.center = function(optionalTarget) {
  console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Box3.prototype.empty = function() {
  console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Box3.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Box3.prototype.isIntersectionSphere = function(sphere) {
  console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
  return this.intersectsSphere(sphere);
};
Box3.prototype.size = function(optionalTarget) {
  console.warn("THREE.Box3: .size() has been renamed to .getSize().");
  return this.getSize(optionalTarget);
};
Euler.prototype.toVector3 = function() {
  console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
};
Sphere.prototype.empty = function() {
  console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Frustum.prototype.setFromMatrix = function(m2) {
  console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
  return this.setFromProjectionMatrix(m2);
};
Matrix3.prototype.flattenToArrayOffset = function(array, offset) {
  console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
  return this.toArray(array, offset);
};
Matrix3.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
  return vector.applyMatrix3(this);
};
Matrix3.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
};
Matrix3.prototype.applyToBufferAttribute = function(attribute) {
  console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
  return attribute.applyMatrix3(this);
};
Matrix3.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
};
Matrix3.prototype.getInverse = function(matrix) {
  console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
  return this.copy(matrix).invert();
};
Matrix4.prototype.extractPosition = function(m2) {
  console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
  return this.copyPosition(m2);
};
Matrix4.prototype.flattenToArrayOffset = function(array, offset) {
  console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
  return this.toArray(array, offset);
};
Matrix4.prototype.getPosition = function() {
  console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
  return new Vector3().setFromMatrixColumn(this, 3);
};
Matrix4.prototype.setRotationFromQuaternion = function(q2) {
  console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
  return this.makeRotationFromQuaternion(q2);
};
Matrix4.prototype.multiplyToArray = function() {
  console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
};
Matrix4.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector4 = function(vector) {
  console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
};
Matrix4.prototype.rotateAxis = function(v2) {
  console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
  v2.transformDirection(this);
};
Matrix4.prototype.crossVector = function(vector) {
  console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.translate = function() {
  console.error("THREE.Matrix4: .translate() has been removed.");
};
Matrix4.prototype.rotateX = function() {
  console.error("THREE.Matrix4: .rotateX() has been removed.");
};
Matrix4.prototype.rotateY = function() {
  console.error("THREE.Matrix4: .rotateY() has been removed.");
};
Matrix4.prototype.rotateZ = function() {
  console.error("THREE.Matrix4: .rotateZ() has been removed.");
};
Matrix4.prototype.rotateByAxis = function() {
  console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
};
Matrix4.prototype.applyToBufferAttribute = function(attribute) {
  console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
  return attribute.applyMatrix4(this);
};
Matrix4.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
};
Matrix4.prototype.makeFrustum = function(left, right, bottom, top, near, far) {
  console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
  return this.makePerspective(left, right, top, bottom, near, far);
};
Matrix4.prototype.getInverse = function(matrix) {
  console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
  return this.copy(matrix).invert();
};
Plane.prototype.isIntersectionLine = function(line) {
  console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
  return this.intersectsLine(line);
};
Quaternion.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
  return vector.applyQuaternion(this);
};
Quaternion.prototype.inverse = function() {
  console.warn("THREE.Quaternion: .inverse() has been renamed to invert().");
  return this.invert();
};
Ray.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Ray.prototype.isIntersectionPlane = function(plane) {
  console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
  return this.intersectsPlane(plane);
};
Ray.prototype.isIntersectionSphere = function(sphere) {
  console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
  return this.intersectsSphere(sphere);
};
Triangle.prototype.area = function() {
  console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
  return this.getArea();
};
Triangle.prototype.barycoordFromPoint = function(point, target) {
  console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
  return this.getBarycoord(point, target);
};
Triangle.prototype.midpoint = function(target) {
  console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
  return this.getMidpoint(target);
};
Triangle.prototypenormal = function(target) {
  console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
  return this.getNormal(target);
};
Triangle.prototype.plane = function(target) {
  console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
  return this.getPlane(target);
};
Triangle.barycoordFromPoint = function(point, a2, b2, c2, target) {
  console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
  return Triangle.getBarycoord(point, a2, b2, c2, target);
};
Triangle.normal = function(a2, b2, c2, target) {
  console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
  return Triangle.getNormal(a2, b2, c2, target);
};
Shape.prototype.extractAllPoints = function(divisions) {
  console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
  return this.extractPoints(divisions);
};
Shape.prototype.extrude = function(options) {
  console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
  return new ExtrudeGeometry(this, options);
};
Shape.prototype.makeGeometry = function(options) {
  console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
  return new ShapeGeometry(this, options);
};
Vector2.prototype.fromAttribute = function(attribute, index, offset) {
  console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset);
};
Vector2.prototype.distanceToManhattan = function(v2) {
  console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
  return this.manhattanDistanceTo(v2);
};
Vector2.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Vector3.prototype.setEulerFromRotationMatrix = function() {
  console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
};
Vector3.prototype.setEulerFromQuaternion = function() {
  console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
};
Vector3.prototype.getPositionFromMatrix = function(m2) {
  console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
  return this.setFromMatrixPosition(m2);
};
Vector3.prototype.getScaleFromMatrix = function(m2) {
  console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
  return this.setFromMatrixScale(m2);
};
Vector3.prototype.getColumnFromMatrix = function(index, matrix) {
  console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
  return this.setFromMatrixColumn(matrix, index);
};
Vector3.prototype.applyProjection = function(m2) {
  console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
  return this.applyMatrix4(m2);
};
Vector3.prototype.fromAttribute = function(attribute, index, offset) {
  console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset);
};
Vector3.prototype.distanceToManhattan = function(v2) {
  console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
  return this.manhattanDistanceTo(v2);
};
Vector3.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Vector4.prototype.fromAttribute = function(attribute, index, offset) {
  console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset);
};
Vector4.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Object3D.prototype.getChildByName = function(name) {
  console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
  return this.getObjectByName(name);
};
Object3D.prototype.renderDepth = function() {
  console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
};
Object3D.prototype.translate = function(distance, axis) {
  console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
  return this.translateOnAxis(axis, distance);
};
Object3D.prototype.getWorldRotation = function() {
  console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
};
Object3D.prototype.applyMatrix = function(matrix) {
  console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
  return this.applyMatrix4(matrix);
};
Object.defineProperties(Object3D.prototype, {
  eulerOrder: {
    get: function() {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      return this.rotation.order;
    },
    set: function(value) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      this.rotation.order = value;
    }
  },
  useQuaternion: {
    get: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }
  }
});
Mesh.prototype.setDrawMode = function() {
  console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
};
Object.defineProperties(Mesh.prototype, {
  drawMode: {
    get: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
      return TrianglesDrawMode;
    },
    set: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }
  }
});
SkinnedMesh.prototype.initBones = function() {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
  if (filmGauge !== void 0)
    this.filmGauge = filmGauge;
  this.setFocalLength(focalLength);
};
Object.defineProperties(Light.prototype, {
  onlyShadow: {
    set: function() {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }
  },
  shadowCameraFov: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
      this.shadow.camera.fov = value;
    }
  },
  shadowCameraLeft: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
      this.shadow.camera.left = value;
    }
  },
  shadowCameraRight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
      this.shadow.camera.right = value;
    }
  },
  shadowCameraTop: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
      this.shadow.camera.top = value;
    }
  },
  shadowCameraBottom: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
      this.shadow.camera.bottom = value;
    }
  },
  shadowCameraNear: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
      this.shadow.camera.near = value;
    }
  },
  shadowCameraFar: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
      this.shadow.camera.far = value;
    }
  },
  shadowCameraVisible: {
    set: function() {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }
  },
  shadowBias: {
    set: function(value) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
      this.shadow.bias = value;
    }
  },
  shadowDarkness: {
    set: function() {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }
  },
  shadowMapWidth: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
      this.shadow.mapSize.width = value;
    }
  },
  shadowMapHeight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
      this.shadow.mapSize.height = value;
    }
  }
});
Object.defineProperties(BufferAttribute.prototype, {
  length: {
    get: function() {
      console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
      return this.array.length;
    }
  },
  dynamic: {
    get: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
      return this.usage === DynamicDrawUsage;
    },
    set: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
      this.setUsage(DynamicDrawUsage);
    }
  }
});
BufferAttribute.prototype.setDynamic = function(value) {
  console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};
BufferAttribute.prototype.copyIndicesArray = function() {
  console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
}, BufferAttribute.prototype.setArray = function() {
  console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
BufferGeometry.prototype.addIndex = function(index) {
  console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
  this.setIndex(index);
};
BufferGeometry.prototype.addAttribute = function(name, attribute) {
  console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
  if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
    console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
    return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
  }
  if (name === "index") {
    console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
    this.setIndex(attribute);
    return this;
  }
  return this.setAttribute(name, attribute);
};
BufferGeometry.prototype.addDrawCall = function(start, count, indexOffset) {
  if (indexOffset !== void 0) {
    console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
  }
  console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
  this.addGroup(start, count);
};
BufferGeometry.prototype.clearDrawCalls = function() {
  console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
  this.clearGroups();
};
BufferGeometry.prototype.computeOffsets = function() {
  console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
};
BufferGeometry.prototype.removeAttribute = function(name) {
  console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
  return this.deleteAttribute(name);
};
BufferGeometry.prototype.applyMatrix = function(matrix) {
  console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
  return this.applyMatrix4(matrix);
};
Object.defineProperties(BufferGeometry.prototype, {
  drawcalls: {
    get: function() {
      console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
      return this.groups;
    }
  },
  offsets: {
    get: function() {
      console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
      return this.groups;
    }
  }
});
InterleavedBuffer.prototype.setDynamic = function(value) {
  console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};
InterleavedBuffer.prototype.setArray = function() {
  console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
ExtrudeGeometry.prototype.getArrays = function() {
  console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
};
ExtrudeGeometry.prototype.addShapeList = function() {
  console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
};
ExtrudeGeometry.prototype.addShape = function() {
  console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
};
Scene.prototype.dispose = function() {
  console.error("THREE.Scene: .dispose() has been removed.");
};
Object.defineProperties(Material.prototype, {
  wrapAround: {
    get: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }
  },
  overdraw: {
    get: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    }
  },
  wrapRGB: {
    get: function() {
      console.warn("THREE.Material: .wrapRGB has been removed.");
      return new Color();
    }
  },
  shading: {
    get: function() {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
      this.flatShading = value === FlatShading;
    }
  },
  stencilMask: {
    get: function() {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
      return this.stencilFuncMask;
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
      this.stencilFuncMask = value;
    }
  },
  vertexTangents: {
    get: function() {
      console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
    },
    set: function() {
      console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
    }
  }
});
Object.defineProperties(ShaderMaterial.prototype, {
  derivatives: {
    get: function() {
      console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      return this.extensions.derivatives;
    },
    set: function(value) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      this.extensions.derivatives = value;
    }
  }
});
WebGLRenderer.prototype.clearTarget = function(renderTarget, color, depth, stencil) {
  console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
  this.setRenderTarget(renderTarget);
  this.clear(color, depth, stencil);
};
WebGLRenderer.prototype.animate = function(callback) {
  console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
  this.setAnimationLoop(callback);
};
WebGLRenderer.prototype.getCurrentRenderTarget = function() {
  console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
  return this.getRenderTarget();
};
WebGLRenderer.prototype.getMaxAnisotropy = function() {
  console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
  return this.capabilities.getMaxAnisotropy();
};
WebGLRenderer.prototype.getPrecision = function() {
  console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
  return this.capabilities.precision;
};
WebGLRenderer.prototype.resetGLState = function() {
  console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
  return this.state.reset();
};
WebGLRenderer.prototype.supportsFloatTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
  return this.extensions.get("OES_texture_float");
};
WebGLRenderer.prototype.supportsHalfFloatTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
  return this.extensions.get("OES_texture_half_float");
};
WebGLRenderer.prototype.supportsStandardDerivatives = function() {
  console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
  return this.extensions.get("OES_standard_derivatives");
};
WebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {
  console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
  return this.extensions.get("WEBGL_compressed_texture_s3tc");
};
WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {
  console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
  return this.extensions.get("WEBGL_compressed_texture_pvrtc");
};
WebGLRenderer.prototype.supportsBlendMinMax = function() {
  console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
  return this.extensions.get("EXT_blend_minmax");
};
WebGLRenderer.prototype.supportsVertexTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
  return this.capabilities.vertexTextures;
};
WebGLRenderer.prototype.supportsInstancedArrays = function() {
  console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
  return this.extensions.get("ANGLE_instanced_arrays");
};
WebGLRenderer.prototype.enableScissorTest = function(boolean) {
  console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
  this.setScissorTest(boolean);
};
WebGLRenderer.prototype.initMaterial = function() {
  console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
};
WebGLRenderer.prototype.addPrePlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
};
WebGLRenderer.prototype.addPostPlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
};
WebGLRenderer.prototype.updateShadowMap = function() {
  console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
};
WebGLRenderer.prototype.setFaceCulling = function() {
  console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
};
WebGLRenderer.prototype.allocTextureUnit = function() {
  console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
};
WebGLRenderer.prototype.setTexture = function() {
  console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
};
WebGLRenderer.prototype.setTexture2D = function() {
  console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
};
WebGLRenderer.prototype.setTextureCube = function() {
  console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
};
WebGLRenderer.prototype.getActiveMipMapLevel = function() {
  console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
  return this.getActiveMipmapLevel();
};
Object.defineProperties(WebGLRenderer.prototype, {
  shadowMapEnabled: {
    get: function() {
      return this.shadowMap.enabled;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
      this.shadowMap.enabled = value;
    }
  },
  shadowMapType: {
    get: function() {
      return this.shadowMap.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
      this.shadowMap.type = value;
    }
  },
  shadowMapCullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  context: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
      return this.getContext();
    }
  },
  vr: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
      return this.xr;
    }
  },
  gammaInput: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
      return false;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
    }
  },
  gammaOutput: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      return false;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
    }
  },
  toneMappingWhitePoint: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
      return 1;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
    }
  },
  gammaFactor: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
      return 2;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
    }
  }
});
Object.defineProperties(WebGLShadowMap.prototype, {
  cullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  renderReverseSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }
  },
  renderSingleSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }
  }
});
Object.defineProperties(WebGLRenderTarget.prototype, {
  wrapS: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      return this.texture.wrapS;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      this.texture.wrapS = value;
    }
  },
  wrapT: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      return this.texture.wrapT;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      this.texture.wrapT = value;
    }
  },
  magFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      return this.texture.magFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      this.texture.magFilter = value;
    }
  },
  minFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      return this.texture.minFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      this.texture.minFilter = value;
    }
  },
  anisotropy: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      return this.texture.anisotropy;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      this.texture.anisotropy = value;
    }
  },
  offset: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      return this.texture.offset;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      this.texture.offset = value;
    }
  },
  repeat: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      return this.texture.repeat;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      this.texture.repeat = value;
    }
  },
  format: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      return this.texture.format;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      this.texture.format = value;
    }
  },
  type: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      return this.texture.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      this.texture.type = value;
    }
  },
  generateMipmaps: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      return this.texture.generateMipmaps;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      this.texture.generateMipmaps = value;
    }
  }
});
Audio.prototype.load = function(file) {
  console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
  const scope = this;
  const audioLoader = new AudioLoader();
  audioLoader.load(file, function(buffer) {
    scope.setBuffer(buffer);
  });
  return this;
};
CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
  console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
  return this.update(renderer, scene);
};
CubeCamera.prototype.clear = function(renderer, color, depth, stencil) {
  console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear().");
  return this.renderTarget.clear(renderer, color, depth, stencil);
};
ImageUtils.crossOrigin = void 0;
ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
  const loader = new TextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(url, onLoad, void 0, onError);
  if (mapping)
    texture.mapping = mapping;
  return texture;
};
ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
  const loader = new CubeTextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(urls, onLoad, void 0, onError);
  if (mapping)
    texture.mapping = mapping;
  return texture;
};
ImageUtils.loadCompressedTexture = function() {
  console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
};
ImageUtils.loadCompressedTextureCube = function() {
  console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
};
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
    revision: REVISION
  } }));
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    console.warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}
var TYPES_ENUM = {
  i8: "i8",
  ui8: "ui8",
  ui8c: "ui8c",
  i16: "i16",
  ui16: "ui16",
  i32: "i32",
  ui32: "ui32",
  f32: "f32",
  f64: "f64",
  eid: "eid"
};
var TYPES_NAMES = {
  i8: "Int8",
  ui8: "Uint8",
  ui8c: "Uint8Clamped",
  i16: "Int16",
  ui16: "Uint16",
  i32: "Int32",
  ui32: "Uint32",
  eid: "Uint32",
  f32: "Float32",
  f64: "Float64"
};
var TYPES = {
  i8: Int8Array,
  ui8: Uint8Array,
  ui8c: Uint8ClampedArray,
  i16: Int16Array,
  ui16: Uint16Array,
  i32: Int32Array,
  ui32: Uint32Array,
  f32: Float32Array,
  f64: Float64Array,
  eid: Uint32Array
};
var UNSIGNED_MAX = {
  uint8: 2 ** 8,
  uint16: 2 ** 16,
  uint32: 2 ** 32
};
var roundToMultiple = (mul) => (x2) => Math.ceil(x2 / mul) * mul;
var roundToMultiple4 = roundToMultiple(4);
var $storeRef = Symbol("storeRef");
var $storeSize = Symbol("storeSize");
var $storeMaps = Symbol("storeMaps");
var $storeFlattened = Symbol("storeFlattened");
var $storeBase = Symbol("storeBase");
var $storeType = Symbol("storeType");
var $storeArrayElementCounts = Symbol("storeArrayElementCounts");
var $storeSubarrays = Symbol("storeSubarrays");
var $subarrayCursors = Symbol("subarrayCursors");
var $subarray = Symbol("subarray");
var $parentArray = Symbol("parentArray");
var $tagStore = Symbol("tagStore");
var $indexType = Symbol("indexType");
var $indexBytes = Symbol("indexBytes");
var $isEidType = Symbol("isEidType");
var stores = {};
var resize = (ta, size) => {
  const newBuffer = new ArrayBuffer(size * ta.BYTES_PER_ELEMENT);
  const newTa = new ta.constructor(newBuffer);
  newTa.set(ta, 0);
  return newTa;
};
var createShadow = (store, key) => {
  if (!ArrayBuffer.isView(store)) {
    const shadowStore = store[$parentArray].slice(0);
    store[key] = store.map((_2, eid) => {
      const { length } = store[eid];
      const start = length * eid;
      const end = start + length;
      return shadowStore.subarray(start, end);
    });
  } else {
    store[key] = store.slice(0);
  }
};
var resizeSubarray = (metadata, store, storeSize) => {
  const cursors = metadata[$subarrayCursors];
  let type = store[$storeType];
  const length = store[0].length;
  const indexType = length <= UNSIGNED_MAX.uint8 ? TYPES_ENUM.ui8 : length <= UNSIGNED_MAX.uint16 ? TYPES_ENUM.ui16 : TYPES_ENUM.ui32;
  if (cursors[type] === 0) {
    const arrayElementCount = metadata[$storeArrayElementCounts][type];
    const array = new TYPES[type](roundToMultiple4(arrayElementCount * storeSize));
    array.set(metadata[$storeSubarrays][type]);
    metadata[$storeSubarrays][type] = array;
    array[$indexType] = TYPES_NAMES[indexType];
    array[$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT;
  }
  const start = cursors[type];
  const end = start + storeSize * length;
  cursors[type] = end;
  store[$parentArray] = metadata[$storeSubarrays][type].subarray(start, end);
  for (let eid = 0; eid < storeSize; eid++) {
    const start2 = length * eid;
    const end2 = start2 + length;
    store[eid] = store[$parentArray].subarray(start2, end2);
    store[eid][$indexType] = TYPES_NAMES[indexType];
    store[eid][$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT;
    store[eid][$subarray] = true;
  }
};
var resizeRecursive = (metadata, store, size) => {
  Object.keys(store).forEach((key) => {
    const ta = store[key];
    if (Array.isArray(ta)) {
      resizeSubarray(metadata, ta, size);
      store[$storeFlattened].push(ta);
    } else if (ArrayBuffer.isView(ta)) {
      store[key] = resize(ta, size);
      store[$storeFlattened].push(store[key]);
    } else if (typeof ta === "object") {
      resizeRecursive(metadata, store[key], size);
    }
  });
};
var resizeStore = (store, size) => {
  if (store[$tagStore])
    return;
  store[$storeSize] = size;
  store[$storeFlattened].length = 0;
  Object.keys(store[$subarrayCursors]).forEach((k2) => {
    store[$subarrayCursors][k2] = 0;
  });
  resizeRecursive(store, store, size);
};
var resetStoreFor = (store, eid) => {
  if (store[$storeFlattened]) {
    store[$storeFlattened].forEach((ta) => {
      if (ArrayBuffer.isView(ta))
        ta[eid] = 0;
      else
        ta[eid].fill(0);
    });
  }
};
var createTypeStore = (type, length) => {
  const totalBytes = length * TYPES[type].BYTES_PER_ELEMENT;
  const buffer = new ArrayBuffer(totalBytes);
  const store = new TYPES[type](buffer);
  store[$isEidType] = type === TYPES_ENUM.eid;
  return store;
};
var createArrayStore = (metadata, type, length) => {
  const storeSize = metadata[$storeSize];
  const store = Array(storeSize).fill(0);
  store[$storeType] = type;
  store[$isEidType] = type === TYPES_ENUM.eid;
  const cursors = metadata[$subarrayCursors];
  const indexType = length <= UNSIGNED_MAX.uint8 ? TYPES_ENUM.ui8 : length <= UNSIGNED_MAX.uint16 ? TYPES_ENUM.ui16 : TYPES_ENUM.ui32;
  if (!length)
    throw new Error("bitECS - Must define component array length");
  if (!TYPES[type])
    throw new Error(`bitECS - Invalid component array property type ${type}`);
  if (!metadata[$storeSubarrays][type]) {
    const arrayElementCount = metadata[$storeArrayElementCounts][type];
    const array = new TYPES[type](roundToMultiple4(arrayElementCount * storeSize));
    array[$indexType] = TYPES_NAMES[indexType];
    array[$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT;
    metadata[$storeSubarrays][type] = array;
  }
  const start = cursors[type];
  const end = start + storeSize * length;
  cursors[type] = end;
  store[$parentArray] = metadata[$storeSubarrays][type].subarray(start, end);
  for (let eid = 0; eid < storeSize; eid++) {
    const start2 = length * eid;
    const end2 = start2 + length;
    store[eid] = store[$parentArray].subarray(start2, end2);
    store[eid][$indexType] = TYPES_NAMES[indexType];
    store[eid][$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT;
    store[eid][$subarray] = true;
  }
  return store;
};
var isArrayType = (x2) => Array.isArray(x2) && typeof x2[0] === "string" && typeof x2[1] === "number";
var createStore = (schema, size) => {
  const $store = Symbol("store");
  if (!schema || !Object.keys(schema).length) {
    stores[$store] = {
      [$storeSize]: size,
      [$tagStore]: true,
      [$storeBase]: () => stores[$store]
    };
    return stores[$store];
  }
  schema = JSON.parse(JSON.stringify(schema));
  const arrayElementCounts = {};
  const collectArrayElementCounts = (s2) => {
    const keys = Object.keys(s2);
    for (const k2 of keys) {
      if (isArrayType(s2[k2])) {
        if (!arrayElementCounts[s2[k2][0]])
          arrayElementCounts[s2[k2][0]] = 0;
        arrayElementCounts[s2[k2][0]] += s2[k2][1];
      } else if (s2[k2] instanceof Object) {
        collectArrayElementCounts(s2[k2]);
      }
    }
  };
  collectArrayElementCounts(schema);
  const metadata = {
    [$storeSize]: size,
    [$storeMaps]: {},
    [$storeSubarrays]: {},
    [$storeRef]: $store,
    [$subarrayCursors]: Object.keys(TYPES).reduce((a2, type) => __spreadProps(__spreadValues({}, a2), { [type]: 0 }), {}),
    [$storeFlattened]: [],
    [$storeArrayElementCounts]: arrayElementCounts
  };
  if (schema instanceof Object && Object.keys(schema).length) {
    const recursiveTransform = (a2, k2) => {
      if (typeof a2[k2] === "string") {
        a2[k2] = createTypeStore(a2[k2], size);
        a2[k2][$storeBase] = () => stores[$store];
        metadata[$storeFlattened].push(a2[k2]);
      } else if (isArrayType(a2[k2])) {
        const [type, length] = a2[k2];
        a2[k2] = createArrayStore(metadata, type, length);
        a2[k2][$storeBase] = () => stores[$store];
        metadata[$storeFlattened].push(a2[k2]);
      } else if (a2[k2] instanceof Object) {
        a2[k2] = Object.keys(a2[k2]).reduce(recursiveTransform, a2[k2]);
      }
      return a2;
    };
    stores[$store] = Object.assign(Object.keys(schema).reduce(recursiveTransform, schema), metadata);
    stores[$store][$storeBase] = () => stores[$store];
    return stores[$store];
  }
};
var SparseSet = () => {
  const dense = [];
  const sparse = [];
  dense.sort = function(comparator) {
    const result = Array.prototype.sort.call(this, comparator);
    for (let i2 = 0; i2 < dense.length; i2++) {
      sparse[dense[i2]] = i2;
    }
    return result;
  };
  const has = (val) => dense[sparse[val]] === val;
  const add = (val) => {
    if (has(val))
      return;
    sparse[val] = dense.push(val) - 1;
  };
  const remove = (val) => {
    if (!has(val))
      return;
    const index = sparse[val];
    const swapped = dense.pop();
    if (swapped !== val) {
      dense[index] = swapped;
      sparse[swapped] = index;
    }
  };
  return {
    add,
    remove,
    has,
    sparse,
    dense
  };
};
var $entityMasks = Symbol("entityMasks");
var $entityComponents = Symbol("entityComponents");
var $entitySparseSet = Symbol("entitySparseSet");
var $entityArray = Symbol("entityArray");
var defaultSize = 1e5;
var globalEntityCursor = 0;
var globalSize = defaultSize;
var resizeThreshold = () => globalSize - globalSize / 5;
var getGlobalSize = () => globalSize;
var removed = [];
var resetGlobals = () => {
  globalSize = defaultSize;
  globalEntityCursor = 0;
  removed.length = 0;
};
var setDefaultSize = (newSize) => {
  const oldSize = globalSize;
  defaultSize = newSize;
  resetGlobals();
  globalSize = newSize;
  resizeWorlds(newSize);
  resizeComponents(newSize);
  console.info(`\u{1F47E} bitECS - resizing all data stores from ${oldSize} to ${newSize}`);
};
var getEntityCursor = () => globalEntityCursor;
var eidToWorld = /* @__PURE__ */ new Map();
var addEntity = (world) => {
  if (globalEntityCursor >= resizeThreshold()) {
    const size = globalSize;
    const amount = Math.ceil(size / 2 / 4) * 4;
    setDefaultSize(size + amount);
  }
  const eid = removed.length > Math.round(defaultSize * 0.01) ? removed.shift() : globalEntityCursor++;
  world[$entitySparseSet].add(eid);
  eidToWorld.set(eid, world);
  world[$notQueries].forEach((q2) => {
    const match = queryCheckEntity(world, q2, eid);
    if (match)
      queryAddEntity(q2, eid);
  });
  world[$entityComponents].set(eid, /* @__PURE__ */ new Set());
  return eid;
};
var removeEntity = (world, eid) => {
  if (!world[$entitySparseSet].has(eid))
    return;
  world[$queries].forEach((q2) => {
    queryRemoveEntity(world, q2, eid);
  });
  removed.push(eid);
  world[$entitySparseSet].remove(eid);
  world[$entityComponents].delete(eid);
  world[$localEntities].delete(world[$localEntityLookup].get(eid));
  world[$localEntityLookup].delete(eid);
  for (let i2 = 0; i2 < world[$entityMasks].length; i2++)
    world[$entityMasks][i2][eid] = 0;
};
var $queries = Symbol("queries");
var $notQueries = Symbol("notQueries");
var $queryAny = Symbol("queryAny");
var $queryAll = Symbol("queryAll");
var $queryNone = Symbol("queryNone");
var $queryMap = Symbol("queryMap");
var $dirtyQueries = Symbol("$dirtyQueries");
var $queryComponents = Symbol("queryComponents");
var enterQuery = (query) => (world) => {
  if (!world[$queryMap].has(query))
    registerQuery(world, query);
  const q2 = world[$queryMap].get(query);
  const entered = q2.entered.dense.slice();
  q2.entered = SparseSet();
  return entered;
};
var exitQuery = (query) => (world) => {
  if (!world[$queryMap].has(query))
    registerQuery(world, query);
  const q2 = world[$queryMap].get(query);
  const exited = q2.exited.dense.slice();
  q2.exited = SparseSet();
  return exited;
};
var registerQuery = (world, query) => {
  const components2 = [];
  const notComponents = [];
  const changedComponents = [];
  query[$queryComponents].forEach((c2) => {
    if (typeof c2 === "function") {
      const [comp, mod] = c2();
      if (!world[$componentMap].has(comp))
        registerComponent(world, comp);
      if (mod === "not") {
        notComponents.push(comp);
      }
      if (mod === "changed") {
        changedComponents.push(comp);
        components2.push(comp);
      }
    } else {
      if (!world[$componentMap].has(c2))
        registerComponent(world, c2);
      components2.push(c2);
    }
  });
  const mapComponents = (c2) => world[$componentMap].get(c2);
  const allComponents = components2.concat(notComponents).map(mapComponents);
  const sparseSet = SparseSet();
  const archetypes = [];
  const changed = [];
  const toRemove = SparseSet();
  const entered = SparseSet();
  const exited = SparseSet();
  const generations = allComponents.map((c2) => c2.generationId).reduce((a2, v2) => {
    if (a2.includes(v2))
      return a2;
    a2.push(v2);
    return a2;
  }, []);
  const reduceBitflags = (a2, c2) => {
    if (!a2[c2.generationId])
      a2[c2.generationId] = 0;
    a2[c2.generationId] |= c2.bitflag;
    return a2;
  };
  const masks = components2.map(mapComponents).reduce(reduceBitflags, {});
  const notMasks = notComponents.map(mapComponents).reduce(reduceBitflags, {});
  const hasMasks = allComponents.reduce(reduceBitflags, {});
  const flatProps = components2.filter((c2) => !c2[$tagStore]).map((c2) => Object.getOwnPropertySymbols(c2).includes($storeFlattened) ? c2[$storeFlattened] : [c2]).reduce((a2, v2) => a2.concat(v2), []);
  const shadows = flatProps.map((prop) => {
    const $2 = Symbol();
    createShadow(prop, $2);
    return prop[$2];
  });
  const q2 = Object.assign(sparseSet, {
    archetypes,
    changed,
    components: components2,
    notComponents,
    changedComponents,
    allComponents,
    masks,
    notMasks,
    hasMasks,
    generations,
    flatProps,
    toRemove,
    entered,
    exited,
    shadows
  });
  world[$queryMap].set(query, q2);
  world[$queries].add(q2);
  allComponents.forEach((c2) => {
    c2.queries.add(q2);
  });
  if (notComponents.length)
    world[$notQueries].add(q2);
  for (let eid = 0; eid < getEntityCursor(); eid++) {
    if (!world[$entitySparseSet].has(eid))
      continue;
    const match = queryCheckEntity(world, q2, eid);
    if (match)
      queryAddEntity(q2, eid);
  }
};
var diff = (q2, clearDiff) => {
  if (clearDiff)
    q2.changed = [];
  const { flatProps, shadows } = q2;
  for (let i2 = 0; i2 < q2.dense.length; i2++) {
    const eid = q2.dense[i2];
    let dirty = false;
    for (let pid = 0; pid < flatProps.length; pid++) {
      const prop = flatProps[pid];
      const shadow = shadows[pid];
      if (ArrayBuffer.isView(prop[eid])) {
        for (let i22 = 0; i22 < prop[eid].length; i22++) {
          if (prop[eid][i22] !== shadow[eid][i22]) {
            dirty = true;
            break;
          }
        }
        shadow[eid].set(prop[eid]);
      } else {
        if (prop[eid] !== shadow[eid]) {
          dirty = true;
          shadow[eid] = prop[eid];
        }
      }
    }
    if (dirty)
      q2.changed.push(eid);
  }
  return q2.changed;
};
var defineQuery = (...args) => {
  let components2;
  let any, all, none;
  if (Array.isArray(args[0])) {
    components2 = args[0];
  }
  if (components2 === void 0 || components2[$componentMap] !== void 0) {
    return (world) => world ? world[$entityArray] : components2[$entityArray];
  }
  const query = function(world, clearDiff = true) {
    if (!world[$queryMap].has(query))
      registerQuery(world, query);
    const q2 = world[$queryMap].get(query);
    commitRemovals(world);
    if (q2.changedComponents.length)
      return diff(q2, clearDiff);
    return q2.dense;
  };
  query[$queryComponents] = components2;
  query[$queryAny] = any;
  query[$queryAll] = all;
  query[$queryNone] = none;
  return query;
};
var queryCheckEntity = (world, q2, eid) => {
  const { masks, notMasks, generations } = q2;
  for (let i2 = 0; i2 < generations.length; i2++) {
    const generationId = generations[i2];
    const qMask = masks[generationId];
    const qNotMask = notMasks[generationId];
    const eMask = world[$entityMasks][generationId][eid];
    if (qNotMask && (eMask & qNotMask) !== 0) {
      return false;
    }
    if (qMask && (eMask & qMask) !== qMask) {
      return false;
    }
  }
  return true;
};
var queryAddEntity = (q2, eid) => {
  q2.toRemove.remove(eid);
  q2.entered.add(eid);
  q2.add(eid);
};
var queryCommitRemovals = (q2) => {
  for (let i2 = q2.toRemove.dense.length - 1; i2 >= 0; i2--) {
    const eid = q2.toRemove.dense[i2];
    q2.toRemove.remove(eid);
    q2.remove(eid);
  }
};
var commitRemovals = (world) => {
  if (!world[$dirtyQueries].size)
    return;
  world[$dirtyQueries].forEach(queryCommitRemovals);
  world[$dirtyQueries].clear();
};
var queryRemoveEntity = (world, q2, eid) => {
  if (!q2.has(eid) || q2.toRemove.has(eid))
    return;
  q2.toRemove.add(eid);
  world[$dirtyQueries].add(q2);
  q2.exited.add(eid);
};
var $componentMap = Symbol("componentMap");
var components = [];
var resizeComponents = (size) => {
  components.forEach((component) => resizeStore(component, size));
};
var defineComponent = (schema, size) => {
  const component = createStore(schema, size || getGlobalSize());
  if (schema && Object.keys(schema).length)
    components.push(component);
  return component;
};
var incrementBitflag = (world) => {
  world[$bitflag] *= 2;
  if (world[$bitflag] >= 2 ** 31) {
    world[$bitflag] = 1;
    world[$entityMasks].push(new Uint32Array(world[$size]));
  }
};
var registerComponent = (world, component) => {
  if (!component)
    throw new Error(`bitECS - Cannot register null or undefined component`);
  const queries = /* @__PURE__ */ new Set();
  const notQueries = /* @__PURE__ */ new Set();
  const changedQueries = /* @__PURE__ */ new Set();
  world[$queries].forEach((q2) => {
    if (q2.allComponents.includes(component)) {
      queries.add(q2);
    }
  });
  world[$componentMap].set(component, {
    generationId: world[$entityMasks].length - 1,
    bitflag: world[$bitflag],
    store: component,
    queries,
    notQueries,
    changedQueries
  });
  if (component[$storeSize] < getGlobalSize()) {
    resizeStore(component, getGlobalSize());
  }
  incrementBitflag(world);
};
var hasComponent = (world, component, eid) => {
  const registeredComponent = world[$componentMap].get(component);
  if (!registeredComponent)
    return false;
  const { generationId, bitflag } = registeredComponent;
  const mask = world[$entityMasks][generationId][eid];
  return (mask & bitflag) === bitflag;
};
var addComponent = (world, component, eid, reset = false) => {
  if (eid === void 0)
    throw new Error("bitECS - entity is undefined.");
  if (!world[$entitySparseSet].has(eid))
    throw new Error("bitECS - entity does not exist in the world.");
  if (!world[$componentMap].has(component))
    registerComponent(world, component);
  if (hasComponent(world, component, eid))
    return;
  const c2 = world[$componentMap].get(component);
  const { generationId, bitflag, queries, notQueries } = c2;
  world[$entityMasks][generationId][eid] |= bitflag;
  queries.forEach((q2) => {
    if (q2.toRemove.has(eid))
      q2.toRemove.remove(eid);
    const match = queryCheckEntity(world, q2, eid);
    if (match)
      queryAddEntity(q2, eid);
    if (!match)
      queryRemoveEntity(world, q2, eid);
  });
  world[$entityComponents].get(eid).add(component);
  if (reset)
    resetStoreFor(component, eid);
};
var removeComponent = (world, component, eid, reset = true) => {
  if (eid === void 0)
    throw new Error("bitECS - entity is undefined.");
  if (!world[$entitySparseSet].has(eid))
    throw new Error("bitECS - entity does not exist in the world.");
  if (!hasComponent(world, component, eid))
    return;
  const c2 = world[$componentMap].get(component);
  const { generationId, bitflag, queries } = c2;
  world[$entityMasks][generationId][eid] &= ~bitflag;
  queries.forEach((q2) => {
    if (q2.toRemove.has(eid))
      q2.toRemove.remove(eid);
    const match = queryCheckEntity(world, q2, eid);
    if (match)
      queryAddEntity(q2, eid);
    if (!match)
      queryRemoveEntity(world, q2, eid);
  });
  world[$entityComponents].get(eid).delete(component);
  if (reset)
    resetStoreFor(component, eid);
};
var $size = Symbol("size");
var $resizeThreshold = Symbol("resizeThreshold");
var $bitflag = Symbol("bitflag");
var $archetypes = Symbol("archetypes");
var $localEntities = Symbol("localEntities");
var $localEntityLookup = Symbol("localEntityLookp");
var worlds = [];
var resizeWorlds = (size) => {
  worlds.forEach((world) => {
    world[$size] = size;
    for (let i2 = 0; i2 < world[$entityMasks].length; i2++) {
      const masks = world[$entityMasks][i2];
      world[$entityMasks][i2] = resize(masks, size);
    }
    world[$resizeThreshold] = world[$size] - world[$size] / 5;
  });
};
var createWorld = (...args) => {
  const world = typeof args[0] === "object" ? args[0] : {};
  const size = typeof args[0] === "number" ? args[0] : typeof args[1] === "number" ? args[1] : getGlobalSize();
  resetWorld(world, size);
  worlds.push(world);
  return world;
};
var resetWorld = (world, size = getGlobalSize()) => {
  world[$size] = size;
  if (world[$entityArray])
    world[$entityArray].forEach((eid) => removeEntity(world, eid));
  world[$entityMasks] = [new Uint32Array(size)];
  world[$entityComponents] = /* @__PURE__ */ new Map();
  world[$archetypes] = [];
  world[$entitySparseSet] = SparseSet();
  world[$entityArray] = world[$entitySparseSet].dense;
  world[$bitflag] = 1;
  world[$componentMap] = /* @__PURE__ */ new Map();
  world[$queryMap] = /* @__PURE__ */ new Map();
  world[$queries] = /* @__PURE__ */ new Set();
  world[$notQueries] = /* @__PURE__ */ new Set();
  world[$dirtyQueries] = /* @__PURE__ */ new Set();
  world[$localEntities] = /* @__PURE__ */ new Map();
  world[$localEntityLookup] = /* @__PURE__ */ new Map();
  return world;
};
var defineSystem = (update) => (world, ...args) => {
  update(world, ...args);
  return world;
};
var pipe = (...fns) => (input) => {
  let tmp2 = input;
  for (let i2 = 0; i2 < fns.length; i2++) {
    const fn = fns[i2];
    tmp2 = fn(tmp2);
  }
  return tmp2;
};
var Types = TYPES_ENUM;
let A;
const I = new Array(32).fill(void 0);
function g(A2) {
  return I[A2];
}
I.push(void 0, null, true, false);
let C = I.length;
function B(A2) {
  const B2 = g(A2);
  return function(A3) {
    A3 < 36 || (I[A3] = C, C = A3);
  }(A2), B2;
}
function Q(A2) {
  C === I.length && I.push(I.length + 1);
  const g2 = C;
  return C = I[g2], I[g2] = A2, g2;
}
let E = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
E.decode();
let i = null;
function o() {
  return i !== null && i.buffer === A.memory.buffer || (i = new Uint8Array(A.memory.buffer)), i;
}
function D(A2, I2) {
  return E.decode(o().subarray(A2, A2 + I2));
}
function S(A2) {
  return A2 == null;
}
let G = null;
let k = null;
function U() {
  return k !== null && k.buffer === A.memory.buffer || (k = new Int32Array(A.memory.buffer)), k;
}
function w(A2) {
  const I2 = typeof A2;
  if (I2 == "number" || I2 == "boolean" || A2 == null)
    return `${A2}`;
  if (I2 == "string")
    return `"${A2}"`;
  if (I2 == "symbol") {
    const I3 = A2.description;
    return I3 == null ? "Symbol" : `Symbol(${I3})`;
  }
  if (I2 == "function") {
    const I3 = A2.name;
    return typeof I3 == "string" && I3.length > 0 ? `Function(${I3})` : "Function";
  }
  if (Array.isArray(A2)) {
    const I3 = A2.length;
    let g3 = "[";
    I3 > 0 && (g3 += w(A2[0]));
    for (let C3 = 1; C3 < I3; C3++)
      g3 += ", " + w(A2[C3]);
    return g3 += "]", g3;
  }
  const g2 = /\[object ([^\]]+)\]/.exec(toString.call(A2));
  let C2;
  if (!(g2.length > 1))
    return toString.call(A2);
  if (C2 = g2[1], C2 == "Object")
    try {
      return "Object(" + JSON.stringify(A2) + ")";
    } catch (A3) {
      return "Object";
    }
  return A2 instanceof Error ? `${A2.name}: ${A2.message}
${A2.stack}` : C2;
}
let J = 0, K = new TextEncoder("utf-8");
const F = typeof K.encodeInto == "function" ? function(A2, I2) {
  return K.encodeInto(A2, I2);
} : function(A2, I2) {
  const g2 = K.encode(A2);
  return I2.set(g2), { read: A2.length, written: g2.length };
};
let a = 32;
function h(A2) {
  if (a == 1)
    throw new Error("out of js stack");
  return I[--a] = A2, a;
}
function M(A2, I2) {
  if (!(A2 instanceof I2))
    throw new Error(`expected instance of ${I2.name}`);
  return A2.ptr;
}
let y = null;
function q() {
  return y !== null && y.buffer === A.memory.buffer || (y = new Float32Array(A.memory.buffer)), y;
}
function N(A2, I2) {
  return q().subarray(A2 / 4, A2 / 4 + I2);
}
let R = null;
function s() {
  return R !== null && R.buffer === A.memory.buffer || (R = new Uint32Array(A.memory.buffer)), R;
}
function c(A2, I2) {
  const g2 = I2(4 * A2.length);
  return q().set(A2, g2 / 4), J = A2.length, g2;
}
function Y(A2, I2) {
  const g2 = I2(4 * A2.length);
  return s().set(A2, g2 / 4), J = A2.length, g2;
}
function l(I2, g2) {
  try {
    return I2.apply(this, g2);
  } catch (I3) {
    A.__wbindgen_exn_store(Q(I3));
  }
}
Object.freeze({ Ball: 0, 0: "Ball", Fixed: 1, 1: "Fixed", Prismatic: 2, 2: "Prismatic", Revolute: 3, 3: "Revolute" }), Object.freeze({ Disabled: 0, 0: "Disabled", VelocityBased: 1, 1: "VelocityBased", AccelerationBased: 2, 2: "AccelerationBased", ForceBased: 3, 3: "ForceBased" }), Object.freeze({ Dynamic: 0, 0: "Dynamic", Static: 1, 1: "Static", KinematicPositionBased: 2, 2: "KinematicPositionBased", KinematicVelocityBased: 3, 3: "KinematicVelocityBased" }), Object.freeze({ Ball: 0, 0: "Ball", Cuboid: 1, 1: "Cuboid", Capsule: 2, 2: "Capsule", Segment: 3, 3: "Segment", Polyline: 4, 4: "Polyline", Triangle: 5, 5: "Triangle", TriMesh: 6, 6: "TriMesh", HeightField: 7, 7: "HeightField", Compound: 8, 8: "Compound", ConvexPolyhedron: 9, 9: "ConvexPolyhedron", Cylinder: 10, 10: "Cylinder", Cone: 11, 11: "Cone", RoundCuboid: 12, 12: "RoundCuboid", RoundTriangle: 13, 13: "RoundTriangle", RoundCylinder: 14, 14: "RoundCylinder", RoundCone: 15, 15: "RoundCone", RoundConvexPolyhedron: 16, 16: "RoundConvexPolyhedron" });
class L {
  static __wrap(A2) {
    const I2 = Object.create(L.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawbroadphase_free(I2);
  }
  constructor() {
    var I2 = A.rawbroadphase_new();
    return L.__wrap(I2);
  }
}
class H {
  static __wrap(A2) {
    const I2 = Object.create(H.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawccdsolver_free(I2);
  }
  constructor() {
    var I2 = A.rawccdsolver_new();
    return H.__wrap(I2);
  }
}
class p {
  static __wrap(A2) {
    const I2 = Object.create(p.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawcolliderset_free(I2);
  }
  coTranslation(I2) {
    var g2 = A.rawcolliderset_coTranslation(this.ptr, I2);
    return v.__wrap(g2);
  }
  coRotation(I2) {
    var g2 = A.rawcolliderset_coRotation(this.ptr, I2);
    return m.__wrap(g2);
  }
  coSetTranslation(I2, g2, C2, B2) {
    A.rawcolliderset_coSetTranslation(this.ptr, I2, g2, C2, B2);
  }
  coSetTranslationWrtParent(I2, g2, C2, B2) {
    A.rawcolliderset_coSetTranslationWrtParent(this.ptr, I2, g2, C2, B2);
  }
  coSetRotation(I2, g2, C2, B2, Q2) {
    A.rawcolliderset_coSetRotation(this.ptr, I2, g2, C2, B2, Q2);
  }
  coSetRotationWrtParent(I2, g2, C2, B2, Q2) {
    A.rawcolliderset_coSetRotationWrtParent(this.ptr, I2, g2, C2, B2, Q2);
  }
  coIsSensor(I2) {
    return A.rawcolliderset_coIsSensor(this.ptr, I2) !== 0;
  }
  coShapeType(I2) {
    return A.rawcolliderset_coShapeType(this.ptr, I2) >>> 0;
  }
  coHalfExtents(I2) {
    var g2 = A.rawcolliderset_coHalfExtents(this.ptr, I2);
    return g2 === 0 ? void 0 : v.__wrap(g2);
  }
  coRadius(I2) {
    try {
      const B2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawcolliderset_coRadius(B2, this.ptr, I2);
      var g2 = U()[B2 / 4 + 0], C2 = q()[B2 / 4 + 1];
      return g2 === 0 ? void 0 : C2;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  coHalfHeight(I2) {
    try {
      const B2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawcolliderset_coHalfHeight(B2, this.ptr, I2);
      var g2 = U()[B2 / 4 + 0], C2 = q()[B2 / 4 + 1];
      return g2 === 0 ? void 0 : C2;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  coRoundRadius(I2) {
    try {
      const B2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawcolliderset_coRoundRadius(B2, this.ptr, I2);
      var g2 = U()[B2 / 4 + 0], C2 = q()[B2 / 4 + 1];
      return g2 === 0 ? void 0 : C2;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  coVertices(I2) {
    try {
      const B2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawcolliderset_coVertices(B2, this.ptr, I2);
      var g2 = U()[B2 / 4 + 0], C2 = U()[B2 / 4 + 1];
      let Q2;
      return g2 !== 0 && (Q2 = N(g2, C2).slice(), A.__wbindgen_free(g2, 4 * C2)), Q2;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  coIndices(I2) {
    try {
      const B2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawcolliderset_coIndices(B2, this.ptr, I2);
      var g2 = U()[B2 / 4 + 0], C2 = U()[B2 / 4 + 1];
      let Q2;
      return g2 !== 0 && (Q2 = function(A2, I3) {
        return s().subarray(A2 / 4, A2 / 4 + I3);
      }(g2, C2).slice(), A.__wbindgen_free(g2, 4 * C2)), Q2;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  coHeightfieldHeights(I2) {
    try {
      const B2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawcolliderset_coHeightfieldHeights(B2, this.ptr, I2);
      var g2 = U()[B2 / 4 + 0], C2 = U()[B2 / 4 + 1];
      let Q2;
      return g2 !== 0 && (Q2 = N(g2, C2).slice(), A.__wbindgen_free(g2, 4 * C2)), Q2;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  coHeightfieldScale(I2) {
    var g2 = A.rawcolliderset_coHeightfieldScale(this.ptr, I2);
    return g2 === 0 ? void 0 : v.__wrap(g2);
  }
  coHeightfieldNRows(I2) {
    try {
      const B2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawcolliderset_coHeightfieldNRows(B2, this.ptr, I2);
      var g2 = U()[B2 / 4 + 0], C2 = U()[B2 / 4 + 1];
      return g2 === 0 ? void 0 : C2 >>> 0;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  coHeightfieldNCols(I2) {
    try {
      const B2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawcolliderset_coHeightfieldNCols(B2, this.ptr, I2);
      var g2 = U()[B2 / 4 + 0], C2 = U()[B2 / 4 + 1];
      return g2 === 0 ? void 0 : C2 >>> 0;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  coParent(I2) {
    return A.rawcolliderset_coParent(this.ptr, I2) >>> 0;
  }
  coFriction(I2) {
    return A.rawcolliderset_coFriction(this.ptr, I2);
  }
  coDensity(I2) {
    try {
      const B2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawcolliderset_coDensity(B2, this.ptr, I2);
      var g2 = U()[B2 / 4 + 0], C2 = q()[B2 / 4 + 1];
      return g2 === 0 ? void 0 : C2;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  coCollisionGroups(I2) {
    return A.rawcolliderset_coCollisionGroups(this.ptr, I2) >>> 0;
  }
  coSolverGroups(I2) {
    return A.rawcolliderset_coSolverGroups(this.ptr, I2) >>> 0;
  }
  coActiveHooks(I2) {
    return A.rawcolliderset_coActiveHooks(this.ptr, I2) >>> 0;
  }
  coActiveCollisionTypes(I2) {
    return A.rawcolliderset_coActiveCollisionTypes(this.ptr, I2);
  }
  coActiveEvents(I2) {
    return A.rawcolliderset_coActiveEvents(this.ptr, I2) >>> 0;
  }
  coSetSensor(I2, g2) {
    A.rawcolliderset_coSetSensor(this.ptr, I2, g2);
  }
  coSetRestitution(I2, g2) {
    A.rawcolliderset_coSetRestitution(this.ptr, I2, g2);
  }
  coSetFriction(I2, g2) {
    A.rawcolliderset_coSetFriction(this.ptr, I2, g2);
  }
  coFrictionCombineRule(I2) {
    return A.rawcolliderset_coFrictionCombineRule(this.ptr, I2) >>> 0;
  }
  coSetFrictionCombineRule(I2, g2) {
    A.rawcolliderset_coSetFrictionCombineRule(this.ptr, I2, g2);
  }
  coRestitutionCombineRule(I2) {
    return A.rawcolliderset_coRestitutionCombineRule(this.ptr, I2) >>> 0;
  }
  coSetRestitutionCombineRule(I2, g2) {
    A.rawcolliderset_coSetRestitutionCombineRule(this.ptr, I2, g2);
  }
  coSetCollisionGroups(I2, g2) {
    A.rawcolliderset_coSetCollisionGroups(this.ptr, I2, g2);
  }
  coSetSolverGroups(I2, g2) {
    A.rawcolliderset_coSetSolverGroups(this.ptr, I2, g2);
  }
  coSetActiveHooks(I2, g2) {
    A.rawcolliderset_coSetActiveHooks(this.ptr, I2, g2);
  }
  coSetActiveEvents(I2, g2) {
    A.rawcolliderset_coSetActiveEvents(this.ptr, I2, g2);
  }
  coSetActiveCollisionTypes(I2, g2) {
    A.rawcolliderset_coSetActiveCollisionTypes(this.ptr, I2, g2);
  }
  coSetShape(I2, g2) {
    M(g2, P);
    var C2 = g2.ptr;
    g2.ptr = 0, A.rawcolliderset_coSetShape(this.ptr, I2, C2);
  }
  constructor() {
    var I2 = A.rawcolliderset_new();
    return p.__wrap(I2);
  }
  len() {
    return A.rawcolliderset_len(this.ptr) >>> 0;
  }
  contains(I2) {
    return A.rawcolliderset_contains(this.ptr, I2) !== 0;
  }
  createCollider(I2, g2, C2, B2, Q2, E2, i2, o2, D2, S2, G2, k2, w2, J2, K2, F2, a2, h2, y2, q2, N2, R2) {
    try {
      const Y2 = A.__wbindgen_add_to_stack_pointer(-16);
      M(I2, P), M(g2, v), M(C2, m), M(E2, v), M(i2, v), M(o2, m), M(R2, V), A.rawcolliderset_createCollider(Y2, this.ptr, I2.ptr, g2.ptr, C2.ptr, B2, Q2, E2.ptr, i2.ptr, o2.ptr, D2, S2, G2, k2, w2, J2, K2, F2, a2, h2, y2, q2, N2, R2.ptr);
      var s2 = U()[Y2 / 4 + 0], c2 = U()[Y2 / 4 + 1];
      return s2 === 0 ? void 0 : c2 >>> 0;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  remove(I2, g2, C2, B2) {
    M(g2, d), M(C2, V), A.rawcolliderset_remove(this.ptr, I2, g2.ptr, C2.ptr, B2);
  }
  isHandleValid(I2) {
    return A.rawcolliderset_contains(this.ptr, I2) !== 0;
  }
  forEachColliderHandle(g2) {
    try {
      A.rawcolliderset_forEachColliderHandle(this.ptr, h(g2));
    } finally {
      I[a++] = void 0;
    }
  }
}
class t {
  static __wrap(A2) {
    const I2 = Object.create(t.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawcontactmanifold_free(I2);
  }
  normal() {
    var I2 = A.rawcontactmanifold_normal(this.ptr);
    return v.__wrap(I2);
  }
  local_n1() {
    var I2 = A.rawcontactmanifold_local_n1(this.ptr);
    return v.__wrap(I2);
  }
  local_n2() {
    var I2 = A.rawcontactmanifold_local_n1(this.ptr);
    return v.__wrap(I2);
  }
  subshape1() {
    return A.rawcontactmanifold_subshape1(this.ptr) >>> 0;
  }
  subshape2() {
    return A.rawcontactmanifold_subshape1(this.ptr) >>> 0;
  }
  num_contacts() {
    return A.rawcontactmanifold_num_contacts(this.ptr) >>> 0;
  }
  contact_local_p1(I2) {
    var g2 = A.rawcontactmanifold_contact_local_p1(this.ptr, I2);
    return g2 === 0 ? void 0 : v.__wrap(g2);
  }
  contact_local_p2(I2) {
    var g2 = A.rawcontactmanifold_contact_local_p1(this.ptr, I2);
    return g2 === 0 ? void 0 : v.__wrap(g2);
  }
  contact_dist(I2) {
    return A.rawcontactmanifold_contact_dist(this.ptr, I2);
  }
  contact_fid1(I2) {
    return A.rawcontactmanifold_contact_fid1(this.ptr, I2) >>> 0;
  }
  contact_fid2(I2) {
    return A.rawcontactmanifold_contact_fid2(this.ptr, I2) >>> 0;
  }
  contact_impulse(I2) {
    return A.rawcontactmanifold_contact_impulse(this.ptr, I2);
  }
  contact_tangent_impulse_x(I2) {
    return A.rawcontactmanifold_contact_tangent_impulse_x(this.ptr, I2);
  }
  contact_tangent_impulse_y(I2) {
    return A.rawcontactmanifold_contact_tangent_impulse_y(this.ptr, I2);
  }
  num_solver_contacts() {
    return A.rawcontactmanifold_num_solver_contacts(this.ptr) >>> 0;
  }
  solver_contact_point(I2) {
    var g2 = A.rawcontactmanifold_solver_contact_point(this.ptr, I2);
    return g2 === 0 ? void 0 : v.__wrap(g2);
  }
  solver_contact_dist(I2) {
    return A.rawcontactmanifold_solver_contact_dist(this.ptr, I2);
  }
  solver_contact_friction(I2) {
    return A.rawcontactmanifold_solver_contact_friction(this.ptr, I2);
  }
  solver_contact_restitution(I2) {
    return A.rawcontactmanifold_solver_contact_restitution(this.ptr, I2);
  }
  solver_contact_tangent_velocity(I2) {
    var g2 = A.rawcontactmanifold_solver_contact_tangent_velocity(this.ptr, I2);
    return v.__wrap(g2);
  }
}
class T {
  static __wrap(A2) {
    const I2 = Object.create(T.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawcontactpair_free(I2);
  }
  collider1() {
    return A.rawcontactpair_collider1(this.ptr) >>> 0;
  }
  collider2() {
    return A.rawcontactpair_collider2(this.ptr) >>> 0;
  }
  numContactManifolds() {
    return A.rawcontactpair_numContactManifolds(this.ptr) >>> 0;
  }
  contactManifold(I2) {
    var g2 = A.rawcontactpair_contactManifold(this.ptr, I2);
    return g2 === 0 ? void 0 : t.__wrap(g2);
  }
}
class O {
  static __wrap(A2) {
    const I2 = Object.create(O.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawdeserializedworld_free(I2);
  }
  takeGravity() {
    var I2 = A.rawdeserializedworld_takeGravity(this.ptr);
    return I2 === 0 ? void 0 : v.__wrap(I2);
  }
  takeIntegrationParameters() {
    var I2 = A.rawdeserializedworld_takeIntegrationParameters(this.ptr);
    return I2 === 0 ? void 0 : n.__wrap(I2);
  }
  takeIslandManager() {
    var I2 = A.rawdeserializedworld_takeIslandManager(this.ptr);
    return I2 === 0 ? void 0 : d.__wrap(I2);
  }
  takeBroadPhase() {
    var I2 = A.rawdeserializedworld_takeBroadPhase(this.ptr);
    return I2 === 0 ? void 0 : L.__wrap(I2);
  }
  takeNarrowPhase() {
    var I2 = A.rawdeserializedworld_takeNarrowPhase(this.ptr);
    return I2 === 0 ? void 0 : f.__wrap(I2);
  }
  takeBodies() {
    var I2 = A.rawdeserializedworld_takeBodies(this.ptr);
    return I2 === 0 ? void 0 : V.__wrap(I2);
  }
  takeColliders() {
    var I2 = A.rawdeserializedworld_takeColliders(this.ptr);
    return I2 === 0 ? void 0 : p.__wrap(I2);
  }
  takeJoints() {
    var I2 = A.rawdeserializedworld_takeJoints(this.ptr);
    return I2 === 0 ? void 0 : r.__wrap(I2);
  }
}
class e {
  static __wrap(A2) {
    const I2 = Object.create(e.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_raweventqueue_free(I2);
  }
  constructor(I2) {
    var g2 = A.raweventqueue_new(I2);
    return e.__wrap(g2);
  }
  drainContactEvents(g2) {
    try {
      A.raweventqueue_drainContactEvents(this.ptr, h(g2));
    } finally {
      I[a++] = void 0;
    }
  }
  drainIntersectionEvents(g2) {
    try {
      A.raweventqueue_drainIntersectionEvents(this.ptr, h(g2));
    } finally {
      I[a++] = void 0;
    }
  }
  clear() {
    A.raweventqueue_clear(this.ptr);
  }
}
class n {
  static __wrap(A2) {
    const I2 = Object.create(n.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawintegrationparameters_free(I2);
  }
  constructor() {
    var I2 = A.rawintegrationparameters_new();
    return n.__wrap(I2);
  }
  get dt() {
    return A.rawintegrationparameters_dt(this.ptr);
  }
  get erp() {
    return A.rawintegrationparameters_erp(this.ptr);
  }
  get jointErp() {
    return A.rawintegrationparameters_jointErp(this.ptr);
  }
  get warmstartCoeff() {
    return A.rawintegrationparameters_warmstartCoeff(this.ptr);
  }
  get allowedLinearError() {
    return A.rawintegrationparameters_allowedLinearError(this.ptr);
  }
  get predictionDistance() {
    return A.rawintegrationparameters_predictionDistance(this.ptr);
  }
  get allowedAngularError() {
    return A.rawintegrationparameters_allowedAngularError(this.ptr);
  }
  get maxLinearCorrection() {
    return A.rawintegrationparameters_maxLinearCorrection(this.ptr);
  }
  get maxAngularCorrection() {
    return A.rawintegrationparameters_maxAngularCorrection(this.ptr);
  }
  get maxVelocityIterations() {
    return A.rawintegrationparameters_maxVelocityIterations(this.ptr) >>> 0;
  }
  get maxPositionIterations() {
    return A.rawintegrationparameters_maxPositionIterations(this.ptr) >>> 0;
  }
  get minIslandSize() {
    return A.rawintegrationparameters_minIslandSize(this.ptr) >>> 0;
  }
  get maxCcdSubsteps() {
    return A.rawintegrationparameters_maxCcdSubsteps(this.ptr) >>> 0;
  }
  set dt(I2) {
    A.rawintegrationparameters_set_dt(this.ptr, I2);
  }
  set erp(I2) {
    A.rawintegrationparameters_set_erp(this.ptr, I2);
  }
  set jointErp(I2) {
    A.rawintegrationparameters_set_jointErp(this.ptr, I2);
  }
  set warmstartCoeff(I2) {
    A.rawintegrationparameters_set_warmstartCoeff(this.ptr, I2);
  }
  set allowedLinearError(I2) {
    A.rawintegrationparameters_set_allowedLinearError(this.ptr, I2);
  }
  set predictionDistance(I2) {
    A.rawintegrationparameters_set_predictionDistance(this.ptr, I2);
  }
  set allowedAngularError(I2) {
    A.rawintegrationparameters_set_allowedAngularError(this.ptr, I2);
  }
  set maxLinearCorrection(I2) {
    A.rawintegrationparameters_set_maxLinearCorrection(this.ptr, I2);
  }
  set maxAngularCorrection(I2) {
    A.rawintegrationparameters_set_maxAngularCorrection(this.ptr, I2);
  }
  set maxVelocityIterations(I2) {
    A.rawintegrationparameters_set_maxVelocityIterations(this.ptr, I2);
  }
  set maxPositionIterations(I2) {
    A.rawintegrationparameters_set_maxPositionIterations(this.ptr, I2);
  }
  set minIslandSize(I2) {
    A.rawintegrationparameters_set_minIslandSize(this.ptr, I2);
  }
  set maxCcdSubsteps(I2) {
    A.rawintegrationparameters_set_maxCcdSubsteps(this.ptr, I2);
  }
}
class d {
  static __wrap(A2) {
    const I2 = Object.create(d.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawislandmanager_free(I2);
  }
  constructor() {
    var I2 = A.rawislandmanager_new();
    return d.__wrap(I2);
  }
  forEachActiveRigidBodyHandle(g2) {
    try {
      A.rawislandmanager_forEachActiveRigidBodyHandle(this.ptr, h(g2));
    } finally {
      I[a++] = void 0;
    }
  }
}
class Z {
  static __wrap(A2) {
    const I2 = Object.create(Z.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawjointparams_free(I2);
  }
  static ball(I2, g2) {
    M(I2, v), M(g2, v);
    var C2 = A.rawjointparams_ball(I2.ptr, g2.ptr);
    return Z.__wrap(C2);
  }
  static prismatic(I2, g2, C2, B2, Q2, E2, i2, o2, D2) {
    M(I2, v), M(g2, v), M(C2, v), M(B2, v), M(Q2, v), M(E2, v);
    var S2 = A.rawjointparams_prismatic(I2.ptr, g2.ptr, C2.ptr, B2.ptr, Q2.ptr, E2.ptr, i2, o2, D2);
    return S2 === 0 ? void 0 : Z.__wrap(S2);
  }
  static fixed(I2, g2, C2, B2) {
    M(I2, v), M(g2, m), M(C2, v), M(B2, m);
    var Q2 = A.rawjointparams_fixed(I2.ptr, g2.ptr, C2.ptr, B2.ptr);
    return Z.__wrap(Q2);
  }
  static revolute(I2, g2, C2, B2) {
    M(I2, v), M(g2, v), M(C2, v), M(B2, v);
    var Q2 = A.rawjointparams_revolute(I2.ptr, g2.ptr, C2.ptr, B2.ptr);
    return Q2 === 0 ? void 0 : Z.__wrap(Q2);
  }
}
class r {
  static __wrap(A2) {
    const I2 = Object.create(r.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawjointset_free(I2);
  }
  jointBodyHandle1(I2) {
    return A.rawjointset_jointBodyHandle1(this.ptr, I2) >>> 0;
  }
  jointBodyHandle2(I2) {
    return A.rawjointset_jointBodyHandle2(this.ptr, I2) >>> 0;
  }
  jointType(I2) {
    return A.rawjointset_jointType(this.ptr, I2) >>> 0;
  }
  jointFrameX1(I2) {
    var g2 = A.rawjointset_jointFrameX1(this.ptr, I2);
    return m.__wrap(g2);
  }
  jointFrameX2(I2) {
    var g2 = A.rawjointset_jointFrameX2(this.ptr, I2);
    return m.__wrap(g2);
  }
  jointAnchor1(I2) {
    var g2 = A.rawjointset_jointAnchor1(this.ptr, I2);
    return v.__wrap(g2);
  }
  jointAnchor2(I2) {
    var g2 = A.rawjointset_jointAnchor2(this.ptr, I2);
    return v.__wrap(g2);
  }
  jointAxis1(I2) {
    var g2 = A.rawjointset_jointAxis1(this.ptr, I2);
    return g2 === 0 ? void 0 : v.__wrap(g2);
  }
  jointAxis2(I2) {
    var g2 = A.rawjointset_jointAxis2(this.ptr, I2);
    return g2 === 0 ? void 0 : v.__wrap(g2);
  }
  jointLimitsEnabled(I2) {
    return A.rawjointset_jointLimitsEnabled(this.ptr, I2) !== 0;
  }
  jointLimitsMin(I2) {
    return A.rawjointset_jointLimitsMin(this.ptr, I2);
  }
  jointLimitsMax(I2) {
    return A.rawjointset_jointLimitsMax(this.ptr, I2);
  }
  jointConfigureMotorModel(I2, g2) {
    A.rawjointset_jointConfigureMotorModel(this.ptr, I2, g2);
  }
  jointConfigureBallMotorVelocity(I2, g2, C2, B2, Q2) {
    A.rawjointset_jointConfigureBallMotorVelocity(this.ptr, I2, g2, C2, B2, Q2);
  }
  jointConfigureBallMotorPosition(I2, g2, C2, B2, Q2, E2, i2) {
    A.rawjointset_jointConfigureBallMotorPosition(this.ptr, I2, g2, C2, B2, Q2, E2, i2);
  }
  jointConfigureBallMotor(I2, g2, C2, B2, Q2, E2, i2, o2, D2, S2) {
    A.rawjointset_jointConfigureBallMotor(this.ptr, I2, g2, C2, B2, Q2, E2, i2, o2, D2, S2);
  }
  jointConfigureUnitMotorVelocity(I2, g2, C2) {
    A.rawjointset_jointConfigureUnitMotorVelocity(this.ptr, I2, g2, C2);
  }
  jointConfigureUnitMotorPosition(I2, g2, C2, B2) {
    A.rawjointset_jointConfigureUnitMotorPosition(this.ptr, I2, g2, C2, B2);
  }
  jointConfigureUnitMotor(I2, g2, C2, B2, Q2) {
    A.rawjointset_jointConfigureUnitMotor(this.ptr, I2, g2, C2, B2, Q2);
  }
  constructor() {
    var I2 = A.rawjointset_new();
    return r.__wrap(I2);
  }
  createJoint(I2, g2, C2, B2) {
    return M(I2, V), M(g2, Z), A.rawjointset_createJoint(this.ptr, I2.ptr, g2.ptr, C2, B2) >>> 0;
  }
  remove(I2, g2, C2, B2) {
    M(g2, d), M(C2, V), A.rawjointset_remove(this.ptr, I2, g2.ptr, C2.ptr, B2);
  }
  len() {
    return A.rawjointset_len(this.ptr) >>> 0;
  }
  contains(I2) {
    return A.rawjointset_contains(this.ptr, I2) !== 0;
  }
  forEachJointHandle(g2) {
    try {
      A.rawjointset_forEachJointHandle(this.ptr, h(g2));
    } finally {
      I[a++] = void 0;
    }
  }
}
class f {
  static __wrap(A2) {
    const I2 = Object.create(f.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawnarrowphase_free(I2);
  }
  constructor() {
    var I2 = A.rawnarrowphase_new();
    return f.__wrap(I2);
  }
  contacts_with(I2, g2) {
    A.rawnarrowphase_contacts_with(this.ptr, I2, Q(g2));
  }
  contact_pair(I2, g2) {
    var C2 = A.rawnarrowphase_contact_pair(this.ptr, I2, g2);
    return C2 === 0 ? void 0 : T.__wrap(C2);
  }
  intersections_with(I2, g2) {
    A.rawnarrowphase_intersections_with(this.ptr, I2, Q(g2));
  }
  intersection_pair(I2, g2) {
    return A.rawnarrowphase_intersection_pair(this.ptr, I2, g2) !== 0;
  }
}
class W {
  static __wrap(A2) {
    const I2 = Object.create(W.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawphysicspipeline_free(I2);
  }
  constructor() {
    var I2 = A.rawphysicspipeline_new();
    return W.__wrap(I2);
  }
  step(I2, g2, C2, B2, Q2, E2, i2, o2, D2) {
    M(I2, v), M(g2, n), M(C2, d), M(B2, L), M(Q2, f), M(E2, V), M(i2, p), M(o2, r), M(D2, H), A.rawphysicspipeline_step(this.ptr, I2.ptr, g2.ptr, C2.ptr, B2.ptr, Q2.ptr, E2.ptr, i2.ptr, o2.ptr, D2.ptr);
  }
  stepWithEvents(I2, g2, C2, B2, E2, i2, o2, D2, S2, G2, k2, U2, w2) {
    M(I2, v), M(g2, n), M(C2, d), M(B2, L), M(E2, f), M(i2, V), M(o2, p), M(D2, r), M(S2, H), M(G2, e), A.rawphysicspipeline_stepWithEvents(this.ptr, I2.ptr, g2.ptr, C2.ptr, B2.ptr, E2.ptr, i2.ptr, o2.ptr, D2.ptr, S2.ptr, G2.ptr, Q(k2), Q(U2), Q(w2));
  }
}
class b {
  static __wrap(A2) {
    const I2 = Object.create(b.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawpointcolliderprojection_free(I2);
  }
  colliderHandle() {
    return A.rawpointcolliderprojection_colliderHandle(this.ptr) >>> 0;
  }
  point() {
    var I2 = A.rawpointcolliderprojection_point(this.ptr);
    return v.__wrap(I2);
  }
  isInside() {
    return A.rawpointcolliderprojection_isInside(this.ptr) !== 0;
  }
}
class j {
  static __wrap(A2) {
    const I2 = Object.create(j.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawquerypipeline_free(I2);
  }
  constructor() {
    var I2 = A.rawquerypipeline_new();
    return j.__wrap(I2);
  }
  update(I2, g2, C2) {
    M(I2, d), M(g2, V), M(C2, p), A.rawquerypipeline_update(this.ptr, I2.ptr, g2.ptr, C2.ptr);
  }
  castRay(I2, g2, C2, B2, Q2, E2) {
    M(I2, p), M(g2, v), M(C2, v);
    var i2 = A.rawquerypipeline_castRay(this.ptr, I2.ptr, g2.ptr, C2.ptr, B2, Q2, E2);
    return i2 === 0 ? void 0 : X.__wrap(i2);
  }
  castRayAndGetNormal(I2, g2, C2, B2, Q2, E2) {
    M(I2, p), M(g2, v), M(C2, v);
    var i2 = A.rawquerypipeline_castRayAndGetNormal(this.ptr, I2.ptr, g2.ptr, C2.ptr, B2, Q2, E2);
    return i2 === 0 ? void 0 : x.__wrap(i2);
  }
  intersectionsWithRay(g2, C2, B2, Q2, E2, i2, o2) {
    try {
      M(g2, p), M(C2, v), M(B2, v), A.rawquerypipeline_intersectionsWithRay(this.ptr, g2.ptr, C2.ptr, B2.ptr, Q2, E2, i2, h(o2));
    } finally {
      I[a++] = void 0;
    }
  }
  intersectionWithShape(I2, g2, C2, B2, Q2) {
    try {
      const o2 = A.__wbindgen_add_to_stack_pointer(-16);
      M(I2, p), M(g2, v), M(C2, m), M(B2, P), A.rawquerypipeline_intersectionWithShape(o2, this.ptr, I2.ptr, g2.ptr, C2.ptr, B2.ptr, Q2);
      var E2 = U()[o2 / 4 + 0], i2 = U()[o2 / 4 + 1];
      return E2 === 0 ? void 0 : i2 >>> 0;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  projectPoint(I2, g2, C2, B2) {
    M(I2, p), M(g2, v);
    var Q2 = A.rawquerypipeline_projectPoint(this.ptr, I2.ptr, g2.ptr, C2, B2);
    return Q2 === 0 ? void 0 : b.__wrap(Q2);
  }
  intersectionsWithPoint(g2, C2, B2, Q2) {
    try {
      M(g2, p), M(C2, v), A.rawquerypipeline_intersectionsWithPoint(this.ptr, g2.ptr, C2.ptr, B2, h(Q2));
    } finally {
      I[a++] = void 0;
    }
  }
  castShape(I2, g2, C2, B2, Q2, E2, i2) {
    M(I2, p), M(g2, v), M(C2, m), M(B2, v), M(Q2, P);
    var o2 = A.rawquerypipeline_castShape(this.ptr, I2.ptr, g2.ptr, C2.ptr, B2.ptr, Q2.ptr, E2, i2);
    return o2 === 0 ? void 0 : z.__wrap(o2);
  }
  intersectionsWithShape(g2, C2, B2, Q2, E2, i2) {
    try {
      M(g2, p), M(C2, v), M(B2, m), M(Q2, P), A.rawquerypipeline_intersectionsWithShape(this.ptr, g2.ptr, C2.ptr, B2.ptr, Q2.ptr, E2, h(i2));
    } finally {
      I[a++] = void 0;
    }
  }
  collidersWithAabbIntersectingAabb(g2, C2, B2) {
    try {
      M(g2, v);
      var Q2 = g2.ptr;
      g2.ptr = 0, M(C2, v);
      var E2 = C2.ptr;
      C2.ptr = 0, A.rawquerypipeline_collidersWithAabbIntersectingAabb(this.ptr, Q2, E2, h(B2));
    } finally {
      I[a++] = void 0;
    }
  }
}
class x {
  static __wrap(A2) {
    const I2 = Object.create(x.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawraycolliderintersection_free(I2);
  }
  colliderHandle() {
    return A.rawpointcolliderprojection_colliderHandle(this.ptr) >>> 0;
  }
  normal() {
    var I2 = A.rawraycolliderintersection_normal(this.ptr);
    return v.__wrap(I2);
  }
  toi() {
    return A.rawraycolliderintersection_toi(this.ptr);
  }
}
class X {
  static __wrap(A2) {
    const I2 = Object.create(X.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawraycollidertoi_free(I2);
  }
  colliderHandle() {
    return A.rawpointcolliderprojection_colliderHandle(this.ptr) >>> 0;
  }
  toi() {
    return A.rawraycolliderintersection_toi(this.ptr);
  }
}
class V {
  static __wrap(A2) {
    const I2 = Object.create(V.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawrigidbodyset_free(I2);
  }
  rbTranslation(I2) {
    var g2 = A.rawrigidbodyset_rbTranslation(this.ptr, I2);
    return v.__wrap(g2);
  }
  rbRotation(I2) {
    var g2 = A.rawrigidbodyset_rbRotation(this.ptr, I2);
    return m.__wrap(g2);
  }
  rbSleep(I2) {
    A.rawrigidbodyset_rbSleep(this.ptr, I2);
  }
  rbIsSleeping(I2) {
    return A.rawrigidbodyset_rbIsSleeping(this.ptr, I2) !== 0;
  }
  rbIsMoving(I2) {
    return A.rawrigidbodyset_rbIsMoving(this.ptr, I2) !== 0;
  }
  rbNextTranslation(I2) {
    var g2 = A.rawrigidbodyset_rbNextTranslation(this.ptr, I2);
    return v.__wrap(g2);
  }
  rbNextRotation(I2) {
    var g2 = A.rawrigidbodyset_rbNextRotation(this.ptr, I2);
    return m.__wrap(g2);
  }
  rbSetTranslation(I2, g2, C2, B2, Q2) {
    A.rawrigidbodyset_rbSetTranslation(this.ptr, I2, g2, C2, B2, Q2);
  }
  rbSetRotation(I2, g2, C2, B2, Q2, E2) {
    A.rawrigidbodyset_rbSetRotation(this.ptr, I2, g2, C2, B2, Q2, E2);
  }
  rbSetLinvel(I2, g2, C2) {
    M(g2, v), A.rawrigidbodyset_rbSetLinvel(this.ptr, I2, g2.ptr, C2);
  }
  rbSetAngvel(I2, g2, C2) {
    M(g2, v), A.rawrigidbodyset_rbSetAngvel(this.ptr, I2, g2.ptr, C2);
  }
  rbSetNextKinematicTranslation(I2, g2, C2, B2) {
    A.rawrigidbodyset_rbSetNextKinematicTranslation(this.ptr, I2, g2, C2, B2);
  }
  rbSetNextKinematicRotation(I2, g2, C2, B2, Q2) {
    A.rawrigidbodyset_rbSetNextKinematicRotation(this.ptr, I2, g2, C2, B2, Q2);
  }
  rbLinvel(I2) {
    var g2 = A.rawrigidbodyset_rbLinvel(this.ptr, I2);
    return v.__wrap(g2);
  }
  rbAngvel(I2) {
    var g2 = A.rawrigidbodyset_rbAngvel(this.ptr, I2);
    return v.__wrap(g2);
  }
  rbLockTranslations(I2, g2, C2) {
    A.rawrigidbodyset_rbLockRotations(this.ptr, I2, g2, C2);
  }
  rbLockRotations(I2, g2, C2) {
    A.rawrigidbodyset_rbLockRotations(this.ptr, I2, g2, C2);
  }
  rbRestrictRotations(I2, g2, C2, B2, Q2) {
    A.rawrigidbodyset_rbRestrictRotations(this.ptr, I2, g2, C2, B2, Q2);
  }
  rbDominanceGroup(I2) {
    return A.rawrigidbodyset_rbDominanceGroup(this.ptr, I2);
  }
  rbSetDominanceGroup(I2, g2) {
    A.rawrigidbodyset_rbSetDominanceGroup(this.ptr, I2, g2);
  }
  rbEnableCcd(I2, g2) {
    A.rawrigidbodyset_rbEnableCcd(this.ptr, I2, g2);
  }
  rbMass(I2) {
    return A.rawrigidbodyset_rbMass(this.ptr, I2);
  }
  rbWakeUp(I2) {
    A.rawrigidbodyset_rbWakeUp(this.ptr, I2);
  }
  rbIsCcdEnabled(I2) {
    return A.rawrigidbodyset_rbIsCcdEnabled(this.ptr, I2) !== 0;
  }
  rbNumColliders(I2) {
    return A.rawrigidbodyset_rbNumColliders(this.ptr, I2) >>> 0;
  }
  rbCollider(I2, g2) {
    return A.rawrigidbodyset_rbCollider(this.ptr, I2, g2) >>> 0;
  }
  rbBodyType(I2) {
    return A.rawrigidbodyset_rbBodyType(this.ptr, I2) >>> 0;
  }
  rbIsStatic(I2) {
    return A.rawrigidbodyset_rbIsStatic(this.ptr, I2) !== 0;
  }
  rbIsKinematic(I2) {
    return A.rawrigidbodyset_rbIsKinematic(this.ptr, I2) !== 0;
  }
  rbIsDynamic(I2) {
    return A.rawrigidbodyset_rbIsDynamic(this.ptr, I2) !== 0;
  }
  rbLinearDamping(I2) {
    return A.rawrigidbodyset_rbLinearDamping(this.ptr, I2);
  }
  rbAngularDamping(I2) {
    return A.rawrigidbodyset_rbAngularDamping(this.ptr, I2);
  }
  rbSetLinearDamping(I2, g2) {
    A.rawrigidbodyset_rbSetLinearDamping(this.ptr, I2, g2);
  }
  rbSetAngularDamping(I2, g2) {
    A.rawrigidbodyset_rbSetAngularDamping(this.ptr, I2, g2);
  }
  rbGravityScale(I2) {
    return A.rawrigidbodyset_rbGravityScale(this.ptr, I2);
  }
  rbSetGravityScale(I2, g2, C2) {
    A.rawrigidbodyset_rbSetGravityScale(this.ptr, I2, g2, C2);
  }
  rbApplyForce(I2, g2, C2) {
    M(g2, v), A.rawrigidbodyset_rbApplyForce(this.ptr, I2, g2.ptr, C2);
  }
  rbApplyImpulse(I2, g2, C2) {
    M(g2, v), A.rawrigidbodyset_rbApplyImpulse(this.ptr, I2, g2.ptr, C2);
  }
  rbApplyTorque(I2, g2, C2) {
    M(g2, v), A.rawrigidbodyset_rbApplyTorque(this.ptr, I2, g2.ptr, C2);
  }
  rbApplyTorqueImpulse(I2, g2, C2) {
    M(g2, v), A.rawrigidbodyset_rbApplyTorqueImpulse(this.ptr, I2, g2.ptr, C2);
  }
  rbApplyForceAtPoint(I2, g2, C2, B2) {
    M(g2, v), M(C2, v), A.rawrigidbodyset_rbApplyForceAtPoint(this.ptr, I2, g2.ptr, C2.ptr, B2);
  }
  rbApplyImpulseAtPoint(I2, g2, C2, B2) {
    M(g2, v), M(C2, v), A.rawrigidbodyset_rbApplyImpulseAtPoint(this.ptr, I2, g2.ptr, C2.ptr, B2);
  }
  constructor() {
    var I2 = A.rawrigidbodyset_new();
    return V.__wrap(I2);
  }
  createRigidBody(I2, g2, C2, B2, Q2, E2, i2, o2, D2, S2, G2, k2, U2, w2, J2, K2, F2, a2, h2) {
    return M(I2, v), M(g2, m), M(E2, v), M(i2, v), M(o2, v), M(D2, v), M(S2, m), A.rawrigidbodyset_createRigidBody(this.ptr, I2.ptr, g2.ptr, C2, B2, Q2, E2.ptr, i2.ptr, o2.ptr, D2.ptr, S2.ptr, G2, k2, U2, w2, J2, K2, F2, a2, h2) >>> 0;
  }
  remove(I2, g2, C2, B2) {
    M(g2, d), M(C2, p), M(B2, r), A.rawrigidbodyset_remove(this.ptr, I2, g2.ptr, C2.ptr, B2.ptr);
  }
  len() {
    return A.rawrigidbodyset_len(this.ptr) >>> 0;
  }
  contains(I2) {
    return A.rawrigidbodyset_contains(this.ptr, I2) !== 0;
  }
  forEachRigidBodyHandle(g2) {
    try {
      A.rawrigidbodyset_forEachRigidBodyHandle(this.ptr, h(g2));
    } finally {
      I[a++] = void 0;
    }
  }
}
class m {
  static __wrap(A2) {
    const I2 = Object.create(m.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawrotation_free(I2);
  }
  constructor(I2, g2, C2, B2) {
    var Q2 = A.rawrotation_new(I2, g2, C2, B2);
    return m.__wrap(Q2);
  }
  static identity() {
    var I2 = A.rawrotation_identity();
    return m.__wrap(I2);
  }
  get x() {
    return A.rawintegrationparameters_dt(this.ptr);
  }
  get y() {
    return A.rawrotation_y(this.ptr);
  }
  get z() {
    return A.rawintegrationparameters_erp(this.ptr);
  }
  get w() {
    return A.rawintegrationparameters_jointErp(this.ptr);
  }
}
class u {
  static __wrap(A2) {
    const I2 = Object.create(u.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawserializationpipeline_free(I2);
  }
  constructor() {
    var I2 = A.rawserializationpipeline_new();
    return u.__wrap(I2);
  }
  serializeAll(I2, g2, C2, Q2, E2, i2, o2, D2) {
    return M(I2, v), M(g2, n), M(C2, d), M(Q2, L), M(E2, f), M(i2, V), M(o2, p), M(D2, r), B(A.rawserializationpipeline_serializeAll(this.ptr, I2.ptr, g2.ptr, C2.ptr, Q2.ptr, E2.ptr, i2.ptr, o2.ptr, D2.ptr));
  }
  deserializeAll(I2) {
    var g2 = A.rawserializationpipeline_deserializeAll(this.ptr, Q(I2));
    return g2 === 0 ? void 0 : O.__wrap(g2);
  }
}
class P {
  static __wrap(A2) {
    const I2 = Object.create(P.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawshape_free(I2);
  }
  static cuboid(I2, g2, C2) {
    var B2 = A.rawshape_cuboid(I2, g2, C2);
    return P.__wrap(B2);
  }
  static roundCuboid(I2, g2, C2, B2) {
    var Q2 = A.rawshape_roundCuboid(I2, g2, C2, B2);
    return P.__wrap(Q2);
  }
  static ball(I2) {
    var g2 = A.rawshape_ball(I2);
    return P.__wrap(g2);
  }
  static capsule(I2, g2) {
    var C2 = A.rawshape_capsule(I2, g2);
    return P.__wrap(C2);
  }
  static cylinder(I2, g2) {
    var C2 = A.rawshape_cylinder(I2, g2);
    return P.__wrap(C2);
  }
  static roundCylinder(I2, g2, C2) {
    var B2 = A.rawshape_roundCylinder(I2, g2, C2);
    return P.__wrap(B2);
  }
  static cone(I2, g2) {
    var C2 = A.rawshape_cone(I2, g2);
    return P.__wrap(C2);
  }
  static roundCone(I2, g2, C2) {
    var B2 = A.rawshape_roundCone(I2, g2, C2);
    return P.__wrap(B2);
  }
  static polyline(I2, g2) {
    var C2 = c(I2, A.__wbindgen_malloc), B2 = J, Q2 = Y(g2, A.__wbindgen_malloc), E2 = J, i2 = A.rawshape_polyline(C2, B2, Q2, E2);
    return P.__wrap(i2);
  }
  static trimesh(I2, g2) {
    var C2 = c(I2, A.__wbindgen_malloc), B2 = J, Q2 = Y(g2, A.__wbindgen_malloc), E2 = J, i2 = A.rawshape_trimesh(C2, B2, Q2, E2);
    return P.__wrap(i2);
  }
  static heightfield(I2, g2, C2, B2) {
    var Q2 = c(C2, A.__wbindgen_malloc), E2 = J;
    M(B2, v);
    var i2 = A.rawshape_heightfield(I2, g2, Q2, E2, B2.ptr);
    return P.__wrap(i2);
  }
  static segment(I2, g2) {
    M(I2, v), M(g2, v);
    var C2 = A.rawshape_segment(I2.ptr, g2.ptr);
    return P.__wrap(C2);
  }
  static triangle(I2, g2, C2) {
    M(I2, v), M(g2, v), M(C2, v);
    var B2 = A.rawshape_triangle(I2.ptr, g2.ptr, C2.ptr);
    return P.__wrap(B2);
  }
  static roundTriangle(I2, g2, C2, B2) {
    M(I2, v), M(g2, v), M(C2, v);
    var Q2 = A.rawshape_roundTriangle(I2.ptr, g2.ptr, C2.ptr, B2);
    return P.__wrap(Q2);
  }
  static convexHull(I2) {
    var g2 = c(I2, A.__wbindgen_malloc), C2 = J, B2 = A.rawshape_convexHull(g2, C2);
    return B2 === 0 ? void 0 : P.__wrap(B2);
  }
  static roundConvexHull(I2, g2) {
    var C2 = c(I2, A.__wbindgen_malloc), B2 = J, Q2 = A.rawshape_roundConvexHull(C2, B2, g2);
    return Q2 === 0 ? void 0 : P.__wrap(Q2);
  }
  static convexMesh(I2, g2) {
    var C2 = c(I2, A.__wbindgen_malloc), B2 = J, Q2 = Y(g2, A.__wbindgen_malloc), E2 = J, i2 = A.rawshape_convexMesh(C2, B2, Q2, E2);
    return i2 === 0 ? void 0 : P.__wrap(i2);
  }
  static roundConvexMesh(I2, g2, C2) {
    var B2 = c(I2, A.__wbindgen_malloc), Q2 = J, E2 = Y(g2, A.__wbindgen_malloc), i2 = J, o2 = A.rawshape_roundConvexMesh(B2, Q2, E2, i2, C2);
    return o2 === 0 ? void 0 : P.__wrap(o2);
  }
}
class z {
  static __wrap(A2) {
    const I2 = Object.create(z.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawshapecollidertoi_free(I2);
  }
  colliderHandle() {
    return A.rawpointcolliderprojection_colliderHandle(this.ptr) >>> 0;
  }
  toi() {
    return A.rawraycolliderintersection_toi(this.ptr);
  }
  witness1() {
    var I2 = A.rawraycolliderintersection_normal(this.ptr);
    return v.__wrap(I2);
  }
  witness2() {
    var I2 = A.rawraycolliderintersection_normal(this.ptr);
    return v.__wrap(I2);
  }
  normal1() {
    var I2 = A.rawshapecollidertoi_normal1(this.ptr);
    return v.__wrap(I2);
  }
  normal2() {
    var I2 = A.rawshapecollidertoi_normal1(this.ptr);
    return v.__wrap(I2);
  }
}
class v {
  static __wrap(A2) {
    const I2 = Object.create(v.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawvector_free(I2);
  }
  static zero() {
    var I2 = A.rawvector_zero();
    return v.__wrap(I2);
  }
  constructor(I2, g2, C2) {
    var B2 = A.rawvector_new(I2, g2, C2);
    return v.__wrap(B2);
  }
  get x() {
    return A.rawintegrationparameters_dt(this.ptr);
  }
  set x(I2) {
    A.rawintegrationparameters_set_dt(this.ptr, I2);
  }
  get y() {
    return A.rawrotation_y(this.ptr);
  }
  set y(I2) {
    A.rawvector_set_y(this.ptr, I2);
  }
  get z() {
    return A.rawintegrationparameters_erp(this.ptr);
  }
  set z(I2) {
    A.rawintegrationparameters_set_erp(this.ptr, I2);
  }
  xyz() {
    var I2 = A.rawvector_xyz(this.ptr);
    return v.__wrap(I2);
  }
  yxz() {
    var I2 = A.rawvector_yxz(this.ptr);
    return v.__wrap(I2);
  }
  zxy() {
    var I2 = A.rawvector_zxy(this.ptr);
    return v.__wrap(I2);
  }
  xzy() {
    var I2 = A.rawvector_xzy(this.ptr);
    return v.__wrap(I2);
  }
  yzx() {
    var I2 = A.rawvector_yzx(this.ptr);
    return v.__wrap(I2);
  }
  zyx() {
    var I2 = A.rawvector_zyx(this.ptr);
    return v.__wrap(I2);
  }
}
async function _(I2) {
  I2 === void 0 && (I2 = new URL("rapier_wasm3d_bg.wasm", "<deleted>"));
  const C2 = { wbg: {} };
  C2.wbg.__wbindgen_object_drop_ref = function(A2) {
    B(A2);
  }, C2.wbg.__wbindgen_number_new = function(A2) {
    return Q(A2);
  }, C2.wbg.__wbg_rawraycolliderintersection_new = function(A2) {
    return Q(x.__wrap(A2));
  }, C2.wbg.__wbindgen_string_new = function(A2, I3) {
    return Q(D(A2, I3));
  }, C2.wbg.__wbg_now_885ca88fafee0fd1 = function(A2) {
    return g(A2).now();
  }, C2.wbg.__wbg_newnoargs_1a11e7e8c906996c = function(A2, I3) {
    return Q(new Function(D(A2, I3)));
  }, C2.wbg.__wbg_get_6d26c712aa73c8b2 = function() {
    return l(function(A2, I3) {
      return Q(Reflect.get(g(A2), g(I3)));
    }, arguments);
  }, C2.wbg.__wbg_call_e91f71ddf1f45cff = function() {
    return l(function(A2, I3) {
      return Q(g(A2).call(g(I3)));
    }, arguments);
  }, C2.wbg.__wbindgen_object_clone_ref = function(A2) {
    return Q(g(A2));
  }, C2.wbg.__wbg_call_e3c72355d091d5d4 = function() {
    return l(function(A2, I3, C3) {
      return Q(g(A2).call(g(I3), g(C3)));
    }, arguments);
  }, C2.wbg.__wbg_call_c143b19d87139944 = function() {
    return l(function(A2, I3, C3, B2) {
      return Q(g(A2).call(g(I3), g(C3), g(B2)));
    }, arguments);
  }, C2.wbg.__wbg_call_72facd37dbc97ddb = function() {
    return l(function(A2, I3, C3, B2, E3) {
      return Q(g(A2).call(g(I3), g(C3), g(B2), g(E3)));
    }, arguments);
  }, C2.wbg.__wbg_bind_07839579f523aa89 = function(A2, I3, C3, B2) {
    return Q(g(A2).bind(g(I3), g(C3), g(B2)));
  }, C2.wbg.__wbg_buffer_79a3294266d4e783 = function(A2) {
    return Q(g(A2).buffer);
  }, C2.wbg.__wbg_self_b4546ea7b590539e = function() {
    return l(function() {
      return Q(self.self);
    }, arguments);
  }, C2.wbg.__wbg_window_c279fea81f426a68 = function() {
    return l(function() {
      return Q(window.window);
    }, arguments);
  }, C2.wbg.__wbg_globalThis_038a6ea0ff17789f = function() {
    return l(function() {
      return Q(globalThis.globalThis);
    }, arguments);
  }, C2.wbg.__wbg_global_4f93ce884bcee597 = function() {
    return l(function() {
      return Q(global.global);
    }, arguments);
  }, C2.wbg.__wbindgen_is_undefined = function(A2) {
    return g(A2) === void 0;
  }, C2.wbg.__wbg_newwithbyteoffsetandlength_22a36e6023ad3cd0 = function(A2, I3, C3) {
    return Q(new Uint8Array(g(A2), I3 >>> 0, C3 >>> 0));
  }, C2.wbg.__wbg_new_945397fb09fec0b8 = function(A2) {
    return Q(new Uint8Array(g(A2)));
  }, C2.wbg.__wbg_set_223873223acf6d07 = function(A2, I3, C3) {
    g(A2).set(g(I3), C3 >>> 0);
  }, C2.wbg.__wbg_length_68e13e7bbd918464 = function(A2) {
    return g(A2).length;
  }, C2.wbg.__wbindgen_number_get = function(I3, C3) {
    const B2 = g(C3);
    var Q2 = typeof B2 == "number" ? B2 : void 0;
    (G !== null && G.buffer === A.memory.buffer || (G = new Float64Array(A.memory.buffer)), G)[I3 / 8 + 1] = S(Q2) ? 0 : Q2, U()[I3 / 4 + 0] = !S(Q2);
  }, C2.wbg.__wbindgen_boolean_get = function(A2) {
    const I3 = g(A2);
    return typeof I3 == "boolean" ? I3 ? 1 : 0 : 2;
  }, C2.wbg.__wbindgen_debug_string = function(I3, C3) {
    var B2 = function(A2, I4, g2) {
      if (g2 === void 0) {
        const g3 = K.encode(A2), C5 = I4(g3.length);
        return o().subarray(C5, C5 + g3.length).set(g3), J = g3.length, C5;
      }
      let C4 = A2.length, B3 = I4(C4);
      const Q3 = o();
      let E3 = 0;
      for (; E3 < C4; E3++) {
        const I5 = A2.charCodeAt(E3);
        if (I5 > 127)
          break;
        Q3[B3 + E3] = I5;
      }
      if (E3 !== C4) {
        E3 !== 0 && (A2 = A2.slice(E3)), B3 = g2(B3, C4, C4 = E3 + 3 * A2.length);
        const I5 = o().subarray(B3 + E3, B3 + C4);
        E3 += F(A2, I5).written;
      }
      return J = E3, B3;
    }(w(g(C3)), A.__wbindgen_malloc, A.__wbindgen_realloc), Q2 = J;
    U()[I3 / 4 + 1] = Q2, U()[I3 / 4 + 0] = B2;
  }, C2.wbg.__wbindgen_throw = function(A2, I3) {
    throw new Error(D(A2, I3));
  }, C2.wbg.__wbindgen_memory = function() {
    return Q(A.memory);
  }, (typeof I2 == "string" || typeof Request == "function" && I2 instanceof Request || typeof URL == "function" && I2 instanceof URL) && (I2 = fetch(I2));
  const { instance: E2, module: i2 } = await async function(A2, I3) {
    if (typeof Response == "function" && A2 instanceof Response) {
      if (typeof WebAssembly.instantiateStreaming == "function")
        try {
          return await WebAssembly.instantiateStreaming(A2, I3);
        } catch (I4) {
          if (A2.headers.get("Content-Type") == "application/wasm")
            throw I4;
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", I4);
        }
      const g2 = await A2.arrayBuffer();
      return await WebAssembly.instantiate(g2, I3);
    }
    {
      const g2 = await WebAssembly.instantiate(A2, I3);
      return g2 instanceof WebAssembly.Instance ? { instance: g2, module: A2 } : g2;
    }
  }(await I2, C2);
  return A = E2.exports, _.__wbindgen_wasm_module = i2, A;
}
var $, AA = function(A2, I2, g2) {
  this.x = A2, this.y = I2, this.z = g2;
}, IA = function() {
  function A2() {
  }
  return A2.new = function(A3, I2, g2) {
    return new AA(A3, I2, g2);
  }, A2.intoRaw = function(A3) {
    return new v(A3.x, A3.y, A3.z);
  }, A2.zeros = function() {
    return A2.new(0, 0, 0);
  }, A2.fromRaw = function(I2) {
    if (!I2)
      return null;
    var g2 = A2.new(I2.x, I2.y, I2.z);
    return I2.free(), g2;
  }, A2;
}(), gA = function(A2, I2, g2, C2) {
  this.x = A2, this.y = I2, this.z = g2, this.w = C2;
}, CA = function() {
  function A2() {
  }
  return A2.identity = function() {
    return new gA(0, 0, 0, 1);
  }, A2.fromRaw = function(A3) {
    if (!A3)
      return null;
    var I2 = new gA(A3.x, A3.y, A3.z, A3.w);
    return A3.free(), I2;
  }, A2.intoRaw = function(A3) {
    return new m(A3.x, A3.y, A3.z, A3.w);
  }, A2;
}();
!function(A2) {
  A2[A2.Dynamic = 0] = "Dynamic", A2[A2.Static = 1] = "Static", A2[A2.KinematicPositionBased = 2] = "KinematicPositionBased", A2[A2.KinematicVelocityBased = 3] = "KinematicVelocityBased";
}($ || ($ = {}));
var BA, QA, EA = function() {
  function A2(A3, I2) {
    this.rawSet = A3, this.handle = I2;
  }
  return A2.prototype.isValid = function() {
    return this.rawSet.contains(this.handle);
  }, A2.prototype.lockTranslations = function(A3, I2) {
    return this.rawSet.rbLockTranslations(this.handle, A3, I2);
  }, A2.prototype.lockRotations = function(A3, I2) {
    return this.rawSet.rbLockRotations(this.handle, A3, I2);
  }, A2.prototype.restrictRotations = function(A3, I2, g2, C2) {
    return this.rawSet.rbRestrictRotations(this.handle, A3, I2, g2, C2);
  }, A2.prototype.dominanceGroup = function() {
    return this.rawSet.rbDominanceGroup(this.handle);
  }, A2.prototype.setDominanceGroup = function(A3) {
    this.rawSet.rbSetDominanceGroup(this.handle, A3);
  }, A2.prototype.enableCcd = function(A3) {
    this.rawSet.rbEnableCcd(this.handle, A3);
  }, A2.prototype.translation = function() {
    var A3 = this.rawSet.rbTranslation(this.handle);
    return IA.fromRaw(A3);
  }, A2.prototype.rotation = function() {
    var A3 = this.rawSet.rbRotation(this.handle);
    return CA.fromRaw(A3);
  }, A2.prototype.nextTranslation = function() {
    var A3 = this.rawSet.rbNextTranslation(this.handle);
    return IA.fromRaw(A3);
  }, A2.prototype.nextRotation = function() {
    var A3 = this.rawSet.rbNextRotation(this.handle);
    return CA.fromRaw(A3);
  }, A2.prototype.setTranslation = function(A3, I2) {
    this.rawSet.rbSetTranslation(this.handle, A3.x, A3.y, A3.z, I2);
  }, A2.prototype.setLinvel = function(A3, I2) {
    var g2 = IA.intoRaw(A3);
    this.rawSet.rbSetLinvel(this.handle, g2, I2), g2.free();
  }, A2.prototype.gravityScale = function() {
    return this.rawSet.rbGravityScale(this.handle);
  }, A2.prototype.setGravityScale = function(A3, I2) {
    this.rawSet.rbSetGravityScale(this.handle, A3, I2);
  }, A2.prototype.setRotation = function(A3, I2) {
    this.rawSet.rbSetRotation(this.handle, A3.x, A3.y, A3.z, A3.w, I2);
  }, A2.prototype.setAngvel = function(A3, I2) {
    var g2 = IA.intoRaw(A3);
    this.rawSet.rbSetAngvel(this.handle, g2, I2), g2.free();
  }, A2.prototype.setNextKinematicTranslation = function(A3) {
    this.rawSet.rbSetNextKinematicTranslation(this.handle, A3.x, A3.y, A3.z);
  }, A2.prototype.setNextKinematicRotation = function(A3) {
    this.rawSet.rbSetNextKinematicRotation(this.handle, A3.x, A3.y, A3.z, A3.w);
  }, A2.prototype.linvel = function() {
    return IA.fromRaw(this.rawSet.rbLinvel(this.handle));
  }, A2.prototype.angvel = function() {
    return IA.fromRaw(this.rawSet.rbAngvel(this.handle));
  }, A2.prototype.mass = function() {
    return this.rawSet.rbMass(this.handle);
  }, A2.prototype.sleep = function() {
    this.rawSet.rbSleep(this.handle);
  }, A2.prototype.wakeUp = function() {
    this.rawSet.rbWakeUp(this.handle);
  }, A2.prototype.isCcdEnabled = function() {
    this.rawSet.rbIsCcdEnabled(this.handle);
  }, A2.prototype.numColliders = function() {
    return this.rawSet.rbNumColliders(this.handle);
  }, A2.prototype.collider = function(A3) {
    return this.rawSet.rbCollider(this.handle, A3);
  }, A2.prototype.bodyType = function() {
    return this.rawSet.rbBodyType(this.handle);
  }, A2.prototype.isSleeping = function() {
    return this.rawSet.rbIsSleeping(this.handle);
  }, A2.prototype.isMoving = function() {
    return this.rawSet.rbIsMoving(this.handle);
  }, A2.prototype.isStatic = function() {
    return this.rawSet.rbIsStatic(this.handle);
  }, A2.prototype.isKinematic = function() {
    return this.rawSet.rbIsKinematic(this.handle);
  }, A2.prototype.isDynamic = function() {
    return this.rawSet.rbIsDynamic(this.handle);
  }, A2.prototype.linearDamping = function() {
    return this.rawSet.rbLinearDamping(this.handle);
  }, A2.prototype.angularDamping = function() {
    return this.rawSet.rbAngularDamping(this.handle);
  }, A2.prototype.setLinearDamping = function(A3) {
    this.rawSet.rbSetLinearDamping(this.handle, A3);
  }, A2.prototype.setAngularDamping = function(A3) {
    this.rawSet.rbSetAngularDamping(this.handle, A3);
  }, A2.prototype.applyForce = function(A3, I2) {
    var g2 = IA.intoRaw(A3);
    this.rawSet.rbApplyForce(this.handle, g2, I2), g2.free();
  }, A2.prototype.applyImpulse = function(A3, I2) {
    var g2 = IA.intoRaw(A3);
    this.rawSet.rbApplyImpulse(this.handle, g2, I2), g2.free();
  }, A2.prototype.applyTorque = function(A3, I2) {
    var g2 = IA.intoRaw(A3);
    this.rawSet.rbApplyTorque(this.handle, g2, I2), g2.free();
  }, A2.prototype.applyTorqueImpulse = function(A3, I2) {
    var g2 = IA.intoRaw(A3);
    this.rawSet.rbApplyTorqueImpulse(this.handle, g2, I2), g2.free();
  }, A2.prototype.applyForceAtPoint = function(A3, I2, g2) {
    var C2 = IA.intoRaw(A3), B2 = IA.intoRaw(I2);
    this.rawSet.rbApplyForceAtPoint(this.handle, C2, B2, g2), C2.free(), B2.free();
  }, A2.prototype.applyImpulseAtPoint = function(A3, I2, g2) {
    var C2 = IA.intoRaw(A3), B2 = IA.intoRaw(I2);
    this.rawSet.rbApplyImpulseAtPoint(this.handle, C2, B2, g2), C2.free(), B2.free();
  }, A2;
}(), iA = function() {
  function A2(A3) {
    this.status = A3, this.translation = IA.zeros(), this.rotation = CA.identity(), this.gravityScale = 1, this.linvel = IA.zeros(), this.mass = 0, this.translationsEnabled = true, this.centerOfMass = IA.zeros(), this.angvel = IA.zeros(), this.principalAngularInertia = IA.zeros(), this.angularInertiaLocalFrame = CA.identity(), this.rotationsEnabledX = true, this.rotationsEnabledY = true, this.rotationsEnabledZ = true, this.linearDamping = 0, this.angularDamping = 0, this.canSleep = true, this.ccdEnabled = false, this.dominanceGroup = 0;
  }
  return A2.newDynamic = function() {
    return new A2($.Dynamic);
  }, A2.newKinematicPositionBased = function() {
    return new A2($.KinematicPositionBased);
  }, A2.newKinematicVelocityBased = function() {
    return new A2($.KinematicVelocityBased);
  }, A2.newStatic = function() {
    return new A2($.Static);
  }, A2.prototype.setDominanceGroup = function(A3) {
    return this.dominanceGroup = A3, this;
  }, A2.prototype.setTranslation = function(A3, I2, g2) {
    if (typeof A3 != "number" || typeof I2 != "number" || typeof g2 != "number")
      throw TypeError("The translation components must be numbers.");
    return this.translation = { x: A3, y: I2, z: g2 }, this;
  }, A2.prototype.setRotation = function(A3) {
    return this.rotation = A3, this;
  }, A2.prototype.setGravityScale = function(A3) {
    return this.gravityScale = A3, this;
  }, A2.prototype.setAdditionalMass = function(A3) {
    return this.mass = A3, this;
  }, A2.prototype.lockTranslations = function() {
    return this.translationsEnabled = false, this;
  }, A2.prototype.setLinvel = function(A3, I2, g2) {
    if (typeof A3 != "number" || typeof I2 != "number" || typeof g2 != "number")
      throw TypeError("The linvel components must be numbers.");
    return this.linvel = { x: A3, y: I2, z: g2 }, this;
  }, A2.prototype.setAngvel = function(A3) {
    return this.angvel = A3, this;
  }, A2.prototype.setAdditionalMassProperties = function(A3, I2, g2, C2) {
    return this.mass = A3, this.centerOfMass = I2, this.principalAngularInertia = g2, this.angularInertiaLocalFrame = C2, this;
  }, A2.prototype.setAdditionalPrincipalAngularInertia = function(A3) {
    return this.principalAngularInertia = A3, this;
  }, A2.prototype.restrictRotations = function(A3, I2, g2) {
    return this.rotationsEnabledX = A3, this.rotationsEnabledY = I2, this.rotationsEnabledZ = g2, this;
  }, A2.prototype.lockRotations = function() {
    return this.restrictRotations(false, false, false);
  }, A2.prototype.setLinearDamping = function(A3) {
    return this.linearDamping = A3, this;
  }, A2.prototype.setAngularDamping = function(A3) {
    return this.angularDamping = A3, this;
  }, A2.prototype.setCanSleep = function(A3) {
    return this.canSleep = A3, this;
  }, A2.prototype.setCcdEnabled = function(A3) {
    return this.ccdEnabled = A3, this;
  }, A2;
}(), oA = function() {
  function A2(A3) {
    this.raw = A3 || new V();
  }
  return A2.prototype.free = function() {
    this.raw.free(), this.raw = void 0;
  }, A2.prototype.createRigidBody = function(A3) {
    var I2 = IA.intoRaw(A3.translation), g2 = CA.intoRaw(A3.rotation), C2 = IA.intoRaw(A3.linvel), B2 = IA.intoRaw(A3.centerOfMass), Q2 = IA.intoRaw(A3.angvel), E2 = IA.intoRaw(A3.principalAngularInertia), i2 = CA.intoRaw(A3.angularInertiaLocalFrame), o2 = this.raw.createRigidBody(I2, g2, A3.gravityScale, A3.mass, A3.translationsEnabled, B2, C2, Q2, E2, i2, A3.rotationsEnabledX, A3.rotationsEnabledY, A3.rotationsEnabledZ, A3.linearDamping, A3.angularDamping, A3.status, A3.canSleep, A3.ccdEnabled, A3.dominanceGroup);
    return I2.free(), g2.free(), C2.free(), B2.free(), Q2.free(), E2.free(), i2.free(), o2;
  }, A2.prototype.remove = function(A3, I2, g2, C2) {
    this.raw.remove(A3, I2.raw, g2.raw, C2.raw);
  }, A2.prototype.len = function() {
    return this.raw.len();
  }, A2.prototype.contains = function(A3) {
    return this.raw.contains(A3);
  }, A2.prototype.get = function(A3) {
    return this.raw.contains(A3) ? new EA(this.raw, A3) : null;
  }, A2.prototype.forEachRigidBody = function(A3) {
    var I2 = this;
    this.forEachRigidBodyHandle(function(g2) {
      A3(new EA(I2.raw, g2));
    });
  }, A2.prototype.forEachRigidBodyHandle = function(A3) {
    this.raw.forEachRigidBodyHandle(A3);
  }, A2.prototype.forEachActiveRigidBody = function(A3, I2) {
    var g2 = this;
    A3.forEachActiveRigidBodyHandle(function(A4) {
      I2(new EA(g2.raw, A4));
    });
  }, A2;
}(), DA = function() {
  function A2(A3) {
    this.raw = A3 || new n();
  }
  return A2.prototype.free = function() {
    this.raw.free(), this.raw = void 0;
  }, Object.defineProperty(A2.prototype, "dt", { get: function() {
    return this.raw.dt;
  }, set: function(A3) {
    this.raw.dt = A3;
  }, enumerable: false, configurable: true }), Object.defineProperty(A2.prototype, "erp", { get: function() {
    return this.raw.erp;
  }, set: function(A3) {
    this.raw.erp = A3;
  }, enumerable: false, configurable: true }), Object.defineProperty(A2.prototype, "jointErp", { get: function() {
    return this.raw.jointErp;
  }, set: function(A3) {
    this.raw.jointErp = A3;
  }, enumerable: false, configurable: true }), Object.defineProperty(A2.prototype, "warmstartCoeff", { get: function() {
    return this.raw.warmstartCoeff;
  }, set: function(A3) {
    this.raw.warmstartCoeff = A3;
  }, enumerable: false, configurable: true }), Object.defineProperty(A2.prototype, "allowedLinearError", { get: function() {
    return this.raw.allowedLinearError;
  }, set: function(A3) {
    this.raw.allowedLinearError = A3;
  }, enumerable: false, configurable: true }), Object.defineProperty(A2.prototype, "predictionDistance", { get: function() {
    return this.raw.predictionDistance;
  }, set: function(A3) {
    this.raw.predictionDistance = A3;
  }, enumerable: false, configurable: true }), Object.defineProperty(A2.prototype, "allowedAngularError", { get: function() {
    return this.raw.allowedAngularError;
  }, set: function(A3) {
    this.raw.allowedAngularError = A3;
  }, enumerable: false, configurable: true }), Object.defineProperty(A2.prototype, "maxLinearCorrection", { get: function() {
    return this.raw.maxLinearCorrection;
  }, set: function(A3) {
    this.raw.maxLinearCorrection = A3;
  }, enumerable: false, configurable: true }), Object.defineProperty(A2.prototype, "maxAngularCorrection", { get: function() {
    return this.raw.maxAngularCorrection;
  }, set: function(A3) {
    this.raw.maxAngularCorrection = A3;
  }, enumerable: false, configurable: true }), Object.defineProperty(A2.prototype, "maxVelocityIterations", { get: function() {
    return this.raw.maxVelocityIterations;
  }, set: function(A3) {
    this.raw.maxVelocityIterations = A3;
  }, enumerable: false, configurable: true }), Object.defineProperty(A2.prototype, "maxPositionIterations", { get: function() {
    return this.raw.maxPositionIterations;
  }, set: function(A3) {
    this.raw.maxPositionIterations = A3;
  }, enumerable: false, configurable: true }), Object.defineProperty(A2.prototype, "minIslandSize", { get: function() {
    return this.raw.minIslandSize;
  }, set: function(A3) {
    this.raw.minIslandSize = A3;
  }, enumerable: false, configurable: true }), Object.defineProperty(A2.prototype, "maxCcdSubsteps", { get: function() {
    return this.raw.maxCcdSubsteps;
  }, set: function(A3) {
    this.raw.maxCcdSubsteps = A3;
  }, enumerable: false, configurable: true }), A2;
}(), SA = function(A2, I2) {
  return (SA = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(A3, I3) {
    A3.__proto__ = I3;
  } || function(A3, I3) {
    for (var g2 in I3)
      Object.prototype.hasOwnProperty.call(I3, g2) && (A3[g2] = I3[g2]);
  })(A2, I2);
};
function GA(A2, I2) {
  if (typeof I2 != "function" && I2 !== null)
    throw new TypeError("Class extends value " + String(I2) + " is not a constructor or null");
  function g2() {
    this.constructor = A2;
  }
  SA(A2, I2), A2.prototype = I2 === null ? Object.create(I2) : (g2.prototype = I2.prototype, new g2());
}
function kA(A2, I2, g2, C2) {
  return new (g2 || (g2 = Promise))(function(B2, Q2) {
    function E2(A3) {
      try {
        o2(C2.next(A3));
      } catch (A4) {
        Q2(A4);
      }
    }
    function i2(A3) {
      try {
        o2(C2.throw(A3));
      } catch (A4) {
        Q2(A4);
      }
    }
    function o2(A3) {
      var I3;
      A3.done ? B2(A3.value) : (I3 = A3.value, I3 instanceof g2 ? I3 : new g2(function(A4) {
        A4(I3);
      })).then(E2, i2);
    }
    o2((C2 = C2.apply(A2, I2 || [])).next());
  });
}
function UA(A2, I2) {
  var g2, C2, B2, Q2, E2 = { label: 0, sent: function() {
    if (1 & B2[0])
      throw B2[1];
    return B2[1];
  }, trys: [], ops: [] };
  return Q2 = { next: i2(0), throw: i2(1), return: i2(2) }, typeof Symbol == "function" && (Q2[Symbol.iterator] = function() {
    return this;
  }), Q2;
  function i2(Q3) {
    return function(i3) {
      return function(Q4) {
        if (g2)
          throw new TypeError("Generator is already executing.");
        for (; E2; )
          try {
            if (g2 = 1, C2 && (B2 = 2 & Q4[0] ? C2.return : Q4[0] ? C2.throw || ((B2 = C2.return) && B2.call(C2), 0) : C2.next) && !(B2 = B2.call(C2, Q4[1])).done)
              return B2;
            switch (C2 = 0, B2 && (Q4 = [2 & Q4[0], B2.value]), Q4[0]) {
              case 0:
              case 1:
                B2 = Q4;
                break;
              case 4:
                return E2.label++, { value: Q4[1], done: false };
              case 5:
                E2.label++, C2 = Q4[1], Q4 = [0];
                continue;
              case 7:
                Q4 = E2.ops.pop(), E2.trys.pop();
                continue;
              default:
                if (!(B2 = E2.trys, (B2 = B2.length > 0 && B2[B2.length - 1]) || Q4[0] !== 6 && Q4[0] !== 2)) {
                  E2 = 0;
                  continue;
                }
                if (Q4[0] === 3 && (!B2 || Q4[1] > B2[0] && Q4[1] < B2[3])) {
                  E2.label = Q4[1];
                  break;
                }
                if (Q4[0] === 6 && E2.label < B2[1]) {
                  E2.label = B2[1], B2 = Q4;
                  break;
                }
                if (B2 && E2.label < B2[2]) {
                  E2.label = B2[2], E2.ops.push(Q4);
                  break;
                }
                B2[2] && E2.ops.pop(), E2.trys.pop();
                continue;
            }
            Q4 = I2.call(A2, E2);
          } catch (A3) {
            Q4 = [6, A3], C2 = 0;
          } finally {
            g2 = B2 = 0;
          }
        if (5 & Q4[0])
          throw Q4[1];
        return { value: Q4[0] ? Q4[1] : void 0, done: true };
      }([Q3, i3]);
    };
  }
}
!function(A2) {
  A2[A2.Ball = 0] = "Ball", A2[A2.Fixed = 1] = "Fixed", A2[A2.Prismatic = 2] = "Prismatic", A2[A2.Revolute = 3] = "Revolute";
}(BA || (BA = {})), function(A2) {
  A2[A2.Disabled = 0] = "Disabled", A2[A2.VelocityBased = 1] = "VelocityBased", A2[A2.AccelerationBased = 2] = "AccelerationBased", A2[A2.ForceBased = 3] = "ForceBased";
}(QA || (QA = {}));
var wA, JA = function() {
  function A2(A3, I2) {
    this.rawSet = A3, this.handle = I2;
  }
  return A2.prototype.isValid = function() {
    return this.rawSet.contains(this.handle);
  }, A2.prototype.bodyHandle1 = function() {
    return this.rawSet.jointBodyHandle1(this.handle);
  }, A2.prototype.bodyHandle2 = function() {
    return this.rawSet.jointBodyHandle2(this.handle);
  }, A2.prototype.type = function() {
    return this.rawSet.jointType(this.handle);
  }, A2.prototype.frameX1 = function() {
    return CA.fromRaw(this.rawSet.jointFrameX1(this.handle));
  }, A2.prototype.frameX2 = function() {
    return CA.fromRaw(this.rawSet.jointFrameX2(this.handle));
  }, A2.prototype.anchor1 = function() {
    return IA.fromRaw(this.rawSet.jointAnchor1(this.handle));
  }, A2.prototype.anchor2 = function() {
    return IA.fromRaw(this.rawSet.jointAnchor2(this.handle));
  }, A2.prototype.axis1 = function() {
    return IA.fromRaw(this.rawSet.jointAxis1(this.handle));
  }, A2.prototype.axis2 = function() {
    return IA.fromRaw(this.rawSet.jointAxis2(this.handle));
  }, A2;
}(), KA = function(A2) {
  function I2() {
    return A2 !== null && A2.apply(this, arguments) || this;
  }
  return GA(I2, A2), I2.prototype.limitsEnabled = function() {
    return this.rawSet.jointLimitsEnabled(this.handle);
  }, I2.prototype.limitsMin = function() {
    return this.rawSet.jointLimitsMin(this.handle);
  }, I2.prototype.limitsMax = function() {
    return this.rawSet.jointLimitsMax(this.handle);
  }, I2.prototype.configureMotorModel = function(A3) {
    this.rawSet.jointConfigureMotorModel(this.handle, A3);
  }, I2.prototype.configureMotorVelocity = function(A3, I3) {
    this.rawSet.jointConfigureUnitMotorVelocity(this.handle, A3, I3);
  }, I2.prototype.configureMotorPosition = function(A3, I3, g2) {
    this.rawSet.jointConfigureUnitMotorPosition(this.handle, A3, I3, g2);
  }, I2.prototype.configureMotor = function(A3, I3, g2, C2) {
    this.rawSet.jointConfigureUnitMotor(this.handle, A3, I3, g2, C2);
  }, I2;
}(JA), FA = function(A2) {
  function I2() {
    return A2 !== null && A2.apply(this, arguments) || this;
  }
  return GA(I2, A2), I2;
}(JA), aA = function(A2) {
  function I2() {
    return A2 !== null && A2.apply(this, arguments) || this;
  }
  return GA(I2, A2), I2;
}(KA), hA = function(A2) {
  function I2() {
    return A2 !== null && A2.apply(this, arguments) || this;
  }
  return GA(I2, A2), I2.prototype.configureMotorModel = function(A3) {
    this.rawSet.jointConfigureMotorModel(this.handle, A3);
  }, I2.prototype.configureMotorVelocity = function(A3, I3) {
    this.rawSet.jointConfigureBallMotorVelocity(this.handle, A3.x, A3.y, A3.z, I3);
  }, I2.prototype.configureMotorPosition = function(A3, I3, g2) {
    this.rawSet.jointConfigureBallMotorPosition(this.handle, A3.w, A3.x, A3.y, A3.z, I3, g2);
  }, I2.prototype.configureMotor = function(A3, I3, g2, C2) {
    this.rawSet.jointConfigureBallMotor(this.handle, A3.w, A3.x, A3.y, A3.z, I3.x, I3.y, I3.z, g2, C2);
  }, I2;
}(JA), MA = function(A2) {
  function I2() {
    return A2 !== null && A2.apply(this, arguments) || this;
  }
  return GA(I2, A2), I2;
}(KA), yA = function() {
  function A2() {
  }
  return A2.ball = function(I2, g2) {
    var C2 = new A2();
    return C2.anchor1 = I2, C2.anchor2 = g2, C2.jointType = BA.Ball, C2;
  }, A2.fixed = function(I2, g2, C2, B2) {
    var Q2 = new A2();
    return Q2.anchor1 = I2, Q2.anchor2 = C2, Q2.frame1 = g2, Q2.frame2 = B2, Q2.jointType = BA.Fixed, Q2;
  }, A2.prismatic = function(I2, g2, C2, B2, Q2, E2) {
    var i2 = new A2();
    return i2.anchor1 = I2, i2.axis1 = g2, i2.tangent1 = C2, i2.anchor2 = B2, i2.axis2 = Q2, i2.tangent2 = E2, i2.jointType = BA.Prismatic, i2;
  }, A2.revolute = function(I2, g2, C2, B2) {
    var Q2 = new A2();
    return Q2.anchor1 = I2, Q2.anchor2 = C2, Q2.axis1 = g2, Q2.axis2 = B2, Q2.jointType = BA.Revolute, Q2;
  }, A2.prototype.intoRaw = function() {
    var A3, I2, g2, C2 = IA.intoRaw(this.anchor1), B2 = IA.intoRaw(this.anchor2), Q2 = false, E2 = 0, i2 = 0;
    switch (this.jointType) {
      case BA.Ball:
        g2 = Z.ball(C2, B2);
        break;
      case BA.Fixed:
        var o2 = CA.intoRaw(this.frame1), D2 = CA.intoRaw(this.frame2);
        g2 = Z.fixed(C2, o2, B2, D2), o2.free(), D2.free();
        break;
      case BA.Prismatic:
        A3 = IA.intoRaw(this.axis1), I2 = IA.intoRaw(this.axis2), this.limitsEnabled && (Q2 = true, E2 = this.limits[0], i2 = this.limits[1]);
        var S2 = IA.intoRaw(this.tangent1), G2 = IA.intoRaw(this.tangent2);
        g2 = Z.prismatic(C2, A3, S2, B2, I2, G2, Q2, E2, i2), S2.free(), G2.free(), A3.free(), I2.free();
        break;
      case BA.Revolute:
        A3 = IA.intoRaw(this.axis1), I2 = IA.intoRaw(this.axis2), g2 = Z.revolute(C2, A3, B2, I2), A3.free(), I2.free();
    }
    return C2.free(), B2.free(), g2;
  }, A2;
}(), qA = function() {
  function A2(A3) {
    this.raw = A3 || new r();
  }
  return A2.prototype.free = function() {
    this.raw.free(), this.raw = void 0;
  }, A2.prototype.createJoint = function(A3, I2, g2, C2) {
    var B2 = I2.intoRaw(), Q2 = this.raw.createJoint(A3.raw, B2, g2, C2);
    return B2.free(), Q2;
  }, A2.prototype.remove = function(A3, I2, g2, C2) {
    this.raw.remove(A3, I2.raw, g2.raw, C2);
  }, A2.prototype.len = function() {
    return this.raw.len();
  }, A2.prototype.contains = function(A3) {
    return this.raw.contains(A3);
  }, A2.prototype.get = function(A3) {
    if (!this.raw.contains(A3))
      return null;
    switch (this.raw.jointType(A3)) {
      case BA.Ball:
        return new hA(this.raw, A3);
      case BA.Prismatic:
        return new aA(this.raw, A3);
      case BA.Fixed:
        return new FA(this.raw, A3);
      case BA.Revolute:
        return new MA(this.raw, A3);
    }
  }, A2.prototype.forEachJoint = function(A3) {
    var I2 = this;
    this.raw.forEachJointHandle(function(g2) {
      A3(new JA(I2.raw, g2));
    });
  }, A2.prototype.forEachJointHandle = function(A3) {
    this.raw.forEachJointHandle(A3);
  }, A2;
}();
!function(A2) {
  A2[A2.Average = 0] = "Average", A2[A2.Min = 1] = "Min", A2[A2.Multiply = 2] = "Multiply", A2[A2.Max = 3] = "Max";
}(wA || (wA = {}));
var NA, RA = function() {
  function A2(A3) {
    this.raw = A3 || new H();
  }
  return A2.prototype.free = function() {
    this.raw.free(), this.raw = void 0;
  }, A2;
}(), sA = function() {
  function A2(A3) {
    this.raw = A3 || new d();
  }
  return A2.prototype.free = function() {
    this.raw.free(), this.raw = void 0;
  }, A2.prototype.forEachActiveRigidBodyHandle = function(A3) {
    this.raw.forEachActiveRigidBodyHandle(A3);
  }, A2;
}(), cA = function() {
  function A2(A3) {
    this.raw = A3 || new L();
  }
  return A2.prototype.free = function() {
    this.raw.free(), this.raw = void 0;
  }, A2;
}(), YA = function() {
  function A2(A3) {
    this.raw = A3 || new f(), this.tempManifold = new lA(null);
  }
  return A2.prototype.free = function() {
    this.raw.free(), this.raw = void 0;
  }, A2.prototype.contactsWith = function(A3, I2) {
    this.raw.contacts_with(A3, I2);
  }, A2.prototype.intersectionsWith = function(A3, I2) {
    this.raw.intersections_with(A3, I2);
  }, A2.prototype.contactPair = function(A3, I2, g2) {
    var C2 = this.raw.contact_pair(A3, I2);
    if (C2) {
      var B2 = C2.collider1() != A3, Q2 = void 0;
      for (Q2 = 0; Q2 < C2.numContactManifolds(); ++Q2)
        this.tempManifold.raw = C2.contactManifold(Q2), this.tempManifold.raw && g2(this.tempManifold, B2), this.tempManifold.free();
      C2.free();
    }
  }, A2.prototype.intersectionPair = function(A3, I2) {
    return this.raw.intersection_pair(A3, I2);
  }, A2;
}(), lA = function() {
  function A2(A3) {
    this.raw = A3;
  }
  return A2.prototype.free = function() {
    this.raw.free(), this.raw = void 0;
  }, A2.prototype.normal = function() {
    return IA.fromRaw(this.raw.normal());
  }, A2.prototype.localNormal1 = function() {
    return IA.fromRaw(this.raw.local_n1());
  }, A2.prototype.localNormal2 = function() {
    return IA.fromRaw(this.raw.local_n2());
  }, A2.prototype.subshape1 = function() {
    return this.raw.subshape1();
  }, A2.prototype.subshape2 = function() {
    return this.raw.subshape2();
  }, A2.prototype.numContacts = function() {
    return this.raw.num_contacts();
  }, A2.prototype.localContactPoint1 = function(A3) {
    return IA.fromRaw(this.raw.contact_local_p1(A3));
  }, A2.prototype.localContactPoint2 = function(A3) {
    return IA.fromRaw(this.raw.contact_local_p2(A3));
  }, A2.prototype.contactDist = function(A3) {
    return this.raw.contact_dist(A3);
  }, A2.prototype.contactFid1 = function(A3) {
    return this.raw.contact_fid1(A3);
  }, A2.prototype.contactFid2 = function(A3) {
    return this.raw.contact_fid2(A3);
  }, A2.prototype.contactImpulse = function(A3) {
    return this.raw.contact_impulse(A3);
  }, A2.prototype.contactTangentImpulseX = function(A3) {
    return this.raw.contact_tangent_impulse_x(A3);
  }, A2.prototype.contactTangentImpulseY = function(A3) {
    return this.raw.contact_tangent_impulse_y(A3);
  }, A2.prototype.numSolverContacts = function() {
    return this.raw.num_solver_contacts();
  }, A2.prototype.solverContactPoint = function(A3) {
    return IA.fromRaw(this.raw.solver_contact_point(A3));
  }, A2.prototype.solverContactDist = function(A3) {
    return this.raw.solver_contact_dist(A3);
  }, A2.prototype.solverContactFriction = function(A3) {
    return this.raw.solver_contact_friction(A3);
  }, A2.prototype.solverContactRestitution = function(A3) {
    return this.raw.solver_contact_restitution(A3);
  }, A2.prototype.solverContactTangentVelocity = function(A3) {
    return IA.fromRaw(this.raw.solver_contact_tangent_velocity(A3));
  }, A2;
}();
!function(A2) {
  A2[A2.Ball = 0] = "Ball", A2[A2.Cuboid = 1] = "Cuboid", A2[A2.Capsule = 2] = "Capsule", A2[A2.Segment = 3] = "Segment", A2[A2.Polyline = 4] = "Polyline", A2[A2.Triangle = 5] = "Triangle", A2[A2.TriMesh = 6] = "TriMesh", A2[A2.HeightField = 7] = "HeightField", A2[A2.ConvexPolyhedron = 9] = "ConvexPolyhedron", A2[A2.Cylinder = 10] = "Cylinder", A2[A2.Cone = 11] = "Cone", A2[A2.RoundCuboid = 12] = "RoundCuboid", A2[A2.RoundTriangle = 13] = "RoundTriangle", A2[A2.RoundCylinder = 14] = "RoundCylinder", A2[A2.RoundCone = 15] = "RoundCone", A2[A2.RoundConvexPolyhedron = 16] = "RoundConvexPolyhedron";
}(NA || (NA = {}));
var LA, HA = function() {
  function A2(A3) {
    this.radius = A3;
  }
  return A2.prototype.intoRaw = function() {
    return P.ball(this.radius);
  }, A2;
}(), pA = function() {
  function A2(A3, I2, g2) {
    this.halfExtents = IA.new(A3, I2, g2);
  }
  return A2.prototype.intoRaw = function() {
    return P.cuboid(this.halfExtents.x, this.halfExtents.y, this.halfExtents.z);
  }, A2;
}(), tA = function() {
  function A2(A3, I2, g2, C2) {
    this.halfExtents = IA.new(A3, I2, g2), this.borderRadius = C2;
  }
  return A2.prototype.intoRaw = function() {
    return P.roundCuboid(this.halfExtents.x, this.halfExtents.y, this.halfExtents.z, this.borderRadius);
  }, A2;
}(), TA = function() {
  function A2(A3, I2) {
    this.halfHeight = A3, this.radius = I2;
  }
  return A2.prototype.intoRaw = function() {
    return P.capsule(this.halfHeight, this.radius);
  }, A2;
}(), OA = function() {
  function A2(A3, I2) {
    this.a = A3, this.b = I2;
  }
  return A2.prototype.intoRaw = function() {
    var A3 = IA.intoRaw(this.a), I2 = IA.intoRaw(this.b), g2 = P.segment(A3, I2);
    return A3.free(), I2.free(), g2;
  }, A2;
}(), eA = function() {
  function A2(A3, I2, g2) {
    this.a = A3, this.b = I2, this.c = g2;
  }
  return A2.prototype.intoRaw = function() {
    var A3 = IA.intoRaw(this.a), I2 = IA.intoRaw(this.b), g2 = IA.intoRaw(this.c), C2 = P.triangle(A3, I2, g2);
    return A3.free(), I2.free(), g2.free(), C2;
  }, A2;
}(), nA = function() {
  function A2(A3, I2, g2, C2) {
    this.a = A3, this.b = I2, this.c = g2, this.borderRadius = C2;
  }
  return A2.prototype.intoRaw = function() {
    var A3 = IA.intoRaw(this.a), I2 = IA.intoRaw(this.b), g2 = IA.intoRaw(this.c), C2 = P.roundTriangle(A3, I2, g2, this.borderRadius);
    return A3.free(), I2.free(), g2.free(), C2;
  }, A2;
}(), dA = function() {
  function A2(A3, I2) {
    this.vertices = A3, this.indices = I2 || new Uint32Array(0);
  }
  return A2.prototype.intoRaw = function() {
    return P.polyline(this.vertices, this.indices);
  }, A2;
}(), ZA = function() {
  function A2(A3, I2) {
    this.vertices = A3, this.indices = I2;
  }
  return A2.prototype.intoRaw = function() {
    return P.trimesh(this.vertices, this.indices);
  }, A2;
}(), rA = function() {
  function A2(A3, I2) {
    this.vertices = A3, this.indices = I2;
  }
  return A2.prototype.intoRaw = function() {
    return this.indices ? P.convexMesh(this.vertices, this.indices) : P.convexHull(this.vertices);
  }, A2;
}(), fA = function() {
  function A2(A3, I2, g2) {
    this.vertices = A3, this.indices = I2, this.borderRadius = g2;
  }
  return A2.prototype.intoRaw = function() {
    return this.indices ? P.roundConvexMesh(this.vertices, this.indices, this.borderRadius) : P.roundConvexHull(this.vertices, this.borderRadius);
  }, A2;
}(), WA = function() {
  function A2(A3, I2, g2, C2) {
    this.nrows = A3, this.ncols = I2, this.heights = g2, this.scale = C2;
  }
  return A2.prototype.intoRaw = function() {
    var A3 = IA.intoRaw(this.scale), I2 = P.heightfield(this.nrows, this.ncols, this.heights, A3);
    return A3.free(), I2;
  }, A2;
}(), bA = function() {
  function A2(A3, I2) {
    this.halfHeight = A3, this.radius = I2;
  }
  return A2.prototype.intoRaw = function() {
    return P.cylinder(this.halfHeight, this.radius);
  }, A2;
}(), jA = function() {
  function A2(A3, I2, g2) {
    this.borderRadius = g2, this.halfHeight = A3, this.radius = I2;
  }
  return A2.prototype.intoRaw = function() {
    return P.roundCylinder(this.halfHeight, this.radius, this.borderRadius);
  }, A2;
}(), xA = function() {
  function A2(A3, I2) {
    this.halfHeight = A3, this.radius = I2;
  }
  return A2.prototype.intoRaw = function() {
    return P.cone(this.halfHeight, this.radius);
  }, A2;
}(), XA = function() {
  function A2(A3, I2, g2) {
    this.halfHeight = A3, this.radius = I2, this.borderRadius = g2;
  }
  return A2.prototype.intoRaw = function() {
    return P.roundCone(this.halfHeight, this.radius, this.borderRadius);
  }, A2;
}();
!function(A2) {
  A2[A2.DYNAMIC_DYNAMIC = 1] = "DYNAMIC_DYNAMIC", A2[A2.DYNAMIC_KINEMATIC = 12] = "DYNAMIC_KINEMATIC", A2[A2.DYNAMIC_STATIC = 2] = "DYNAMIC_STATIC", A2[A2.KINEMATIC_KINEMATIC = 52224] = "KINEMATIC_KINEMATIC", A2[A2.KINEMATIC_STATIC = 8704] = "KINEMATIC_STATIC", A2[A2.STATIC_STATIC = 32] = "STATIC_STATIC", A2[A2.DEFAULT = 15] = "DEFAULT", A2[A2.ALL = 60943] = "ALL";
}(LA || (LA = {}));
var VA, mA = function() {
  function A2(A3, I2) {
    this.rawSet = A3, this.handle = I2;
  }
  return A2.prototype.isValid = function() {
    return this.rawSet.contains(this.handle);
  }, A2.prototype.translation = function() {
    return IA.fromRaw(this.rawSet.coTranslation(this.handle));
  }, A2.prototype.rotation = function() {
    return CA.fromRaw(this.rawSet.coRotation(this.handle));
  }, A2.prototype.isSensor = function() {
    return this.rawSet.coIsSensor(this.handle);
  }, A2.prototype.setSensor = function(A3) {
    this.rawSet.coSetSensor(this.handle, A3);
  }, A2.prototype.setShape = function(A3) {
    var I2 = A3.intoRaw();
    this.rawSet.coSetShape(this.handle, I2), I2.free();
  }, A2.prototype.setRestitution = function(A3) {
    this.rawSet.coSetRestitution(this.handle, A3);
  }, A2.prototype.setFriction = function(A3) {
    this.rawSet.coSetFriction(this.handle, A3);
  }, A2.prototype.frictionCombineRule = function() {
    return this.rawSet.coFrictionCombineRule(this.handle);
  }, A2.prototype.setFrictionCombineRule = function(A3) {
    this.rawSet.coSetFrictionCombineRule(this.handle, A3);
  }, A2.prototype.restitutionCombineRule = function() {
    return this.rawSet.coRestitutionCombineRule(this.handle);
  }, A2.prototype.setRestitutionCombineRule = function(A3) {
    this.rawSet.coSetRestitutionCombineRule(this.handle, A3);
  }, A2.prototype.setCollisionGroups = function(A3) {
    this.rawSet.coSetCollisionGroups(this.handle, A3);
  }, A2.prototype.setSolverGroups = function(A3) {
    this.rawSet.coSetSolverGroups(this.handle, A3);
  }, A2.prototype.activeHooks = function() {
    this.rawSet.coActiveHooks(this.handle);
  }, A2.prototype.setActiveHooks = function(A3) {
    this.rawSet.coSetActiveHooks(this.handle, A3);
  }, A2.prototype.activeEvents = function() {
    return this.rawSet.coActiveEvents(this.handle);
  }, A2.prototype.setActiveEvents = function(A3) {
    this.rawSet.coSetActiveEvents(this.handle, A3);
  }, A2.prototype.activeCollisionTypes = function() {
    return this.rawSet.coActiveCollisionTypes(this.handle);
  }, A2.prototype.setActiveCollisionTypes = function(A3) {
    this.rawSet.coSetActiveCollisionTypes(this.handle, A3);
  }, A2.prototype.setTranslation = function(A3) {
    this.rawSet.coSetTranslation(this.handle, A3.x, A3.y, A3.z);
  }, A2.prototype.setTranslationWrtParent = function(A3) {
    this.rawSet.coSetTranslationWrtParent(this.handle, A3.x, A3.y, A3.z);
  }, A2.prototype.setRotation = function(A3) {
    this.rawSet.coSetRotation(this.handle, A3.x, A3.y, A3.z, A3.w);
  }, A2.prototype.setRotationWrtParent = function(A3) {
    this.rawSet.coSetRotationWrtParent(this.handle, A3.x, A3.y, A3.z, A3.w);
  }, A2.prototype.shapeType = function() {
    return this.rawSet.coShapeType(this.handle);
  }, A2.prototype.halfExtents = function() {
    return IA.fromRaw(this.rawSet.coHalfExtents(this.handle));
  }, A2.prototype.radius = function() {
    return this.rawSet.coRadius(this.handle);
  }, A2.prototype.roundRadius = function() {
    return this.rawSet.coRoundRadius(this.handle);
  }, A2.prototype.halfHeight = function() {
    return this.rawSet.coHalfHeight(this.handle);
  }, A2.prototype.vertices = function() {
    return this.rawSet.coVertices(this.handle);
  }, A2.prototype.indices = function() {
    return this.rawSet.coIndices(this.handle);
  }, A2.prototype.heightfieldHeights = function() {
    return this.rawSet.coHeightfieldHeights(this.handle);
  }, A2.prototype.heightfieldScale = function() {
    var A3 = this.rawSet.coHeightfieldScale(this.handle);
    return IA.fromRaw(A3);
  }, A2.prototype.heightfieldNRows = function() {
    return this.rawSet.coHeightfieldNRows(this.handle);
  }, A2.prototype.heightfieldNCols = function() {
    return this.rawSet.coHeightfieldNCols(this.handle);
  }, A2.prototype.parent = function() {
    return this.rawSet.coParent(this.handle);
  }, A2.prototype.friction = function() {
    return this.rawSet.coFriction(this.handle);
  }, A2.prototype.density = function() {
    return this.rawSet.coDensity(this.handle);
  }, A2.prototype.collisionGroups = function() {
    return this.rawSet.coCollisionGroups(this.handle);
  }, A2.prototype.solverGroups = function() {
    return this.rawSet.coSolverGroups(this.handle);
  }, A2;
}(), uA = function() {
  function A2(A3) {
    this.shape = A3, this.useMassProps = false, this.density = 1, this.friction = 0.5, this.restitution = 0, this.rotation = CA.identity(), this.translation = IA.zeros(), this.isSensor = false, this.collisionGroups = 4294967295, this.solverGroups = 4294967295, this.frictionCombineRule = wA.Average, this.restitutionCombineRule = wA.Average, this.activeCollisionTypes = LA.DEFAULT, this.activeEvents = 0, this.activeHooks = 0, this.mass = 0, this.centerOfMass = IA.zeros(), this.principalAngularInertia = IA.zeros(), this.angularInertiaLocalFrame = CA.identity();
  }
  return A2.ball = function(I2) {
    return new A2(new HA(I2));
  }, A2.capsule = function(I2, g2) {
    return new A2(new TA(I2, g2));
  }, A2.segment = function(I2, g2) {
    return new A2(new OA(I2, g2));
  }, A2.triangle = function(I2, g2, C2) {
    return new A2(new eA(I2, g2, C2));
  }, A2.roundTriangle = function(I2, g2, C2, B2) {
    return new A2(new nA(I2, g2, C2, B2));
  }, A2.polyline = function(I2, g2) {
    return new A2(new dA(I2, g2));
  }, A2.trimesh = function(I2, g2) {
    return new A2(new ZA(I2, g2));
  }, A2.cuboid = function(I2, g2, C2) {
    return new A2(new pA(I2, g2, C2));
  }, A2.roundCuboid = function(I2, g2, C2, B2) {
    return new A2(new tA(I2, g2, C2, B2));
  }, A2.heightfield = function(I2, g2, C2, B2) {
    return new A2(new WA(I2, g2, C2, B2));
  }, A2.cylinder = function(I2, g2) {
    return new A2(new bA(I2, g2));
  }, A2.roundCylinder = function(I2, g2, C2) {
    return new A2(new jA(I2, g2, C2));
  }, A2.cone = function(I2, g2) {
    return new A2(new xA(I2, g2));
  }, A2.roundCone = function(I2, g2, C2) {
    return new A2(new XA(I2, g2, C2));
  }, A2.convexHull = function(I2) {
    return new A2(new rA(I2, null));
  }, A2.convexMesh = function(I2, g2) {
    return new A2(new rA(I2, g2));
  }, A2.roundConvexHull = function(I2, g2) {
    return new A2(new fA(I2, null, g2));
  }, A2.roundConvexMesh = function(I2, g2, C2) {
    return new A2(new fA(I2, g2, C2));
  }, A2.prototype.setTranslation = function(A3, I2, g2) {
    if (typeof A3 != "number" || typeof I2 != "number" || typeof g2 != "number")
      throw TypeError("The translation components must be numbers.");
    return this.translation = { x: A3, y: I2, z: g2 }, this;
  }, A2.prototype.setRotation = function(A3) {
    return this.rotation = A3, this;
  }, A2.prototype.setSensor = function(A3) {
    return this.isSensor = A3, this;
  }, A2.prototype.setDensity = function(A3) {
    return this.useMassProps = false, this.density = A3, this;
  }, A2.prototype.setMassProperties = function(A3, I2, g2, C2) {
    return this.useMassProps = true, this.mass = A3, this.centerOfMass = I2, this.principalAngularInertia = g2, this.angularInertiaLocalFrame = C2, this;
  }, A2.prototype.setRestitution = function(A3) {
    return this.restitution = A3, this;
  }, A2.prototype.setFriction = function(A3) {
    return this.friction = A3, this;
  }, A2.prototype.setFrictionCombineRule = function(A3) {
    return this.frictionCombineRule = A3, this;
  }, A2.prototype.setRestitutionCombineRule = function(A3) {
    return this.restitutionCombineRule = A3, this;
  }, A2.prototype.setCollisionGroups = function(A3) {
    return this.collisionGroups = A3, this;
  }, A2.prototype.setSolverGroups = function(A3) {
    return this.solverGroups = A3, this;
  }, A2.prototype.setActiveHooks = function(A3) {
    return this.activeHooks = A3, this;
  }, A2.prototype.setActiveEvents = function(A3) {
    return this.activeEvents = A3, this;
  }, A2.prototype.setActiveCollisionTypes = function(A3) {
    return this.activeCollisionTypes = A3, this;
  }, A2;
}(), PA = function() {
  function A2(A3) {
    this.raw = A3 || new p();
  }
  return A2.prototype.free = function() {
    this.raw.free(), this.raw = void 0;
  }, A2.prototype.createCollider = function(A3, I2, g2) {
    var C2 = g2 != null && g2 != null;
    if (C2 && isNaN(g2))
      throw Error("Cannot create a collider with a parent rigid-body handle that is not a number.");
    var B2 = I2.shape.intoRaw(), Q2 = IA.intoRaw(I2.translation), E2 = CA.intoRaw(I2.rotation), i2 = IA.intoRaw(I2.centerOfMass), o2 = IA.intoRaw(I2.principalAngularInertia), D2 = CA.intoRaw(I2.angularInertiaLocalFrame), S2 = this.raw.createCollider(B2, Q2, E2, I2.useMassProps, I2.mass, i2, o2, D2, I2.density, I2.friction, I2.restitution, I2.frictionCombineRule, I2.restitutionCombineRule, I2.isSensor, I2.collisionGroups, I2.solverGroups, I2.activeCollisionTypes, I2.activeHooks, I2.activeEvents, C2, C2 ? g2 : 0, A3.raw);
    return B2.free(), Q2.free(), E2.free(), i2.free(), o2.free(), D2.free(), S2;
  }, A2.prototype.remove = function(A3, I2, g2, C2) {
    this.raw.remove(A3, I2.raw, g2.raw, C2);
  }, A2.prototype.get = function(A3) {
    return this.raw.contains(A3) ? new mA(this.raw, A3) : null;
  }, A2.prototype.len = function() {
    return this.raw.len();
  }, A2.prototype.contains = function(A3) {
    return this.raw.contains(A3);
  }, A2.prototype.forEachCollider = function(A3) {
    var I2 = this;
    this.forEachColliderHandle(function(g2) {
      A3(new mA(I2.raw, g2));
    });
  }, A2.prototype.forEachColliderHandle = function(A3) {
    this.raw.forEachColliderHandle(A3);
  }, A2;
}(), zA = function() {
  function A2(A3, I2) {
    this.origin = A3, this.dir = I2;
  }
  return A2.prototype.pointAt = function(A3) {
    return { x: this.origin.x + this.dir.x * A3, y: this.origin.y + this.dir.y * A3, z: this.origin.z + this.dir.z * A3 };
  }, A2;
}(), vA = function() {
  function A2(A3, I2, g2) {
    this.colliderHandle = A3, this.toi = I2, this.normal = g2;
  }
  return A2.fromRaw = function(I2) {
    if (!I2)
      return null;
    var g2 = new A2(I2.colliderHandle(), I2.toi(), IA.fromRaw(I2.normal()));
    return I2.free(), g2;
  }, A2;
}(), _A = function() {
  function A2(A3, I2) {
    this.colliderHandle = A3, this.toi = I2;
  }
  return A2.fromRaw = function(I2) {
    if (!I2)
      return null;
    var g2 = new A2(I2.colliderHandle(), I2.toi());
    return I2.free(), g2;
  }, A2;
}(), $A = function() {
  function A2(A3, I2, g2) {
    this.colliderHandle = A3, this.point = I2, this.isInside = g2;
  }
  return A2.fromRaw = function(I2) {
    if (!I2)
      return null;
    var g2 = new A2(I2.colliderHandle(), IA.fromRaw(I2.point()), I2.isInside());
    return I2.free(), g2;
  }, A2;
}(), AI = function() {
  function A2(A3, I2, g2, C2, B2, Q2) {
    this.colliderHandle = A3, this.toi = I2, this.witness1 = g2, this.witness2 = C2, this.normal1 = B2, this.normal2 = Q2;
  }
  return A2.fromRaw = function(I2) {
    if (!I2)
      return null;
    var g2 = new A2(I2.colliderHandle(), I2.toi(), IA.fromRaw(I2.witness1()), IA.fromRaw(I2.witness2()), IA.fromRaw(I2.normal1()), IA.fromRaw(I2.normal2()));
    return I2.free(), g2;
  }, A2;
}(), II = function() {
  function A2(A3) {
    this.raw = A3 || new W();
  }
  return A2.prototype.free = function() {
    this.raw.free(), this.raw = void 0;
  }, A2.prototype.step = function(A3, I2, g2, C2, B2, Q2, E2, i2, o2, D2, S2) {
    var G2 = IA.intoRaw(A3);
    D2 ? this.raw.stepWithEvents(G2, I2.raw, g2.raw, C2.raw, B2.raw, Q2.raw, E2.raw, i2.raw, o2.raw, D2.raw, S2, S2 ? S2.filterContactPair : null, S2 ? S2.filterIntersectionPair : null) : this.raw.step(G2, I2.raw, g2.raw, C2.raw, B2.raw, Q2.raw, E2.raw, i2.raw, o2.raw), G2.free();
  }, A2;
}(), gI = function() {
  function A2(A3) {
    this.raw = A3 || new j();
  }
  return A2.prototype.free = function() {
    this.raw.free(), this.raw = void 0;
  }, A2.prototype.update = function(A3, I2, g2) {
    this.raw.update(A3.raw, I2.raw, g2.raw);
  }, A2.prototype.castRay = function(A3, I2, g2, C2, B2) {
    var Q2 = IA.intoRaw(I2.origin), E2 = IA.intoRaw(I2.dir), i2 = _A.fromRaw(this.raw.castRay(A3.raw, Q2, E2, g2, C2, B2));
    return Q2.free(), E2.free(), i2;
  }, A2.prototype.castRayAndGetNormal = function(A3, I2, g2, C2, B2) {
    var Q2 = IA.intoRaw(I2.origin), E2 = IA.intoRaw(I2.dir), i2 = vA.fromRaw(this.raw.castRayAndGetNormal(A3.raw, Q2, E2, g2, C2, B2));
    return Q2.free(), E2.free(), i2;
  }, A2.prototype.intersectionsWithRay = function(A3, I2, g2, C2, B2, Q2) {
    var E2 = IA.intoRaw(I2.origin), i2 = IA.intoRaw(I2.dir);
    this.raw.intersectionsWithRay(A3.raw, E2, i2, g2, C2, B2, function(A4) {
      return Q2(vA.fromRaw(A4));
    }), E2.free(), i2.free();
  }, A2.prototype.intersectionWithShape = function(A3, I2, g2, C2, B2) {
    var Q2 = IA.intoRaw(I2), E2 = CA.intoRaw(g2), i2 = C2.intoRaw(), o2 = this.raw.intersectionWithShape(A3.raw, Q2, E2, i2, B2);
    return Q2.free(), E2.free(), i2.free(), o2;
  }, A2.prototype.projectPoint = function(A3, I2, g2, C2) {
    var B2 = IA.intoRaw(I2), Q2 = $A.fromRaw(this.raw.projectPoint(A3.raw, B2, g2, C2));
    return B2.free(), Q2;
  }, A2.prototype.intersectionsWithPoint = function(A3, I2, g2, C2) {
    var B2 = IA.intoRaw(I2);
    this.raw.intersectionsWithPoint(A3.raw, B2, g2, C2), B2.free();
  }, A2.prototype.castShape = function(A3, I2, g2, C2, B2, Q2, E2) {
    var i2 = IA.intoRaw(I2), o2 = CA.intoRaw(g2), D2 = IA.intoRaw(C2), S2 = B2.intoRaw(), G2 = AI.fromRaw(this.raw.castShape(A3.raw, i2, o2, D2, S2, Q2, E2));
    return i2.free(), o2.free(), D2.free(), S2.free(), G2;
  }, A2.prototype.intersectionsWithShape = function(A3, I2, g2, C2, B2, Q2) {
    var E2 = IA.intoRaw(I2), i2 = CA.intoRaw(g2), o2 = C2.intoRaw();
    this.raw.intersectionsWithShape(A3.raw, E2, i2, o2, B2, Q2), E2.free(), i2.free(), o2.free();
  }, A2.prototype.collidersWithAabbIntersectingAabb = function(A3, I2, g2) {
    var C2 = IA.intoRaw(A3), B2 = IA.intoRaw(I2);
    this.raw.collidersWithAabbIntersectingAabb(C2, B2, g2), C2.free(), B2.free();
  }, A2;
}(), CI = function() {
  function A2(A3) {
    this.raw = A3 || new u();
  }
  return A2.prototype.free = function() {
    this.raw.free(), this.raw = void 0;
  }, A2.prototype.serializeAll = function(A3, I2, g2, C2, B2, Q2, E2, i2) {
    var o2 = IA.intoRaw(A3), D2 = this.raw.serializeAll(o2, I2.raw, g2.raw, C2.raw, B2.raw, Q2.raw, E2.raw, i2.raw);
    return o2.free(), D2;
  }, A2.prototype.deserializeAll = function(A3) {
    return BI.fromRaw(this.raw.deserializeAll(A3));
  }, A2;
}(), BI = function() {
  function A2(A3, I2, g2, C2, B2, Q2, E2, i2, o2, D2, S2, G2) {
    this.gravity = A3, this.integrationParameters = new DA(I2), this.islands = new sA(g2), this.broadPhase = new cA(C2), this.narrowPhase = new YA(B2), this.bodies = new oA(Q2), this.colliders = new PA(E2), this.joints = new qA(i2), this.ccdSolver = new RA(o2), this.queryPipeline = new gI(D2), this.physicsPipeline = new II(S2), this.serializationPipeline = new CI(G2);
  }
  return A2.prototype.free = function() {
    this.integrationParameters.free(), this.islands.free(), this.broadPhase.free(), this.narrowPhase.free(), this.bodies.free(), this.colliders.free(), this.joints.free(), this.ccdSolver.free(), this.queryPipeline.free(), this.physicsPipeline.free(), this.serializationPipeline.free(), this.integrationParameters = void 0, this.islands = void 0, this.broadPhase = void 0, this.narrowPhase = void 0, this.bodies = void 0, this.colliders = void 0, this.ccdSolver = void 0, this.joints = void 0, this.queryPipeline = void 0, this.physicsPipeline = void 0, this.serializationPipeline = void 0;
  }, A2.fromRaw = function(I2) {
    return I2 ? new A2(IA.fromRaw(I2.takeGravity()), I2.takeIntegrationParameters(), I2.takeIslandManager(), I2.takeBroadPhase(), I2.takeNarrowPhase(), I2.takeBodies(), I2.takeColliders(), I2.takeJoints()) : null;
  }, A2.prototype.takeSnapshot = function() {
    return this.serializationPipeline.serializeAll(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.joints);
  }, A2.restoreSnapshot = function(A3) {
    return new CI().deserializeAll(A3);
  }, A2.prototype.step = function(A3, I2) {
    this.physicsPipeline.step(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.joints, this.ccdSolver, A3, I2), this.queryPipeline.update(this.islands, this.bodies, this.colliders);
  }, Object.defineProperty(A2.prototype, "timestep", { get: function() {
    return this.integrationParameters.dt;
  }, set: function(A3) {
    this.integrationParameters.dt = A3;
  }, enumerable: false, configurable: true }), Object.defineProperty(A2.prototype, "maxVelocityIterations", { get: function() {
    return this.integrationParameters.maxVelocityIterations;
  }, set: function(A3) {
    this.integrationParameters.maxVelocityIterations = A3;
  }, enumerable: false, configurable: true }), Object.defineProperty(A2.prototype, "maxPositionIterations", { get: function() {
    return this.integrationParameters.maxPositionIterations;
  }, set: function(A3) {
    this.integrationParameters.maxPositionIterations = A3;
  }, enumerable: false, configurable: true }), A2.prototype.createRigidBody = function(A3) {
    return this.bodies.get(this.bodies.createRigidBody(A3));
  }, A2.prototype.createCollider = function(A3, I2) {
    return this.colliders.get(this.colliders.createCollider(this.bodies, A3, I2));
  }, A2.prototype.createJoint = function(A3, I2, g2) {
    return this.joints.get(this.joints.createJoint(this.bodies, A3, I2.handle, g2.handle));
  }, A2.prototype.getRigidBody = function(A3) {
    return this.bodies.get(A3);
  }, A2.prototype.getCollider = function(A3) {
    return this.colliders.get(A3);
  }, A2.prototype.getJoint = function(A3) {
    return this.joints.get(A3);
  }, A2.prototype.removeRigidBody = function(A3) {
    this.bodies.remove(A3.handle, this.islands, this.colliders, this.joints);
  }, A2.prototype.removeCollider = function(A3, I2) {
    this.colliders.remove(A3.handle, this.islands, this.bodies, I2);
  }, A2.prototype.removeJoint = function(A3, I2) {
    this.joints.remove(A3.handle, this.islands, this.bodies, I2);
  }, A2.prototype.forEachCollider = function(A3) {
    this.colliders.forEachCollider(A3);
  }, A2.prototype.forEachColliderHandle = function(A3) {
    this.colliders.forEachColliderHandle(A3);
  }, A2.prototype.forEachRigidBody = function(A3) {
    this.bodies.forEachRigidBody(A3);
  }, A2.prototype.forEachRigidBodyHandle = function(A3) {
    this.bodies.forEachRigidBodyHandle(A3);
  }, A2.prototype.forEachActiveRigidBody = function(A3) {
    this.bodies.forEachActiveRigidBody(this.islands, A3);
  }, A2.prototype.forEachActiveRigidBodyHandle = function(A3) {
    this.islands.forEachActiveRigidBodyHandle(A3);
  }, A2.prototype.castRay = function(A3, I2, g2, C2) {
    return this.queryPipeline.castRay(this.colliders, A3, I2, g2, C2);
  }, A2.prototype.castRayAndGetNormal = function(A3, I2, g2, C2) {
    return this.queryPipeline.castRayAndGetNormal(this.colliders, A3, I2, g2, C2);
  }, A2.prototype.intersectionsWithRay = function(A3, I2, g2, C2, B2) {
    this.queryPipeline.intersectionsWithRay(this.colliders, A3, I2, g2, C2, B2);
  }, A2.prototype.intersectionWithShape = function(A3, I2, g2, C2) {
    return this.queryPipeline.intersectionWithShape(this.colliders, A3, I2, g2, C2);
  }, A2.prototype.projectPoint = function(A3, I2, g2) {
    return this.queryPipeline.projectPoint(this.colliders, A3, I2, g2);
  }, A2.prototype.intersectionsWithPoint = function(A3, I2, g2) {
    this.queryPipeline.intersectionsWithPoint(this.colliders, A3, I2, g2);
  }, A2.prototype.castShape = function(A3, I2, g2, C2, B2, Q2) {
    return this.queryPipeline.castShape(this.colliders, A3, I2, g2, C2, B2, Q2);
  }, A2.prototype.intersectionsWithShape = function(A3, I2, g2, C2, B2) {
    this.queryPipeline.intersectionsWithShape(this.colliders, A3, I2, g2, C2, B2);
  }, A2.prototype.collidersWithAabbIntersectingAabb = function(A3, I2, g2) {
    this.queryPipeline.collidersWithAabbIntersectingAabb(A3, I2, g2);
  }, A2.prototype.contactsWith = function(A3, I2) {
    this.narrowPhase.contactsWith(A3, I2);
  }, A2.prototype.intersectionsWith = function(A3, I2) {
    this.narrowPhase.intersectionsWith(A3, I2);
  }, A2.prototype.contactPair = function(A3, I2, g2) {
    this.narrowPhase.contactPair(A3, I2, g2);
  }, A2.prototype.intersectionPair = function(A3, I2) {
    return this.narrowPhase.intersectionPair(A3, I2);
  }, A2;
}();
!function(A2) {
  A2[A2.INTERSECTION_EVENTS = 1] = "INTERSECTION_EVENTS", A2[A2.CONTACT_EVENTS = 2] = "CONTACT_EVENTS";
}(VA || (VA = {}));
var QI, EI, iI = function() {
  function A2(A3, I2) {
    this.raw = I2 || new e(A3);
  }
  return A2.prototype.free = function() {
    this.raw.free(), this.raw = void 0;
  }, A2.prototype.drainContactEvents = function(A3) {
    this.raw.drainContactEvents(A3);
  }, A2.prototype.drainIntersectionEvents = function(A3) {
    this.raw.drainIntersectionEvents(A3);
  }, A2.prototype.clear = function() {
    this.raw.clear();
  }, A2;
}();
!function(A2) {
  A2[A2.FILTER_CONTACT_PAIRS = 1] = "FILTER_CONTACT_PAIRS", A2[A2.FILTER_INTERSECTION_PAIRS = 2] = "FILTER_INTERSECTION_PAIRS";
}(QI || (QI = {})), function(A2) {
  A2[A2.EMPTY = 0] = "EMPTY", A2[A2.COMPUTE_IMPULSE = 1] = "COMPUTE_IMPULSE";
}(EI || (EI = {}));
for (var oI = { byteLength: function(A2) {
  var I2 = JI(A2), g2 = I2[0], C2 = I2[1];
  return 3 * (g2 + C2) / 4 - C2;
}, toByteArray: function(A2) {
  var I2, g2, C2 = JI(A2), B2 = C2[0], Q2 = C2[1], E2 = new GI(function(A3, I3, g3) {
    return 3 * (I3 + g3) / 4 - g3;
  }(0, B2, Q2)), i2 = 0, o2 = Q2 > 0 ? B2 - 4 : B2;
  for (g2 = 0; g2 < o2; g2 += 4)
    I2 = SI[A2.charCodeAt(g2)] << 18 | SI[A2.charCodeAt(g2 + 1)] << 12 | SI[A2.charCodeAt(g2 + 2)] << 6 | SI[A2.charCodeAt(g2 + 3)], E2[i2++] = I2 >> 16 & 255, E2[i2++] = I2 >> 8 & 255, E2[i2++] = 255 & I2;
  Q2 === 2 && (I2 = SI[A2.charCodeAt(g2)] << 2 | SI[A2.charCodeAt(g2 + 1)] >> 4, E2[i2++] = 255 & I2);
  Q2 === 1 && (I2 = SI[A2.charCodeAt(g2)] << 10 | SI[A2.charCodeAt(g2 + 1)] << 4 | SI[A2.charCodeAt(g2 + 2)] >> 2, E2[i2++] = I2 >> 8 & 255, E2[i2++] = 255 & I2);
  return E2;
}, fromByteArray: function(A2) {
  for (var I2, g2 = A2.length, C2 = g2 % 3, B2 = [], Q2 = 16383, E2 = 0, i2 = g2 - C2; E2 < i2; E2 += Q2)
    B2.push(KI(A2, E2, E2 + Q2 > i2 ? i2 : E2 + Q2));
  C2 === 1 ? (I2 = A2[g2 - 1], B2.push(DI[I2 >> 2] + DI[I2 << 4 & 63] + "==")) : C2 === 2 && (I2 = (A2[g2 - 2] << 8) + A2[g2 - 1], B2.push(DI[I2 >> 10] + DI[I2 >> 4 & 63] + DI[I2 << 2 & 63] + "="));
  return B2.join("");
} }, DI = [], SI = [], GI = typeof Uint8Array != "undefined" ? Uint8Array : Array, kI = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", UI = 0, wI = kI.length; UI < wI; ++UI)
  DI[UI] = kI[UI], SI[kI.charCodeAt(UI)] = UI;
function JI(A2) {
  var I2 = A2.length;
  if (I2 % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var g2 = A2.indexOf("=");
  return g2 === -1 && (g2 = I2), [g2, g2 === I2 ? 0 : 4 - g2 % 4];
}
function KI(A2, I2, g2) {
  for (var C2, B2, Q2 = [], E2 = I2; E2 < g2; E2 += 3)
    C2 = (A2[E2] << 16 & 16711680) + (A2[E2 + 1] << 8 & 65280) + (255 & A2[E2 + 2]), Q2.push(DI[(B2 = C2) >> 18 & 63] + DI[B2 >> 12 & 63] + DI[B2 >> 6 & 63] + DI[63 & B2]);
  return Q2.join("");
}
function FI() {
  return kA(this, void 0, void 0, function() {
    return UA(this, function(A2) {
      switch (A2.label) {
        case 0:
          return [4, _(oI.toByteArray("AGFzbQEAAAAByghzYAJ/fwBgA39/fwBgBH9/f38AYAJ/fwF/YAF/AX5gA39/fwF/YAF/AX9gAX8AYAV/f39/fwBgBn9/f399fwBgAX8BfWAFf39/fX8AYAABf2AGf39/f39/AGAEf39/fQF/YAN/f38BfWADf399AX9gBH9/f38BfWADf399AGAHf39/f39/fwBgAn9/AX1gBH9/f38Bf2ACf30AYAh/f39/f399fwF/YAV/f39/fQBgBn9/f39/fwF/YAZ/f319fX0AYAAAYAV/f39/fwF/YAF9AX1gDn9/f39/f39/f39/f39/AGAJf39/f39/f399AGAIf39/f39/f30AYAZ/f39/f30AYAR/f399AGAFf399fX0AYAN9fX0Bf2AIf39/f39/f38AYAt/f39/f39/f319fwBgBH9/fX8AYAV/f31/fwBgA399fQBgBH99fX0AYAJ9fQF/YAJ9fQF9YAl/f39/f39/f38AYAp/f39/f39/f39/AGAKf39/f39/fX9/fwBgGH9/f39/f31/f399fX1/f39/f39/f39/fwBgCH9/f39/fX9/AGAJf39/f399f39/AGAHf39/f31/fwBgCH9/f399f39/AGAEf399fQBgB39/fX19fX8AYAV/fn9+fwBgBH99f38AYAZ/fX1/f30AYAd/fX19f399AGAJf39/f39/fX9/AX9gB39/f399f38Bf2AUf39/fX1/f39/f39/f399fX9/f38Bf2AEf31/fwF/YAN9fX8Bf2AEfX19fQF/YAt/f39/f39/f39/fwBgEX9/f39/f39/f39/f39/f39/AGASf39/f39/f39/f39/fX99fX19AGAPf39/f39/f39/f39/fX1/AGAKf39/f39/f399fQBgCX9/f39/f399fwBgDX9/f39/f399fX19fX0AYAl/f39/f39+fn4AYAd/f39/f399AGAJf39/f39/fX9/AGAIf39/f319f38AYAt/f399f399f319fwBgBX9/f319AGAJf399f39/f39/AGAGf399fX1/AGAIf399fX19fX0AYAt/f319fX19fX19fQBgBX9/fH9/AGADf31/AGAGf31/f39/AGAIf31/f39/f38AYAl/fX9/f39/f38AYBB/fX9/f39/f39/f39/f39/AGAMf31/f39/f399fX1/AGAMf31/f399fX19fX1/AGAFf31/f30AYAp/fX99f319fX1/AGAJf319fX9/fX9/AGAFf319fX0AYAR/fH9/AGACfn8AYAl/f39/f39/f38Bf2AJf39/f39/f319AX9gBX9/f399AX9gBH9/fX8Bf2AEf399fQF/YAJ/fgF/YAN/fX8Bf2AGf31/f39/AX9gA398fwF/YAR/fH9/AX9gA35/fwF/YAF9AX9gAXwBf2ABfgF+YAR+fn9/AX5gBn9/f39/fwF9YAR/f399AX1gAAF8YAF/AXwCsgccA3diZxpfX3diaW5kZ2VuX29iamVjdF9kcm9wX3JlZgAHA3diZxVfX3diaW5kZ2VuX251bWJlcl9uZXcAbAN3YmckX193YmdfcmF3cmF5Y29sbGlkZXJpbnRlcnNlY3Rpb25fbmV3AAYDd2JnFV9fd2JpbmRnZW5fc3RyaW5nX25ldwADA3diZxpfX3diZ19ub3dfODg1Y2E4OGZhZmVlMGZkMQByA3diZyBfX3diZ19uZXdub2FyZ3NfMWExMWU3ZThjOTA2OTk2YwADA3diZxpfX3diZ19nZXRfNmQyNmM3MTJhYTczYzhiMgADA3diZxtfX3diZ19jYWxsX2U5MWY3MWRkZjFmNDVjZmYAAwN3YmcbX193YmluZGdlbl9vYmplY3RfY2xvbmVfcmVmAAYDd2JnG19fd2JnX2NhbGxfZTNjNzIzNTVkMDkxZDVkNAAFA3diZxtfX3diZ19jYWxsX2MxNDNiMTlkODcxMzk5NDQAFQN3YmcbX193YmdfY2FsbF83MmZhY2QzN2RiYzk3ZGRiABwDd2JnG19fd2JnX2JpbmRfMDc4Mzk1NzlmNTIzYWE4OQAVA3diZx1fX3diZ19idWZmZXJfNzlhMzI5NDI2NmQ0ZTc4MwAGA3diZxtfX3diZ19zZWxmX2I0NTQ2ZWE3YjU5MDUzOWUADAN3YmcdX193Ymdfd2luZG93X2MyNzlmZWE4MWY0MjZhNjgADAN3YmchX193YmdfZ2xvYmFsVGhpc18wMzhhNmVhMGZmMTc3ODlmAAwDd2JnHV9fd2JnX2dsb2JhbF80ZjkzY2U4ODRiY2VlNTk3AAwDd2JnF19fd2JpbmRnZW5faXNfdW5kZWZpbmVkAAYDd2JnMV9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVu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GxsEAQEBCgMFAwMABggsBwoKChsDBAQGBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAMFBgoGCgYGCgYGBgYGBgoGBgoGBgYGBgYEBAAHAQQHAXAB3AbcBgUDAQARBgkBfwFBgIDAAAsHiEumAgZtZW1vcnkCAAd2ZXJzaW9uAJEKF19fd2JnX3Jhd2NjZHNvbHZlcl9mcmVlALYIEHJhd2NjZHNvbHZlcl9uZXcA0QkjX193YmdfcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX2ZyZWUA1woccmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX25ldwC0CRtyYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfZHQAhwsccmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX2VycADjCiFyYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfam9pbnRFcnAA5AoncmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3dhcm1zdGFydENvZWZmAOUKK3Jhd2ludGVncmF0aW9ucGFyYW1ldGVyc19hbGxvd2VkTGluZWFyRXJyb3IA5gorcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3ByZWRpY3Rpb25EaXN0YW5jZQDnCixyYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfYWxsb3dlZEFuZ3VsYXJFcnJvcgDoCixyYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfbWF4TGluZWFyQ29ycmVjdGlvbgDpCi1yYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfbWF4QW5ndWxhckNvcnJlY3Rpb24A6goucmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX21heFZlbG9jaXR5SXRlcmF0aW9ucwDrCi5yYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfbWF4UG9zaXRpb25JdGVyYXRpb25zAOwKJnJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19taW5Jc2xhbmRTaXplAO0KJ3Jhd2ludGVncmF0aW9ucGFyYW1ldGVyc19tYXhDY2RTdWJzdGVwcwDuCh9yYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfc2V0X2R0AO8KIHJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19zZXRfZXJwAMQKJXJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19zZXRfam9pbnRFcnAAxQorcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3NldF93YXJtc3RhcnRDb2VmZgDGCi9yYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfc2V0X2FsbG93ZWRMaW5lYXJFcnJvcgDHCi9yYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfc2V0X3ByZWRpY3Rpb25EaXN0YW5jZQDICjByYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfc2V0X2FsbG93ZWRBbmd1bGFyRXJyb3IAyQowcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3NldF9tYXhMaW5lYXJDb3JyZWN0aW9uAMoKMXJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19zZXRfbWF4QW5ndWxhckNvcnJlY3Rpb24AywoycmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3NldF9tYXhWZWxvY2l0eUl0ZXJhdGlvbnMAzAoycmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3NldF9tYXhQb3NpdGlvbkl0ZXJhdGlvbnMAzQoqcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3NldF9taW5Jc2xhbmRTaXplAM4KK3Jhd2ludGVncmF0aW9ucGFyYW1ldGVyc19zZXRfbWF4Q2NkU3Vic3RlcHMAzwobX193YmdfcmF3aXNsYW5kbWFuYWdlcl9mcmVlALMFFHJhd2lzbGFuZG1hbmFnZXJfbmV3AP4GLXJhd2lzbGFuZG1hbmFnZXJfZm9yRWFjaEFjdGl2ZVJpZ2lkQm9keUhhbmRsZQD0CBxyYXdqb2ludHNldF9qb2ludEJvZHlIYW5kbGUxAL0HHHJhd2pvaW50c2V0X2pvaW50Qm9keUhhbmRsZTIAswcVcmF3am9pbnRzZXRfam9pbnRUeXBlAP4HGHJhd2pvaW50c2V0X2pvaW50RnJhbWVYMQC+BxhyYXdqb2ludHNldF9qb2ludEZyYW1lWDIAvwcYcmF3am9pbnRzZXRfam9pbnRBbmNob3IxAOoFGHJhd2pvaW50c2V0X2pvaW50QW5jaG9yMgDrBRZyYXdqb2ludHNldF9qb2ludEF4aXMxAN8FFnJhd2pvaW50c2V0X2pvaW50QXhpczIA4AUecmF3am9pbnRzZXRfam9pbnRMaW1pdHNFbmFibGVkAMUHGnJhd2pvaW50c2V0X2pvaW50TGltaXRzTWluAMsHGnJhd2pvaW50c2V0X2pvaW50TGltaXRzTWF4AMwHJHJhd2pvaW50c2V0X2pvaW50Q29uZmlndXJlTW90b3JNb2RlbADDCStyYXdqb2ludHNldF9qb2ludENvbmZpZ3VyZUJhbGxNb3RvclZlbG9jaXR5ANcHK3Jhd2pvaW50c2V0X2pvaW50Q29uZmlndXJlQmFsbE1vdG9yUG9zaXRpb24A0wYjcmF3am9pbnRzZXRfam9pbnRDb25maWd1cmVCYWxsTW90b3IAoQYrcmF3am9pbnRzZXRfam9pbnRDb25maWd1cmVVbml0TW90b3JWZWxvY2l0eQDYBytyYXdqb2ludHNldF9qb2ludENvbmZpZ3VyZVVuaXRNb3RvclBvc2l0aW9uAM8HI3Jhd2pvaW50c2V0X2pvaW50Q29uZmlndXJlVW5pdE1vdG9yAMYHGV9fd2JnX3Jhd2pvaW50cGFyYW1zX2ZyZWUA1woTcmF3am9pbnRwYXJhbXNfYmFsbADKBRhyYXdqb2ludHBhcmFtc19wcmlzbWF0aWMAvAQUcmF3am9pbnRwYXJhbXNfZml4ZWQAmQMXcmF3am9pbnRwYXJhbXNfcmV2b2x1dGUAlgUWX193YmdfcmF3am9pbnRzZXRfZnJlZQDUBg9yYXdqb2ludHNldF9uZXcA/wYXcmF3am9pbnRzZXRfY3JlYXRlSm9pbnQA0wcScmF3am9pbnRzZXRfcmVtb3ZlAIkID3Jhd2pvaW50c2V0X2xlbgDHCRRyYXdqb2ludHNldF9jb250YWlucwDTCB5yYXdqb2ludHNldF9mb3JFYWNoSm9pbnRIYW5kbGUA9QgdcmF3cmlnaWRib2R5c2V0X3JiVHJhbnNsYXRpb24A3AYacmF3cmlnaWRib2R5c2V0X3JiUm90YXRpb24A5gYXcmF3cmlnaWRib2R5c2V0X3JiU2xlZXAA5wgccmF3cmlnaWRib2R5c2V0X3JiSXNTbGVlcGluZwCKCBpyYXdyaWdpZGJvZHlzZXRfcmJJc01vdmluZwCLCCFyYXdyaWdpZGJvZHlzZXRfcmJOZXh0VHJhbnNsYXRpb24A3QYecmF3cmlnaWRib2R5c2V0X3JiTmV4dFJvdGF0aW9uAN4GIHJhd3JpZ2lkYm9keXNldF9yYlNldFRyYW5zbGF0aW9uAOsGHXJhd3JpZ2lkYm9keXNldF9yYlNldFJvdGF0aW9uANUJG3Jhd3JpZ2lkYm9keXNldF9yYlNldExpbnZlbACIBxtyYXdyaWdpZGJvZHlzZXRfcmJTZXRBbmd2ZWwAiQctcmF3cmlnaWRib2R5c2V0X3JiU2V0TmV4dEtpbmVtYXRpY1RyYW5zbGF0aW9uAIwIKnJhd3JpZ2lkYm9keXNldF9yYlNldE5leHRLaW5lbWF0aWNSb3RhdGlvbgD/CRhyYXdyaWdpZGJvZHlzZXRfcmJMaW52ZWwA3wYYcmF3cmlnaWRib2R5c2V0X3JiQW5ndmVsAOAGH3Jhd3JpZ2lkYm9keXNldF9yYkxvY2tSb3RhdGlvbnMArQcjcmF3cmlnaWRib2R5c2V0X3JiUmVzdHJpY3RSb3RhdGlvbnMA+gYgcmF3cmlnaWRib2R5c2V0X3JiRG9taW5hbmNlR3JvdXAA6QcjcmF3cmlnaWRib2R5c2V0X3JiU2V0RG9taW5hbmNlR3JvdXAA1AgbcmF3cmlnaWRib2R5c2V0X3JiRW5hYmxlQ2NkAL4IFnJhd3JpZ2lkYm9keXNldF9yYk1hc3MAjQgYcmF3cmlnaWRib2R5c2V0X3JiV2FrZVVwANUIHnJhd3JpZ2lkYm9keXNldF9yYklzQ2NkRW5hYmxlZACOCB5yYXdyaWdpZGJvZHlzZXRfcmJOdW1Db2xsaWRlcnMA2QcacmF3cmlnaWRib2R5c2V0X3JiQ29sbGlkZXIA9gYacmF3cmlnaWRib2R5c2V0X3JiQm9keVR5cGUA0AcacmF3cmlnaWRib2R5c2V0X3JiSXNTdGF0aWMAjwgdcmF3cmlnaWRib2R5c2V0X3JiSXNLaW5lbWF0aWMAkAgbcmF3cmlnaWRib2R5c2V0X3JiSXNEeW5hbWljAJEIH3Jhd3JpZ2lkYm9keXNldF9yYkxpbmVhckRhbXBpbmcA/wcgcmF3cmlnaWRib2R5c2V0X3JiQW5ndWxhckRhbXBpbmcAgAgicmF3cmlnaWRib2R5c2V0X3JiU2V0TGluZWFyRGFtcGluZwDWCCNyYXdyaWdpZGJvZHlzZXRfcmJTZXRBbmd1bGFyRGFtcGluZwC/CB5yYXdyaWdpZGJvZHlzZXRfcmJHcmF2aXR5U2NhbGUAkgghcmF3cmlnaWRib2R5c2V0X3JiU2V0R3Jhdml0eVNjYWxlALcIHHJhd3JpZ2lkYm9keXNldF9yYkFwcGx5Rm9yY2UAigcecmF3cmlnaWRib2R5c2V0X3JiQXBwbHlJbXB1bHNlAIsHHXJhd3JpZ2lkYm9keXNldF9yYkFwcGx5VG9ycXVlAIwHJHJhd3JpZ2lkYm9keXNldF9yYkFwcGx5VG9ycXVlSW1wdWxzZQCNByNyYXdyaWdpZGJvZHlzZXRfcmJBcHBseUZvcmNlQXRQb2ludADhBSVyYXdyaWdpZGJvZHlzZXRfcmJBcHBseUltcHVsc2VBdFBvaW50AOIFGl9fd2JnX3Jhd3JpZ2lkYm9keXNldF9mcmVlAJYGE3Jhd3JpZ2lkYm9keXNldF9uZXcA3gcfcmF3cmlnaWRib2R5c2V0X2NyZWF0ZVJpZ2lkQm9keQCUBBZyYXdyaWdpZGJvZHlzZXRfcmVtb3ZlAM4FE3Jhd3JpZ2lkYm9keXNldF9sZW4AyAkYcmF3cmlnaWRib2R5c2V0X2NvbnRhaW5zANcIJnJhd3JpZ2lkYm9keXNldF9mb3JFYWNoUmlnaWRCb2R5SGFuZGxlAPYIGF9fd2JnX3Jhd2Jyb2FkcGhhc2VfZnJlZQDoCBFyYXdicm9hZHBoYXNlX25ldwC1CRxyYXdjb2xsaWRlcnNldF9jb1RyYW5zbGF0aW9uAOEGGXJhd2NvbGxpZGVyc2V0X2NvUm90YXRpb24A4gYfcmF3Y29sbGlkZXJzZXRfY29TZXRUcmFuc2xhdGlvbgCTCChyYXdjb2xsaWRlcnNldF9jb1NldFRyYW5zbGF0aW9uV3J0UGFyZW50AJQIHHJhd2NvbGxpZGVyc2V0X2NvU2V0Um90YXRpb24AgAolcmF3Y29sbGlkZXJzZXRfY29TZXRSb3RhdGlvbldydFBhcmVudACBChlyYXdjb2xsaWRlcnNldF9jb0lzU2Vuc29yAJUIGnJhd2NvbGxpZGVyc2V0X2NvU2hhcGVUeXBlALYJHHJhd2NvbGxpZGVyc2V0X2NvSGFsZkV4dGVudHMAvAUXcmF3Y29sbGlkZXJzZXRfY29SYWRpdXMA6gcbcmF3Y29sbGlkZXJzZXRfY29IYWxmSGVpZ2h0AOsHHHJhd2NvbGxpZGVyc2V0X2NvUm91bmRSYWRpdXMA1QYZcmF3Y29sbGlkZXJzZXRfY29WZXJ0aWNlcwC9BhhyYXdjb2xsaWRlcnNldF9jb0luZGljZXMAvgYjcmF3Y29sbGlkZXJzZXRfY29IZWlnaHRmaWVsZEhlaWdodHMAvwYhcmF3Y29sbGlkZXJzZXRfY29IZWlnaHRmaWVsZFNjYWxlAJcFIXJhd2NvbGxpZGVyc2V0X2NvSGVpZ2h0ZmllbGROUm93cwDJBiFyYXdjb2xsaWRlcnNldF9jb0hlaWdodGZpZWxkTkNvbHMAygYXcmF3Y29sbGlkZXJzZXRfY29QYXJlbnQAhQcZcmF3Y29sbGlkZXJzZXRfY29GcmljdGlvbgCHCBhyYXdjb2xsaWRlcnNldF9jb0RlbnNpdHkAnQcgcmF3Y29sbGlkZXJzZXRfY29Db2xsaXNpb25Hcm91cHMAtAcdcmF3Y29sbGlkZXJzZXRfY29Tb2x2ZXJHcm91cHMAtQcccmF3Y29sbGlkZXJzZXRfY29BY3RpdmVIb29rcwCWCCVyYXdjb2xsaWRlcnNldF9jb0FjdGl2ZUNvbGxpc2lvblR5cGVzAIEIHXJhd2NvbGxpZGVyc2V0X2NvQWN0aXZlRXZlbnRzAJcIGnJhd2NvbGxpZGVyc2V0X2NvU2V0U2Vuc29yAMAIH3Jhd2NvbGxpZGVyc2V0X2NvU2V0UmVzdGl0dXRpb24A2AgccmF3Y29sbGlkZXJzZXRfY29TZXRGcmljdGlvbgDZCCRyYXdjb2xsaWRlcnNldF9jb0ZyaWN0aW9uQ29tYmluZVJ1bGUAgggncmF3Y29sbGlkZXJzZXRfY29TZXRGcmljdGlvbkNvbWJpbmVSdWxlAKsIJ3Jhd2NvbGxpZGVyc2V0X2NvUmVzdGl0dXRpb25Db21iaW5lUnVsZQCDCCpyYXdjb2xsaWRlcnNldF9jb1NldFJlc3RpdHV0aW9uQ29tYmluZVJ1bGUArAgjcmF3Y29sbGlkZXJzZXRfY29TZXRDb2xsaXNpb25Hcm91cHMAzQcgcmF3Y29sbGlkZXJzZXRfY29TZXRTb2x2ZXJHcm91cHMAzgcfcmF3Y29sbGlkZXJzZXRfY29TZXRBY3RpdmVIb29rcwCtCCByYXdjb2xsaWRlcnNldF9jb1NldEFjdGl2ZUV2ZW50cwCuCChyYXdjb2xsaWRlcnNldF9jb1NldEFjdGl2ZUNvbGxpc2lvblR5cGVzAK8IGXJhd2NvbGxpZGVyc2V0X2NvU2V0U2hhcGUAuAcZX193YmdfcmF3Y29sbGlkZXJzZXRfZnJlZQCSBRJyYXdjb2xsaWRlcnNldF9uZXcAlwcScmF3Y29sbGlkZXJzZXRfbGVuAMgJF3Jhd2NvbGxpZGVyc2V0X2NvbnRhaW5zANoIHXJhd2NvbGxpZGVyc2V0X2NyZWF0ZUNvbGxpZGVyAPMDFXJhd2NvbGxpZGVyc2V0X3JlbW92ZQDwBSRyYXdjb2xsaWRlcnNldF9mb3JFYWNoQ29sbGlkZXJIYW5kbGUA9wgZX193YmdfcmF3bmFycm93cGhhc2VfZnJlZQDMBBJyYXduYXJyb3dwaGFzZV9uZXcAtwkccmF3bmFycm93cGhhc2VfY29udGFjdHNfd2l0aADJCRtyYXduYXJyb3dwaGFzZV9jb250YWN0X3BhaXIAmAghcmF3bmFycm93cGhhc2VfaW50ZXJzZWN0aW9uc193aXRoAMoJIHJhd25hcnJvd3BoYXNlX2ludGVyc2VjdGlvbl9wYWlyAK4JHV9fd2JnX3Jhd2NvbnRhY3RtYW5pZm9sZF9mcmVlANcKGHJhd2NvbnRhY3RwYWlyX2NvbGxpZGVyMQDBCBhyYXdjb250YWN0cGFpcl9jb2xsaWRlcjIAsAgicmF3Y29udGFjdHBhaXJfbnVtQ29udGFjdE1hbmlmb2xkcwDWCR5yYXdjb250YWN0cGFpcl9jb250YWN0TWFuaWZvbGQA3wcZcmF3Y29udGFjdG1hbmlmb2xkX25vcm1hbACYBxtyYXdjb250YWN0bWFuaWZvbGRfbG9jYWxfbjEAngcccmF3Y29udGFjdG1hbmlmb2xkX3N1YnNoYXBlMQDxCR9yYXdjb250YWN0bWFuaWZvbGRfbnVtX2NvbnRhY3RzANcJI3Jhd2NvbnRhY3RtYW5pZm9sZF9jb250YWN0X2xvY2FsX3AxAOUGH3Jhd2NvbnRhY3RtYW5pZm9sZF9jb250YWN0X2Rpc3QA/AgfcmF3Y29udGFjdG1hbmlmb2xkX2NvbnRhY3RfZmlkMQD9CB9yYXdjb250YWN0bWFuaWZvbGRfY29udGFjdF9maWQyAP4IInJhd2NvbnRhY3RtYW5pZm9sZF9jb250YWN0X2ltcHVsc2UA/wgscmF3Y29udGFjdG1hbmlmb2xkX2NvbnRhY3RfdGFuZ2VudF9pbXB1bHNlX3gAgAkscmF3Y29udGFjdG1hbmlmb2xkX2NvbnRhY3RfdGFuZ2VudF9pbXB1bHNlX3kAgQkmcmF3Y29udGFjdG1hbmlmb2xkX251bV9zb2x2ZXJfY29udGFjdHMA2AkncmF3Y29udGFjdG1hbmlmb2xkX3NvbHZlcl9jb250YWN0X3BvaW50ANkGJnJhd2NvbnRhY3RtYW5pZm9sZF9zb2x2ZXJfY29udGFjdF9kaXN0AMYIKnJhd2NvbnRhY3RtYW5pZm9sZF9zb2x2ZXJfY29udGFjdF9mcmljdGlvbgC4CC1yYXdjb250YWN0bWFuaWZvbGRfc29sdmVyX2NvbnRhY3RfcmVzdGl0dXRpb24AuQgycmF3Y29udGFjdG1hbmlmb2xkX3NvbHZlcl9jb250YWN0X3RhbmdlbnRfdmVsb2NpdHkA2wYlX193YmdfcmF3cG9pbnRjb2xsaWRlcnByb2plY3Rpb25fZnJlZQDXCilyYXdwb2ludGNvbGxpZGVycHJvamVjdGlvbl9jb2xsaWRlckhhbmRsZQDCCCByYXdwb2ludGNvbGxpZGVycHJvamVjdGlvbl9wb2ludADaByNyYXdwb2ludGNvbGxpZGVycHJvamVjdGlvbl9pc0luc2lkZQDwCiVfX3diZ19yYXdyYXljb2xsaWRlcmludGVyc2VjdGlvbl9mcmVlANcKIXJhd3JheWNvbGxpZGVyaW50ZXJzZWN0aW9uX25vcm1hbADbBx5yYXdyYXljb2xsaWRlcmludGVyc2VjdGlvbl90b2kA4wocX193YmdfcmF3cmF5Y29sbGlkZXJ0b2lfZnJlZQDXChNfX3diZ19yYXdzaGFwZV9mcmVlAIkJD3Jhd3NoYXBlX2N1Ym9pZACVCRRyYXdzaGFwZV9yb3VuZEN1Ym9pZACKCQ1yYXdzaGFwZV9iYWxsAKMJEHJhd3NoYXBlX2NhcHN1bGUAuQcRcmF3c2hhcGVfY3lsaW5kZXIAngkWcmF3c2hhcGVfcm91bmRDeWxpbmRlcgCWCQ1yYXdzaGFwZV9jb25lAJ8JEnJhd3NoYXBlX3JvdW5kQ29uZQCXCRFyYXdzaGFwZV9wb2x5bGluZQDgBxByYXdzaGFwZV90cmltZXNoAOEHFHJhd3NoYXBlX2hlaWdodGZpZWxkAI0GEHJhd3NoYXBlX3NlZ21lbnQA2QURcmF3c2hhcGVfdHJpYW5nbGUA9gQWcmF3c2hhcGVfcm91bmRUcmlhbmdsZQDyBBNyYXdzaGFwZV9jb252ZXhIdWxsAIQIGHJhd3NoYXBlX3JvdW5kQ29udmV4SHVsbAD6BxNyYXdzaGFwZV9jb252ZXhNZXNoALYHGHJhd3NoYXBlX3JvdW5kQ29udmV4TWVzaACyBx5fX3diZ19yYXdzaGFwZWNvbGxpZGVydG9pX2ZyZWUA1wobcmF3c2hhcGVjb2xsaWRlcnRvaV9ub3JtYWwxANwHFl9fd2JnX3Jhd3JvdGF0aW9uX2ZyZWUA1woPcmF3cm90YXRpb25fbmV3AJIKFHJhd3JvdGF0aW9uX2lkZW50aXR5ALcKDXJhd3JvdGF0aW9uX3kA8QoOcmF3dmVjdG9yX3plcm8A8goNcmF3dmVjdG9yX25ldwCmCg9yYXd2ZWN0b3Jfc2V0X3kA0AoNcmF3dmVjdG9yX3h5egChCA1yYXd2ZWN0b3JfeXh6AKIIDXJhd3ZlY3Rvcl96eHkAowgNcmF3dmVjdG9yX3h6eQCkCA1yYXd2ZWN0b3JfeXp4AKUIDXJhd3ZlY3Rvcl96eXgApggYX193YmdfcmF3ZXZlbnRxdWV1ZV9mcmVlAHERcmF3ZXZlbnRxdWV1ZV9uZXcA0QcgcmF3ZXZlbnRxdWV1ZV9kcmFpbkNvbnRhY3RFdmVudHMAqgklcmF3ZXZlbnRxdWV1ZV9kcmFpbkludGVyc2VjdGlvbkV2ZW50cwCrCRNyYXdldmVudHF1ZXVlX2NsZWFyAIYHHV9fd2JnX3Jhd3BoeXNpY3NwaXBlbGluZV9mcmVlANEBFnJhd3BoeXNpY3NwaXBlbGluZV9uZXcA6QgXcmF3cGh5c2ljc3BpcGVsaW5lX3N0ZXAAzQQhcmF3cGh5c2ljc3BpcGVsaW5lX3N0ZXBXaXRoRXZlbnRzAL4EG19fd2JnX3Jhd3F1ZXJ5cGlwZWxpbmVfZnJlZQC2CBRyYXdxdWVyeXBpcGVsaW5lX25ldwDSCRdyYXdxdWVyeXBpcGVsaW5lX3VwZGF0ZQDsBhhyYXdxdWVyeXBpcGVsaW5lX2Nhc3RSYXkAhwUkcmF3cXVlcnlwaXBlbGluZV9jYXN0UmF5QW5kR2V0Tm9ybWFsAOoEJXJhd3F1ZXJ5cGlwZWxpbmVfaW50ZXJzZWN0aW9uc1dpdGhSYXkA7AUmcmF3cXVlcnlwaXBlbGluZV9pbnRlcnNlY3Rpb25XaXRoU2hhcGUAiAUdcmF3cXVlcnlwaXBlbGluZV9wcm9qZWN0UG9pbnQAgwUncmF3cXVlcnlwaXBlbGluZV9pbnRlcnNlY3Rpb25zV2l0aFBvaW50AOcGGnJhd3F1ZXJ5cGlwZWxpbmVfY2FzdFNoYXBlAKgDJ3Jhd3F1ZXJ5cGlwZWxpbmVfaW50ZXJzZWN0aW9uc1dpdGhTaGFwZQCmBTJyYXdxdWVyeXBpcGVsaW5lX2NvbGxpZGVyc1dpdGhBYWJiSW50ZXJzZWN0aW5nQWFiYgCCBR9fX3diZ19yYXdkZXNlcmlhbGl6ZWR3b3JsZF9mcmVlAP8BIHJhd2Rlc2VyaWFsaXplZHdvcmxkX3Rha2VHcmF2aXR5AJkHLnJhd2Rlc2VyaWFsaXplZHdvcmxkX3Rha2VJbnRlZ3JhdGlvblBhcmFtZXRlcnMArgcmcmF3ZGVzZXJpYWxpemVkd29ybGRfdGFrZUlzbGFuZE1hbmFnZXIAyAQjcmF3ZGVzZXJpYWxpemVkd29ybGRfdGFrZUJyb2FkUGhhc2UAgAckcmF3ZGVzZXJpYWxpemVkd29ybGRfdGFrZU5hcnJvd1BoYXNlAMkEH3Jhd2Rlc2VyaWFsaXplZHdvcmxkX3Rha2VCb2RpZXMAtAUicmF3ZGVzZXJpYWxpemVkd29ybGRfdGFrZUNvbGxpZGVycwCTBR9yYXdkZXNlcmlhbGl6ZWR3b3JsZF90YWtlSm9pbnRzAMYEJXJhd3NlcmlhbGl6YXRpb25waXBlbGluZV9zZXJpYWxpemVBbGwA0gMncmF3c2VyaWFsaXphdGlvbnBpcGVsaW5lX2Rlc2VyaWFsaXplQWxsAKAHGV9fd2JnX3Jhd2NvbnRhY3RwYWlyX2ZyZWUA1woUX193YmdfcmF3dmVjdG9yX2ZyZWUA1woicmF3cmlnaWRib2R5c2V0X3JiTG9ja1RyYW5zbGF0aW9ucwCtBxxyYXdjb250YWN0bWFuaWZvbGRfc3Vic2hhcGUyAPEJHHJhd3NlcmlhbGl6YXRpb25waXBlbGluZV9uZXcAjwsNcmF3cm90YXRpb25feACHCw1yYXdyb3RhdGlvbl96AOMKDXJhd3JvdGF0aW9uX3cA5AoLcmF3dmVjdG9yX3gAhwsLcmF3dmVjdG9yX3kA8QoLcmF3dmVjdG9yX3oA4wopcmF3cmF5Y29sbGlkZXJpbnRlcnNlY3Rpb25fY29sbGlkZXJIYW5kbGUAwgggcmF3cmF5Y29sbGlkZXJ0b2lfY29sbGlkZXJIYW5kbGUAwggicmF3c2hhcGVjb2xsaWRlcnRvaV9jb2xsaWRlckhhbmRsZQDCCA9yYXd2ZWN0b3Jfc2V0X3gA7woPcmF3dmVjdG9yX3NldF96AMQKG3Jhd2NvbnRhY3RtYW5pZm9sZF9sb2NhbF9uMgCeByNfX3diZ19yYXdzZXJpYWxpemF0aW9ucGlwZWxpbmVfZnJlZQDXCiNyYXdjb250YWN0bWFuaWZvbGRfY29udGFjdF9sb2NhbF9wMgDlBhxyYXdjb2xsaWRlcnNldF9pc0hhbmRsZVZhbGlkANoIFXJhd3JheWNvbGxpZGVydG9pX3RvaQDjChdyYXdzaGFwZWNvbGxpZGVydG9pX3RvaQDjChxyYXdzaGFwZWNvbGxpZGVydG9pX3dpdG5lc3MxANsHHHJhd3NoYXBlY29sbGlkZXJ0b2lfd2l0bmVzczIA2wcbcmF3c2hhcGVjb2xsaWRlcnRvaV9ub3JtYWwyANwHEV9fd2JpbmRnZW5fbWFsbG9jAKIKEl9fd2JpbmRnZW5fcmVhbGxvYwCMCx9fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyAJYMD19fd2JpbmRnZW5fZnJlZQC2CxRfX3diaW5kZ2VuX2V4bl9zdG9yZQDHCwmgDQEAQQEL2wbCC5MM9gHnDJcMpgynDIIMmQyaDKUJlwuGC7MJ1ATzCKkJxAvmCLELsgyYDMMLsQzmDOYM6AyMCu0CmQTmDIgBVWSVDPQK5wxrOSYuQf0BOiCmCZgLswy6CpsMuQq4CrgK3AnAB+IHuwqKBdYExQStBcYLxgvGC8YLiwmRB68JsgPJArsDoweFBbQIoAzLBYUK0gzgC9MM0AzPDOYLqAymC8IGrwaHDGyIDGqGDIUBhQxm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IgI2AgAgACgCACACa0EDTQRAIAQgAkEEEOkGIAMoAgAhAgsgAyACQQRqNgIAIAQoAgAgAmogFTgAACAGQTBqKgIAIRQgASgCACIDQQhqIgAoAgAhAiADQQRqKAIAIAJrQQNNBEAgAyACQQQQ6QYgACgCACECCyAAIAJBBGo2AgAgAygCACACaiAUOAAAIAZBNGoqAgAhFCABKAIAIgNBCGoiACgCACECIANBBGooAgAgAmtBA00EQCADIAJBBBDpBiAAKAIAIQILIAAgAkEEajYCACADKAIAIAJqIBQ4AAAgBkE4aioCACEUIAEoAgAiA0EIaiIAKAIAIQIgA0EEaigCACACa0EDTQRAIAMgAkEEEOkGIAAoAgAhAgsgACACQQRqNgIAIAMoAgAgAmogFDgAACAGQTxqKgIAIRQgASgCACIDQQhqIgAoAgAhAiADQQRqKAIAIAJrQQNNBEAgAyACQQQQ6QYgACgCACECCyAAIAJBBGo2AgAgAygCACACaiAUOAAAIAZBQGsqAgAhFCABKAIAIgNBCGoiACgCACECIANBBGooAgAgAmtBA00EQCADIAJBBBDpBiAAKAIAIQILIAAgAkEEajYCACADKAIAIAJqIBQ4AAAgBkHEAGoqAgAhFCABKAIAIgNBCGoiACgCACECIANBBGooAgAgAmtBA00EQCADIAJBBBDpBiAAKAIAIQILIAAgAkEEajYCACADKAIAIAJqIBQ4AAAgBkHIAGoqAgAhFCABKAIAIgNBCGoiACgCACECIANBBGooAgAgAmtBA00EQCADIAJBBBDpBiAAKAIAIQILIAAgAkEEajYCACADKAIAIAJqIBQ4AAACQAJAAkACQAJAAkAgBkHNAGotAABBAWsOAwECAwALQQAhBCABKAIAIgJBCGooAgAhByACQQRqKAIAIAdrQQRJDQMMBAtBASEEIAEoAgAiAkEIaigCACEHIAJBBGooAgAgB2tBBEkNAgwDC0ECIQQgASgCACICQQhqKAIAIQcgAkEEaigCACAHa0EESQ0BDAILQQMhBCABKAIAIgJBCGooAgAhByACQQRqKAIAIAdrQQNLDQELIAIgB0EEEOkGIAJBCGooAgAhBwsgAigCACAHaiAENgAAIAJBCGogB0EEajYCAAwBCyABKAIAIgNBCGoiACgCACECIANBBGooAgAgAmtB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IARBBE8EQCABIARBfGoiBDYCBCABIAEoAgAiBUEEajYCACAFNQAAQiCGDAELEIgLrUIghkIBhAsiYEIgiCFiIGCnBEAgYqchAwwBCwJAIARFDQAgASAEQX9qIgY2AgQgASABKAIAIgVBAWo2AgACQAJAAkAgBS0AACIIDgIBAgALQRBBBBDFCyIDRQ07IAMgCDoAASADQQI6AAAMAwtBACEICyAGQQRJDQAgASAEQXtqIgY2AgQgASAFQQVqNgIAIAZBBEkNACAFKAABIS0gASAEQXdqIgY2AgQgASAFQQlqNgIAIAUoAAUiGkEETwRAIAJBAToA0AEgAiAarTcD2AEgAkHQAWpBqI7AAEHshcAAEN4FIQMMAgsCfiAGRQRAEIgLrUIghkIBhAwBCyABIARBdmo2AgQgASAFQQpqNgIAIAUxAAlCCIYLImFCAYNQRQRAIGFCIIinIQMMAgsgEygCACIEQQ9LDQILEIgLIQMLIF6nIgRFDQcgBEEDdEUNByAsEOEBDAcLIGRCCIinITggcachBSBppyFKIGKnIUsgASAEQXBqNgIEIAEgASgCACIEQRBqNgIAIAJB+ANqIAooAgA2AgAgAkHoA2ogNCgCADYCACACQdABaiIGQQhqIAspAwA3AwAgBkEQaiANKQMANwMAIAZBGGogESkDADcDACAGQSBqIBwpAwA3AwAgAiACKQOQBDcD8AMgAiACKQOABDcD4AMgAiACKQOgBDcD0AEgBEEIaikAACFiIAQpAAAhZCACQbICaiACQbYCai0AADoAACACIAIvAbQCOwGwAiBiQiCGIGRCIIiEIWAgYkIgiCFpIGFCCIinITQgZKchO0EBIRELIAJB2ANqIAJB+ANqKAIANgIAIAJByANqIAJB6ANqKAIANgIAIAJBmANqIgZBCGogAkHQAWoiBEEIaikDADcDACAGQRBqIARBEGopAwA3AwAgBkEYaiAEQRhqKQMANwMAIAZBIGogBEEgaikDADcDACACIAIpA/ADNwPQAyACIAIpA+ADNwPAAyACIAIpA9ABNwOYAyACQZYDaiACQbICai0AADoAACACIAIvAbACOwGUAyBpQiCGIGBCIIiEIWQgO60gYEIghoQhYEEADAYLEIgLIQMMBAsgAigC1AEhAwwDC0EBQcSRwABB7IXAABDNBSEDDAILIAIoAtQB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AkHc9sAAEM0IAAsgACACQez2wAAQzQgACyAEIAJBxPrAABDNCAALIAMgAkHU+sAAEM0IAAsgAyACQZT7wAAQzQgACyAEIAJBsIHBABDNCAALIAMgAkHAgcEAEM0IAAsgAyACQfCBwQAQzQgACyAEIAJB2IXBABDNCAALIAMgAkHohcEAEM0IAAsgAyACQZiGwQAQzQgAC0Hst8AAQShBzPzAABDbCQAL0IEBBD5/A34SfQJ8IwBB0AVrIhIkACAALQDIAwRAIABCADcDMCAAQgA3AxggAEIANwPgASAAQgA3A6gBIABB2AFqQQA2AgAgAEGQAWpCADcDACAAQfgAakIANwMAIABB4ABqQgA3AwAgAEHIAGpCADcDACAAQcADakEANgIAIABBwAJqQgA3AwAgAEGoAmpCADcDACAAQZACakIANwMAIABB+AFqQgA3AwAgAEHAAWpCADcDACAAQagDakIANwMAIABBkANqQgA3AwAgAEH4AmpCADcDACAAQdgCakIANwMAIABB4AJqQgA3AwAgAEIANwMAIABBEGoQjwc5AwAgAEIBNwMICyAGIAcgCSgCACAJQQhqIjcoAgAQygIgAyAGIAcgCCgCACAIKAIIIAkQogEgACACQSRqKgIAIAMgBCAFIAYgByAJKAIAIDcoAgAgCigCACAKKAIIIA0gDiAPIBBBARC4BCA3KAIAIREgN0EANgIAAkAgEUUNACAHKAIIIRMgBygCACEUIAkoAgAiFSEIAkAgEUEDdCIXQXhqIhFBCHENACAVQQhqIQggEyAVKQIAIk+nIhZNDQAgFkGgAWwgFGpBACATIBZLGyIWKAIAQQFHDQAgFigCBCBPQiCIp0cNACAWQQA2AigLIBFFDQAgFSAXaiEXA0ACQCATIAgpAgAiT6ciEU0NACARQaABbCAUakEAIBMgEUsbIhEoAgBBAUcNACARKAIEIE9CIIinRw0AIBFBADYCKAsCQCATIAhBCGopAgAiT6ciEUsiFUUNACARQaABbCAUakEAIBUbIhEoAgBBAUcNACARKAIEIE9CIIinRw0AIBFBADYCKAsgFyAIQRBqIghHDQALCyAKQQA2AgggAioCACFVIBJBEGogAkHEABDkBhogAEHcA2ohSCAAQdADaiFJIAtBKGohQCAFQQhqITggA0EwaiFLIANBPGohQSASKAJQ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AAsQjwchZCAAQgA3AzggACAAKwMwIGQgZaGgOQMwIAAQjwc5A4gBIABCATcDgAECQCAZIDkoAgAiE00NACBNKAIAIBMiEWsgGSARayIVSQRAIE4gEyAVEIMGIDkoAgAhEQsgACgCgAQgEUGoAWxqIQggFUECTwRAIBNBf3MgGWohEwNAIAggHjYCACAIQaABakIANwIAIAhBnAFqIB42AgAgCEGUAWpCADcCACAIQZABaiAeNgIAIAhBiAFqQgA3AgAgCEGEAWogHjYCACAIQfwAakIANwIAIAhB+ABqIB42AgAgCEHwAGpCADcCACAIQewAaiAeNgIAIAhB5ABqQgA3AgAgCEHgAGogHjYCACAIQdgAakIANwIAIAhB1ABqIB42AgAgCEHMAGpCADcCACAIQcgAaiAeNgIAIAhBQGtCADcCACAIQTxqIB42AgAgCEE0akIANwIAIAhBMGogHjYCACAIQShqQgA3AgAgCEEkaiAeNgIAIAhBHGpCADcCACAIQRhqIB42AgAgCEEQakIANwIAIAhBDGogHjYCACAIQQRqQgA3AgAgCEGoAWohCCATQX9qIhMNAAsgESAVakF/aiERCyAVRQRAIDkgESITNgIADAELIAggHjYCnAEgCCAeNgKQASAIIB42AkggCCAeNgI8IAggHjYCMCAIIB42AiQgCCAeNgIYIAggHjYCDCAIQgA3AgQgCCAeNgIAIAhBoAFqQgA3AgAgCEGUAWpCADcCACAIQYgBakIANwIAIAhBhAFqIB42AgAgCEH8AGpCADcCACAIQfgAaiAeNgIAIAhB8ABqQgA3AgAgCEHsAGogHjYCACAIQeQAakIANwIAIAhB4ABqIB42AgAgCEHYAGpCADcCACAIQdQAaiAeNgIAIAhBzABqQgA3AgAgCEFAa0IANwIAIAhBNGpCADcCACAIQShqQgA3AgAgCEEcakIANwIAIAhBEGpCADcCACAoKAIAQX9qIRkgEigC0AQhICA5IBFBAWoiEzYCAAsgEigCyAQhFAJAIBlFDQACQAJAAkAgE0UEQEEAIRVBACEIDAELIBlBf2ohF0EAIRNBACERQQAhCANAIEQoAgAiAiAITQ0CIEUoAgAiAiAITQ0DIAAoAoAEIBFqIAggACASQRBqIAMgBiAUICAgACgC0AMgE2oiAigCACACQQhqKAIAIAso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DEYNACADKAKwASIGIA5PDQogHyAOTw0LIAMqAqABIB9BA3QgBGopAgAiIae+IiUgBkEDdCAEaikCACIgp76TlCADKgKkASAhQiCIp74iIyAgQiCIp76TlJJDAABIN15FBEAgAygCmAIiBiAOTw0NIAMqAogCICUgBkEDdCAEaikCACIgp76TlCADKgKMAiAjICBCIIinvpOUkkMAAEg3XkUNASADKAKkAiALRgRAIANBoAJqIAtBARCUBiADKAKgAiERIAMoAqgCIQsLIAtBAnQgEWogHzYCACADIAtBAWoiCzYCqAIMAQsgAygCwAEiCiADKAK8AUYEQCADQbgBaiAKQQEQlAYgAygCwAEhCgsgAygCuAEgCkECdGogHzYCACADIApBAWo2AsABCyAHQQRqIQcgDUF8aiINDQALDAsLIBMgCkG0sMIAEM0IAAsgECAOQdDBwgAQzQgACyATIBBBxLDCABDNCAALIAsgEEGwssIAEM0IAAsgByAQQcCywgAQzQgACyAMIA5B4LLCABDNCAALIAggDkHwssIAEM0IAAsgESAOQeCywgAQzQgACyAGIA5BgLPCABDNCAALIB8gDkGQs8IAEM0IAAsgBiAOQYCzwgAQzQgACyAJBEBBACEHIAkhBQNAAkACQAJAIAcgBUkEQCADKAKwASIJIA5PDRYgB0ECdCAYaiIGKAIAIg0gDk8NAQJAIAMqAqABIA1BA3QgBGopAgAiIae+IiUgCUEDdCAEaikCACIgp76TlCADKgKkASAhQiCIp74iIyAgQiCIp76TlJJDAABIN15FBEAgAygCmAIiDCAOTw0EIAMqAogCICUgDEEDdCAEaikCACIgp76TlCADKgKMAiAjICBCIIinvpOUkkMAAEg3Xg0BIAdBAWohBwwFCyADKALAASIMIAMoArwBRgRAIANBuAFqIAxBARCUBiADKALAASEMCyADKAK4ASAMQQJ0aiANNgIAIAMgDEEBajYCwAEgBiAFQX9qIgVBAnQgGGooAgA2AgAMBAsgAygCpAIgC0YEQCADQaACaiALQQEQlAYgAygCqAIhCwsgAygCoAIgC0ECdGogDTYCACADIAtBAWoiCzYCqAIgBiAFQX9qIgVBAnQgGGooAgA2AgAMAwsgByAFQdCywgAQzQgACyANIA5BkLPCABDNCAALIAwgDkGAs8IA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AgAiJiAmlJIgAkEYaioCACInICeUkkMAAAAAkiIoIAkqAgAiIyAMKgIAIiSSIjAgB5IiByAHlF1FDQAaQwAAgD8hIkMAAAAAIQcgKEMAAAAAXARAICcgKBCzASIilSEHICYgIpUhISAlICKVISILICQgByACKgIMIiwgIiACQQRqKgIAIieUICEgAioCACImlJMiJSAlkiIqlCAnICEgAkEIaioCACItlCAHICeUkyIlICWSIi+UICYgByAmlCAiIC2UkyIlICWSIi6Uk5KSjCIllCErICQgISAsIC6UICYgKpQgLSAvlJOSkowiJpQhKSAkICIgLCAvlCAtIC6UICcgKpSTkpKMIieUISQgIyAHlCEqICMgIZQhLyAjICKUIS4gKBCzASAwkyEjQQELIQEgACAuOAIEIAAgATYCACAAQTRqICM4AgAgAEEwaiAlOAIAIABBLGogJjgCACAAQShqICc4AgAgAEEkaiAHOAIAIABBIGogITgCACAAQRxqICI4AgAgAEEYaiArOAIAIABBFGogKTgCACAAQRBqICQ4AgAgAEEMaiAqOAIAIABBCGogLzgCAAwPCyAIQdAAaiIBIAIgCiANIAgoAjQgBxDxAiAAQTBqIAFBMGopAwA3AgAgAEEoaiABQShqKQMANwIAIABBIGogAUEgaikDADcCACAAQRhqIAFBGGopAwA3AgAgAEEQaiABQRBqKQMANwIAIABBCGogAUEIaikDADcCACAAIAgpA1A3AgAMDgsgCEHQAGogAiALIAogDyAHEPECQQEhAgJAIAgoAlBBAUcEQEEAIQIMAQsgCEGEAWoqAgAhISAIQYgFaiIBQRBqIgYgCEHQAGoiA0EUaikCADcDACABQQhqIgkgCEHcAGoiDCkCADcDACABQShqIgogA0EsaikCADcDACABQSBqIgQgCEH0AGopAgA3AwAgAUEYaiIFIAhB7ABqKQIANwMAIAhByARqIgNBCGoiCyABQRRqKAIANgIAIAggCCkCVDcDiAUgCCAIKQKUBTcDyAQgA0EUaiAMKAIANgIAIAggCCkCVDcC1AQgA0EgaiIMIAFBLGooAgA2AgAgA0EYaiIBIAgpAqwFNwMAIANBLGogBCgCADYCACAIIAUpAwA3AuwEIAogA0EoaikDADcDACAEIAwpAwA3AwAgBSABKQMANwMAIAYg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CQsgCEGUAWohASAIKALMAiAGRgRAIAhByAJqIAYQ9wUgCCgC0AIhBgsgCCgCyAIgBkEkbGoiAyABKQIANwIAIANBIGogAUEgaigCADYCACADQRhqIAFBGGopAgA3AgAgA0EQaiABQRBqKQIANwIAIANBCGogAUEIaikCADcCACAIIAZBAWoiATYC0AIgCUECRg0CIAhBuAFqIQMgCCgCzAIgAUYEQCAIQcgCaiABEPcFIAgoAtACIQELIAgoAsgCIAFBJGxqIgQgAykCADcCACAEQSBqIANBIGooAgA2AgAgBEEYaiADQRhqKQIANwIAIARBEGogA0EQaikCADcCACAEQQhqIANBCGopAgA3AgAgCCABQQFqIgU2AtACIAlBA0YNAyAIQdwBaiEBIAgoAswCIAVGBEAgCEHIAmogBRD3BSAIKALQAiEFCyAIKALIAiAFQSRsaiIDIAEpAgA3AgAgA0EgaiABQSBqKAIANgIAIANBGGogAUEYaikCADcCACADQRBqIAFBEGopAgA3AgAgA0EIaiABQQhqKQIANwIAIAggBUEBaiIENgLQAiAJQQRGDQVBBEEEQeThwQAQzQgACyAIQaACaiIBQSRqKgIAISUgCEHAAmoqAgAhIyAIQbwCaioCACEkIAhBuAJqKgIAISYgCEG0AmoqAgAhKCAIQbACaioCACEwIAhBrAJqKgIAIScgAUEIaioCACEtIAgqAqQCIStBACEBAkAgA0F+ag4CAAoJC0GszcEAQShB3NPBABDbCQALIAggBSAGKAKkAREAACAIKAIAIgwEQCAIKAIEIQogCEGIBGoiBUEIaiIGIAJBCGopAgA3AwAgBUEYaiIJIAJBGGooAgA2AgAgBiAGKgIAIiGMOAIAIAggAikCEDcDmAQgCCACKQIANwOIBCAhIAgqApgEIiWUIAgqAogEIiMgCSoCACInlJMhJiAjIAVBFGoiAioCACIrlCAIKgKMBCIkICWUkyIiICKSISIgAiAIKgKUBCIpICYgJpIiJpQgIyAilCAhICQgJ5QgISArlJMiKCAokiIolJOSICuTOAIAIAkgKSAilCAkICiUICMgJpSTkiAnkzgCACAIICOMOAKIBCAIICSMOAKMBCAIICkgKJQgISAmlCAkICKUk5IgJZM4ApgEIAhB0ABqIAEgBSAMIAogAyAEIAcQmQFBASECAkAgCCgCUEEBRwRAQQAhAgwBCyAIQYQBaioCACEhIAhBiAVqIgFBEGoiBiAIQdAAaiIDQRRqKQIANwMAIAFBCGoiCSAIQdwAaiIMKQIANwMAIAFBKGoiCiADQSxqKQIANwMAIAFBIGoiBCAIQfQAaikCADcDACABQRhqIgUgCEHsAGopAgA3AwAgCEHIBGoiA0EIaiILIAFBFGooAgA2AgAgCCAIKQJUNwOIBSAIIAgpApQFNwPIBCADQRRqIAwoAgA2AgAgCCAIKQJUNwLUBCADQSBqIgwgAUEsaigCADYCACADQRhqIgEgCCkCrAU3AwAgA0EsaiAEKAIANgIAIAggBSkDADcC7AQgCiADQShqKQMANwMAIAQgDCkDADcDACAFIAEpAwA3AwAgBiADQRBqKQMANwMAIAkgCykDADcDACAIIAgpA8gENwOIBQsgACACNgIAIAAgCCkDiAU3AgQgAEE0aiAhOAIAIABBDGogCEGIBWoiAUEIaikDADcCACAAQRRqIAhBmAVqKQMANwIAIABBHGogAUEYaikDADcCACAAQSRqIAhBqAVqKQMANwIAIABBLGogCEGwBWopAwA3AgAMCgsgAEECNgIADAkLIAFBAU0NASAIKALIAiIBKgIkIAEqAgCTIge8Qf////8Hcb4hISABQSxqKgIAIAEqAgiTIiNDAAAAACAhIAFBKGoqAgAgASoCBJMiIbxB/////wdxvl4iARsiJCAHjCAhIAEbIiIgIpRDAAAAACAjjCABGyIlICWUICQgJJSSkkMAAAAAkhCzASIklSEnIAhBuANqIgFBCGoiAyAhICeUIAcgJSAklSIllJM4AgAgCCAHICIgJJUiB5QgIyAnlJM4ArwDIAggIyAllCAhIAeUkzgCuAMgCEGIBGogDCABIBsRAQAgCEGIBWoiBEEIaiIBIAMoAgA2AgAgASABKgIAjDgCACAIIAgpA7gDNwOIBSAIIAgqAogFjDgCiAUgCCAIKgKMBYw4AowFIAhByARqIBQgAiAEIBwRAgAgCCoCiAQhByAIKgKMBCEjIAgqApAEISEgCCoCyAQhJCAIKgLMBCEiIAgqAtAEISUgCCgC0AIiBSAIKALMAkYEQCAIQcgCaiAFEPcFIAgoAtACIQULIAgoAsgCIAVBJGxqIgEgJDgCGCABIAc4AgwgASAhICWTOAIIIAEgIyAikzgCBCABIAcgJJM4AgAgAUEgaiAlOAIAIAFBHGogIjgCACABQRRqICE4AgAgAUEQaiAjOAIAIAggBUEBaiIFNgLQAgsgCCgCyAIhAyAIQQI2ApAEIAhCgICAgBA3AogEIAhBATYC0AQgCEKBgICAEDcCyAQgCEGIBWoiASADIAUgCEGIBGoiBCAIQcgEaiIDEP8CIARBOGoiCSABQThqIgUpAwA3AwAgBEEwaiIKIAFBMGoiBikDADcDACAEQShqIgsgAUEoaiINKQMANwMAIARBIGoiDyABQSBqIhApAwA3AwAgBEEYaiIOIAFBGGoiFSkDADcDACAEQRBqIAFBEGoiFikDADcDACAEQQhqIgQgAUEIaiIXKQMANwMAIAggCCkDiAU3A4gEIAgoAtACIRggCCgCyAIhESAIQQE2AsADIAhCgICAgCA3ArgDIAhBADYC0AQgCEIANwLIBCABIBEgGCAIQbgDaiADEP8CIANBOGogBSkDADcDACADQTBqIAYpAwA3AwAgA0EoaiANKQMANwMAIANBIGogECkDADcDACADQRhqIBUpAwA3AwAgA0EQaiAWKQMANwMAIANBCGogFykDADcDACAIIAgpA4gFNwPIBCAIKALYAiIDIAgoAtwCIgVGBEAgCEHUAmogBRCRBiAIKALcAiEFIAgoAtgCIQMLIAgoAtQCIgYgBUEGdGoiASAIKQOIBDcCACABQShqIAspAwA3AgAgAUEgaiAPKQMANwIAIAFBGGogDikDADcCACABQRBqIAhBmARqKQMANwIAIAFBCGogBCkDADcCACABQTBqIAopAwA3AgAgAUE4aiAJKQMANwIAIAggBUEBaiIFNgLcAiADIAVGBEAgCEHUAmogAxCRBiAIKALUAiEGIAgoAtwCIQULIAVBBnQgBmoiASAIKQPIBDcCACABQShqIAhByARqIgNBKGopAwA3AgAgAUEgaiADQSBqKQMANwIAIAFBGGogA0EYaikDADcCACABQRBqIANBEGopAwA3AgAgAUEIaiADQQhqKQMANwIAIAFBOGogA0E4aikDADcCACABQTBqIANBMGopAwA3AgAgCCAFQQFqNgLcAiAIKAL0AiIBIQMgCCgC8AIgAUYEQCAIQewCaiABEJAGIAgoAvQCIQMLIAgoAuwCIgQgA0EDdGpCADcC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IANBEGpCADcDACAEQgA3AsQBIARB7LjBACgCACIFNgLkASAEIAU2AtgBIAQgBTYCzAEgBCAFNgLAAUEAIQYgBCgCvAEiB0EBaiIIIAdJDQIgBEHAAWpBABD3BSAEKALAASIFIAQoAsgBIgNBJGxqIgYgBCkDIDcCACAGQSBqIARBQGsoAgA2AgAgBkEYaiAEQThqKQMANwIAIAZBEGogBEEwaikDADcCACAGQQhqIARBKGopAwA3AgAgBCADQQFqIgM2AsgBIAdFBEAgBEGAAmpCADcDACAEQfgBakIANwMAIARCADcD8AEMCgsgBEHEAGohByAEKALEASADRgRAIARBwAFqIAMQ9wUgBCgCwAEhBSAEKALIASEDCyADQSRsIAVqIgYgBykCADcCACAGQSBqIAdBIGooAgA2AgAgBkEYaiAHQRhqKQIANwIAIAZBEGogB0EQaikCADcCACAGQQhqIAdBCGopAgA3AgAgBCADQQFqIgc2AsgBIAhBAkYNASAEQegAaiEGIAQoAsQBIAdGBEAgBEHAAWogBxD3BSAEKALIASEHIAQoAsABIQULIAdBJGwgBWoiAyAGKQIANwIAIANBIGogBkEgaigCADYCACADQRhqIAZBGGopAgA3AgAgA0EQaiAGQRBqKQIANwIAIANBCGogBkEIaikCADcCACAEIAdBAWoiBjYCyAEgCEEDRg0CIARBjAFqIQcgBCgCxAEgBkYEQCAEQcABaiAGEPcFIAQoAsgBIQYgBCgCwAEhBQsgBkEkbCAFaiIDIAcpAgA3AgAgA0EgaiAHQSBqKAIANgIAIANBGGogB0EYaikCADcCACADQRBqIAdBEGopAgA3AgAgA0EIaiAHQQhqKQIANwIAIAQgBkEBaiIPNgLIASAIQQRGDQRBBEEEQeThwQAQzQgACyAAQQE6AAwgACACKQIANwIAIABBCGogAkEIaigCADYCAAwMCyAHQQFNDQEgBUEsaioCACAFKgIIkyIvQwAAAAAgBSoCJCAFKgIAkyIuvEH/////B3G+IAVBKGoqAgAgBSoCBJMiLLxB/////wdxvl4iAxsiKCAujCAsIAMbIiogKpRDAAAAACAvjCADGyInICeUICggKJSSkkMAAAAAkhCzASIplSErIDsgLCArlCAuICcgKZUiJ5STIiggKCAolCAvICeUICwgKiAp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gICAMDcCiAMgBEEANgLgAyAEQoKAgIAQNwLYAyANIAMgBSAEQYgDaiAOEP8CIA5BOGogGikDADcDACAOQTBqIBspAwA3AwAgDkEoaiAcKQMANwMAIA5BIGogCSkDADcDACAOQRhqIAgpAwA3AwAgDkEQaiAHKQMANwMAIA5BCGogBikDADcDACAEIAQpA5gENwPYAyAELQDYBCAEKALQASIGIAQoAtQBIghGBEAgBEHMAWogCBCRBiAEKALUASEIIAQoAtABIQYLIAQoAswBIgcgCEEGdGoiAyAEKQOIAjcCACADQShqIB0pAwA3AgAgA0EgaiAPKQMANwIAIANBGGogEykDADcCACADQRBqIBkpAwA3AgAgA0EIaiASKQMANwIAIANBMGogESkDADcCACADQThqIBApAwA3AgAgBCAIQQFqIgg2AtQBIAYgCEYEQCAEQcwBaiAGEJEGIAQoAswBIQcgBCgC1AEhCCAEKALQASEGCyAIQQZ0IAdqIgUgBCkDyAI3AgAgBUEoaiAEQcgCaiIDQShqKQMANwIAIAVBIGogA0EgaikDADcCACAFQRhqIANBGGopAwA3AgAgBUEQaiADQRBqKQMANwIAIAVBCGogA0EIaikDADcCACAFQThqIANBOGopAwA3AgAgBUEwaiADQTBqKQMANwIAIAQgCEEBaiIINgLUASAGIAhGBEAgBEHMAWogBhCRBiAEKALMASEHIAQoAtQBIQggBCgC0AEhBgsgCEEGdCAHaiIFIAQpA5gDNwIAIAVBKGogBEGYA2oiA0EoaikDADcCACAFQSBqIANBIGopAwA3AgAgBUEYaiADQRhqKQMANwIAIAVBEGogA0EQaikDADcCACAFQQhqIANBCGopAwA3AgAgBUE4aiADQThqKQMANwIAIAVBMGogA0EwaikDADcCACAEIAhBAWoiCDYC1AEgBiAIRgRAIARBzAFqIAYQkQYgBCgC1AEhCCAEKALMASEHCyAIQQZ0IAdqIgUgBCkD2AM3AgAgBUEoaiAEQdgDaiIDQShqKQMANwIAIAVBIGogA0EgaikDADcCACAFQRhqIANBGGopAwA3AgAgBUEQaiADQRBqKQMANwIAIAVBCGogA0EIaikDADcCACAFQThqIANBOGopAwA3AgAgBUEwaiADQTBqKQMANwIAIAQgCEEBaiIDNgLU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aiIJKQMANwMAIAVBKGogA0EoaiIIKQMANwMAIAVBIGoiDCADQSBqIg0pAwA3AwAgBUEYaiIKIANBGGoiECkDADcDACAFQRBqIANBEGoiESkDADcDACAFQQhqIhIgA0EIaiIFKQMANwMAIAQgBCkDmAQ3A5gDIAQoAsgBIRMgBCgCwAEhFCAEQQE2AtACIARCgICAgCA3AsgCIARBADYC4AMgBEIANwLYAyADIBQgEyAEQcgCaiABEP8CIAFBOGogBikDADcDACABQTBqIAkpAwA3AwAgAUEoaiAIKQMANwMAIAFBIGogDSkDADcDACABQRhqIBApAwA3AwAgAUEQaiARKQMANwMAIAFBCGogBSkDADcDACAEIAQpA5gENwPYAyAEKALUASIDIAQoAtABIgVGBEAgBEHMAWogAxCRBiAEKALQASEFIAQoAtQBIQMLIAQoAswBIgYgA0EGdGoiASAEKQOYAzcCACABQShqIARBmANqIglBKGopAwA3AgAgAUEgaiAMKQMANwIAIAFBGGogCikDADcCACABQRBqIAlBEGopAwA3AgAgAUEIaiASKQMANwIAIAFBMGogCykDADcCACABQThqIAcpAwA3AgAgBCADQQFqIgM2AtQBIAMgBUYEQCAEQcwBaiAFEJEGIAQoAswBIQYgBCgC1AEhAwsgA0EGdCAGaiIBIAQpA9gDNwIAIAFBKGogBEHYA2oiBUEoaikDADcCACABQSBqIAVBIGopAwA3AgAgAUEYaiAFQRhqKQMANwIAIAFBEGogBUEQaikDADcCACABQQhqIAVBCGopAwA3AgAgAUE4aiAFQThqKQMANwIAIAFBMGogBUEwaikDADcCACAEIANBAWo2AtQBIAQoAuwBIgEhBSAEKALoASABRgRAIARB5AFqIAEQkAYgBCgC7AEhBQsgBCgC5AEiAyAFQQN0akIANwIAIAQgBUEBajYC7AEgAUEDdCADaiIFKgIEIRsgBSgCACEGAkAgAUUEQEEAIQUMAQsDQEEAQX8gGyABQX9qIgdBAXYiBUEDdCADaiILQQRqKgIAIhxgIgkbQQFBAiAJGyAbIBxfG0F/akH/AXFBAUsEQCABIQUMAgsgAUEDdCADaiALKQIANwIAIAUhASAHQQFLDQALCyAFQQN0IANqIgEgGzgCBCABIAY2AgAgBCgC7AEiASEF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pAQgBEHwAWoiAUEIaiADKQMANwMAIAFBEGogAkEQaikDADcDACAEIAQpA9gDNwPwAQwECyAHIAFBmN3BABDNCAALIARBiANqIBAQnAMgBCgCiANBAUYNAAsLIAQoAtQBIgEgB00NASAEQdgDaiIBIAQoAswBIAdBBnRqIAQoAsABIAQoAsgBEJwEIARBmARqIgJBCGoiAyABQQhqKAIANgIAIAJBFGogAUEUaigCADYCACAEIAQpAuQDNwKkBCAEQfABaiIBQQhqIAMpAwA3AwAgAUEQaiACQRBqKQMANwMAIAQgBCkD2AM3A/ABCyAAIAQpA/ABNwIAIABBCGogBEH4AWooAgA2AgAgAEEBOgAMIARBwAFqENoGDAULIAcgAUH43MEAEM0IAAtB5LbBAEErQejcwQAQ2wkACyAAQQE6AAwgACACKQIANwIAIABBCGogAkEIaigCADYCACAEQcABahDaBgwCCyAEQZgEaiAEQQEQ+AEgBCoCoAQhHCAEKgKcBCEeIAQqApgECyEbIABBADoADCAAIBw4AgggACAeOAIEIAAgGzgCAAsgBEHgBGokAA8LQazNwQBBKEHc38EAENsJAAuyUgMXfwF+Dn0jAEHgBGsiBCQAIARBGGpBADYCACAEQbgBakEANgIAIARCADcDECAEQgA3A7ABIARCgoCAgDA3AwggBEKAgICAEDcDACAEQcQAakEAQewAEOgGGkMAAIA/IR4gAioCACIdIB2UIAIqAgQiHyAflJIgAioCCCIgICCUkkMAAAAAkiIiQwAAgCheBEAgICAiELMBIh6VISEgHyAelSEcIB0gHpUhHgsgISAhlCAcIByUIB4gHpSSkkMAAAAAkhCzASEiIARBQGsgIDgCACAEQTxqIB84AgAgBEE4aiAdOAIAIARBNGogISAilSIkIAEqAgwiIZQgASgCCEH/////B3EiDCAkvEGAgICAeHFyvpIiJDgCACAEQTBqICEgHCAilSIclCABKAIEQf////8HcSIKIBy8QYCAgIB4cXK+kiIcOAIAIARBLGogISAeICKVIh6UIAEoAgBB/////wdxIgkgHrxBgICAgHhxcr6SIh44AgAgBEEoaiAkICCTOAIAIARBJGogHCAfkzgCACAEQQA2ArwBIARBADYCHCAEIB4gHZM4AiAgICAdQwAAAACUIhwgH0MA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bCAPakEAIAsgAUsbIgEoAgBBAUcNDiABKAIEIAdBBGooAgBHDQ4gASgCiAIiB0UNASABKAKAAiEBIAdBA3QhDgNAIAAoAkQiByABKAIAIg1NDQMgACgCKCIHIAAoAjwgDUEEdGooAgAiFE0NBCAAKAIgIBRBB3RqIgctAHlFBEAgB0H5AGpBAToAACARKAIAIg1Bf2ohByATIA0gEygCACINIAAoAixrIAdxa0EBRgR/IBwQxAQgEygCACENIBEoAgBBf2oFIAcLIA1BAWpxNgIAIAwoAgAgDUECdGogFDYCAAsgAUEIaiEBIA5BeGoiDg0ACwwBCwsgBEEBaw4CAwIECyANIAdB8MXAABDNCAALIBQgB0GAxsAAEM0IAAsgACgCLCIBIABBMGoiHSgCACIHRg0DIAAqAkghLCAAQThqIRogAEE0aiEWA0AgACAaKAIAQX9qIAFBAWpxIgQ2AiwgFigCACABQQJ0aigCACIBIAAoAigiFUkEfyAAKAIgIRcgBkL////7////v383A+gCIAZC////+/f//79/NwPgAiAGQv////v3//+//wA3A9gCIAZC////+////79/NwPQAiAGQv////v3//+/fzcDyAIgBkL////79///v/8ANwPAAiAGQv////v///+/fzcDuAIgBkL////79///v383A7ACIAZC////+/f//7//ADcDqAIgBkL////7////v383A6ACIAZC////+/f//79/NwOYAiAGQv////v3//+//wA3A5ACIAFBB3QgF2oiG0EAIAEgFUkbIhFB4ABqIRIgAigCCCETIAIoAgAhCiADKAIIIRQgAygCACEPIAAoAjwhDCAAKAJEIQ0gBkGQAmohB0EAIQ4CQANAAkAgDiASaigCACEIAkAgES0AeEUEQCAIIBVPDQEgBkGQA2oiASAIQQd0IBdqEMoDIAdBEGogAUEQaikDADcCACAHQQhqIAFBCGopAwA3AgAgByAGKQOQAzcCAAwBCyAIIA1PDQAgFCAIQQR0IAxqIgEoAggiCE0NASAIQaABbCAPaiIJQQAgFCAISxsiCCgCAEEBRw0BIAFBDGooAgAiASAIKAIERw0BIAkoAgBBAUcNDyAJKAIEIAFHDQ8gCEHUAGohCyAJQRhqIRgCQCAIQSxqKAIAIgEEQCATIAhBMGpBACABQQFGGyIZKAIAIgFNDREgAUGgAmwgCmoiEEEAIBMgAUsbIggoAgBBAUcNESAZKAIEIgEgCCgCBEcNESAQKAIAQQFHDREgECgCBCABRw0RIBBBtAFqKgIAIScgEEG4AWoqAgAhKiAQQbwBaioCACEpIBBBoAFqKgIAISsgEEGUAWoqAgAhLSAQQYwBaioCACEjIBBB3AFqKgIAITAgEEGcAWoqAgAhLiAQQdQBaioCACExIBBBkAFqKgIAIS8gEEHYAWoqAgAhMiAQQZgBaioCACEkIBBBqAFqKgIAISYgEEHIAWoqAgAhIiAQQawBaioCACEhIBBBzAFqKgIAISggBiAQQdABaioCACAQQYgBaioCACIllCAFlCAQQbABaioCAJI4ApgDIAYgISAoICWUIAWUkjgClAMgBiAmICIgJZQgBZSSOAKQAyAGICkgKyAtIDGUIC4gMpSSICsgMJSSIiKUIC0gIyAxlCAvIDKUkiAtIDCUkiIhlCAuIC8gMZQgJCAylJIgLiAwlJIiKJSSkiAFlJI4AqQDIAYgKiAuICKUIC8gIZQgJCAolJKSIAWUkjgCoAMgBiAnIC0gIpQgIyAhlCAvICiUkpIgBZSSOAKcAyAGQYABaiAGQZADaiIJIAUgCEEYaiAQQdAAahCAAiAGIAYqAowBIicgGSoCFCImlCAGKgKAASIjIBkqAggiIpSTIAYqAoQBIiQgGSoCDCIhlJMgBioCiAEiJSAZKgIQIiiUkzgCnAMgBiAlICaUICMgIZQgJyAolJIgJCAilJOSOAKYAyAGICUgIpQgJCAmlCAnICGUICMgKJSTkpI4ApQDIAYgJCAolCAnICKUICMgJpSSkiAlICGUkzgCkAMgIyAZKgIcIiaUICQgGSoCGCIilJMiKCAokiEqICUgIpQgIyAZKgIgIiGUkyIoICiSISkgBiAGKgKYASAhICcgKpQgIyAplCAkICQgIZQgJSAmlJMiKCAokiIolJOSkpI4AqgDIAYgBioClAEgJiAnICmUICUgKJQgIyAqlJOSkpI4AqQDIAYgBioCkAEgIiAnICiUICQgKpQgJSAplJOSkpI4AqADIAZB8ABqIgggGEEEaigCACIBNgIEIAggGCgCACABKAIIQQdqQXhxajYCACAGQfgCaiAGKAJwIAsgCSAGKAJ0KAKwARECAAwBCyAGQfgAaiIIIBhBBGooAgAiATYCBCAIIBgoAgAgASgCCEEHakF4cWo2AgAgBkH4AmogBigCeCALIAYoAnwoAoABEQEACyAHIAYpA/gCNwIAIAdBEGogBkH4AmoiAUEQaikDADcCACAHQQhqIAFBCGopAwA3AgALIAdBGGohByAOQQRqIg5BEEcNAQwCCwsMDAsgBkGAAWoiByAGQZACakHgABDkBhogBkGQA2oiASAHEKMEIAcgGyABEIgDAkACQCAGLQCAAUUNACAGLQCBAUUNACAGLQCCAUUNACAGLQCDAUUNACAdKAIAIQcMAQsgGyAGQZADakHgABC/BCEBIAYgLDgCjAEgBiAsOAKIASAGICw4AoQBIAYgLDgCgAEgASAGQYABahCyAiABKAJwIQggGigCACIBQX9qIQcgASAdKAIAIgEgBGsgB3FrQQFGBEAgHBDEBCAaKAIAQX9qIQcgHSgCACEBCyAdIAFBAWogB3EiBzYCACAWKAIAIAFBAnRqIAg2AgALIBtBADoAeSAcKAIABSAECyIBIAdHDQALDAMLIAAoAiwiASAAQTBqIhgoAgAiB0YNAiAAKgJIISogAEE4aiEaIABBNGohFQNAIAAgGigCAEF/aiABQQFqcSIENgIsIBUoAgAgAUECdGooAgAiASAAKAIoIhdJBH8gACgCICETIAZC////+////79/NwPoAiAGQv////v3//+/fzcD4AIgBkL////79///v/8ANwPYAiAGQv////v///+/fzcD0AIgBkL////79///v383A8gCIAZC////+/f//7//ADcDwAIgBkL////7////v383A7gCIAZC////+/f//79/NwOwAiAGQv////v3//+//wA3A6gCIAZC////+////79/NwOgAiAGQv////v3//+/fzcDmAIgBkL////79///v/8ANwOQAiABQQd0IBNqIhtBACABIBdJGyISQeAAaiEKIAIoAgghFCACKAIAIQ8gAygCCCELIAMoAgAhDCAAKAI8IQ4gACgCRCENIAZBkAJqIQFBACEHAkADQAJAIAcgCmooAgAhCQJAIBItAHhFBEAgCSAXTw0BIAZBkANqIgggCUEHdCATahDKAyABQRBqIAhBEGopAwA3AgAgAUEIaiAIQQhqKQMANwIAIAEgBikDkAM3AgAMAQsgCSANTw0AIAsgCUEEdCAOaiII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vwQhCCAGICI4ApwCIAYgIjgCmAIgBiAiOAKUAiAGICI4ApACIAggBkGQAmoQsgIgCCgCcCEEIA4gDkF/aiIBIAcgAmtxa0EBRgRAIBwQxAQgDSgCACERIA8oAgAhByAJKAIAIg5Bf2ohAQsgB0ECdCARaiAENgIAIA8gB0EBaiABcSIHNgIAIAAoAiwhASAIQQA6AHkLIAEgB0cNAAsMAQsgACoCSCEoIABBxABqQQA2AgAgAEEoakEANgIAIAYgAEEIajYC7AEgA0EYaigCACIJQf////8DcSEAIAAgCUcNASAJQQJ0IgFBAEgNASAAIAlGQQJ0IQACQCABRQRAIAAiBw0BDAcLIAEgABDFCyIHRQ0GCyAGQQA2AvgBIAYgBzYC8AEgBiABQQJ2NgL0ASAJrUIYfiIeQiCIpyIADQEgHqciB0EASA0BIABFQQJ0IQACQCAHRQRAIAAiAQ0BDAYLIAcgABDFCyIBRQ0FCyAGQQA2AogCIAYgATYCgAIgBiAHQRhuIgA2AoQCIAAgCUkEQCAGQYACakEAIAkQggYgBigCiAIhDSAGKAKAAiEBCyANQRhsIAFqIQAgCUECTwRAIAlBf2oiB0EDcSEBIAlBfmpBA08EQEEAIAdBfHFrIQcDQCAAQv////v3//+//wA3AgAgAEHYAGpC////+////79/NwIAIABB0ABqQv////v3//+/fzcCACAAQcgAakL////79///v/8ANwIAIABBQGtC////+////79/NwIAIABBOGpC////+/f//79/NwIAIABBMGpC////+/f//7//ADcCACAAQShqQv////v///+/fzcCACAAQSBqQv////v3//+/fzcCACAAQRhqQv////v3//+//wA3AgAgAEEQakL////7////v383AgAgAEEIakL////79///v383AgAgAEHgAGohACAHQQRqIgcNAAsLIAEEQANAIABC////+/f//7//ADcCACAAQRBqQv////v///+/fzcCACAAQQhqQv////v3//+/fzcCACAAQRhqIQAgAUF/aiIBDQALCyAJIA1qQX9qIQ0LIAYiCCAJBH8gAEL////79///v383AgggAEL////79///v/8ANwIAIABBEGpC////+////79/NwIAIA1BAWoFIA0LNgKIAiAIQThqIgBBADoABCAAQX82AgAg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QQFGGyISKAIAIgBNDQkgAEGgAmwgBGoiC0EAIA4gAEsbIgMoAgBBAUcNCSASKAIEIgAgAygCBEcNCSALKAIAQQFHDQkgCygCBCAARw0JIAtBtAFqKgIAISUgC0G4AWoqAgAhJyALQbwBaioCACEqIAtBoAFqKgIAITIgC0GUAWoqAgAhLCALQYwBaioCACErIAtB3AFqKgIAIS8gC0GcAWoqAgAhLSALQdQBaioCACEwIAtBkAFqKgIAIS4gC0HYAWoqAgAhMSALQZgBaioCACEjIAtBqAFqKgIAISkgC0HIAWoqAgAhJiALQawBaioCACEiIAtBzAFqKgIAISEgBiALQdABaioCACALQYgBaioCACIklCAFlCALQbABaioCAJI4ApgDIAYgIiAhICSUIAWUkjgClAMgBiApICYgJJQgBZSSOAKQAyAGICogMiAsIDCUIC0gMZSSIDIgL5SSIiaUICwgKyAwlCAuIDGUkiAsIC+UkiIilCAtIC4gMJQgIyAxlJIgLSAvlJIiIZSSkiAFlJI4AqQDIAYgJyAtICaUIC4gIpQgIyAhlJKSIAWUkjgCoAMgBiAlICwgJpQgKyAilCAuICGUkpIgBZSSOAKcAyAGQYABaiAGQZADaiAFIANBGGogC0HQAGoQgAIgBiAGKgKMASIlIBIqAhQiKZQgBioCgAEiKyASKgIIIiaUkyAGKgKEASIjIBIqAgwiIpSTIAYqAogBIiQgEioCECIhlJM4ApwCIAYgJCAplCArICKUICUgIZSSICMgJpSTkjgCmAIgBiAkICaUICMgKZQgJSAilCArICGUk5KSOAKUAiAGICMgIZQgJSAmlCArICmUkpIgJCAilJM4ApACICsgEioCHCIplCAjIBIqAhgiJpSTIiEgIZIhJyAkICaUICsgEioCICIilJMiISAhkiEqIAYgBioCmAEgIiAlICeUICsgKpQgIyAjICKUICQgKZSTIiEgIZIiIZSTkpKSOAKoAiAGIAYqApQBICkgJSAqlCAkICGUICsgJ5STkpKSOAKkAiAGIAYqApABICYgJSAhlCAjICeUICQgKpSTkpKSOAKgAiAGQShqIgMgCkEEaigCACIANgIEIAMgCigCACAAKAIIQQdqQXhxajYCACARIAYoAiggB0HMAGogBkGQAmogBigCLCgCsAERAgAFIAZBMGoiAyAKQQRqKAIAIgA2AgQgAyAKKAIAIAAoAghBB2pBeHFqNgIAIBEgBigCMCAHQcwAaiAGKAI0KAKAAREBAAsgBiANNgKUAyAGIA82ApADIAZB+AJqIA8gDSAREOgBIAIhAAwACwALIAZBkAJqEMMIIAZBCGoiAEEAOgAEIABBfzYCACAGLQAMIQEgBigCCCEAIAYoAuwBIgNBIGooAgAiByADQRxqKAIARgRAIANBGGogBxCSBiADKAIgIQcLIAMoAhggB0EHdGogBkGQAmpB4AAQ5AYiAkEAOwF4IAJB9ABqIAE6AAAgAiAANgJwIAJB6ABqQn83AwAgAkKBgICAcDcDYCADIAdBAWo2AiAgBkEAOgAEIAZBADYCACAGQZADaiIBIAYoAuwBIAYoAvABIAYoAvgBIAYoAoACIAYoAogCIAYoAgAgBi0ABCAoEFkgBkH4AmoiAEEQaiAGQaQDaikCACIfNwMAIABBCGogBkGcA2opAgAiIDcDACAGIAYpApQDIh43A/gCIAYoAuwBIgAgHjcCACAAQQhqICA3AgAgAEEQaiAfNwIAIAZBgAFqIgBBEGogHzcDACAAQQhqICA3AwAgBkHYAWpC////+////79/NwMAIAZB0AFqQv////v3//+/fzcDACAGQcABakL////7////v383AwAgBkG4AWpC////+/f//79/NwMAIAZBqAFqQv////v///+/fzcDACAAQSBqQv////v3//+/fzcDACAGIB43A4ABIAZC////+/f//7//ADcDyAEgBkL////79///v/8ANwOwASAGQv////v3//+//wA3A5gBIAEgABCjBCAGKALsASIAQSBqKAIARQ0CIAAoAhggBkGQA2pB4AAQ5AYaAkAgBigChAIiAUUNACAGKAKAAiIARQ0AIAFBGGxFDQAgABDhAQsgBigC9AEiAUUNACAGKALwASIARQ0AIAFBAnRFDQAgABDhAQsgBkHwA2okAA8LEJEMAAtBAEEAQYDHwAAQzQgACyAJIABBoJ3DACgCACIAQa8GIAAbEQAAAAsgByAAQaCdwwAoAgAiAEGvBiAAGxEAAAALIAEgAEGgncMAKAIAIgBBrwYgABsRAAAAC0Gkv8AAQStBlObAABDbCQALn0EDGn8GfgF9IwBB4AJrIgIkAAJAAkAgACIYAn8gASgCBCIARQRAIBhBADYCBEEADAELIAEgAEF/ajYCBAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABKAIAIgEoAgQiAEEETwRAIAEgAEF8aiIENgIEIAEgASgCACIDQQRqIgU2AgACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMoAAAiBg4TAQIDBAUGBwgJCgsMDQ4PEBESEwALIAJBAToAkAEgAiAGrTcDmAEgAkGQAWpB6IvAAEHshcAAEN4FIQAMJQsCfiAEQQRPBEAgASAAQXhqNgIEIAEgA0EIajYCACADNQAEQiCGDAELEIgLrUIghkIBhAsiHEIgiKchAyAcpwRAIAMhAAwlC0EAIQBCACEcDBQLIAJBkAFqIAEQmANBASEAIAIoApQBIQMgAigCkAFBAUcEQCACQZwBaigCACEFIAJBmAFqKgIAISIMFAsgAyEADCMLIAJBkAFqIAEQmAMgAigClAEhACACKAKQAUEBRg0iIAJBnAFqKAIAIQUgAkGYAWoiAyoCACEiIAJBkAFqIAEQmAMgAigClAEhBCACKAKQAUEBRgRAIAQhAAwjCyADKQMAIRwCfiABKAIEIgNBBE8EQCABIANBfGo2AgQgASABKAIAIgNBBGo2AgAgAzUAAEIghgwBCxCIC61CIIZCAYQLIh1CIIinIQYgHacEQCAGIQAMIwsgHEIgiKchDEIAIR0gACEDQQIhAAwSCyACQZABaiABEJgDIAIoApQBIQAgAigCkAFBAUYNISACQZwBaigCACEFIAJBmAFqIgMqAgAhIiACQZABaiABEJgDIAIoApQBIQQgAigCkAFBAUYEQCAEIQAMIgsgAykDACIcQiCIpyEMIAAhA0EDIQAMEQsgAkGQAWogARCYAyACKAKUASEAIAIoApABQQFGDSAgAkGcAWooAgAhBSACQZgBaiIDKgIAISIgAkGQAWogARCYAyACKAKUASEEIAIoApABQQFGBEAgBCEADCELIAMpAwAhHCACQZABaiABEJgDIAIoApQBIQYgAigCkAFBAUYEQCAGIQAMIQsgHEIgiKchDCACQZgBaikDACIdQiCIpyEPIAAhA0EEIQAMEAsgAkEDNgLMAiACIAE2AsgCIAJBkAFqIAJByAJqEGIgAigCkAFBAUYNESACQawBaigCACIARQRAQQBBwIbAAEHshcAAEM0FIQAMIAsgAkGYAmogAkGkAWopAgA3AwAgAkGQAmogAkGcAWopAgA3AwAgAkGkAmogAkGwAWopAwA3AgAgAkGsAmogAkG4AWopAwA3AgAgAkG0AmogAkHAAWopAwA3AgAgAkG8AmogAkHIAWopAwA3AgAgAkHEAmogAkHQAWooAgA2AgAgAiACKQKUATcDiAIgAiAANgKgAiACQZABaiACQcgCahCbBAJAIAIoApABQQFHBEAgAigClAEiCEUEQEEBQcCGwABB7IXAABDNBSEADCELIAJBmAFqKQMAIR4gAigCzAIEQCACKALIAiIBKAIEIgBBB00EQBCICyEADCELIAEgAEF4aiIFNgIEIAEgASgCACIAQQhqNgIAIAApAAAQpgYiHEIgiKchACAcpw0gIABBgCAgAEGAIEkbIgRBDGwhAwJAIARFBEBBBCEHDAELIANBBBDFCyIHRQ0mC0EAIQQgAkEANgKYASACIAc2ApABIAIgA0H//wNxQQxuNgKUASAABEADQAJAAkAgBUEESQ0AIAEgBUF8aiIGNgIEIAEgASgCACIDQQRqNgIAIAZBBEkNACADKAAAIQkgASAGQXxqIgY2AgQgASADQQhqNgIAIAZBA0sNAQsQiAshACACKAKUASIBRQ0jIAIoApABIgNFDSMgAUEMbEUNIyADEOEBDCMLIABBf2ohACADNQAEIRwgASAGQXxqIgU2AgQgASADQQxqNgIAIAM1AAhCIIYgHIQhHCACKAKUASAERgRAIAJBkAFqIARBARD9BSACKAKQASEHIAIoApgBIQQLIARBDGwgB2oiAyAcNwIEIAMgCTYCACACIARBAWoiBDYCmAEgAA0ACyACKAKQASEHCyAHDQILQQJBwIbAAEHshcAAEM0FIQAMHwsgAigClAEhAAwfCyACKQKUASIfQiCIpyESIB5CIIinIQ0gAikCrAIiIEIgiKchCSACKQKkAiIdQiCIpyEPIAJBuAJqKQMAIiFCIIinIQsgAkGYAmopAwAiHEIgiKchDCACQcQCaigCACEKIAJBwAJqKAIAIRMgAkG0AmooAgAhFCACKAKgAiEGIAIoApQCIQQgAigCkAIhBSACKgKMAiEiIAIoAogCIQMgH6chFiAepyEVICCnIQ4gIachEEEFIQAMDwsgAkEDNgLMAiACIAE2AsgCIAJBkAFqIAJByAJqEGIgAigCkAFBAUYNESACQawBaigCACIARQRAQQBBxIfAAEHshcAAEM0FIQAMHwsgAkGYAmogAkGkAWopAgA3AwAgAkGQAmogAkGcAWopAgA3AwAgAkGkAmogAkGwAWopAwA3AgAgAkGsAmogAkG4AWopAwA3AgAgAkG0AmogAkHAAWopAwA3AgAgAkG8AmogAkHIAWopAwA3AgAgAkHEAmogAkHQAWooAgA2AgAgAiACKQKUATcDiAIgAiAANgKgAiACQZABaiACQcgCahCbBAJAIAIoApABQQFHBEAgAigClAEiCEUEQEEBQcSHwABB7IXAABDNBSEADB4LIAJBmAFqKQMAIR4gAigCzAIEQCACKALIAiIBKAIEIgBBB00EQBCICyEADB4LIAEgAEF4aiIFNgIEIAEgASgCACIAQQhqNgIAIAApAAAQpgYiHEIgiKchACAcpw0dAkAgAEGAICAAQYAgSRsiBEUEQEEEIQcMAQsgBEEDdCIDQQQQxQsiB0UNJQtBACEDIAJBADYCmAEgAiAENgKUASACIAc2ApABIAAEQANAAkAgBUEETwRAIAEgBUF8aiIGNgIEIAEgASgCACIEQQRqNgIAIAZBA0sNAQsQiAshACACKAKUASIBRQ0gIAIoApABIgNFDSAgAUEDdEUNICADEOEBDCALIABBf2ohACAENQAAIRwgASAGQXxqIgU2AgQgASAEQQhqNgIAIAQ1AARCIIYgHIQhHCACKAKUASADRgRAIAJBkAFqIANBARCPBiACKAKQASEHIAIoApgBIQMLIANBA3QgB2ogHDcCACACIANBAWoiAzYCmAEgAA0ACyACKAKQASEHCyAHDQILQQJBxIfAAEHshcAAEM0FIQAMHAsgAigClAEhAAwcCyACKQKUASIfQiCIpyESIB5CIIinIQ0gAikCrAIiIEIgiKchCSACKQKkAiIdQiCIpyEPIAJBuAJqKQMAIiFCIIinIQsgAkGYAmopAwAiHEIgiKchDCACQcQCaigCACEKIAJBwAJqKAIAIRMgAkG0AmooAgAhFCACKAKgAiEGIAIoApQCIQQgAigCkAIhBSACKgKMAiEiIAIoAogCIQMgH6chFiAepyEVICCnIQ4gIachEEEGIQAMDgsgAkGQAWogARCYAyACKAKU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IQggA0EBaiEDIARBBGohBCAsQgF8IixCBFINAAsgCUHgBWoiAkEIaiAJQcAHaiIDQQhqKQMANwMAIAJBEGogA0EQaikDADcDACACQRhqIANBGGopAwA3AwAgAkEgaiADQSBqKQMANwMAIAJBKGogA0EoaikDADcDACACQTBqIANBMGopAwA3AwAgAkE4aiADQThqKAIANgIAIAkgCSkDwAc3A+AFIAkoArwHIQUgCSoCtAchMyAJKgKwByEwIAkqAqwHITEgCSoCqAchLyAJQaAFaiICQQhqIAxBCGopAAA3AwAgAkEQaiAMQRBqKQAANwMAIAJBGGogDEEYaikAADcDACACQSBqIAxBIGopAAA3AwAgAkEoaiAMQShqKQAANwMAIAJBMGogDEEwaikAADcDACACQTdqIAxBN2opAAA3AAAgCUHgBGoiAkEIaiAOQQhqKQAANwMAIAJBEGogDkEQaikAADcDACACQRhqIA5BGGopAAA3AwAgAkEgaiAOQSBqKQAANwMAIAJBKGogDkEoaikAADcDACACQTBqIA5BMGopAAA3AwAgAkE3aiAOQTdqKQAANwAAIAkgDCkAADcDoAUgCSAOKQAANwPgBCAJLQD8ByECIAktALwIIQMgCS0A/AghBCAJQaAEaiIIQTdqIA1BN2opAAA3AAAgCEEwaiANQTBqKQAANwMAIAhBKGogDUEoaikAADcDACAIQSBqIA1BIGopAAA3AwAgCEEYaiANQRhqKQAANwMAIAhBEGogDUEQaikAADcDACAIQQhqIA1BCGopAAA3AwAgCSANKQAANwOgBCAJLQC8CSEIIAlBkgRqIBVBAmotAAA6AAAgCSAVLwAAOwGQBAsgCUHAB2oiCkE4aiAJQeAFaiILQThqKAIANgIAIApBMGogC0EwaikDADcDACAKQShqIAtBKGopAwA3AwAgCkEgaiALQSBqKQMANwMAIApBGGogC0EYaikDADcDACAKQRBqIAtBEGopAwA3AwAgCkEIaiALQQhqKQMANwMAIAkgCSkD4AU3A8AHIAkgAjoA/AcgDCAJKQOgBTcAACAMQQhqIAlBoAVqIgJBCGopAwA3AAAgDEEQaiACQRBqKQMANwAAIAxBGGogAkEYaikDADcAACAMQSBqIAJBIGopAwA3AAAgDEEoaiACQShqKQMANwAAIAxBMGog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AwAgBEEQaiAMQRBqKQIANwMAIARBGGogDEEYaikCADcDACAEQSBqIAxBIGopAgA3AwAgBEEoaiAMQShqKQIANwMAIAlB3ghqIA1BAmotAAA6AAAgCSAMKQIANwPgCCAJIA0vAAA7AdwIIAkqAqAHIgggKF0hFCAIIVkLQQQhBkEAISFDAAAAACErQwAAAAAhKkEAIQdBBCEEAkAgJUIEg1ANACAdRQ0AIB0oAgAhIiAJKALcByIEQdABaigCACAJQQQ6ANQHIAQoAswBIQQoAgwhByAJIAlB3AdqNgL0ByAJIAlBoAdqNgLwByAEICIgCUHwB2pB9O7BACAHEQIAIAktANQHIgRBBEYEQEEAIQcMAQsgCUGoCGoiB0EIaiALKQIANwMAIAdBEGogDEEQaikCADcDACAHQRhqIAxBGGopAgA3AwAgB0EgaiAMQSBqKQIANwMAIAdBKGogDEEoaikCADcDACAJQaYIaiANQQJqLQAAOgAAIAkgDCkCADcDqAggCSANLwAAOwGkCCAJKgKgByIqIChdIQcgKiFaCwJAICVCCINQDQAgHEUNACAcKAIAISMgCSgC3AciBkHQAWooAgAgCUEEOgDUByAGKALMASEGKAIMIQogCSAJQdwHajYC9AcgCSAJQaAHajYC8AcgBiAjIAlB8AdqQfTuwQAgChECACAJLQDUByIGQQRGDQAgCUHwB2oiCkEIaiALKQIANwMAIApBEGogDEEQaikCADcDACAKQRhqIAxBGGopAgA3AwAgCkEgaiAMQSBqKQIANwMAIApBKGogDEEoaikCADcDACAJQe4HaiANQQJqLQAAOgAAIAkgDCkCADcD8AcgCSANLwAAOwHsByAJKgKgByIrIChdISEgKyFbCyAJQYAFaiILQShqIAlBoAlqIgpBKGopAwA3AwAgC0EgaiAKQSBqKQMANwMAIAtBGGogCkEYaikDADcDACALQRBqIApBEGopAwA3AwAgC0EIaiAKQQhqKQMANwMAIAlByARqIgtBCGogCUHgCGoiCkEIaikDADcDACALQRBqIApBEGopAwA3AwAgC0EYaiAKQRhqKQMANwMAIAtBIGogCkEgaikDADcDACALQShqIApBKGopAwA3AwAgCSAJKQOgCTcDgAUgCSAJKQPgCDcDyAQgCUGQBGoiC0EoaiAJQagIaiIKQShq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IQNBqrLBAC0AACERQauywQAtAAAhFSAEIQIDQAJAIAMoAgAiFkH/////B3EiDkH/////B0YNACAMIA5NDQkgDkEFdiIOIA1PDQkgB0UNCSARIBUgDkECdCAHaigCACAWdkEBcRtB/wFxDQAgAiEEDAMLIANBCGohAyAFIAJBAWoiAksNAAsgBSAEQQFqIgIgBSACSxshBAsgCiEDDAQLIAtBf2ohCyAKQQFqIgMgCkkhAiADIQogBSAEQQFqIgRLDQALDAILIAMgB0GIncEAEM0IAAsgAiAPQaSgwQAQzQgACyADRQRAQQAhAwwBCyAEIANrQQN0IBJqIARBA3QgEmogBSAEa0EDdBC/BBoLIBAgBSADazYCACAJQTBqIhAoAgAhBSAQQQA2AgACQCAFRQ0AIAlBKGooAgAiEkEEaiEOQQEhA0EAIQtBACEKQQAhBANAAkACQAJAIANBAXFFBEAgBEEDdCASaiEDIAQgC2pBA3QgEmohAgNAIANBBGooAgAiE0H/////B3EiBkH/////B0cEQCAMIAZNDQggBkEFdiIGIA1PDQggB0UNCEGqssEAQauywQAgBkECdCAHaigCACATdkEBcRstAABFDQQLIAIgAykCADcCACADQQhqIQMgAkEIaiECIAUgBEEBaiIESw0ACwwBCyAEQQN0IA5qIQNBqrLBAC0AACETQauywQAtAAAhESAEIQIDQAJAIAMoAgAiFUH/////B3EiBkH/////B0YNACAMIAZNDQcgBkEFdiIGIA1PDQcgB0UNByATIBEgBkECdCAHaigCACAVdkEBcRtB/wFxDQAgAiEEDAMLIANBCGohAyAFIAJBAWoiAksNAAsgBSAEQQFqIgIgBSACSxshBAsgCiEGDAELIAtBf2ohCyAKQQFqIgYgCkkhAyAGIQogBSAEQQFqIgRLDQELCyAGRQRAQQAhBgwBCyAEIAZrQQN0IBJqIARBA3QgEmogBSAEa0EDdBC/BBoLIBAgBSAGazYCACAJQdAAaiISKAIAIQVBACEDIBJBADYCAAJAIAVFDQAgCUHIAGooAgAiC0EEaiEOQQEhAkEAIQpBACEGQQAhBANAAkACQAJAIAJBAXFFBEAgBEEDdCALaiEDIAQgCmpBA3QgC2ohAgNAIANBBGooAgAiE0H/////B3EiEEH/////B0cEQCAMIBBN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EZQgDyASlCAYIBOUkpKTIBAgAEG0AWoqAgAiH5QgFSAAQbgBaioCACIglJIgFCAAQbwBaioCACIhlJKSkpSTIgtDAAAAACALQwAAAABgGyELIAMgCzgCACAUICEgCyAOkyILlJIhFCAVICAgC5SSIRUgECAfIAuUkiEQIAwgHiALlJIhDCAXIBwgC5SSIRcgGSAdIAuUkiEZIBEgDSALICOUIg6UkiERIBIgDyAOlJIhEiATIBggDpSSIRMgGiANICIgC5QiC5SSIRogFiAPIAuUkiEWIBsgGCALlJIhGyAAQZQCaiAFRg0FIABBsAJqIgMqAgAiDiAAQbQCaioCACAAQawCaioCACANIBqUIA8gFpQgGCAblJKSIBkgACoClAIiHZQgFyAAQZgCaioCACIclJIgDCAAQZwCaioCACIelJKSIA0gEZQgDyASlCAYIBOUkpKTIBAgAEGgAmoqAgAiH5QgFSAAQaQCaioCACIglJIgFCAAQagCaioCACIhlJKSkpSTIgtDAAAAACALQwAAAABgGyELIAMgCzgCACAUICEgCyAOkyILlJIhFCAVICAgC5SSIRUgECAfIAuUkiEQIAwgHiALlJIhDCAXIBwgC5SSIRcgGSAdIAuUkiEZIBEgDSALICOUIg6UkiERIBIgDyAOlJIhEiATIBggDpSSIRMgGiANICIgC5QiC5SSIRogFiAPIAuUkiEWIBsgGCALlJIhGyAAQYADaiAFRg0FIABBnANqIgMqAgAiDiAAQaADaioCACAAQZgDaioCACANIBqUIA8gFpQgGCAblJKSIBkgACoCgAMiHZQgFyAAQYQDaioCACIclJIgDCAAQYgDaioCACIelJKSIA0gEZQgDyASlCAYIBOUkpKTIBAgAEGMA2oqAgAiH5QgFSAAQZADaioCACIglJIgFCAAQZQDaioCACIhlJKSkpSTIgtDAAAAACALQwAAAABgGyELIAMgCzgCACAUICEgCyAOkyILlJIhFCAVICAgC5SSIRUgECAfIAuUkiEQIAwgHiALlJIhDCAXIBwgC5SSIRcgGSAdIAuUkiEZIBEgDSALICOUIg6UkiERIBIgDyAOlJIhEiATIBggDpSSIRMgGiANICIgC5QiDZSSIRogFiAPIA2UkiEWIBsgGCANlJIhGwwFCyAFQQRBkJHBABDPCAALIAMgAkGAkcEAEM0IAAsgBCACQbyOwQAQzQgACyAFQQRB3I7BABDPCAALIAYgAkHMjsEAEM0IAAsgACgCMCEECyAEIAJJBEAgBEEYbCABaiIDIBk4AgwgAyAaOAIIIAMgFjgCBCADIBs4AgAgA0EUaiAMOAIAIANBEGogFzgCACAAKAI0IgMgAkkNAyADIAJB/I7BABDNCAALIAQgAkHsjsEAEM0IAAsgBygCACEDCyADIAJJDQAgAyACQaCRwQAQzQgACyADQRhsIAFqIgAgEDgCDCAAIBE4AgggACASOAIEIAAgEzgCACAAQRRqIBQ4AgAgAEEQaiAVOAIAC6EfAwh/AX4mfSMAQYACayIHJAACQAJAIAZFBEAgBSAAQ54Gfz9DbxKDOhDHAkUNAQwCCyAFIAFDngZ/P0NvEoM6EMcCDQELIABBGGoqAgAhLyAAQRRqKgIAITAgAEEQaioCACEmIANBIGoqAgAhGyADQRxqKgIAIRYgA0EYaioCACEUIANBFGoqAgAhJyADQRBqKgIAISAgA0EMaioCACEeIANBCGoqAgAhGiADQQRqKgIAIR8gAEEIaioCACEXIABBBGoqAgAhGCAAQQxqKgIAIRwgAyoCACEdIAAqAgAhGUP//3//ISEDQCACIAlqKgIAITEgB0EQaiIIQQhqIgpBADYCACAHQgA3AxAgCCAJaiIOQYCAgPx7NgIAIBsgHCAZIAcqAhQiKpQgGCAHKgIQIiWUkyIQIBCSIhWUIBggGCAKKgIAIiiUIBcgKpSTIhAgEJIiE5QgGSAXICWUIBkgKJSTIhAgEJIiEJSTkiAokyIRlCAUIBwgE5QgFyAQlCAYIBWUk5IgJZMiEpQgFiAcIBCUIBkgFZQgFyATlJOSICqTIhCUkpIhMiAHQZABaiAJaiEMIAchCCAvIRMCfSAaIBGUIB0gEpQgHyAQlJKSIiQgJyARlCAeIBKUICAgEJSSkiIVXkUEQCAWIRIgGyERIBQgFSAyXkUNARogICESICchESAeDAELIB8hEiAaIREgHSAkIDJeDQAaIBYhEiAbIREgFAshECAIIBMgESAcIBkgEpQgGCAQlJMiFSAVkiIklCAZIBcgEJQgGSARlJMiFSAVkiIVlCAYIBggEZQgFyASlJMiESARkiIRlJOSkpI4ApgBIAggMCASIBwgFZQgFyARlCAZICSUk5KSkjgClAEgCCAmIBAgHCARlCAYICSUIBcgFZSTkpKSOAKQASAMKgIAjCAxkyIQICFeBEAgECEhICghKSAqISMgJSEiCyAKQQA2AgAgCEIANwMQIA5BgICA/AM2AgAgGyAcIBkgCCoCFCIqlCAYIAgqAhAiJZSTIhAgEJIiJJQgGCAYIAoqAgAiKJQgFyAqlJMiECAQkiIVlCAZIBcgJZQgGSAolJMiECAQkiIQlJOSICiTIhGUIBQgHCAVlCAXIBCUIBggJJSTkiAlkyISlCAWIBwgEJQgGSAklCAXIBWUk5IgKpMiEJSSkiEkAn0gGiARlCAdIBKUIB8gEJSSkiIVICcgEZQgHiASlCAgIBCUkpIiE15FBEAgFiESIBshESAUIBMgJF5FDQEaICAhEiAnIREgHgwBCyAfIRIgGiERIB0gFSAkXg0AGiAWIRIgGyERIBQLIRAgByAvIBEgHCAZIBKUIBggEJSTIhMgE5IiFZQgGSAXIBCUIBkgEZSTIhMgE5IiE5QgGCAYIBGUIBcgEpSTIhEgEZIiEZSTkpKSOAKYASAHIDAgEiAcIBOUIBcgEZQgGSAVlJOSkpI4ApQBIAcgJiAQIBwgEZQgGCAVlCAXIBOUk5KSkjgCkAEgDCoCACAxkyIQICFeBEAgECEhICghKSAqISMgJSEiCyAJQQRqIglBDEcNAAsCQCAhIAReRQRAIAdBGGogA0EIaigCADYCACAHIAMpAgA3AxAgBwJ/QQAgHiAdkyIoIBYgH5MiE5QgICAfkyIQIBQgHZMiEZSTIiUgJZQgECAbIBqTIhKUICcgGpMiECATlJMiEyATlCAQIBGUICggEpSTIhIgEpSSkkMAAAAAkiIQQwAAgCheRQ0AGiAHQZwBaiAlIBAQswEiEJU4AgAgB0GYAWogEiAQlTgCACAHIBMgEJU4ApQBQQELNgKQASAHIAdBEGogB0GQAWogAiABEOwCAkAgByoCACIxIAReRQRAIAJBCGoqAgAhKiACQQRqKgIAISUgAioCACEoQQAhCiAHQfgBakEANgIAIAdB6AFqQQA2AgAgB0GQAWoiCUHEAGpCADcCACAJQTRqQQA2AgAgB0GwAWpCADcDACAHQaABakEANgIAIAdB9AFqICYgHSAcIBggGpQgFyAflJMiECAQkiIylCAYIBkgH5QgGCAdlJMiECAQkiIklCAXIBcgHZQgGSAalJMiECAQkiIVlJOSkpIiKyAmIBQgHCAYIBuUIBcgFpSTIhAgEJIiHZQgGCAZIBaUIBggFJSTIhAgEJIiE5QgFyAXIBSUIBkgG5STIhAgEJIiFJSTkpKSIi2TIjM4AgAgB0HgAWogMCAfIBwgFZQgFyAylCAZICSUk5KSkiIsIDAgFiAcIBSUIBcgHZQgGSATlJOSkpIiLpMiNDgCACAHQdABaiAtICYgHiAcIBggJ5QgFyAglJMiECAQkiIRlCAYIBkgIJQgGCAelJMiECAQkiISlCAXIBcgHpQgGSAnlJMiECAQkiIQlJOSkpIiHpMiNTgCACAJQSxqIC4gMCAgIBwgEJQgFyARlCAZIBKUk5KSkiIWkyImOAIAIAlBHGogHiArkyIfOAIAIAdB7AFqIDOMOAIAIAdByAFqIDWMOAIAIAlBFGogH4w4AgAgByAvIBogHCAklCAZIBWUIBggMpSTkpKSIhUgLyAbIBwgE5QgGSAUlCAYIB2Uk5KSkiIakyIdOALkASAHQdwBaiAdjDgCACAHIBogLyAnIBwgEpQgGSAQlCAYIBGUk5KSkiIQkyIgOALAASAHQbgBaiAgjDgCACAHQQA2ApABIAcgFiAskyISOAKYASAHIDSMOALwASAHICaMOALMASAHIBKMOAKoASAHIBAgFZMiEzgCnAEgByATjCIbOAKUASAHQRBqIghBxABqIBBDAAAAAJQgFiAzlCAeIDSUk5I4AgAgB0HMAGogFkMAAAAAlCAeIB2UkiAQIDOUkzgCACAIQTRqIBAgNJQgHkMAAAAAlCAWIB2Uk5I4AgAgCEEsaiAaQwAAAACUIhQgLiA1lCAtICaUk5I4AgAgB0E0aiAuQwAAAACUIhEgLSAglJIgGiA1lJM4AgAgCEEcaiAaICaUIC1DAAAAAJQiECAuICCUk5I4AgAgCEEUaiAUIB8gLpQgEiAtlJOSOAIAIAhBDGogEyAtlCARkiAfIBqUkzgCACAHIBVDAAAAAJQiFiAsIDOUICsgNJSTkjgCUCAHICxDAAAAAJQiFCArIB2UkiAVIDOUkzgCSCAHIBUgNJQgK0MAAAAAlCIRICwgHZSTkjgCQCAHIBYgLCA1lCArICaUk5I4AjggByAUICsgIJSSIBUgNZSTOAIwIAcgFSAmlCARICwgIJSTkjgCKCAHIBYgLCAflCArIBKUk5I4AiAgByAUICsgE5SSIBUgH5STOAIYIAcgEiAalCAQIBMgLpSTkjgCFCAHIBUgEpQgESAsIBOUk5I4AhBD//9//yEQQwAAAAAhFgNAAkAgCSoCACIeIB6UIAlBBGoiDCoCACITIBOUkiAJQQhqIg4qAgAiFCAUlJJDAAAAAJIiEUMAAAA0XkUNACAHQRBqIApqIggqAgAiHyAIQQRqKgIAIh1eIQggKLxB/////wdxIB68QYCAgIB4cXK+IAkqAgAiJ5QgJbxB/////wdxIBO8QYCAgIB4cXK+IAwqAgAiIJSSICq8Qf////8HcSAUvEGAgICAeHFyviAOKgIAIh6UkiARkSIalSERIB8gHSAIG4wgGpUgEZMiFCAdIB8gCBsgGpUgEZMiESAQXgRAICcgGpUhFiAeIBqVIRIgICAalSEbIBEhEAsgEF5FDQAgHowgGpUhEiAgjCAalSEbICeMIBqVIRYgFCEQCyAJQQxqIQkgCkEIaiIKQcgARw0ACyAQIAReRQ0BCyAFQQA2AggMAwsCQCAxICFeRUVBACAxIBBeG0UEQCAQICFeRQ0BIBYhIiAbISMgEiEpDAELIABBDGoqAgAiFiAHKgIEIhQgAEEEaioCACIhlCAHQQhqKgIAIiMgACoCACITlJMiECAQkiIRlCATIBMgB0EMaioCACIilCAUIABBCGoqAgAiG5STIhAgEJIiEpQgISAjIBuUICIgIZSTIhAgEJIiEJSTkiAikyEpIBYgEpQgGyAQlCATIBGUk5IgI5MhIyAWIBCUICEgEZQgGyASlJOSIBSTISILIAFBDGoqAgAhGyABQQhqKgIAISEgAUEEaioCACETIAEqAgAhFCAHICI4ApABIAcgIzgClAEgByApOAKYASAHQRBqIAIgB0GQAWoiARDeASAHQegAaiICQSBqIANBIGooAgA2AgAgAkEYaiADQRhqKQIANwMAIAJBEGogA0EQaikCADcDACACQQhqIANBCGopAgA3AwAgByADKQIANwNoIAEgAhCrBgJAIAUoAggiCK1CNH4iD0IgiKciAQ0AIA+nIgtBAEgNACABRUECdCECIAUoAgAhAwJAIAtFBEAgAiIBDQEMBAsgCyACEMULIgFFDQMLIBsgIiATlCAjIBSUkyIQIBCSIhGUIBQgKSAUlCAiICGUkyIQIBCSIhKUIBMgIyAhlCApIBOUkyIQIBCSIhCUk5IgKZMhFiAbIBKUICEgEJQgFCARlJOSICOTIRQgGyAQlCATIBGUICEgEpSTkiAikyERIAEgAyALEOQGIQMgBUEANgIIIAAgIiAjICkgB0EQaiAHQZABaiAEIAUgBhAxAkAgBkUEQCAiIQQgIyEQICkhEiARISIgFCEjIBYhKQwBCyARIQQgFCEQIBYhEgsgBSAiOAIYIAUgBDgCDCAFQSBqICk4AgAgBUEcaiAjOAIAIAVBFGogEjgCACAFQRBqIBA4AgACQCAFKAIIIgJFDQAgCEUNACAIQTRsIgAgA2ohDCAFKAIAIgEgAkE0bGohDiADQSRqIQogA0E0aiECIABBTGoiCEE0bkEBcSEGA0AgAUEkaiENIAEoAhwhCQJ/IAMgBg0AGiACIAMoAhwgCUcNABogAiABKAIgIAMoAiBHDQAaIAopAgAhDyANQQhqIApBCGopAgA3AgAgDSAPNwIAIAILIQAgCEE0TwRAIABB2ABqIQUDQAJAIAUiAEFEaigCACAJRw0AIAEoAiAgAEFIaigCAEcNACAAQUxqIgUpAgAhDyANQQhqIAVBCGopAgA3AgAgDSAPNwIACwJAIABBeGooAgAgCUcNACABKAIgIABBfGooAgBHDQAgACkCACEPIA1BCGogAEEIaikCADcCACANIA83AgALIABB6ABqIQUgAEEQaiAMRw0ACwsgDiABQTRqIgFHDQALCyALQTRwIQAgC0E0SQ0DIAsgAGtFDQMgAxDhAQwDCxCRDAALIAVBADYCCAwBCyALIAJBoJ3DACgCACIAQa8GIAAbEQAAAAsgB0GAAmokAAuPIQMafwF+An0jAEEgayISJAACQAJAIANFDQAgAEEcaiIPQQA2AgAgBCgCCCEQAkACQAJAAkAgAUECTQRAIAQoAgAhCiADQQJ0IQwgAEEUaiELAkACQANAIBAgAigCACIDTQ0EIANBLGwgCmogAUECdGoiCUEMaioCACIhIAAqAgRfRQ0CIAlBGGoqAgAiIiAAKgIAYEUNASADQYCAgIB4ciEGIA4gAEEYaiIJKAIAIghGBEAgCyAOEIAGIA8oAgAhDiAJKAIAIQgLIANB/////wdxIQkgDyAOQQFqIgM2AgAgACgCFCIRIA5BDGxqIgdBADYCCCAHIAY2AgQgByAhOAIAIAMgCEYEQCALIAgQgAYgACgCFCERIA8oAgAhAwsgDyADQQFqIg42AgAgA0EMbCARaiIGQQA2AgggBiAJNgIEIAYgIjgCACACQQRqIQIgDEF8aiIMDQALIA5BFUkNBQJAIA5BAXatQgx+IiBCIIinIgINACAgpyIYQQBIDQAgAkVBAnQhAgJAIBhFBEAgAiIPDQEMCwsgGCACEMULIg9FDQoLIBJCADcCBCASQbzBwAAoAgAiFTYCACARQXRqIR4gEUFoaiEdIBFBXGohH0EAIQsgDiEKAkACQAJAA0AgCiEHQQAhCkEBIQYCQCAHQX9qIhBFDQACQEEAQX8gEEEMbCARaioCACIhIAdBfmoiCEEMbCARaioCACIiYCICG0EBQQIgAhsgISAiXxtBf0cEQCAHQX5qIQYgB0EMbCAfaiECQQAhAwNAIAMgBkYEQCAHIQYMBAsgIiACKgIAIiFgIQwgIiAhXyEJIAJBdGohAiADQQFqIQMgISEiQQBBfyAMG0EBQQIgDBsgCRtBf0cNAAsgA0EBaiEGIANBf3MgB2ohAwwBCyAHQQxsIg0gHWohDEECIQkDQAJAIAkhCiAMIQIgCCIDRQ0AICIgA0F/aiIIQQxsIBFqKgIAIiFgIRQgIiAhXyEGIAJBdGohDCAKQQFqIQkgISEiQQBBfyAUG0EBQQIgFBsgBhtBf0YNAQsLAkACQCAHIANPBEAgByAOSw0BIAcgA2siBkECSQ0DQQAhCSAGQQF2QQFGDQIgDSAdaiEIIApBAXZB/v///wdxIRYDQCASQRhqIhcgAkEIaiIUKAIANgIAIBIgAikCADcDECAIQRRqIg0oAgAhDCACIAhBDGoiCikCADcCACAUIAw2AgAgDSAXKAIANgIAIAogEikDEDcCACAXIAJBFGoiFCgCADYCACASIAJBDGoiDSkCADcDECAIQQhqIgwoAgAhCiANIAgpAgA3AgAgFCAKNgIAIAwgFygCADYCACAIIBIpAxA3AgAgAkEYaiECIAhBaGohCCAWIAlBAmoiCUcNAAsMAgsgAyAHQaDCwAAQ0AgACyAHIA5BoMLAABDPCAALIAZBAnFFDQAgA0EMbCARaiICIAlBDGxqIg0pAgAhICAJQX9zIAZqQQxsIAJqIghBCGoiDCgCACEKIA0gCCkCADcCACANQQhqIgkoAgAhAiAJIAo2AgAgDCACNgIAIAggIDcCAAsgA0UEQCADIQoMAQsgBkEJSwRAIAMhCgwBCwJAIAcgDk0EQCADQQxsIBFqIQgDQCAHIANBf2oiCkkNAgJAIAcgCmsiBkECSQ0AQQBBfyADQQxsIBFqIgIqAgAiIiAKQQxsIBFqIg0qAgAiIWAiCRtBAUECIAkbICIgIV8bQX9HDQAgDSkCBCEgIA1BCGogAkEIaigCADYCACANIAIpAgA3AgACQCAGQQNJDQAgECEMIAghCUEAQX8gDSoCGCIiICFgIg0bQQFBAiANGyAiICFfG0F/Rw0AA0ACQCAJQQhqIAlBFGooAgA2AgAgCSICIAJBDGoiCSkCADcCACAMQX9qIgwgA0YNAEEAQX8gAkEYaioCACIiICFgIg0bQQFBAiANGyAiICFfG0F/Rg0BCwsgAkEMaiECCyACICA3AgQgAiAhOAIACyAKRQ0DIAhBdGohCCAKIQMgBkEKSQ0ACwwCCyAHIANBf2oiCkkNACAHIA5BsMLAABDPCAALIAogB0GwwsAAENAIAAsgEigCBCALRgRAIBIgCxCQBiASKAIAIRUgEigCCCELCyALQQN0IBVqIgIgBjYCBCACIAo2AgAgEiALQQFqIgk2AggCQAJAIAkiC0ECSQ0AA0ACQAJAAkACQCAJIgtBf2oiCUEDdCAVaiIDKAIARQ0AIAtBA3QgFWoiBkF0aigCACIMIAMoAgQiAk0NACALQQNJBEBBAiELIApFDREMCAsgC0F9aiITQQN0IBVqKAIEIgMgAiAMak0NASALQQRJBEBBAyELIApFDREMCAsgBkFkaigCACADIAxqTQ0BDAULIAtBA0kNASADKAIEIQIgC0F9aiITQQN0IBVqKAIEIQMLIAMgAkkNAQsgC0F+aiETCyALIBNBAWoiAk0NAiALIBNNDQQgE0EDdCAVaiIbKAIEIhYgGygCAGoiBiACQQN0IBVqIhwoAgAiGkkNBSAGIA5LDQYgG0EEaiAaQQxsIBFqIgIgHCgCBCIZQQxsIgdqIQMgBkEMbCEQAkAgBiAaayIMIBlrIgggGUkEQCAPIAMgCEEMbCIGEOQGIQwgBiAMaiEHAkAgGUEBSA0AIAhBAUgNACAQIB5qIQYDQEEAQX8gB0F0aiINKgIAIiEgA0F0aiIQKgIAIiJgIggbQQFBAiAIGyAhICJfG0F/RiEXIAYgECANIBcbIggpAgA3AgAgBkEIaiAIQQhqKAIANgIAIAcgDSAXGyEHIAIgECADIBcbIgNPDQEgBkF0aiEGIAcgDEsNAAsLIAwhBiADIQIMAQsgByAPIAIgBxDkBiIGaiEHIBlBAUgNACAMIBlMDQAgECARaiENA0AgAiADIAZBAEF/IAMqAgAiISAGKgIAIiJgIgwbQQFBAiAMGyAhICJfGyIQQX9GIggbIgwpAgA3AgAgAkEIaiAMQQhqKAIANgIAIAJBDGohAiAQQX9HQQxsIAZqIgYgB08NASAIQQxsIANqIgMgDUkNAAsLIAIgBiAHIAZrIgIgAkEMcGsQ5AYaIBYgGWo2AgAgGyAaNgIAIBwgHEEIaiALIBNrQQN0QXBqEL8EGiASIAk2AghBASELIAlBAUsNAAsLIApFDQoMAQsLIAIgC0HAwsAAEM0IAAsgEyALQdDCwAAQzQgACyAaIAZB4MLAABDQCAALIAYgDkHgwsAAEM8IAAsQkQwAC0HgmcEAQThBmJrBABDbCQALQZiZwQBBOEHQmcEAENsJAAsgECACKAIAIgNNDQBBiODAAEEbQYiZwQAQ+woACyADIBBB+JjBABDNCAALAkAgEigCBCICRQ0AIAJBA3RFDQAgFRDhAQsgGEEMcCECIBhBDEkNASAYIAJrRQ0BIA8Q4QEMAQsgA0EBakECSQ0AIANBDGwgEWohCEEAIQwDQCADQQxsIQIgA0F/aiEDQQBBfyACIBFqIgIqAgAiIiACQXRqIgoqAgAiIWAiCRtBAUECIAkbICIgIV8bQX9GBEAgA0EMbCARaikCBCEgIApBCGogAkEIaigCADYCACAKIAIpAgA3AgACQCAOIANrQQNJDQAgDCEHIAghBkEAQX8gCioCGCIiICFgIgkbQQFBAiAJGyAiICFfG0F/Rw0AA0ACQCAGQQhqIAZBFGooAgA2AgAgBiICIAJBDGoiBikCADcCACAHQX9qIgdFDQBBAEF/IAJBGGoqAgAiIiAhYCIJG0EBQQIgCRsgIiAhXxtBf0YNAQsLIAJBDGohAgsgAiAgNwIEIAIgITgCAAsgDEEBaiEMIAhBdGohCCADDQALCwJAIABBHGooAgAiCyAAQRBqIggoAgAiCmoiCSAKTQRAIAkhBgwBCyAAQQxqKAIAIAoiBmsgC0kEQCAAQQhqIAogCxCPBiAAQRBqKAIAIQYLIAAoAgggBkEDdGohAyALQQJPBEAgC0F/aiIMQQdxIQIgC0F+akEHTwRAQQAgDEF4cWshBwNAIANC////+/f/////ADcCACADQThqQv////v3/////wA3AgAgA0EwakL////79/////8ANwIAIANBKGpC////+/f/////ADcCACADQSBqQv////v3/////wA3AgAgA0EYakL////79/////8ANwIAIANBEGpC////+/f/////ADcCACADQQhqQv////v3/////wA3AgAgA0FAayEDIAdBCGoiBw0ACwsgAgRAA0AgA0L////79/////8ANwIAIANBCGohAyACQX9qIgINAAsLIAYgC2pBf2ohBgsgCwRAIANC////+/f/////ADcCACAGQQFqIQYLIABBHGooAgAhCwsgCCAGNgIAIAAoAhQiDiALQQxsaiEMIAAoAgghFAJAAkACQCALBEAgCkF+aiEIIAlBfmohByAMIQkCQAJAA0ACQCAGIAhLBEAgCUF0aiEKIAdBA3QgFGohAyAIQQN0IBRqIQIDQCACKgIAIiEgCioCACIiXw0CIAYgB00NBCADQQRqIAJBBGooAgA2AgAgAyAhOAIAIANBeGohAyACQXhqIQIgB0F/aiEHIAYgCEF/aiIISw0ACwsgCCAGQaiawQAQzQgACyAGIAdNDQIgA0EEaiAJQXhqKAIANgIAIAMgIjgCACAJQXxqIAc2AgAgB0F/aiEHIA4gCiIJRw0ACyAGQX9qIRMMAwsgByAGQciawQAQzQgACyAHIAZBuJrBABDNCAALIAZBf2ohEyAGRQ0BCyAFRQ0CIABBHGpBADYCACAEKAIIIRYCQAJAAkAgAUEDTwRAIAtBDGwhAwNAIANFDQcgA0F0aiEDIA4oAgQhACAOQQxqIQ4gAEF/Sg0ACyAWIABB/////wdxIghLDQEMBQsgBCgCACENIBNBA3RBeGohCyABQQJ0IRADQCAOQXRqIQMDQCADQQxqIgAgDEYNByADQRBqIAAhAygCACIAQX9KDQALIBYgAEH/////B3EiCE0NBSATIANBCGooAgAiAEEBaiIPSQ0CIANBDGohDiAPIBNGDQAgAyoCACEhIAhBLGwgDWoiASAQakEYaioCACEiIAFBIGohCiABQRxqIQYgAUEY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vPDAABCiCQALAkAgDEUNACAMQRhsRQ0AIAIQ4QELAkAgBkEwaiIDKAIAIgcgC00NAAJAAkAgFSgCACIBIAtBBHQiAmooAggiBEF/RwRAIAZBMGohBQNAIAhB+AVqIBUgBBCQASAFKAIAIgcgC00NAiACIBUoAgAiAWooAggiBEF/Rw0ACwsgByALTQ0AIAtBBHQiAiABakEMaigCACIEQX9HBEAgBkEwaiEFA0AgCEH4BWogFSAEEJABIAUoAgAiByALTQ0CIAIgFSgCACIBakEMaigCACIEQX9HDQALCyAHIAtLDQEgCyAHEMsIAAsgCyAHQezowAAQzQgACyAGQTBqIAdBf2oiAjYCACACQQR0IAFqIgRBCGopAgAhHCALQQR0IAFqIgEgBCkCADcCACABQQhqIBw3AgAgAiALTQ0AIAEpAggiHEIgiKchByAGKAI0IQIgBigCPCIBIBynIgVLBEADQCAFQeQBbCACaiIEIAs2AtwBIAQoAtQBIgUgAUkNAAsLIAEgB00NAANAIAdB5AFsIAJqIgQgCzYC4AEgBCgC2AEiByABSQ0ACwsgAygCACALSyIBRQ0AIAYoAiggC0EEdGpBACABGyIBQQRqKAIAIQkgASgCACIDIAZBCGooAgAiBE8EQCAGQQhqAn8gA0EBaiIBIARNBEAgAQwBCyAGQQRqKAIAIAQiAmsgASACayIFSQRAIAYgBCAFEI8GIAZBCGooAgAhAgsgBigCACACQQN0aiEHIAVBAk8EQCADIARrIgpBB3EhASAEQX9zIANqQQdPBEBBACAKQXhxayEEA0AgB0L/////DzcCACAHQThqQv////8PNwIAIAdBMGpC/////w83AgAgB0EoakL/////DzcCACAHQSBqQv////8PNwIAIAdBGGpC/////w83AgAgB0EQakL/////DzcCACAHQQhqQv////8PNwIAIAdBQGshByAEQQhqIgQNAAsLIAEEQANAIAdC/////w83AgAgB0EIaiEHIAFBf2oiAQ0ACwsgAiAFakF/aiECCyACIAVFDQAaIAdC/////w83AgAgAkEBagsiBDYCAAsgBCADTQRAIAMgBEGc5MAAEM0IAAsgBigCACADQQN0aiIBIAs2AgQgASAJNgIACwJAIAgoApQEIgFFDQAgCCgCkAQiAkUNACABQQN0RQ0AIAIQ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ByEKDAQLIChCgICAgHCDQgKEISggCkGyAWovAQAhJyAKKAKgASEcIAooApABIR0gCigCjAEhHiAKKAKIASEfIAoqAoQBISsgCikCfCEpIAooAnghICAKKQJwISogCigCbCEhIAooAkwhIiAKKAIoISMgCigCJCEkIAlBOGogDCgCADYCACAJQShqIA0oAgA2AgAgCUHAAWoiDEEIaiAKQThqKQIANwMAIAxBEGogCkFAaykCADcDACAMQRhqIApByABqKAIANgIAIAlB4ABqIgxBGGogCkHoAGooAgA2AgAgEyAKQeAAaikCADcDACAMQQhqIApB2ABqKQIANwMAIAkgCSkDUDcDMCAJIAkpA0A3AyAgCSAKKQIwNwPAASAJIAopAlA3A2AgCUEYaiAKQZwBaigCADYCACAJIAopApQBNwMQIAkgCkGqAWopAQA3AcYCIAkgCikCpAE3A8ACIApBtAFqIQoMAQsgDygCACEHQQAhGiAJQRhqQQA2AgAgCUE4akEANgIAIAlBKGpBADYCACAJQgA3AxAgCUIANwPAAiAJQgA3AcYCIAlCADcDMCAJQgA3AyAgB0EAIAgbISNBACAHIAgbISRDAACAPyErQQAhFUEAIRtBACEiQQAhIUEAISBBACEfQQAhHkEAIR0gFyIHIRwLIAYoAggiDCAGQQRqKAIARgRAIAYgDBD7BSAGKAIIIQwLIAYoAgAgDEG0AWxqIg0gFTYCCCANIBo2AgQgDSAHNgIAIA0gCSkDMDcCDCANIAkpAyA3AhggDSAbNgIsIA0gIzYCKCANICQ2AiQgDUEUaiAJQThqKAIANgIAIA1BIGogCUEoaigCADYCACANQTBqIAkpA8ABNwIAIA1BOGogCUHAAWoiB0EIaikDADcCACANQUBrIAdBEGopAwA3AgAgDUHIAGogB0EYaigCADYCACANICI2AkwgDUGQAWogHTYCACANQYwBaiAeNgIAIA1BiAFqIB82AgAgDUGEAWogKzgCACANQfwAaiApNwIAIA1B+ABqICA2AgAgDUHwAGogKjcCACANICE2AmwgDUHoAGogCUHgAGoiB0EYaigCADYCACANQeAAaiATKQMANwIAIA1B2ABqIAdBCGopAwA3AgAgDUHQAGogCSkDYDcCACANQZQBaiAJKQMQNwIAIA1BnAFqIAlBGGooAgA2AgAgDUGgAWogHDYCACANQaoBaiAJKQHGAjcBACANQaQBaiAJKQPAAjcCACANQbIBaiAnOwEAIAYgDEEBaiIHNgIIDAILIAchCgwACwALIAcgC0F/aksEQCAGKAIAIAlBwAFqIAIgDygCABCdBiAWayEHIAhFBEAgACABIAlBwAFqQazLwAAgAyAEIAUgBxAgGiARIQcMAgsgCUHgAGoiDUEIaiIMIAFBCGopAgA3AwAgE0EIaiAZQQhqKAIANgIAIBMgGSkCADcCACAMIAwqAgAiK4w4AgAgCSABKQIANwNgIAkgCSoCYCIsjDgCYCAJIAkqAmQiLYw4AmQgCSAJKgJsIi4gLCAJKgJ0Ii+UIC0gCSoCcCIwlJMiMSAxkiIxlCAtIC0gCSoCeCIzlCArIC+UkyIyIDKSIjKUICwgKyAwlCAsIDOUkyI0IDSSIjSUk5IgM5M4AnggCSAuIDSUICwgMZQgKyAylJOSIC+TOAJ0IAkgLiAylCArIDSUIC0gMZSTkiAwkzgCcCAAIA0gAyAEIAlBwAFqQazLwAAgBSAHECAaIBEhBwwBCwsgC0F/aiAHQZjKwAAQzQgAC4EgAxF/BH4EfSMAQYABayIDJAACQAJAIAECfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQCABKAK8AQ4EFBMAAQILIANBQGsiBUEIaiABQShqKAIANgIAIAVBFGogAUHMAGooAgA2AgAgBUEgaiABQfAAaigCADYCACADIAEpAiA3A0AgAyABQcQAaiIEKQIANwJMIAMgAUHoAGoiAikCADcDWCADQQA2AnggA0IANwNwIANBGGoiBiAFIANB8ABqQQEQTiADQRBqIgsgBkEIaikDADcDACADIAMpAxg3AwggBkEUaigCACEFIANBMGoqAgAhFyADQTRqKgIAIRggAygCKA4DDA0OGQsgA0FAayIGQQhqIAFBKGooAgA2AgAgBkEUaiABQcwAaigCADYCACAGQSBqIAFB8ABqKAIANgIAIANB7ABqIAFBlAFqKAIANgIAIAMgASkCIDcDQCADIAFBxABqIgQpAgA3AkwgAyABQegAaiICKQIANwNYIAMgAUGMAWoiBSkCADcCZCADQQA2AnggA0IANwNwIANBGGoiCyAGIANB8ABqEEIgA0EQaiIMIAtBCGopAwA3AwAgAyADKQMYNwMIIAtBFGooAgAhBiADQTBqKgIAIRcgA0E0aioCACEZIAMoAigOAwECAx0LQZTiwQBBH0G04sEAENsJAAsgBkEETw0RIANBQGsiAkEgaiIEIAFBQGsiBSgCADYCACACQRhqIgsgAUE4aiIJKQIANwMAIAJBEGoiCiABQTBqIggpAgA3AwAgAkEIaiIHIAFBKGoiDSkCADcDACABQSBqIAZBJGxqIgJBIGoiDigCACEPIAJBGGoiECkCACETIAJBEGoiESkCACEUIAJBCGoiEikCACEVIAEpAiAhFiABIAIpAgA3AiAgDSAVNwIAIAggFDcCACAJIBM3AgAgBSAPNgIAIAMgFjcDQCACIAMpA0A3AgAgEiAHKQMANwIAIBEgCikDADcCACAQIAspAwA3AgAgDiAEKAIANgIAIAEoAgAhAiABIAZBAnQgAWoiBCgCADYCACAEIAI2AgAgAUGAgID8AzYCsAFBAAwaCyAGDgYYAgMEBQYBCyADQThqKgIAIRgCQAJAAn0CQAJAAkACQCAGDgQGAQIDAAtBrM3BAEEoQcTiwQAQ2wkACyAZIRoMAwsgBCECIBghGiAXDAELIAFBIGohAiAXIRogGAshFyAZIRgLIAIgBSkCADcCACACQSBqIAVBIGooAgA2AgAgAkEYaiAFQRhqKQIANwIAIAJBEGogBUEQaikCADcCACACQQhqIAVBCGopAgA3AgAgGiEZCyABIBc4ArABIAFBuAFqIBg4AgAgAUG0AWogGTgCAEECDBgLQazNwQBBKEHU4sEAENsJAAsgBCkCACETIAQgAikCADcCACADQUBrIgVBIGoiBiAEQSBqIgsoAgA2AgAgBUEYaiIJIARBGGoiCikCADcDACAFQRBqIgggBEEQaiIHKQIANwMAIAVBCGoiBSAEQQhqIgQpAgA3AwAgBCACQQhqIgQpAgA3AgAgByACQRBqIgcpAgA3AgAgCiACQRhqIgopAgA3AgAgCyACQSBqIgsoAgA2AgAgAyATNwNAIAIgAykDQDcCACALIAYoAgA2AgAgCiAJKQMANwIAIAcgCCkDADcCACAEIAUpAwA3AgAgAUEEaiEEIAFBCGoMBAsgBCkCACETIAQgBSkCADcCACADQUBrIgJBIGoiBiAEQSBqIgsoAgA2AgAgAkEYaiIJIARBGGoiCikCADcDACACQRBqIgggBEEQaiIHKQIANwMAIAJBCGoiAiAEQQhqIgQpAgA3AwAgBCAFQQhqIgQpAgA3AgAgByAFQRBqIgcpAgA3AgAgCiAFQRhqIgopAgA3AgAgCyAFQSBqIgsoAgA2AgAgAyATNwNAIAUgAykDQDcCACALIAYoAgA2AgAgCiAJKQMANwIAIAcgCCkDADcCACAEIAIpAwA3AgAgAUEEaiEEIAFBDGoMAwsgASkCICETIAEgAikCADcCICADQUBrIgRBIGoiBSABQUBrIgYoAgA2AgAgBEEYaiILIAFBOGoiCSkCADcDACAEQRBqIgogAUEwaiIIKQIANwMAIARBCGoiBCABQShqIgcpAgA3AwAgByACQQhqIgcpAgA3AgAgCCACQRBqIggpAgA3AgAgCSACQRhqIgkpAgA3AgAgBiACQSBqIgYoAgA2AgAgAyATNwNAIAIgAykDQDcCACAGIAUoAgA2AgAgCSALKQMANwIAIAggCikDADcCACAHIAQpAwA3AgAgAUEIaiECDBELIAEpAiAhEyABIAUpAgA3AiAgA0FAayICQSBqIgQgAUFAayIGKAIANgIAIAJBGGoiCyABQThqIgkpAgA3AwAgAkEQaiIKIAFBMGoiCCkCADcDACACQQhqIgIgAUEoaiIHKQIANwMAIAcgBUEIaiIHKQIANwIAIAggBUEQaiIIKQIANwIAIAkgBUEYaiIJKQIANwIAIAYgBUEgaiIGKAIANgIAIAMgEzcDQCAFIAMpA0A3AgAgBiAEKAIANgIAIAkgCykDADcCACAIIAopAwA3AgAgByACKQMANwIAIAFBDGohAgwQCyABKQIgIRMgASACKQIANwIgIANBQGsiBkEgaiILIAFBQGsiCCgCADYCACAGQRhqIgkgAUE4aiIHKQIANwMAIAZBEGoiCiABQTBqIg0pAgA3AwAgBkEIaiIGIAFBKGoiDikCADcDACAOIAJBCGoiDikCADcCACANIAJBEGoiDSkCADcCACAHIAJBGGoiBykCADcCACAIIAJBIGoiCCgCADYCACADIBM3A0AgAiADKQNANwIAIAggCygCADYCACAHIAkpAwA3AgAgDSAKKQMANwIAIA4gBikDADcCACABKAIIIQIgASABKAIANgIIIAEgAjYCACALIARBIGoiAigCADYCACAJIARBGGoiCCkCADcDACAKIARBEGoiBykCADcDACAGIARBCGoiDSkCADcDACAEKQIAIRMgBCAFKQIANwIAIA0gBUEIaiIEKQIANwIAIAcgBUEQaiIHKQIANwIAIAggBUEYaiIIKQIANwIAIAIgBUEgaiICKAIANgIAIAMgEzcDQCAFIAMpA0A3AgAgAiALKAIANgIAIAggCSkDADcCACAHIAopAwA3AgAgBCAGKQMANwIAIAFBBGohBCABQQxqCyECIBchGAwPCyAFQQRPDQggA0FAayICQSBqIgQgAUFAayIGKAIANgIAIAJBGGoiCSABQThqIgopAgA3AwAgAkEQaiIMIAFBMGoiCCkCADcDACACQQhqIgcgAUEoaiINKQIANwMAIAFBIGogBUEkbGoiAkEgaiIOKAIAIQ8gAkEYaiIQKQIAIRMgAkEQaiIRKQIAIRQgAkEIaiISKQIAIRUgASkCICEWIAEgAikCADcCICANIBU3AgAgCCAUNwIAIAogEzcCACAGIA82AgAgAyAWNwNAIAIgAykDQDcCACASIAcpAwA3AgAgESAMKQMANwIAIBAgCSkDADcCACAOIAQoAgA2AgAgASgCACECIAEgBUECdCABaiIEKAIANgIAIAQgAjYCACABQQA2ArwBIAFBgICA/AM2ArABDAwLIAUOAwECAwsLIANBOGooAgAhAiABIBc4ArABIAFBuAFqIAI2AgAgAUG0AWogGDgCAAwKCyABQQE2ArwBIAEgFzgCsAEgAUG0AWogGDgCAAwJCyABKQIgIRMgASACKQIANwIgIANBQGsiBEEgaiIFIAFBQGsiBigCADYCACAEQRhqIgkgAUE4aiIKKQIANwMAIARBEGoiDCABQTBqIggpAgA3AwAgBEEIaiIEIAFBKGoiBykCADcDACAHIAJBCGoiBykCADcCACAIIAJBEGoiCCkCADcCACAKIAJBGGoiCikCADcCACAGIAJBIGoiBigCADYCACADIBM3A0AgAiADKQNANwIAIAYgBSgCADYCACAKIAkpAwA3AgAgCCAMKQMANwIAIAcgBCkDADcCACABQQE2ArwBIAFBtAFqIBc4AgAgASAYOAKwASABKAIIIQIgASABKAIANgIIIAEgAjYCAAwICyAEKQIAIRMgBCACKQIANwIAIANBQGsiBUEgaiIGIARBIGoiCSgCADYCACAFQRhqIgogBEEYaiIMKQIANwMAIAVBEGoiCCAEQRBqIgcpAgA3AwAgBUEIaiIFIARBCGoiBCkCADcDACAEIAJBCGoiBCkCADcCACAHIAJBEGoiBykCADcCACAMIAJBGGoiDCkCADcCACAJIAJBIGoiCSgCADYCACADIBM3A0AgAiADKQNANwIAIAkgBigCADYCACAMIAopAwA3AgAgByAIKQMANwIAIAQgBSkDADcCACABQQE2ArwBIAFBtAFqIBg4AgAgASAXOAKwASABIAEpAgRCIIk3AgQMBwsgA0EYaiIEQQhqIgYgAUEoaigCADYCACAEQRRqIAFBzABqKAIANgIAIAMgASkCIDcDGCADIAFBxABqIgIpAgA3AiQgA0EANgIQIANCADcDCCADQUBrIgUgBCADQQhqEPUCIAYgBUEIaikDADcDACADIAMpA0A3AxggBUEUaigCACEEIAMoAlBFDQMgA0HYAGoqAgAhFyABIAQ2ArABIAFBtAFqIBc4AgAMBAsgAUGAgID8AzYCsAEgACABKQIgNwIAIABBCGogAUEoaigCADYCAAwLCyAGQQRB1LbBABDNCAALIAVBBEHUtsEAEM0IAAsCQAJAIAQOAgABAwsgAUEANgK8ASABQYCAgPwDNgKwAQwBCyABKQIgIRMgASACKQIANwIgIANBQGsiBEEgaiIFIAFBQGsiBigCADYCACAEQRhqIgsgAUE4aiIJKQIANwMAIARBEGoiCiABQTBqIgwpAgA3AwAgBEEIaiIEIAFBKGoiCCkCADcDACAIIAJBCGoiCCkCADcCACAMIAJBEGoiDCkCADcCACAJIAJBGGoiCSkCADcCACAGIAJBIGoiBigCADYCACADIBM3A0AgAiADKQNANwIAIAYgBSgCADYCACAJIAspAwA3AgAgDCAKKQMANwIAIAggBCkDADcCACABQQA2ArwBIAFBgICA/AM2ArABIAEgASkCAEIgiTcCAAsgACADKQMYNwIAIABBCGogA0EgaigCADYCAAwHC0GszcEAQShB5OLBABDbCQALIAAgAykDCDcCACAAQQhqIAsoAgA2AgAMBQsgASEEIBkhGCAXIRkLIAQoAgAhBSAEIAIoAgA2AgAgAiAFNgIAIBghFwsgASAXOAKwASABQbQBaiAZOAIAQQELNgK8AQsgACADKQMINwIAIABBCGogDCgCADYCAAsgA0GAAWokAAuCHgIBfyF9IwBBgAFrIgQkACABQRxqKgIAIQ4gAUEgaioCACEPIAFBEGoqAgAhCyABKgIYIRAgASoCDCEMIAEqAgAhCCABKgIEIQkgBCABQRRqKgIAIg0gASoCCCIKkyIROAIQIAQgCyAJkyISOAIMIAQgDCAIkyITOAIIIAQgDyAKkyIUOAIgIAQgDiAJkyIVOAIcIAQgECAIkyIWOAIYIAQgAkEIaioCACIHIAqTIhw4AjAgBCACQQRqKgIAIgUgCZMiHTgCLCAEIAIqAgAiBiAIkyIeOAIoIB4gFpQgHSAVlJIgHCAUlJIhFwJAAkACQAJAAkACQAJAIBMgHpQgEiAdlJIgESAclJIiH0MAAAAAX0VFQQAgF0MAAAAAXxtFBEAgBCAHIA2TIhg4AkAgBCAFIAuTIhk4AjwgBCAGIAyTIhs4AjggGyAWlCAZIBWUkiAYIBSUkiEjIBsgE5QgGSASlJIgGCARlJIiIEMAAAAAYEEAICMgIF8bDQEgBCAFIA6TIho4AkwgBCAGIBCTIiE4AkggBCAHIA+TIiI4AlAgISATlCAaIBKUkiAiIBGUkiEkICEgFpQgGiAVlJIgIiAUlJIiGkMAAAAAYEEAICQgGl8bDQIgBCAPIA2TIg84AmAgBCAOIAuTIg44AlwgBCAQIAyTIhA4AlggBEHoAGogBEEIaiAEQRhqIARB2ABqIARBKGogBEE4aiAEQcgAaiAfICAgFyAaICMgJBCnAyAEKAJoQQFrDgMEBQYDCwJAAkAgCCAGWw0AQQAhASAIvEH/////B3G+QwAAgH9bDQEgBrxB/////wdxvkMAAIB/Ww0BIAggBpOLIgtDAAAANF8NACALIAaLIgYgCIsiCyAGIAteG0MAAAA0lF9FDQELAkAgCSAFWw0AQQAhASAJvEH/////B3G+QwAAgH9bDQEgBbxB/////wdxvkMAAIB/Ww0BIAkgBZOLIgZDAAAANF8NACAGIAWLIgUgCYsiBiAFIAZeG0MAAAA0lF9FDQELQQEhASAKIAdbDQBBACEBIAq8Qf////8Hcb5DAACAf1sNACAHvEH/////B3G+QwAAgH9bDQBBASEBIAogB5OLIgVDAAAANF8NACAFIAeLIgcgCosiBSAHIAVeG0MAAAA0lF8hAQsgAEIANwIQIAAgAToADCAAIAo4AgggACAJOAIEIAAgCDgCAAwGCwJAAkAgDCAGWw0AQQAhASAMvEH/////B3G+QwAAgH9bDQEgBrxB/////wdxvkMAAIB/Ww0BIAwgBpOLIghDAAAANF8NACAIIAaLIgYgDIsiCCAGIAheG0MAAAA0lF9FDQELAkAgCyAFWw0AQQAhASALvEH/////B3G+QwAAgH9bDQEgBbxB/////wdxvkMAAIB/Ww0BIAsgBZOLIgZDAAAANF8NACAGIAWLIgUgC4siBiAFIAZeG0MAAAA0lF9FDQELQQEhASANIAdbDQBBACEBIA28Qf////8Hcb5DAACAf1sNACAHvEH/////B3G+QwAAgH9bDQBBASEBIA0gB5OLIgVDAAAANF8NACAFIAeLIgcgDYsiBSAHIAVeG0MAAAA0lF8hAQsgAEKAgICAEDcCECAAIAE6AAwgACANOAIIIAAgCzgCBCAAIAw4AgAMBQsCQAJAIBAgBlsNAEEAIQEgELxB/////wdxvkMAAIB/Ww0BIAa8Qf////8Hcb5DAACAf1sNASAQIAaTiyIIQwAAADRfDQAgCCAGiyIGIBCLIgggBiAIXhtDAAAANJRfRQ0BCwJAIA4gBVsNAEEAIQEgDrxB/////wdxvkMAAIB/Ww0BIAW8Qf////8Hcb5DAACAf1sNASAOIAWTiyIGQwAAADRfDQAgBiAFiyIFIA6LIgYgBSAGXhtDAAAANJRfRQ0BC0EBIQEgDyAHWw0AQQAhASAPvEH/////B3G+QwAAgH9bDQAgB7xB/////wdxvkMAAIB/Ww0AQQEhASAPIAeTiyIFQwAAADRfDQAgBSAHiyIHIA+LIgUgByAFXhtDAAAANJRfIQELIABCgICAgCA3AhAgACABOgAMIAAgDzgCCCAAIA44AgQgACAQOAIADAQLQwAAgD8gHyATIBOUIBIgEpSSIBEgEZSSQwAAAACSlSILkyEMIAogESALlJIhCiAJIBIgC5SSIQkCQAJAIAggEyALlJIiCCAGWw0AQQAhASAIvEH/////B3G+QwAAgH9bDQEgBrxB/////wdxvkMAAIB/Ww0BIAggBpOLIg1DAAAANF8NACANIAaLIgYgCIsiDSAGIA1eG0MAAAA0lF9FDQELAkAgCSAFWw0AQQAhASAJvEH/////B3G+QwAAgH9bDQEgBbxB/////wdxvkMAAIB/Ww0BIAkgBZOLIgZDAAAANF8NACAGIAWLIgUgCYsiBiAFIAZeG0MAAAA0lF9FDQELQQEhASAKIAdbDQBBACEBIAq8Qf////8Hcb5DAACAf1sNACAHvEH/////B3G+QwAAgH9bDQBBASEBIAogB5OLIgVDAAAANF8NACAFIAeLIgcgCosiBSAHIAVeG0MAAAA0lF8hAQsgAEIBNwIQIAAgAToADCAAIAo4AgggACAJOAIEIAAgCDgCACAAQRhqIAy8rSALvK1CIIaENwIADAMLQwAAgD8gFyAWIBaUIBUgFZSSIBQgFJSSQwAAAACSlSILkyEMIAogFCALlJIhCiAJIBUgC5SSIQkCQAJAIAggFiALlJIiCCAGWw0AQQAhASAIvEH/////B3G+QwAAgH9bDQEgBrxB/////wdxvkMAAIB/Ww0BIAggBpOLIg1DAAAANF8NACANIAaLIgYgCIsiDSAGIA1eG0MAAAA0lF9FDQELAkAgCSAFWw0AQQAhASAJvEH/////B3G+QwAAgH9bDQEgBbxB/////wdxvkMAAIB/Ww0BIAkgBZOLIgZDAAAANF8NACAGIAWLIgUgCYsiBiAFIAZeG0MAAAA0lF9FDQELQQEhASAKIAdbDQBBACEBIAq8Qf////8Hcb5DAACAf1sNACAHvEH/////B3G+QwAAgH9bDQBBASEBIAogB5OLIgVDAAAANF8NACAFIAeLIgcgCosiBSAHIAVeG0MAAAA0lF8hAQsgAEKBgICAIDcCECAAIAE6AAwgACAKOAIIIAAgCTgCBCAAIAg4AgAgAEEYaiAMvK0gC7ytQiCGhDcCAAwCC0MAAIA/IBsgEJQgGSAOlJIgGCAPlJIgECAQlCAOIA6UkiAPIA+UkkMAAAAAkpUiCpMhESANIA8gCpSSIQggCyAOIAqUkiEJAkACQCAMIBAgCpSSIgsgBlsNAEEAIQEgC7xB/////wdxvkMAAIB/Ww0BIAa8Qf////8Hcb5DAACAf1sNASALIAaTiyIMQwAAADRfDQAgDCAGiyIGIAuLIgwgBiAMXhtDAAAANJRfRQ0BCwJAIAkgBVsNAEEAIQEgCbxB/////wdxvkMAAIB/Ww0BIAW8Qf////8Hcb5DAACAf1sNASAJIAWTiyIGQwAAADRfDQAgBiAFiyIFIAmLIgYgBSAGXhtDAAAANJRfRQ0BC0EBIQEgCCAHWw0AQQAhASAIvEH/////B3G+QwAAgH9bDQAgB7xB/////wdxvkMAAIB/Ww0AQQEhASAIIAeTiyIFQwAAADRfDQAgBSAHiyIHIAiLIgUgByAFXhtDAAAANJRfIQELIABCgYCAgBA3AhAgACABOgAMIAAgCDgCCCAAIAk4AgQgACALOAIAIABBGGogEbytIAq8rUIghoQ3AgAMAQsCQAJAAkACQCAEQfAAaioCACAEQfQAaioCACIhkiAEQfgAaioCACIikiIlQwAAAABbBEAgAw0DIBsgG5QgGSAZlJIgGCAYlJJDAAAAAJIgFyAXIBqTlSIFIAUgECAQlCAOIA6UkiAPIA+UkkMAAAAAkpSUkyEXIB4gHpQgHSAdlJIgHCAclJJDAAAAAJIiByAfIB8gIJOVIgYgBiATIBOUIBIgEpSSIBEgEZSSQwAAAACSlJSTIhggByAjICCTIgcgJCAHkiAak5UiByAHIBYgFpQgFSAVlJIgFCAUlJJDAAAAAJKUlJMiGV0NASAZIBddDQIgDSAPIAeUkiEKIAsgDiAHlJIhCSAMIBAgB5SSIQhBASEBDAQLQwAAgD8gIUMAAIA/ICWVIgyUIguTICIgDJQiDJMhDSAKIAsgEZSSIAwgFJSSIQogCSALIBKUkiAMIBWUkiEJIAQoAmwhAgJAAkAgCCALIBOUkiAMIBaUkiIIIAZbDQBBACEBIAi8Qf////8Hcb5DAACAf1sNASAGvEH/////B3G+QwAAgH9bDQEgCCAGk4siEUMAAAA0Xw0AIBEgBosiBiAIiyIRIAYgEV4bQwAAADSUX0UNAQsCQCAJIAVbDQBBACEBIAm8Qf////8Hcb5DAACAf1sNASAFvEH/////B3G+QwAAgH9bDQEgCSAFk4siBkMAAAA0Xw0AIAYgBYsiBSAJiyIGIAUgBl4bQwAAADSUX0UNAQtBASEBIAogB1sNAEEAIQEgCrxB/////wdxvkMAAIB/Ww0AIAe8Qf////8Hcb5DAACAf1sNAEEBIQEgCiAHk4siBUMAAAA0Xw0AIAUgB4siByAKiyIFIAcgBV4bQwAAADSUXyEBCyAAQQI2AhAgACABOgAMIAAgCjgCCCAAIAk4AgQgACAIOAIAIABBIGogDDgCACAAQRxqIAs4AgAgAEEYaiANOAIAIABBFGogAjYCAAwECyAYIBddRQRAIA0gDyAHlJIhCiALIA4gB5SSIQkgDCAQIAeUkiEIQQEhAQwDCyAKIAYgEZSSIQogCSAGIBKUkiEJIAggBiATlJIhCEEAIQEgBiEHDAILIAogBSAUlJIhCiAJIAUgFZSSIQkgCCAFIBaUkiEIQQIhASAFIQcMAQsgAEEDNgIQIABBAToADCAAIAIpAgA3AgAgAEEIaiACQQhqKAIANgIADAELIABBATYCECAAQQE6AAwgACAKOAIIIAAgCTgCBCAAIAg4AgAgAEEUaiABNgIAIABBGGpDAACAPyAHk7ytIAe8rUIghoQ3AgALIARBgAFqJAAL5B0DHH8Cfgp9IwBB0ANrIgUkACAFIAI2AmQgBUE8aiACKgIMIiQ4AgAgBUE4aiAkOAIAIAVBNGogJDgCACAFQSxqIAIqAggiJjgCACAFQShqICY4AgAgBUEkaiAmOAIAIAVBHGogAioCBCIjOAIAIAVBGGogIzgCACAFQRRqICM4AgAgBUHcAGogAkEUaioCACIlOAIAIAVB2ABqICU4AgAgBUHUAGogJTgCACAFQdAAaiAlOAIAIAVBzABqIAJBEGoqAgAiJTgCACAFQcgAaiAlOAIAIAVBxABqICU4AgAgBUFAayAlOAIAIAUgATYCYCAFIAQ6AGwgBSADOAJoIAUgJDgCMCAFICY4AiAgBSAjOAIQIAUgAioCACIDOAIMIAUgAzgCCCAFIAM4AgQgBSADOAIAAkACQCABQSBqKAIAIg0EQCAFQgA3AnQgBUHsuMEAKAIANgJwIAVB8ABqIgJBABCQBiAFKAJwIAUoAngiBEEDdGpCgICAgPD///9+NwIAIAUgBEEBajYCeCAFQZABaiACEJwDQQQhDgJAIAUoApABQQFHDQAgBUHQAmpBBHIhDyAFQbADaiICQQxqIQwgAkEEciEVQ///f38hJANAICQgBSoCmAGMXw0BAkACQAJAAkACQAJAIA0gBSgClAEiAksEQCAFQaABaiABKAIYIAJBB3RqQYABEOQGGiAFLQCYAiIWBEAgBSgCjAIiByABKAI8IgJJIQYgASgCNCIEIAdBDGxqQQAgBhtBCGpBACAGGyEXIAUoAogCIgcgAkkhBiAHQQxsIARqQQAgBhtBCGpBACAGGyEYIAUoAoQCIgcgAkkhBiAHQQxsIARqQQAgBhtBCGpBACAGGyEZIAUoAoACIgYgAkkhAiAGQQxsIARqQQAgAhtBCGpBACACGyEUCyAFIAUqAmgiJzgCvAMgBSAnOAK4AyAFICc4ArQDIAUgJzgCsAMgBUHQAmogBUGgAWogBSAFQbADahCHAiAFQcgCaiIEIA9BCGoiECgCADYCACAFIA8pAgA3A8ACIAUoAtACIQIgBSoC4AIhIyAFKgLkAiEDIAUqAugCISYgBSoC7AIhJSAWRQRAQQQhBkEEIQdBBCEKQQQhBAwDCyAVIAUpA8ACNwIAIBVBCGogBCgCADYCACAFIAI2ArADIAUgJSAkXToA0wIgBSAmICRdOgDSAiAFIAMgJF06ANECIAUgIyAkXToA0AIgBUGgA2ogBUGwA2ogBUHQAmoQiAlDAAAAACEDQQAhGkEEIQogBS0AbCERIAUoAmQhEiAFKAJgIQhBBCEEQQAhG0MAAAAAISMgBS0AoAMgBS0AoQNBAXRyIAUtAKIDQQJ0ciAFLQCjA0EDdHKtIiFCAYNQDQEgFEUNASAIKAJUIgkgFCgCACICTQ0DIAgoAkgiCSAIKAJMIAJBA3RqIgQoAgAiAk0NBCAJIAQoAgQiC00NBSAMIAgoAkAiBCALQQxsaiIGKQIANwIAIAxBCGogBkEIaigCADYCACAFQbADaiIGQQhqIAJBDGwgBGoiAkEIaigCADYCACAFIAIpAgA3A7ADIAVB0AJqIAYgEiAnIBFBAEcQiQIgBSgC4AIiBEEERg0BIAVBqANqIBAoAgA2AgAgBSAPKQIANwOgA0EBIRsgBSgC5AIhHiAFKgLQAiIpISMMAQsgAiANQajIwQAQzQgACwJAICFC/wGDIiFCAoNQDQAgGUUNACAIKAJUIgkgGSgCACICTQ0CIAgoAkgiCSAIKAJMIAJBA3RqIgsoAgAiAk0NAyAJIAsoAgQiC00NBCAMIAgoAkAiBiALQQxsaiIHKQIANwIAIAxBCGogB0EIaigCADYCACAFQbADaiIHQQhqIAJBDGwgBmoiAkEIaigCADYCACAFIAIpAgA3A7ADIAVB0AJqIAcgEiAnIBFBAEcQiQIgBSgC4AIiCkEERg0AIAVBmANqIBAoAgA2AgAgBSAPKQIANwOQA0GAAiEaIAUoAuQCIR8gBSoC0AIiKiEDC0MAAAAAISVBACEcQQQhBkEEIQdBACEdAn1DAAAAACAhQgSDUA0AGkMAAAAAIBhFDQAaIAgoAlQiCSAYKAIAIgJNDQIgCCgCSCIJIAgoAkwgAkEDdGoiCygCACICTQ0DIAkgCygCBCILTQ0EIAwgCCgCQCIHIAtBDGxqIgkpAgA3AgAgDEEIaiAJQQhqKAIANgIAIAVBsANqIglBCGogAkEMbCAHaiICQQhqKAIANgIAIAUgAikCADcDsAMgBUHQAmogCSASICcgEUEARxCJAkMAAAAAIAUoAuACIgdBBEYNABogBUGIA2ogECgCADYCACAFIA8pAgA3A4ADQYCABCEdIAUoAuQCISAgBSoC0AIiKwshJgJAICFCCINQDQAgF0UNACAIKAJUIgkgFygCACICTQ0CIAgoAkgiCSAIKAJMIAJBA3RqIgsoAgAiAk0NAyAJIAsoAgQiC00NBCAMIAgoAkAiBiALQQxsaiIIKQIANwIAIAxBCGogCEEIaigCADYCACAFQbADaiIIQQhqIAJBDGwgBmoiAkEIaigCADYCACAFIAIpAgA3A7ADIAVB0AJqIAggEiAnIBFBAEcQiQIgBSgC4AIiBkEERg0AIAVB+AJqIBAoAgA2AgAgBSAPKQIANwPwAkGAgIAIIRwgBSgC5AIhCyAFKgLQAiIlISwLIAVB2AJqIAVBqANqKAIANgIAIAVBuANqIAVBmANqKAIANgIAIAVBuAJqIAVBiANqKAIANgIAIAUgBSkDoAM3A9ACIAUgBSkDkAM3A7ADIAUgBSkDgAM3A7ACIAUgBSkD8AI3A6ACIAUgBUH4AmooAgA2AqgCIB1BgIAEcSAaQYACcSAbcnIgHHIhAgsgAkEVdkH4AXEgAkEOdkH8AXEgAkEHdkH+AXEgAkH/AXFycnKtIiFCAYMhIiAWBEAgASgCPCECAkAgIlANACAjICRdRQ0AIARBBEYNACAFKAKAAiACTw0AIAVBiAFqIAVB2AJqKAIANgIAIAUgBSkD0AI3A4ABICkhKCAeIRMgBCEOICMhJAsCQCAhQgKDUA0AIAMgJF1FDQAgCkEERg0AIAUoAoQCIAJPDQAgBUGIAWogBUG4A2ooAgA2AgAgBSAFKQOwAzcDgAEgKiEoIB8hEyAKIQ4gAyEkCwJAICFCBINQDQAgJiAkXUUNACAHQQRGDQAgBSgCiAIgAk8NACAFQYgBaiAFQbgCaigCADYCACAFIAUpA7ACNwOAASArISggICETIAchDiAmISQLICFCCINQDQQgJSAkXUUNBCAGQQRGDQQgBSgCjAIgAk8NBCAFQYgBaiAFKAKoAjYCACAFIAUpA6ACNwOAASAsISggCyETIAYhDiAlISQMBAsCQCAiUA0AIAUoAoACIgcgDU8NACAjjCEjIAUoAngiAiEEIAUoAnQgAkYEQCAFQfAAaiACEJAGIAUoAnghBAsgBSgCcCIGIARBA3RqIgogIzgCBCAKIAc2AgAgBSAEQQFqNgJ4IAJBA3QgBmoiBCoCBCEjIAQoAgAhBwJAIAJFBEBBACEEDAELA0BBAEF/ICMgAkF/aiIKQQF2IgRBA3QgBmoiCEEEaioCACInYCIJG0EBQQIgCRsgIyAnXxtBf2pB/wFxQQFLBEAgAiEEDAILIAJBA3QgBmogCCkCADcCACAEIQIgCkEBSw0ACwsgBEEDdCAGaiICICM4AgQgAiAHNgIACwJAICFCAoNQDQAgBSgChAIiByANTw0AIAOMIQMgBSgCeCICIQQgBSgCdCACRgRAIAVB8ABqIAIQkAYgBSgCeCEECyAFKAJwIgYgBEEDdGoiCiADOAIEIAogBzYCACAFIARBAWo2AnggAkEDdCAGaiIEKgIEIQMgBCgCACEHAkAgAkUEQEEAIQQMAQsDQEEAQX8gAyACQX9qIgpBAXYiBEEDdCAGaiIIQQRqKgIAIiNgIgkbQQFBAiAJGyADICNfG0F/akH/AXFBAUsEQCACIQQMAgsgAkEDdCAGaiAIKQIANwIAIAQhAiAKQQFLDQALCyAEQQN0IAZqIgIgAzgCBCACIAc2AgALAkAgIUIEg1ANACAFKAKIAiIHIA1PDQAgJowhAyAFKAJ4IgIhBCAFKAJ0IAJGBEAgBUHwAGogAhCQBiAFKAJ4IQQLIAUoAnAiBiAEQQN0aiIKIAM4AgQgCiAHNgIAIAUgBEEBajYCeCACQQN0IAZqIgQqAgQhAyAEKAIAIQcCQCACRQRAQQAhBAwBCwNAQQBBfyADIAJBf2oiCkEBdiIEQQN0IAZqIghBBGoqAgAiJmAiCRtBAUECIAkbIAMgJl8bQX9qQf8BcUEBSwRAIAIhBAwCCyACQQN0IAZqIAgpAgA3AgAgBCECIApBAUsNAAsLIARBA3QgBmoiAiADOAIEIAIgBzYCAAsgIUIIg1ANAyAFKAKMAiIHIA1PDQMgJYwhAyAFKAJ4IgIhBCAFKAJ0IAJGBEAgBUHwAGogAhCQBiAFKAJ4IQQLIAUoAnAiBiAEQQN0aiIKIAM4AgQgCiAHNgIAIAUgBEEBajYCeCACQQN0IAZqIgQqAgQhAyAEKAIAIQcCQCACRQRAQQAhBAwBCwNAQQBBfyADIAJBf2oiCkEBdiIEQQN0IAZqIghBBGoqAgAiJmAiCRtBAUECIAkbIAMgJl8bQX9qQf8BcUEBSwRAIAIhBAwCCyACQQN0IAZqIAgpAgA3AgAgBCECIApBAUsNAAsLIARBA3QgBmoiAiADOAIEIAIgBzYCAAwDCyACIAlBwPHBABDNCAALIAIgCUHQ8cEAEM0IAAsgCyAJQeDxwQAQzQgACyAFQZABaiAFQfAAahCcAyAFKAKQAUEBRg0ACwsgBUGoAWogBUGIAWooAgA2AgAgBSAFKQOAATcDoAECQCAFKAJ0IgFFDQAgBSgCcCICRQ0AIAFBA3RFDQAgAhDhAQsgDkEERw0BCyAAQQQ2AhAMAQsgACAFKQOgATcABCAAIBM2AhQgACAONgIQIAAgKDgCACAAQQxqIAVBqAFqKAIANgAACyAFQdADaiQAC8AdAw9/An4GfSMAQbADayIEJAAgBCACNgI0IARBLGogAioCCCIVOAIAIARBKGogFTgCACAEQSRqIBU4AgAgBEEcaiACKgIEIhc4AgAgBEEYaiAXOAIAIARBFGogFzgCACAEIAE2AjAgBCADOgA4IAQgFTgCICAEIBc4AhAgBCACKgIAIhc4AgwgBCAXOAIIIAQgFzgCBCAEIBc4AgACQCABQSxqKAIAIgwEQCAEQgA3AkQgBEHsuMEAKAIANgJAIARBQGsiA0EAEJAGIAQoAkAgBCgCSCICQQN0akKAgICA8P///343AgAgBCACQQFqNgJIIARB4ABqIAMQnANBAiENAkAgBCgCYEEBRw0AIARBrQNqIQogBEGjA2ohC0P//39/IRcDQCAXIAQqAmiMXw0BAkACQCAMIAQoAmQiAksEQCAEQfAAaiABKAIkIAJBB3RqQYABEOQGGiAELQDoASIPBEAgBCgC3AEiAiABKAJIIgdJIQMgASgCQCIFIAJBDGxqQQAgAxtBCGpBACADGyEQIAQoAtgBIgIgB0khAyACQQxsIAVqQQAgAxtBCGpBACADGyERIAQoAtQBIgIgB0khAyACQQxsIAVqQQAgAxtBCGpBACADGyESIAQoAtABIgIgB0khAyACQQxsIAVqQQAgAxtBCGpBACADGyEOCyAEQcACaiAEQfAAaiAEEJ8CIAQqAsACIhUgF10hAyAEKgLMAiEYIAQqAsgCIRkgBCoCxAIhFiAPRQRAQQIhAiAWIBddQQF0IANyIBkgF11BAnRyIBggF11BA3RyrSETQQIhA0ECIQdBAiEFDAMLQQIhByAWIBddQwAAAAAhFkECIQVDAAAAACEVQQF0IANyIBkgF11BAnRyIBggF11BA3RyrSITQgGDUA0BIA5FDQEgBCgCMCIDKAIIIgIgDigCACIGTQ0BIAMoAgAgBkEkbGpBACACIAZLGyIFQSBqKAIAIQMgBEGgA2oiAiAFKAIcIAMoAghBB2pBeHFqIAUgBCgCNCAELQA4IAMoAjQRCAAgBCoCoAMgBCgCNCIDKgIAkyIVIBWUIAQqAqQDIANBBGoqAgCTIhUgFZSSIAJBCGoiAioCACADQQhqKgIAkyIVIBWUkkMAAAAAkhCzASEVIARBmANqIAIoAgA2AgAgBEGOA2ogCkECai0AADoAACAEIAQpA6ADNwOQAyAEIAovAAA7AYwDIAQtAKwDIQUMAQsgAiAMQajIwQAQzQgACwJAIBNCAoNQDQAgEkUNACAEKAIwIgMoAggiAiASKAIAIgZNDQAgAygCACAGQSRsakEAIAIgBksbIgdBIGooAgAhAyAEQaADaiICIAcoAhwgAygCCEEHakF4cWogByAEKAI0IAQtADggAygCNBEIACAEKgKgAyAEKAI0IgMqAgCTIhYgFpQgBCoCpAMgA0EEaioCAJMiFiAWlJIgAkEIaiICKgIAIANBCGoqAgCTIhYgFpSSQwAAAACSELMBIRYgBEGIA2ogAigCADYCACAEQf4CaiAKQQJqLQAAOgAAIAQgBCkDoAM3A4ADIAQgCi8AADsB/AIgBC0ArAMhBwtBAiECQwAAAAAhGEMAAAAAIRkCf0ECIBNCBINQDQAaQQIgEUUNABpBAiAEKAIwIgkoAggiBiARKAIAIghNDQAaIAkoAgAgCEEkbGpBACAGIAhLGyIJQSBqKAIAIQYgBEGgA2oiAyAJKAIcIAYoAghBB2pBeHFqIAkgBCgCNCAELQA4IAYoAjQRCAAgBCoCoAMgBCgCNCIGKgIAkyIZIBmUIAQqAqQDIAZBBGoqAgCTIhkgGZSSIANBCGoiAyoCACAGQQhqKgIAkyIZIBmUkkMAAAAAkhCzASEZIARB+AJqIAMoAgA2AgAgBEHuAmogCkECai0AADoAACAEIAQpA6ADNwPwAiAEIAovAAA7AewCIAQtAKwDCyEDAkAgE0IIg1ANACAQRQ0AIAQoAjAiCSgCCCIGIBAoAgAiCE0NACAJKAIAIAhBJGxqQQAgBiAISxsiCUEgaigCACEGIARBoANqIgIgCSgCHCAGKAIIQQdqQXhxaiAJIAQoAjQgBC0AOCAGKAI0EQgAIAQqAqADIAQoAjQiBioCAJMiGCAYlCAEKgKkAyAGQQRqKgIAkyIYIBiUkiACQQhqIgIqAgAgBkEIaioCAJMiGCAYlJJDAAAAAJIQswEhGCAEQegCaiACKAIANgIAIARB3gJqIApBAmotAAA6AAAgBCAEKQOgAzcD4AIgBCAKLwAAOwHcAiAELQCsAyECCyAEQbgCaiAEQZgDaigCADYCACAEQagCaiAEQYgDaigCADYCACAEQZgCaiAEQfgCaigCADYCACAEQa4CaiAEQY4Dai0AADoAACAEIAQpA5ADNwOwAiAEIAQpA4ADNwOgAiAEIAQpA/ACNwOQAiAEIAQpA+ACNwOAAiAEIAQvAYwDOwGsAiAEIARB6AJqKAIANgKIAiAEQZ4CaiAEQf4Cai0AADoAACAEQY4CaiAEQe4Cai0AADoAACAEQf4BaiAEQd4Cai0AADoAACAEIAQvAfwCOwGcAiAEIAQvAewCOwGMAiAEIAQvAdwCOwH8AQsgE0IBgyEUAkAgDwRAIAEoAkghBgJAIBRQDQAgFSAXXUUNACAFQf8BcUECRg0AIAQoAtABIAZPDQAgCyAEKQOwAjcAACALQQhqIARBuAJqKAIANgAAIARBzgBqIARBrgJqLQAAOgAAIAQgBC8BrAI7AUwgBCAEKQCgAzcDUCAEIARBpwNqKQAANwBXIAUhDSAVIRcLAkAgE0ICg1ANACAWIBddRQ0AIAdB/wFxQQJGDQAgBCgC1AEgBk8NACALIAQpA6ACNwAAIAtBCGogBEGoAmooAgA2AAAgBEHOAGogBEGeAmotAAA6AAAgBCAELwGcAjsBTCAEIAQpAKADNwNQIAQgBEGnA2opAAA3AFcgByENIBYhFwsCQCATQgSDUA0AIBkgF11FDQAgA0H/AXFBAkYNACAEKALYASAGTw0AIAsgBCkDkAI3AAAgC0EIaiAEQZgCaigCADYAACAEQc4AaiAEQY4Cai0AADoAACAEIAQvAYwCOwFMIAQgBCkAoAM3A1AgBCAEQacDaikAADcAVyADIQ0gGSEXCyATQgiDUA0BIBggF11FDQEgAkH/AXFBAkYNASAEKALcASAGTw0BIAsgBCkDgAI3AAAgC0EIaiAEKAKIAjYAACAEQc4AaiAEQf4Bai0AADoAACAEIAQvAfwBOwFMIAQgBCkAoAM3A1AgBCAEQacDaikAADcAVyACIQ0gGCEXDAELAkAgFFANACAEKALQASIHIAxPDQAgFYwhFSAEKAJIIgIhBSAEKAJEIAJGBEAgBEFAayACEJAGIAQoAkghBQsgBCgCQCIIIAVBA3RqIgMgFTgCBCADIAc2AgAgBCAFQQFqNgJIIAJBA3QgCGoiAyoCBCEaIAMoAgAhCQJAIAJFBEBBACEFDAELA0BBAEF/IBogAkF/aiIGQQF2IgVBA3QgCGoiB0EEaioCACIVYCIDG0EBQQIgAxsgGiAVXxtBf2pB/wFxQQFLBEAgAiEFDAILIAJBA3QgCGogBykCADcCACAFIQIgBkEBSw0ACwsgBUEDdCAIaiICIBo4AgQgAiAJNgIACwJAIBNCAoNQDQAgBCgC1AEiByAMTw0AIBaMIRUgBCgCSCICIQUgBCgCRCACRgRAIARBQGsgAhCQBiAEKAJIIQULIAQoAkAiCCAFQQN0aiIDIBU4AgQgAyAHNgIAIAQgBUEBajYCSCACQQN0IAhqIgMqAgQhFiADKAIAIQkCQCACRQRAQQAhBQwBCwNAQQBBfyAWIAJBf2oiBkEBdiIFQQN0IAhqIgdBBGoqAgAiFWAiAxtBAUECIAMbIBYgFV8bQX9qQf8BcUEBSwRAIAIhBQwCCyACQQN0IAhqIAcpAgA3AgAgBSECIAZBAUsNAAsLIAVBA3QgCGoiAiAWOAIEIAIgCTYCAAsCQCATQgSDUA0AIAQoAtgBIgcgDE8NACAZjCEVIAQoAkgiAiEFIAQoAkQgAkYEQCAEQUBrIAIQkAYgBCgCSCEFCyAEKAJAIgggBUEDdGoiAyAVOAIEIAMgBzYCACAEIAVBAWo2AkggAkEDdCAIaiIDKgIEIRYgAygCACEJAkAgAkUEQEEAIQUMAQsDQEEAQX8gFiACQX9qIgZBAXYiBUEDdCAIaiIHQQRqKgIAIhVgIgMbQQFBAiADGyAWIBVfG0F/akH/AXFBAUsEQCACIQUMAgsgAkEDdCAIaiAHKQIANwIAIAUhAiAGQQFLDQALCyAFQQN0IAhqIgIgFjgCBCACIAk2AgALIBNCCINQDQAgBCgC3AEiByAMTw0AIBiMIRUgBCgCSCICIQUgBCgCRCACRgRAIARBQGsgAhCQBiAEKAJIIQULIAQoAkAiCCAFQQN0aiIDIBU4AgQgAyAHNgIAIAQgBUEBajYCSCACQQN0IAhqIgMqAgQhFiADKAIAIQkCQCACRQRAQQAhBQwBCwNAQQBBfyAWIAJBf2oiBkEBdiIFQQN0IAhqIgdBBGoqAgAiFWAiAxtBAUECIAMbIBYgFV8bQX9qQf8BcUEBSwRAIAIhBQwCCyACQQN0IAhqIAcpAgA3AgAgBSECIAZBAUsNAAsLIAVBA3QgCGoiAiAWOAIEIAIgCTYCAAsgBEHgAGogBEFAaxCcAyAEKAJgQQFGDQALCyAEQcICaiAEQc4Aai0AADoAACAEIAQpA1A3A3AgBCAEKQBXNwB3IAQgBC8BTDsBwAICQCAEKAJEIgJFDQAgBCgCQCIBRQ0AIAJBA3RFDQAgARDhAQsgDUH/AXFBAkcNAQtB5LbBAEErQaTrwQAQ2wkACyAAIAQvAcACOwANIABBD2ogBEHCAmotAAA6AAAgBCAEKQB3NwCnAyAEIAQpA3A3A6ADIABBCGogBEGrA2ooAAA2AAAgACAEKQCjAzcAACAAIA06AAwgBEGwA2okAAu/GQMafwF+BHwjAEHABGsiBiQAIAZBCGpBAEGgARDoBhogBkGoAWpBAEGgARDoBhogBkHIAmpBAEGgARDoBhogBkHoA2pBAEHQABDoBhogAkF9akEYbSIOIQhBiMrCACgCACIKIQMgDkECdEGYysIAaiEEIA5BaGwgAmohB0EAIQIDQCACIANPIQkgAiADSSACaiAGQQhqIAJBA3RqIAhBAEgEfEQAAAAAAAAAAAUgBCgCALcLOQMAIARBBGohBCAIQQFqIQgiAiADSyAJckEBRw0ACyAHQWhqIQlBACEFA0AgBSAKSSEERAAAAAAAAAAAIR5BACECA0ACQCAeIAJBA3QgAGorAwAgBkEIaiAFIAJrQQN0aisDAKKgIR4gAkEATw0AIAJBAEkgAmoiAkEATQ0BCwsgBkHIAmogBUEDdGogHjkDACAFIApJBEAgBCAFaiIFIApNDQELCyAJQf0XIAlB/RdIG0GCcGogB0Hpd2ogCUH+D0oiDxshECAJQfBoIAlB8GhKG0GSD2ogB0GxB2ogCUG5cEgiERshEkQAAAAAAADwf0QAAAAAAADgfyAPG0QAAAAAAAAAAEQAAAAAAABgAyARG0QAAAAAAADwPyAJQYJ4SCITGyAJQf8HSiIUGyAQIBIgCSATGyAUG0H/B2qtQjSGv6IhIEEPIAdrQR9xIRZBECAHa0EfcSEVIApBAnQgBmpB5ANqIRcgB0FnaiEYIAohBAJAA0AgBkHIAmogBEEDdGorAwAhHiAEBEAgBkHoA2ohAiAEIQgDQCAeRAAAAAAAAHA+oiIfRAAAAAAAAODBZiEDIB5BAEH/////BwJ/IB+ZRAAAAAAAAOBBYwRAIB+qDAELQYCAgIB4C0GAgICAeCADGyAfRAAAwP///99BZBsgHyAfYhu3Ih9EAAAAAAAAcMGioCIeRAAAAAAAAODBZiEDIAJBAEH/////BwJ/IB6ZRAAAAAAAAOBBYwRAIB6qDAELQYCAgIB4C0GAgICAeCADGyAeRAAAwP///99BZBsgHiAeYhs2AgAgCEF/aiIFQQEgCEEBSyIDGyEIIAZByAJqIAVBA3RqKwMAIB+gIR4gAkEEaiECIAMNAAsLAn8CQCAURQRAIBMNASAJDAILIB5EAAAAAAAA4H+iIB4gDxtEAAAAAAAA4H+iIR4gEAwBCyAeRAAAAAAAAGADoiAeIBEbRAAAAAAAAGADoiEeIBILIQICQCAeIAJB/wdqrUI0hr+iIiFEAAAAAAAAwD+iIh69Ih1CNIinQf8PcSICQbIISw0AIB5EAAAAAAAAAABhDQAgBiAeRAAAAAAAADBDoEQAAAAAAAAww6AgHkQAAAAAAAAww6BEAAAAAAAAMEOgIB1Cf1UiBRsgHqEiHzkDuAQgAkH/B08EQCAeIB+gIh5EAAAAAAAA8L+gIB4gH0QAAAAAAAAAAGQbIR4MAQtEAAAAAAAAAABEAAAAAAAA8L8gBRshHiAGKwO4BBoLICEgHkQAAAAAAAAgwKKgIh5EAAAAAAAA4MFmIQUgHkEAQf////8HAn8gHplEAAAAAAAA4EFjBEAgHqoMAQtBgICAgHgLQYCAgIB4IAUbIB5EAADA////30FkGyAeIB5iGyILt6EhHgJAAkACQAJ/IAlBAEoiGUUEQCAJDQIgBEECdCAGakHkA2ooAgBBF3UMAQsgBEECdCAGakHkA2oiBSgCACIDIBV1IQIgBSADIAIgFXRrIgU2AgAgAiALaiELIAUgFnULIgxBAEoNAQwCC0EAIQwgHkQAAAAAAADgP2ZFDQFBAiEMCwJAIARFBEBBACEFDAELIARBAXFBACEFQQAhCCAEQQFHBEAgBEF+cSEbIAZB6ANqIQIDQCACKAIAIQNB////ByENAn8CQCAFDQBBgICACCENIAMNAEEBDAELIAIgDSADazYCAEEACyEFIAhBAmohCCACQQRqIhwoAgAhDUH///8HIQMCfwJAIAVFDQBBgICACCEDIA0NAEEADAELIBwgAyANazYCAEEBCyEFIAJBCGohAiAIIBtHDQALC0UNACAGQegDaiAIQQJ0aiIDKAIAIQJB////ByEIAkAgBQ0AQYCAgAghCCACDQBBACEFDAELIAMgCCACazYCAEEBIQULAkAgGUUNAEH///8DIQICQAJAIBgOAgEAAgtB////ASECCyAEQQJ0IAZqQeQDaiIDIAMoAgAgAnE2AgALIAtBAWohCyAMQQJHDQBEAAAAAAAA8D8gHqEiHiAgoSAeIAUbIR5BAiEMCyAeRAAAAAAAAAAAYQRAAkAgCiAEQX9qIgJLDQBBACEIA0ACQCAGQegDaiACQQJ0aigCACAIciEIIAogAk8NACAKIAIgCiACSWsiAk0NAQsLIAhFDQAgBEECdCAGakHkA2ohAiAJIQcDQCAEQX9qIQQgB0FoaiEHIAIoAgAgAkF8aiECRQ0ACwwDCyAXIQIgBCEFA0AgBUEBaiEFIAIoAgAgAkF8aiECRQ0ACyAEQQFqIgMgBSIESw0BA0AgBkEIaiADQQN0aiADIA5qQQJ0QZjKwgBqKAIAtzkDAEEAIQJEAAAAAAAAAAAhHgNAAkAgHiACQQN0IABqKwMAIAZBCGogAyACa0EDdGorAwCioCEeIAJBAE8NACACQQBJIAJqIgJBAE0NAQsLIAZByAJqIANBA3RqIB45AwAgAyAETw0CIAMgBEkgA2oiAyAETQ0ACwwBCwsCQAJAQRggB2siAkH/B0wEQCACQYJ4Tg0CIB5EAAAAAAAAYAOiIR4gAkG4cEwNAUHhByAHayECDAILIB5EAAAAAAAA4H+iIR4gAkH/D0gEQEGZeCAHayECDAILIB5EAAAAAAAA4H+iIR4gAkH9FyACQf0XSBtBgnBqIQIMAQsgHkQAAAAAAABgA6IhHiACQfBoIAJB8GhKG0GSD2ohAgsCQCAeIAJB/wdqrUI0hr+iIh5EAAAAAAAAcEFmRQRAIAkhBwwBCyAeRAAAAAAAAHA+oiIfRAAAAAAAAODBZiECIB5BAEH/////BwJ/IB+ZRAAAAAAAAOBBYwRAIB+qDAELQYCAgIB4C0GAgICAeCACGyAfRAAAwP///99BZBsgHyAfYhu3Ih5EAAAAAAAAcMGioCIfRAAAAAAAAODBZiECIAZB6ANqIARBAnRqQQBB/////wcCfyAfmUQAAAAAAADgQWMEQCAfqgwBC0GAgICAeAtBgICAgHggAhsgH0QAAMD////fQWQbIB8gH2IbNgIAIARBAWohBAsgHkQAAAAAAADgwWYhAiAGQegDaiAEQQJ0akEAQf////8HAn8gHplEAAAAAAAA4EFjBEAgHqoMAQtBgICAgHgLQYCAgIB4IAIbIB5EAADA////30FkGyAeIB5iGzYCAAsCfAJAIAdB/wdMBEBEAAAAAAAA8D8gB0GCeE4NAhogB0G4cEwNASAHQckHaiEHRAAAAAAAAGADDAILIAdB/w9IBEAgB0GBeGohB0QAAAAAAADgfwwCCyAHQf0XIAdB/RdIG0GCcGohB0QAAAAAAADwfwwBCyAHQfBoIAdB8GhKG0GSD2ohB0QAAAAAAAAAAAsgB0H/B2qtQjSGv6IhHiAEQQFxBH8gBAUgBkHIAmogBEEDdGogHiAGQegDaiAEQQJ0aigCALeiOQMAIB5EAAAAAAAAcD6iIR4gBEF/agshAiAEBEAgAkEBaiEAIAZB6ANqIAJBf2oiBUECdGohAiAGQcgCaiAFQQN0aiEDA0AgAyAeRAAAAAAAAHA+oiIfIAIoAgC3ojkDACADQQhqIB4gAkEEaigCALeiOQMAIAJBeGohAiADQXBqIQMgH0QAAAAAAABwPqIhHiAAQX5qIgANAAsLIAZByAJqIARBA3RqIQggBCEAA0AgBCAAIgVrIQkgBUF/aiEARAAAAAAAAAAAIR5BACECQQEhAwNAAkAgHiACQaDMwgBqKwMAIAIgCGorAwCioCEeIAMgCksNACACQQhqIQIgAyAJTSADQQFqIQMNAQsLIAZBqAFqIAlBA3RqIB45AwAgCEF4aiEIIAUNAAsCQCAEQQFqQQNxIgBFBEBEAAAAAAAAAAAhHiAEIQMMAQsgBkGoAWogBEEDdGohAkQAAAAAAAAAACEeIAQhAwNAIANBf2ohAyAeIAIrAwCgIR4gAkF4aiECIABBf2oiAA0ACwsgBEEDTwRAIANBAWohACADQQN0IAZqQZABaiECA0AgHiACQRhqKwMAoCACQRBqKwMAoCACQQhqKwMAoCACKwMAoCEeIAJBYGohAiAAQXxqIgANAAsLIAEgHpogHiAMGzkDACAGQcAEaiQAIAtBB3EL0R0DH38Dfht9IwBBgAhrIgskACALQQhqIg8gBiAHKAJ4EQAAIAtBOGogBzYCACAPQShqIAQ2AgAgCyAKOgA8IAsgCTgCHCALIAg4AhggCyAGNgI0IAsgAzYCLCALIAU2AiggCyACNgIkIAsgATYCIAJAAkAgAyAEKAIQEQYAIgpBIGooAgAEQCALQgA3AkQgC0HsuMEAKAIANgJAIAtBQGsiAUEAEJAGIAsoAkAgCygCSCICQQN0akKAgICA8P///343AgAgCyACQQFqNgJIIAtBkAFqIAEQnANBBCEBAkAgCygCkAFBAUcNACALQbMGaiEFIAtB3ARqIRQgC0HZBGohEiALQbACaiETIAtB8AZqIgFBHGohFSABQShqIRYgAUEEciEXIAFBEGohGCALQcgHaiIBQShqIRkgAUEcaiEaIAFBEGohDyABQQRyIRsgC0GYBmohAkP//39/IQkgCkEgaiEcIAtBkARqIR1BBCEBA0AgCSALKgKYAYxfDQEgHCgCACIEIAsoApQBIgNLBEAgC0GgAWogCigCGCADQQd0akGAARDkBhogCy0AmAIiDQRAIAsoAowCIgcgCigCPCIDSSEGIAooAjQiBCAHQQxsakEAIAYbQQhqQQAgBhshHyALKAKIAiIHIANJIQYgB0EMbCAEakEAIAYbQQhqQQAgBhshICALKAKEAiIHIANJIQYgB0EMbCAEakEAIAYbQQhqQQAgBhshISALKAKAAiIGIANJIQMgBkEMbCAEakEAIAMbQQhqQQAgAxshHgsgCyAJOAKEBCALIAtBCGo2AoAEIB1CADcDACALQgA3A4gEQQAhBCALQQA2ApwEIAtBBDoAjAYgC0EEOgDQBSALQQQ6AJQFIAtBBDoA2AQgCyoCvAEhLSALKgLsASEuIAsqAqwBIS8gCyoC3AEhMyALKgLMASE0IAsqAvwBITUgCyoCuAEhNiALKgLoASE3IAsqAqgBITggCyoC2AEhOSALKgLIASE6IAsqAvgBITsgCyoCtAEhPCALKgLkASE9IAsqAqQBIT8gCyoC1AEhQCALKgLEASE+IAsqAvQBIUEgCyoC0AEiQiALKgKgASJDkyIIIAiUIAsqAuABIkQgCyoCsAEiRZMiCCAIlJIgCyoC8AEiRiALKgLAASJHkyIIIAiUkkMAAAAAkhCzASEIIEAgP5MiMCAwlCA9IDyTIjAgMJSSIEEgPpMiMCAwlJJDAAAAAJIQswEhMCA5IDiTIjEgMZQgNyA2kyIxIDGUkiA7IDqTIjEgMZSSQwAAAACSELMBITEgCyAzIC+TIjIgMpQgLiAtkyIyIDKUkiA1IDSTIjIgMpSSQwAAAACSELMBOAKgBiALIDE4ApwGIAsgMDgCmAYgCyAIOAKUBiA0IDWSQwAAAD+UITQgOiA7kkMAAAA/lCE1ID4gQZJDAAAAP5QhOiBHIEaSQwAAAD+UITsgLSAukkMAAAA/lCE+IDYgN5JDAAAAP5QhNiA8ID2SQwAAAD+UITcgRSBEkkMAAAA/lCE8IC8gM5JDAAAAP5QhMyA4IDmSQwAAAD+UITggPyBAkkMAAAA/lCE5IEMgQpJDAAAAP5QhPSALQcACaiEDIAIhBwNAIAsgBDYCpAYgCyAzOALMAiALIDg4AsgCIAsgOTgCxAIgCyA9OALAAiADKgIAIS0gCyA+OALMAiALIDY4AsgCIAsgNzgCxAIgCyA8OALAAiADKgIAIS4gCyA0OALMAiALIDU4AsgCIAsgOjgCxAIgCyA7OALAAiADKgIAIS8gCyAIOAKoBiALIAsoAoAEIgZBDGoqAgA4AqwGIAZBHGooAgAhBiALIC84AsgCIAsgLjgCxAIgCyAtOALAAiALQbAGaiAGIAtBwAJqIgwQywIgCygCgAQiBigCICEOIAtByAdqIhBBCGoiESAGQQhqKAIANgIAIAsgBikCADcDyAcgDCAOIBAQywIgCygCgAQiBioCFCEIIAYqAhAhLSAGKAIYIQYCQCALKgKoBiIuIAsqAqwGIi9gRQRAIAtBADYCsAcgC0HIB2ogBiALQcACaiAvIAtBrAZqIAtBsAZqIC4gC0GoBmogLSAIIAtBsAdqEGAgCy0A/AciBkEERg0BIBggGykCADcCACAXIA8pAgA3AgAgFiAaKQIANwIAIBUgGSkCADcCACAYQQhqIBtBCGooAgA2AgAgF0EIaiAPQQhqKAIANgIAIBZBCGogGkEIaigCADYCACAVQQhqIBlBCGooAgA2AgAgCyALKgLIBzgC8AYMAQsgC0EANgLIByALQfAGaiAGIAtBsAZqIC4gC0GoBmogC0HAAmogLyALQawGaiAtIAggC0HIB2oQYCALLQCkByEGCwJAIAZB/wFxQQRGDQAgCyoC8AYhCAJAAkACQCANBEAgCyAfNgK8ByALICA2ArgHIAsgITYCtAcgCyAeNgKwByAIIAsqAoQEXQ0BDAQLIAsoAqQGIgZBBE8NASALQZwEaiAGaiAIIAsqAoQEXToAACALQYgEaiAGQQJ0aiAIOAIADAMLIAsoAqQGIgZBA0sNASALQbAHaiAGQQJ0aigCACIGRQ0CIAsgBigCACIGNgLEByALKAKABCIMKAIkIAxBKGooAgAoAgwhDCALIAtBxAdqNgLgByALIAtBoARqNgLcByALIAtBhARqNgLYByALIAtBnARqNgLUByALIAtBpAZqNgLQByALIAtBiARqNgLMByALIAtBgARqNgLIByAGIAtByAdqQaTuwQAgDBECAAwCCyAGQQRBiOjBABDNCAALIAZBBEGY6MEAEM0IAAsgBEEDRwRAIARBAWohBCADQQRqIQMgByoCACEIIAdBBGohBwwBCwsgEyALKQOIBDcCACATQQhqIgYgHSkDADcCACARIAtBoARqIgNBCGoiBykDADcDACAPIANBEGoiDSkDADcDACALQcgHaiIEQRhqIgwgA0EYaiIOKQMANwMAIARBIGoiECADQSBqIiIpAwA3AwAgBEEoaiIjIANBKGoiJCkDADcDACAEQTBqIgQgA0EwaiIlKQMANwMAIAsgCykDoAQ3A8gHIAsoApwEIQMgC0GyB2oiJiASQQJqIictAAA6AAAgCyASLwAAOwGw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ASACQfgBaiACQcABahCkAkGMl8MAKAIAIQBBjJfDACACKALAATYCACACIAA2AjAgAEUNACAAIAAoAgAiAEF/ajYCACAAQQFHDQAgAkEwahCdCQsgAigC9AEiBEGMAWohCyAEQUBrIQcgAigCICEIQQAhDCAEKAKMASIAIAQoAkAiAXFFDQMMBAsgAkGMAmogCToAACACQYQCaiACQeABaikDADcCACACQY8CaiACQc4Aai0AADoAACACIAIpA9gBNwL8ASACIAIvAUw7AI0CQQAhBAwHCyABIAsoAgAiAHFFDQALCwsgCEEANgIwDAILIAAoAgQhACACQShqIAFBCGopAgA3AwAgAkEeaiAGQQJqLQAAOgAAIAIgASkCADcDICACIAYvAAA7ARwgAkIANwMwIAIgAEEIaiIFNgJIIAJBiAFqQgA3AwBBACEBIAJBkAFqQQA2AgAgAEE8aiIGLQAAIAZBAToAACACQgA3A4ABIAJCADcDaCACQgA3A1AgAiACQdAAajYCTARAA0AgASABQQFqIAFBB09BACABQQpLGxshASAALQA8IABBAToAPA0ACwsgAkHYAWogAEEgahCiAwJAIAIoAuABBEAgAiACKQPYATcDmAEgAigCTEFAayIBIAIoApwBNgIAIABBADoAPCACQaABaiACQeABaigCADYCAAJAIAEoAgAiAEUEQCAJQQJGDQFBpL/AAEErQey7wAAQ2wkACyAAIAIpAyA3AgAgACAJOgAQIAAgAi8BHDsAESAAQQE6ABUgAEEIaiACQShqKQMANwIAIABBE2ogAkEeai0AADoAAAsgAkECNgL4ASACKAKgASIBKAIAIQAgASAAQX9qNgIAIABBAUcNASACQaABahCdCQwBCyAAQThqLQAARQRAIAJBsAFqIAU2AgAgAkGkAWogAkEoaikDADcCACACQa8BaiACQR5qLQAAOgAAIAIgAikDIDcCnAEgAiAJOgCsASACIAIvARw7AK0BIAJBuAFqIAJByABqNgIAIAJBtAFqIAJBMGo2AgBBiJfDACgCACEAIAIgAkHMAGo2ApgBAkAgAEEBRg0AEOwHIQVBiJfDACgCACEBQYiXwwBBATYCAEGMl8MAKAIAIQBBjJfDACAFNgIAIAIgADYC/AEgAiABNgL4ASABRQ0AIABFDQAgACAAKAIAIgBBf2o2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AHJFOgDMAQwCC0ECIAlBAkYNABogAkGMAmogCToAACACQYQCaiACQeABaikDADcCACACQY8CaiACQc4Aai0AADoAACACIAIpA9gBNwL8ASACIAIvAUw7AI0CQQELIgQ2AvgBDAELIAVBADoAyAEgAkECNgL4AQsgBEF/akECSQRAIAJBkAJqJAAPC0Hst8AAQShB/LjAABDbCQALQewFQQRBoJ3DACgCACIAQa8GIAAbEQAAAAugHgILfyp9IwBBoAFrIgkkAAJAAkACQAJAAkACQAJAAkACQCADQQVPBEAgCUEANgIIIAlCADcDACADQQJ0IQtDAACAPyADs5UhFQNAIAIgCmooAgAiCCAFTw0CIBUgCEEYbCAEaiIIQQhqKgIAIAhBFGoqAgCSQwAAAD+UIhiUIBeSIRcgFSAIQQRqKgIAIAhBEGoqAgCSQwAAAD+UIhaUIBSSIRQgFSAIKgIAIAhBDGoqAgCSQwAAAD+UIhmUIBOSIRMgGyAVIBggGJSUkiEbIBwgFSAWIBaUlJIhHCAeIBUgGSAZlJSSIR4gCyAKQQRqIgpHDQALIAkgEzgCACAJIBQ4AgQgCSAXOAIIIAlB8ABqIgogAiADIAQgBSAJQQIgHCAUIBSUkyIUIB4gEyATlJMiE10iAiAUIBMgAhsgGyAXIBeUk14bIgNBAWpBA3AQsAQgCUH8AGoiAigCACEIIAkoAnghCyAKIAkoAnAgCSgCdCAEIAUgCSADQQJqQQNwIgMQsAQgAigCACENIAkoAnghDiAJKAJ0IQwgCSgCcCEPIAogCyAIIAQgBSAJIAMQsAQgAigCACELIAkoAnghECAJKAJ0IREgCSgCcCESIAFBIGoiCigCACIDIgggAUEcaigCAEYEQCABQRhqIAMQkgYgCigCACEICyABKAIYIAhBB3RqIgJC////+////79/NwMwIAJC////+/f//7//ADcDICACQv////v3//+//wA3AxAgAkL////79///v/8ANwMIIAJC////+/f//7//ADcDACACQgA3A2AgAkHYAGpC////+////79/NwMAIAJB0ABqQv////v///+/fzcDACACQcgAakL////7////v383AwAgAkFAa0L////7////v383AwAgAkE4akL////7////v383AwAgAkEoakL////79///v/8ANwMAIAJBGGpC////+/f//7//ADcDACACQegAakIANwMAIAIgBjYCcCACQQA7AXggAkH0AGogBzoAACAKIAhBAWo2AgAgCUEQaiABIA8gDCAEIAUgA0EAEFYgCUEwaiABIA4gDSAEIAUgA0EBEFYgCUHQAGogASASIBEgBCAFIANBAhBWIAlB8ABqIAEgECALIAQgBSADQQMQViAKKAIAIgIgA00NAyAJKAJwIQQgCSgCUCEFIAkoAjAhBiABKAIYIANBB3RqIgIgCSgCEDYCYCACQewAaiAENgIAIAJB6ABqIAU2AgAgAkHkAGogBjYCACABQSBqIgUoAgAiAiADTQ0EIAlB8ABqIgJBGGoqAgAhEyACQRRqKgIAIRQgAkEQaioCACEXIAJBDGoqAgAhFSACQQhqKgIAIRggCUHQAGoiAkEYaioCACEWIAJBFGoqAgAhGSACQRBqKgIAIRsgAkEMaioCACEcIAJBCGoqAgAhHiAJQTBqIgJBGGoqAgAhGiACQRRqKgIAIR0gAkEQaioCACEfIAJBDGoqAgAhICACQQhqKgIAISQgCUEQaiIEQRhqKgIAISEgBEEUaioCACEiIARBDGoqAgAhIyAEQQhqKgIAISUgCSoCdCEmIAkqAlQhJyAJKgI0ISggCSoCFCEpIANBB3QiBiABKAIYaiICIARBEGoqAgAiKjgCMCACICM4AiAgAiAlOAIQIAIgJjgCDCACICc4AgggAiAoOAIEIAIgKTgCACACQdwAaiATOAIAIAJB2ABqIBY4AgAgAkHUAGogGjgCACACQdAAaiAhOAIAIAJBzABqIBQ4AgAgAkHIAGogGTgCACACQcQAaiAdOAIAIAJBQGsgIjgCACACQTxqIBc4AgAgAkE4aiAbOAIAIAJBNGogHzgCACACQSxqIBU4AgAgAkEoaiAcOAIAIAJBJGogIDgCACACQRxqIBg4AgAgAkEYaiAeOAIAIAJBFGogJDgCACAFKAIAIgIgA00NBSABKAIYIAlCADcDmAEgCUIANwOQASAGaiAJQZABahCyAiAAIAM2AgAgAEEYaiAhIBogISAaYBsiGiAWIBogFmAbIhYgEyAWIBNgGzgCACAAQRRqICIgHSAiIB1gGyITIBkgEyAZYBsiEyAUIBMgFGAbOAIAIABBEGogKiAfICogH2AbIhMgGyATIBtgGyITIBcgEyAXYBs4AgAgAEEMaiAjICAgIyAgXxsiEyAcIBMgHF8bIhMgFSATIBVfGzgCACAAQQhqICUgJCAlICRfGyITIB4gEyAeXxsiEyAYIBMgGF8bOAIAIAAgKSAoICkgKF8bIhMgJyATICdfGyITICYgEyAmXxs4AgQMCQsgAUEgaiIPKAIAIQ5BfyENIANFBEBD//9/fyEkQ///f/8hIUF/IQpBfyELQX8hCEP//3//IRpD//9//yEdQ///f38hH0P//39/ISBD//9//yEiQ///f/8hI0P//3//ISVD//9/fyEmQ///f38hJ0P//39/IShD//9//yEXQ///f/8hG0P//3//IRxD//9/fyEeQ///f38hKUP//39/ISpD//9//yErQ///f/8hLEP//3//IS1D//9/fyEuQ///f38hL0P//39/ITBD//9//yEVQ///f/8hGEP//3//IRZD//9/fyEZQ///f38hE0P//39/IRQMCAsgAigCACIKIAVPDQYgASgCPCIMIApNDQVD//9/fyEkIApBGGwgBGoiCCoCACIwQ///f3+WIRRD//9//yEhIAhBFGoqAgAiK0P//3//lyEVIAhBEGoqAgAiLEP//3//lyEYIAhBDGoqAgAiLUP//3//lyEWIAhBCGoqAgAiLkP//39/liEZIAhBBGoqAgAiL0P//39/liETIAEoAjQgCkEMbGoiCEEAOgAEIAggDjYCACADQQFHDQFBfyELQX8hCEP//3//IRpD//9//yEdQ///f38hH0P//39/ISBD//9//yEiQ///f/8hI0P//3//ISVD//9/fyEmQ///f38hJ0P//39/IShD//9//yEXQ///f/8hG0P//3//IRxD//9/fyEeQ///f38hKUP//39/ISoMBwsgCCAFQdjHwQAQzQgACyACKAIEIgsgBU8EQCALIQoMBQsgASgCPCIMIAtNBEAgCyEKDAQLIBQgC0EYbCAEaiIIKgIAIiogFCAqXxshFCAVIAhBFGoqAgAiFyAVIBdgGyEVIBggCEEQaioCACIbIBggG2AbIRggFiAIQQxqKgIAIhwgFiAcYBshFiAZIAhBCGoqAgAiHiAZIB5fGyEZIBMgCEEEaioCACIpIBMgKV8bIRMgASgCNCALQQxsaiIIQQE6AAQgCCAONgIAIANBAkYEQEF/IQhD//9//yEaQ///f/8hHUP/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I2AbOAIAIABBEGogGyAiIBsgImAbIhsgGiAbIBpgGyIaICEgGiAhYBs4AgAgAEEMaiAYIBwgGCAcXxsiGCAXIBggF18bIhcgGSAXIBlfGzgCACAAQQhqIBUgFiAVIBZfGyIVIBQgFSAUXxsiFCAIIBQgCF8bOAIAIAAgKSAqICkgKl8bIgggKCAIIChfGyIIICcgCCAnXxs4AgQMCQsgAUEgaiIRKAIAIRBBfyEOIANFBEBD//9/fyEoQ///f/8hKUF/IQpBfyEMQX8hC0P//3//ISFD//9//yEaQ///f38hG0P//39/ISJD//9//yEkQ///f/8hJUP//3//IR9D//9/fyEgQ///f38hJkP//39/ISdD//9//yEqQ///f/8hK0P//3//ISxD//9/fyEtQ///f38hLkP//39/IS9D//9//yEcQ///f/8hHkP//3//IR1D//9/fyEjQ///f38hMEP//39/ITFD//9//yEWQ///f/8hGUP//3//IRdD//9/fyEYQ///f38hFUP//39/IRQMCAsgAigCACIKIAVPDQYgCkEYbCAEaiIMQQRqKgIAITAgDEEIaioCACEjIAxBDGoqAgAhHSAMQRBqKgIAIR4gDEEUaioCACEcIAwqAgAhMSAJQRhqIgxBADoABCAMIBA2AgAgASgCPCIPIApNDQVD//9/fyEoIDFD//9/f5YhFEP//3//ISkgHEP//3//lyEWIB5D//9//5chGSAdQ///f/+XIRcgI0P//39/liEYIDBD//9/f5YhFSAJKAIYIQwgASgCNCAKQQR0aiILIAktABw6AAQgCyAMNgIAIANBAUcNAUF/IQxBfyELQ///f/8hIUP//3//IRpD//9/fyEbQ///f38hIkP//3//ISRD//9//yElQ///f/8hH0P//39/ISBD//9/fyEmQ///f38hJ0P//3//ISpD//9//yErQ///f/8hLEP//39/IS1D//9/fyEuQ///f38hLwwHCyAKIAVBwMbAABDNCAALIAIoAgQiDCAFTwRAIAwhCgwFCyAMQRhsIARqIgtBBGoqAgAhLiALQQhqKgIAIS0gC0EMaioCACEsIAtBEGoqAgAhKyALQRRqKgIAISogCyoCACEvIAlBEGoiC0EBOgAEIAsgEDYCACABKAI8Ig8gAigCBCILTQRAIAshCgwECyAUIC8gFCAvXxshFCAWICogFiAqYBshFiAZICsgGSArYBshGSAXICwgFyAsYBshFyAYIC0gGCAtXxshGCAVIC4gFSAuXxshFSAJKAIQIQ0gASgCNCALQQR0aiILIAktABQ6AAQgCyANNgIAIANBAkYEQEF/IQtD//9//yEhQ///f/8hGkP//39/IRtD//9/fyEiQ///f/8hJEP//3//ISVD//9//yEfQ///f38hIEP//39/ISZD//9/fyEnDAYLIAIoAggiCyAFTwRAIAshCgwFCyALQRhsIARqIg1BBGoqAgAhJiANQQhqKgIAISAgDUEMaioCACEfIA1BEGoqAgAhJSANQRRqKgIAISQgDSoCACEnIAlBCGoiDUECOgAEIA0gEDYCACABKAI8Ig8gAigCCCINTQRAIA0hCgwECyAUICcgFCAnXxshFCAWICQgFiAkYBshFiAZICUgGSAlYBshGSAXIB8gFyAfYBshFyAYICAgGCAgXxshGCAVICYgFSAmXxshFSAJKAIIIQ8gASgCNCANQQR0aiINIAktAAw6AAQgDSAPNgIAIANBA0YEQEP//3//ISFD//9//yEaQ///f38hG0P//39/ISIMBgsgAigCDCIOIAVPBEAgDiEKDAULIA5BGGwgBGoiAyoCACEiIANBFGoqAgAhKSADQRBqKgIAISEgA0EMaioCACEaIANBCGoqAgAhKCADQQRqKgIAIRsgCUEDOgAEIAkgEDYCACABKAI8Ig8gAigCDCICTQRAIAIhCgwECyAJKAIAIQMgASgCNCACQQR0aiICIAktAAQ6AAQgAiADNgIAIBQgIiAUICJfGyEUIBUgGyAVIBtfGyEVIBggKCAYIChfGyEYIBcgGiAXIBpgGyEXIBkgISAZICFgGyEZIBYgKSAWIClgGyEWDAULIAMgAkHQxsAAEM0IAAsgAyAEQeDGwAAQzQgACyADIAJB8MbAABDNCAALIAogD0GwxsAAEM0IAAsgCiAFQaDGwAAQzQgACyAJQZwCaiApOAIAIAlBmAJqICE4AgAgCUGUAmogGjgCACAJQZACaiAoOAIAIAlBjAJqIBs4AgAgCUGEAmogJDgCACAJQYACaiAlOAIAIAlB/AFqIB84AgAgCUH4AWogIDgCACAJQfQBaiAmOAIAIAlB7AFqICo4AgAgCUHoAWogKzgCACAJQeQBaiAsOAIA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IABB9QFPBEBBzf97IABNDQIgAEELakF4cSEEQeCdwwAoAgBFDQFBACAEayECAkACQAJ/QQAgBEGAAkkNABpBHyAEQf///wdLDQAaIARBBiAEQQh2ZyIAa3ZBAXEgAEEBdGtBPmoLIgVBAnRB7J/DAGooAgAiAARAIARBAEEZIAVBAXZrIAVBH0YbdCEHA0ACQCAAKAIEQXhxIgYgBEkNACAGIARrIgYgAk8NACAAIQEgBiICDQBBACECDAMLIABBFGooAgAiBiADIAYgB0EddkEEcSAAakEQaigCACIARxsgAyAGGyEDIAdBAXQhByAADQALIAMEQCADIQAMAgsgAQ0CC0EAIQFB4J3DACgCAEEBIAV0QQF0IgBBACAAa3JxIgBFDQNBACAAayAAcWhBAnRB7J/DAGooAgAiAEUNAwsDQCAAIAEgACgCBEF4cSIBIARrIgMgAkkgASAET3EiBRshASADIAIgBRshAiAAKAIQIgMEfyADBSAAQRRqKAIACyIADQALIAFFDQILQeygwwAoAgAiACAET0EAIAIgACAEa08bDQEgASAEaiEDIAEQkAUCQCACQRBPBEAgASAEQQNyNgIEIAMgAkEBcjYCBCACIANqIAI2AgAgAkGAAk8EQCADIAIQjAUMAgsgAkEDdiICQQN0QeSdwwBqIQACf0HcncMAKAIAIgVBASACdCICcQRAIAAoAggMAQtB3J3DACACIAVyNgIAIAALIQIgACADNgIIIAIgAzYCDCADIAA2AgwgAyACNgIIDAELIAEgAiAEaiIAQQNyNgIEIAAgAWpBBGoiACAAKAIAQQFyNgIACyABQQhqIgJFDQEMAgsCQAJAAkACfwJAAkBB3J3DACgCACIFQRAgAEEEakELIABLG0EHakF4cSIEQQN2IgF2IgBBA3FFBEAgBEHsoMMAKAIATQ0HIAANAUHgncMAKAIAIgBFDQdBACAAayAAcWhBAnRB7J/DAGooAgAiASgCBEF4cSAEayECIAEoAhAiAEUEQCABQRRqKAIAIQALIAAEQANAIAAoAgRBeHEgBGsiBSACSSEDIAUgAiADGyECIAAgASADGyEBIAAoAhAiAwR/IAMFIABBFGooAgALIgANAAsLIAEgBGohACABEJAFIAJBEEkNBSABIARBA3I2AgQgACIFIAJBAXI2AgQgACACaiACNgIA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C0EIahCzAgsgCyoCnAEhAyAAIAspA4gBNwIoIABBAToANCAAIBw4AiQgACAdOAIgIAAgIDgCHCAAIBc4AhggACAYOAIUIAAgGzgCECAAIB84AgwgACAlOAIIIAAgJjgCBCAAIAM4AgAgAEEwaiALQZABaigCADYCAAwDCyAAQQQ6ADQMAgsgAEEEOgA0DAELIABBBDoANAsgC0HgAWokAAvhGgMcfwJ+Bn0jAEGQBGsiAyQAIAMgAjYCNCADQSxqIAIqAggiITgCACADQShqICE4AgAgA0EkaiAhOAIAIANBHGogAioCBCIiOAIAIANBGGogIjgCACADQRRqICI4AgAgAyABNgIwIANBADoAOCADICE4AiAgAyAiOAIQIAMgAioCACIhOAIMIAMgITgCCCADICE4AgQgAyAhOAIAAkAgAUEgaigCAARAIANCADcCTCADQey4wQAoAgA2AkggA0HIAGoiAkEAEJAGIAMoAkggAygCUCIEQQN0akKAgICA8P///343AgAgAyAEQQFqNgJQIANB8ABqIAIQnAMCQCADKAJwQQFHBEBBBCEKDAELIANBwANqIgJBDGohFCACQRhqIRUgAUEgaigCACEPIANB6AJqIRogA0HQAmoiAkEDaiEMIAJB1ABqIRYgA0GIA2ohFyACQRxqIRggASgCPCESIAEoAjQhEyABKAIYIRtD//9/fyEhQQQhCgNAICEgAyoCeIxfDQECfwJAIA8gAygCdCICSwRAIANBgAFqIAJBB3QgG2pBgAEQ5AYaIAMtAPgBIgcEQCADKALsASIEIBJJIQIgBEEMbCATakEAIAIbQQhqQQAgAhshHCADKALoASIEIBJJIQIgBEEMbCATakEAIAIbQQhqQQAgAhshHSADKALkASIEIBJJIQIgBEEMbCATakEAIAIbQQhqQQAgAhshHiADKALgASIEIBJJIQIgBEEMbCATakEAIAIbQQhqQQAgAhshGQsgA0GgAmogA0GAAWogAxCfAiADKgKgAiIlICFdIQIgAyoCrAIhIiADKgKoAiEjIAMqAqQCISQgB0UNASADIBw2ArwCIAMgHTYCuAIgAyAeNgK0AiADIBk2ArACQgAhICADQcACaiIEQQhqQgA3AwAgA0IANwPAAiADQQQ2ArgDIANBBDYCnAMgA0EENgKAAyADQQQ2AuQCICQgIV1B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ayICJAACQCAAIgoCfyABKAIEIgBFBEAgCkEcakEANgIAQQAMAQsgASAAQX9qNgIEIAJBgANqIAEoAgAiBBCYAyACKAKEAyEBAkAgAigCgANBAUYNACACQYgDaiIAKQMAIR0gAkGAA2ogBBCYAyACKAKEAyEXIAIoAoADQQFGBEAgFyEBDAELIAQoAgQiA0EHTQRAEIgLIQEMAQsgACkDACEeIAQgA0F4ajYCBCAEIAQoAgAiAEEIajYCACAAKQAAEKYGIhtCIIinIQAgG6cEQCAAIQEMAQsCQAJAAkACQAJAAkACQAJAAkACQAJAIABBgCAgAEGAIEkbIgNFBEBBECENDAELIANBB3QiB0EQEMULIg1FDQELIAJBADYCECACIAM2AgwgAiANNgIIIAAEQCACQaACaiIDQRxqIQ4gA0EMaiEPIAJB8AFqIgNBHGohECADQQxqIRggAkGMA2ohBwNAIAJBAjYC7AEgAiAENgLoASACQYADaiACQegBahCiAiACKAKEAyEDAkACQCACKAKAA0EBRwRAIAJB0AJqIgVBCGoiBiAHQQhqIhEpAgA3AwAgBUEQaiIIIAdBEGoiEikCADcDACAFQRhqIgkgB0EYaiITKQIANwMAIAVBIGoiCyAHQSBqIhQpAgA3AwAgBUEoaiIFIAdBKGoiFSgCADYCACACIAcpAgA3A9ACIANBAUcNBiACKAKIAyEZIAJB8AFqIgNBKGogBSgCADYCACADQSBqIAspAwA3AwAgA0EYaiAJKQMANwMAIANBEGogCCkDADcDACADQQhqIhYgBikDADcDACACIAIpA9ACNwPwASACQYADaiACQegBahCiAiACKAKEAyEDIAIoAoADQQFGDQcgBiARKQIANwMAIAggEikCADcDACAJIBMpAgA3AwAgCyAUKQIANwMAIAUgFSgCADYCACACIAcpAgA3A9ACIANBAUcEQEEBIAJBuANqQdyDwAAQzQUhAQwPCyACKAKIAyERIAJBoAJqIgNBKGogBSgCADYCACADQSBqIAspAwA3AwAgA0EYaiAJKQMANwMAIANBEGogCCkDADcDACADQQhqIgMgBikDADcDACACQeABaiIIIBYoAgA2AgAgAiACKQPQAjcDoAIgAiACKQPwATcD2AEgAiAYQQhqKQIANwPIASACIBgpAgA3A8ABIAIgEEEI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BSgCiAFrIAFxaiAOQQFqIAUoAoQBSRsgACAKGzYCACAKBEAgAiAPNgIwIAQhBwwICyAGQQYgBkEGSRshBEEAIQEDQCABIAR2IAFBAWohAUUNAAsgBkEHSSAGaiEGIAAhAQwBCyAFKAKIASAFKAIAaiABRwRAIAZBBiAGQQZJGyEAQQAhAQNAIAEgAHYgAUEBaiEBRQ0ACyAGQQdJIAZqIQYgCCgCACEBDAELIAxBC0cEQCADKALkASIFQYwBaiELIAVBQGshCCAMQQFqIQwgAygCECECIAUoAowBIgAgBSgCQCIBcUUNAwwECwJAIAMpA4gBQgFRBEAgAygCmAEhACADKQOQASEQELAMQX8gAykDACIRIBBSIBEgEFQbIgFBf0EAIAMoAgggAEkbIAEbQf8BcUECSQ0BC0GIl8MAKAIAIQAgAyADQYgBajYC8AEgAyADQeQBajYC7AEgAyADQRBqNgLoAQJAIABBAUYNABDsByECQYiXwwAoAgAhAUGIl8MAQQE2AgBBjJfDACgCACEAQYyXwwAgAjYCACADIAA2AswBIAMgATYCyAEgAUUNACAARQ0AIAAgACgCACIAQX9qNgIAIABBAUcNACANEJ0JC0GMl8MAKAIAIQBBjJfDAEEANgIAAkAgAEUEQCADEOwHIgA2AsgBIANB6AFqIANByAFqEKQCIAAgACgCACIAQX9qNgIAIABBAUcNASADQcgBahCdCQwBCyAAQgA3AhAgAyAANgKwASADQegBaiADQbABahCkAkGMl8MAKAIAIQBBjJfDACADKAKwATYCACADIAA2AsgBIABFDQAgACAAKAIAIgBBf2o2AgAgAEEBRw0AIANByAFqEJ0JCyADKALkASIFQYwBaiELIAVBQGshCCADKAIQIQJBACEMIAUoAowBIgAgBSgCQCIBcUUNAwwECyADIAk2AuwBQQAhBgwJCyABIAsoAgAiAHFFDQALCwsgAkEANgIwDAILIABBDGooAgAhACADQRhqIAJBCGopAgA3AwAgAyACKQIANwMQIANCADcDICADIABBCGoiAjYCOCADQfgAakIANwMAQQAhASADQYABakEANgIAIABBPGoiBy0AACAHQQE6AAAgA0IANwNwIANCADcDWCADQgA3A0AgAyADQUBrNgI8BEADQCABIAFBAWogAUEHT0EAIAFBCksbGyEBIAAtADwgAEEBOgA8DQALCyADQcgBaiAAQSBqEKIDAkACQCADKALQAQRAIAMgAykDyAE3A4gBIAMoAjxBQGsiASADKAKMATYCACAAQQA6ADwgA0GQAWogA0HQAWooAgA2AgACQCABKAIAIgAEQCAAIAk2AgAgACADKQMQNwIEIABBAToAFSAAQQxqIANBGGopAwA3AgAMAQsgCUECRw0DCyADKAKQASIBKAIAIQAgASAAQX9qNgIAIANBAjYC6AEgAEEBRw0BIANBkAFqEJ0JDAELIABBOGotAABFBEAgA0GgAWogAjYCACADQZgBaiADQRhqKQMANwMAIAMgCTYCjAEgAyADKQMQNwOQASADQagBaiADQThqNgIAIANBpAFqIANBIGo2AgBBiJfDACgCACEAIAMgA0E8ajYCiAECQCAAQQFGDQAQ7AchAkGIl8MAKAIAIQFBiJfDAEEBNgIAQYyXwwAoAgAhAEGMl8MAIAI2AgAgAyAANgLsASADIAE2AugBIAFFDQAgAEUNACAAIAAoAgAiAEF/ajYCACAAQQFHDQAgA0HoAWpBBHIQnQkLQYyXwwAoAgAhAEGMl8MAQQA2AgACQCAARQRAIAMQ7AciADYC6AEgA0HIAWogA0GIAWogA0HoAWoQ2QEgACAAKAIAIgBBf2o2AgAgAEEBRw0BIANB6AFqEJ0JDAELIABCADcCECADIAA2AuQBIANB6AFqIANBiAFqIANB5AFqENkBQYyXwwAoAgAhAEGMl8MAIAMoAuQBNgIAIAMgADYCsAECQCAARQ0AIAAgACgCACIAQX9qNgIAIABBAUcNACADQbABahCdCQsgA0HIAWoiAEEIaiADQegBaiIBQQhqKQMANwMAIABBEGogAUEQaikDADcDACADIAMpA+gBNwPIAQsgA0G4AWoiACADQcgBaiIBQQxqKQIANwMAIANBwAFqIgIgAUEUaigCADYCACADIAMpAswBNwOwAQJAIAMoAsgBIgFBA0cEQCADQegBaiIHQQxqIAApAwA3AgAgB0EUaiACKAIANgIAIAMgATYC6AEgAyADKQOwATcC7AEMAQsgAxDsByIANgLIASADQegBaiADQYgBaiADQcgBahDZASAAIAAoAgAiAEF/ajYCACAAQQFHDQAgA0HIAWoQnQkLIAMoAowBQQJGDQEgAygCoAFBADoANAwBCyAAQQA6ADwgA0HwAWogAykDEDcDACADQfgBaiADQRhqKQMANwMAIAMgCTYC7AEgA0EBNgLoAQsgAygC6AEhBgwFC0Gkv8AAQStB7LvAABDbCQALIABBDGooAgAhBCADQcgAaiACQQhqKQIANwMAIAMgAikCADcDQAJAIAQoAkAiAUEBcUUEQCAEQcQAaigCACEHAkACQANAAn8CQAJAIAFBAXZBH3EiAEEfRwRAIABBHkcNAiAIRQ0BDAILIAUgBUEBaiAFQQdPQQAgBUEKSxsbIQUgBCgCRCEHIAQoAkAMAgtB7AVBBBDFCyIIBEAgCEEAQewFEOgGGgwBCwwLCwJAIAcNAEHsBUEEEMULIgIEQCACQQBB7AUQ6AYhAiAEIAQoAkQiByACIAcbNgJEIAcEQCAIBEAgCBDhAQsgBCgCRCEHIAIhCCAEKAJADAMLIAQgAjYCBCACIQcMAQsMCwsgBCgCQCICIAFGIQYgBCABQQJqIAIgBhs2AkAgBg0CIAVBBiAFQQZJGyEAIAQoAkQhB0EAIQEDQCABIAB2IAFBAWohAUUNAAsgBUEHSSAFaiEFIAILIgFBAXFFDQALQQAhAEEAIQcMAQsgAEEeRw0AIAhFBEBBpL/AAEErQfC6wAAQ2wkACyAEIAg2AkQgBCAEKAJAQQJqNgJAIAcgCDYCACADQdABaiADQcgAaikDADcDACADIAMpA0A3A8gBQR4hAAwCCyAIBEAgCBDhAQsgA0HQAWogA0HIAGopAwA3AwAgAyADKQNANwPIASAHDQELQQIhBiAJQQJGDQQgA0HwAWogAykDQDcDACADQfgBaiADQcgAaikDADcDAAwCCyAAQRhsIAdqIgBBBGogCTYCACAAQQhqIAMpA8gBNwIAIABBEGogA0HQAWopAwA3AgAgAEEYaiIAIAAoAgBBAXI2AgAgBEGcAWotAABFBEAgBEGYAWoiAC0AACAAQQE6AAAEQEEAIQEDQCABIAFBAWogAUEHT0EAIAFBCksbGyEBIAQtAJgBIARBAToAmAENAAsLIAQtAJwBRQRAIANBiAFqIARBgAFqIgEQogMCQCADKAKQASIARQ0AIAAgACgCACIAQX9qNgIAIABBAUcNACADQZABahCdCQsgARCdBCAEIARBiAFqKAIAIARBlAFqKAIAckU6AJwBCyAEQQA6AJgBC0ECIQYMAwsgAkE0aiAHNgIAIAMoAhAiAigCMCIBBEAgAygC5AEhACABIAMpAyA3AgggAUEQaiADQShqKQMANwIAIAEgCTYCBCABIAJBNGooAgA2AgBBAiEGIABBzAFqLQAADQMgAEHIAWoiAS0AACABQQE6AAAEQEEAIQEDQCABIAFBAWogAUEHT0EAIAFBCksbGyEBIAAtAMgBIABBAToAyAENAAsLIAAtAMwBDQIgA0HoAWogAEGwAWoiAhCiAwJAIAMoAvABIgFFDQAgASABKAIAIgFBf2o2AgAgAUEBRw0AIANB8AFqEJ0JCyACEJ0EIAAgAEG4AWooAgAgAEHEAWooAgByRToAzAEMAgtBAiEGIAlBAkYNAiADQfABaiADKQMgNwMAIANB+AFqIANBKGopAwA3AwALIAMgCTYC7AFBASEGDAELIABBADoAyAELIAZBf2pBAkkEQCADQYACaiQADwtB7LfAAEEoQfy4wAAQ2wkAC0HsBUEEQaCdwwAoAgAiAEGvBiAAGxEAAAALjxoDG38CfgZ9IwBBgARrIgMkACADIAI2AjQgA0EsaiACKgIIIiA4AgAgA0EoaiAgOAIAIANBJGogIDgCACADQRxqIAIqAgQiITgCACADQRhqICE4AgAgA0EUaiAhOAIAIAMgATYCMCADQQA6ADggAyAgOAIgIAMgITgCECADIAIqAgAiIDgCDCADICA4AgggAyAgOAIEIAMgIDgCAAJAIAFBIGooAgAEQCADQgA3AkwgA0HsuMEAKAIANgJIIANByABqIgJBABCQBiADKAJIIAMoAlAiBEEDdGpCgICAgPD///9+NwIAIAMgBEEBajYCUCADQfAAaiACEJwDAkAgAygCcEEBRwRAQQQhCQwBCyADQdQDaiEUIAFBIGooAgAhECADQfACaiEZIANB2AJqIgJBA2ohCiACQdQAaiEVIANBkANqIRYgAkEcaiEXIAEoAjwhEiABKAI0IRMgASgCGCEaQ///f38hIEEEIQkDQCAgIAMqAniMXw0BAn8CQCAQIAMoAnQiAksEQCADQYABaiACQQd0IBpqQYABEOQGGiADLQD4ASIHBEAgAygC7AEiBCASSSECIARBDGwgE2pBACACG0EIakEAIAIbIRsgAygC6AEiBCASSSECIARBDGwgE2pBACACG0EIakEAIAIb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QX9qIAlxIQkgDUEUbCASaiIYQQRqKAIAIBRHDQAgGEEIaigCACATRw0ACyAAKAIUIgYoAggiByANQRRsIBJqIgEoAgwiBE0NAiAFQShqIAYoAgAgBEG0AWxqEIwCIAFBDGoiByAAKAIYIg8oAgBBCGooAgA2AgAgAUEQaiAAKAIcLQAAOgAAIA8oAgAiASgCCCIEIAFBBGooAgBGBEAgASAEEPsFIAEoAgghBAsgASgCACAEQbQBbGogBUEoakG0ARDkBhogASAEQQFqNgIIDAULIAAoAhgiDygCACIHQQhqKAIAIQwgACgCHC0AACESAkAgDkUEQCALKAIAKAIAIQ0gCigCACgCACEJQQAhBkEAIQogACgCICgCACIEBEAgBUEoaiIKQRhqIARBGGooAgA2AgAgCkEQaiAEQRBqKQIANwMAIApBCGogBEEIaikCADcDACAFIAQpAgA3AyhBASEKCyAFQYACaiIEQRhqIAVBKGoiC0EYaiIOKAIANgIAIARBEGogC0EQaiIQKQMANwMAIARBCGogC0EIaiIEKQMANwMAIAUgBSkDKDcDgAIgAQRAIA4gAUEYaigCADYCACAQIAFBEGopAgA3AwAgBCABQQhqKQIANwMAIAUgASkCADcDKEEBIQYLIAVB4AFqIgFBGGogDigCADYCACABQRBqIBApAwA3AwAMAQsgCigCACgCACENIAsoAgAoAgAhCUEAIQogAQRAIAVBKGoiBEEYaiABQRhqKAIANgIAIARBEGogAUEQaikCADcDACAEQQhqIAFBCGopAgA3AwAgBSABKQIANwMoQQEhCgsgBUGAAmoiAUEYaiAFQShqIgRBGGoiCygCADYCACABQRBqIARBEGoiDikDADcDACABQQhqIARBCGoiBCkDADcDACAFIAUpAyg3A4ACAn9BACAAKAIgKAIAIgFFDQAaIAsgAUEYaigCADYCACAOIAFBEGopAgA3AwAgBCABQQhqKQIANwMAIAUgASkCADcDKEEBCyEGIAVB4AFqIgFBGGogCygCADYCACABQRBqIA4pAwA3AwALIAFBCGogBCkDADcDACAFIAUpAyg3A+ABQbzBwAAoAgAhCyAMIgQgB0EEaigCAEYEQCAHIAwQ+wUgB0EIaigCACEECyAHKAIAIARBtAFsaiIBQgA3AgQgASALNgIAIAEgCjYC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zAEgAiAHNgLIASACIBMgAkG4AWoiAyACQcgBaiIBEIEClCISIAIqAlyUIBYgAioCoAGUkjgCoAEgAiASIAIqAmCUIBYgAioCpAGUkjgCpAEgAkECNgLMASACIAJBrAFqNgLIASACIBMgAyABEIEClCISIAIqAlyUIBYgAioCrAGUkjgCrAEgEiACKgJglCAWIAIqArABlJIMAQsgAiASIAIqAlyUOAKUASACIBIgAioCYJQ4ApgBIAJBAjYCzAEgAiAHNgLIASACIBMgAkG4AWoiAyACQcgBaiIBEIEClCISIAIqAlyUOAKgASACIBIgAioCYJQ4AqQBIAJBAjYCzAEgAiACQawBajYCyAEgAiATIAMgARCBApQiEiACKgJclDgCrAEgEiACKgJglAshEiACQbABaiIBIBI4AgAgAkEkaiACQZgBaikDADcCACACQSxqIAJBoAFqKQMANwIAIAJBNGogAkGoAWopAwA3AgAgAkE8aiABKAIANgIAIAIgAikDkAE3AhwgAioCfLxB/////wdxviETIAIqAoABvEH/////B3G+IRIgAkEBNgIYIAIgFTgCSCACIBQ4AkQgAiAZOAJAIAIgEzgCUCACIBI4AlQgAkEQaiACQUBrIAJB0ABqIgFBAhCbBSABQQRyIRAgAkEYaiIBQQxqIREgAUEEciELQQAhASACKAIUIQYgAigCECEFAkADQCABIQcgBSAGRgRAIAJByABqIgMgFyADKgIAlDgCACACIBcgAioCQJQ4AkAgAiAXIAIqAkSUOAJEIAJB2ABqIgdBCGoiASADKAIANgIAIAJB7ABqIAJBGGoiA0EIaikDADcCACACQfQAaiADQRBqKQMANwIAIAJB/ABqIANBGGopAwA3AgAgAkGEAWogA0EgaikDADcCACAAIAIpA0A3AgAgAiACKQMYNwJkIABBCGogASkDADcCACAAQRBqIAdBEGopAwA3AgAgAEEYaiAHQRhqKQMANwIAIABBIGogB0EgaikDADcCACAAQShqIAdBKGopAwA3AgAgAEEwaiAHQTBqKAIANgIADAILAkACQCAGIAVrQQFqIgFBAk0EQCABQQJGDQEMAgsgBUEDSQRAIAZBf2oiDkEDSQRAIAZBA0kEQCAFQQJ0IgkgAkFAayIDaiIEKgIAIRIgDkECdCIBIANqIQ8gBkECdCADaiIMKgIAIRggAkHQAGogAWoiDSoCACIVIBWUIhNDAAAAAFwEQCAYIBMgDyoCACAYk0MAAAA/lCIUQwAAwH9DAACAPyAUmCAUIBRcGyATIBQgFJSSELMBlJKVkyEYCyAFQQJJBEAgDiAGIAYgBUsEfSASIBiTIRUgCSAQaiEKIAVBDGwgEWohCCACQdAAaiAJaioCACEYIAUhAQNAIBhDAAAAAFwEQCAYIBiUIBUgFYwgFUMAAAAAYCIDGyIZIBmUkhCzASIUIBSMIAMbIRMgASAFSwRAIApBeGogEzgCAAsCQAJAIAFBAkcEQCAYjCATlSIaIBqUIhwgEpQgGSAUlSIbIBuUIh0gBEEEaiIDKgIAIh6UkiAbIBqUIhYgFpIgCkF8aiIJKgIAIhmUIhSSIRMgAyATOAIAIAQgHSASlCAcIB6UkiAUkzgCACAJIBYgEiAek5QgGSAdIByTlJIiEjgCACABIA5GDQIgAQ0BIAogGyAKKgIAIhWUOAIAIBUgGoyUIRggEiEVDAILQbi6wQBBG0HsvcEAEPwKAAtBuLrBAEEbQfy9wQAQ/AoACyABQQFqIQEgAigCGEEBRgRAIAhBBGoiBCoCACEUIAQgGiAIQXhqIgQqAgAiEpQgGyAUlJI4AgAgBCAbIBKUIBogFJSTOAIAIAhBfGoiBCoCACEUIAQgGyAUlCAaIAhBCGoiBCoCACISlJM4AgAgBCAaIBSUIBsgEpSSOAIAIAggGyAIKgIAIhSUIBogCEEMaiIEKgIAIhKUkzgCACAEIBogFJQgGyASlJI4AgALIApBBGohCiAIQQxqIQggAyEEIBMhEiABIAZHDQELCyANKgIABSAVC7xB/////wdxviAPKgIAvEH/////B3G+IAwqAgC8Qf////8Hcb6SQwAAADSUXxshBgwFC0G4usEAQRtB3L3BABD8CgALQbi6wQBBG0HMvcEAEPwKAAtBuLrBAEEbQby9wQAQ/AoAC0G4usEAQRtBrL3BABD8CgALAkACQCAFQQNJBEAgBUECRg0BIAVBAnQiASACQdAAamoqAgAiGSAZlCIVIAJBQGsgAWoiAyoCACITIANBBGoiASoCACIUk0MAAAA/lCISIBKUkiISQwAAAABgRQ0CIAEgEyAUkkMAAAA/lCITIBIQswEiEpM4AgAgAyATIBKSIhI4AgACQCACKAIYQQFGBEAgEiAUkyISQwAAAABgIQMgFSASIBKMIAMbIhIgEpSSELMBIhVDAAAANF4NAQsgBkF/aiEGDAQLIAVBDGwgC2oiBEEMaiIBKgIAIRMgASASIBWVIhQgE5QgGSAVIBWMIAMblSIVIAQqAgAiEpSTOAIAIAQgFCASlCAVIBOUkjgCACAEQQRqIgEqAgAhEyABIBQgE5QgFSAEQRBqIgEqAgAiEpSSOAIAIAEgFCASlCAVIBOUkzgCACAEQQhqIgEqAgAhEyABIBQgE5QgFSAEQRRqIgEqAgAiEpSSOAIAIAEgFCASlCAVIBOUkzgCACAGQX9qIQYMAwtBuLrBAEEbQYy+wQAQ/AoAC0G4usEAQRtBnL7BABD8CgALQeS2wQBBK0GsvsEAENsJAAsgAkEIaiACQUBrIAJB0ABqIAYQmwUgAigCDCEGIAIoAgghBSAHQQFqIgEgB08NAAsgAEECNgIMCyACQdABaiQAC50XAgt/KX0CQAJAAkAgACgCAEEBaw4CAgEACyAAKAIEIgQgA0kEQCAEQRxsIAJqIgMqAhAhEyADKgIMIRwgAyoCCCEWIAMqAgQhFyADKgIAIRggA0EYaiIFKgIAIREgA0EUaiIGKgIAIRAgAEGoAWotAAAiAgRAIAFBIGoqAgAhLSACQQxsIQdBACECQegAIQEDQAJAIAJBMEcEQCAAKgKAASIbIBEgACACaiIEQUBrKgIAIhIgHCAYIARBPGoqAgAiD5QgFyAEQThqKgIAIh2UkyIVIBWSIhqUIBggFiAdlCAYIBKUkyIVIBWSIh6UIBcgFyASlCAWIA+UkyISIBKSIhKUk5KSkiIhIARBEGoqAgCTlCAAKgJ4IhUgEyAdIBwgEpQgFyAalCAWIB6Uk5KSkiIlIARBCGoqAgCTlCAAKgJ8Ih0gECAPIBwgHpQgFiASlCAYIBqUk5KSkiIeIARBDGoqAgCTlJKSIg8gACABaioCAIwgLZMiKF1FDQFDAAAAACESIAAqAqQBjCIaIBogDyAokyAAKgKgAZQiDyAPIBpdGyAPIA9cGyAAKgKEASIoIAAqApQBIBUgISARkyIalCAbICUgE5MiIZSTjCIPlCAAKgKMASIlIBsgHiAQkyIelCAdIBqUkyIalJMgACoCmAEiIiAdICGUIBUgHpSTIh6UkyIhIA+UIBogJSAPlCAaIAAqAogBlJMgHiAAKgKQASIllJMiGZSTIB4gIiAPlCAaICWUkyAeIAAqApwBlJMiGpSTkpUhDyAbICggD4yUIhuUISUgHSAblCEoIBUgG5QhIkMAAIA/IRtDAAAAACEVQwAAAAAhHSAaIA+UQwAAAD+UIhogGpQgGSAPlEMAAAA/lCIeIB6UICEgD5RDAAAAP5QiDyAPlJKSQwAAAACSIiFDAACAKF9FBEAjAEEQayIEQwAAAH84AgwgBCoCDBogIRCzASISEOABIRVDAACAPyASEOMBlCEbIBpDAACAPyAVlCASlSISlCEdIA8gEpQhFSAeIBKUIRILIBcgEpQhDyAYIBWUIRogHCAdlCAcIBWUISEgGCAdlCAcIBKUIRQgHCAblCAYIBKUkyAXIBWUkyAWIB2UkyEcIBEgJZIhESAQICiSIRAgEyAikiETIBYgFZQgFCAYIBuUkpIgFyAdlJMhGCAhIBcgG5QgFiASlJOSkiEXIA8gFiAblJIgGpOSIRYMAQtBBEEEQciJwQAQzQgACyABQQRqIQEgByACQQxqIgJHDQALCyADQQRqIBc4AgAgAyAYOAIAIANBCGogFjgCACADQQxqIBw4AgAgA0EQaiATOAIAIAYgEDgCACAFIBE4AgAPCyAEIANBuInBABDNCAALQey3wABBKEG0h8EAENsJAAsgACgCBCIEIANJBEAgAEEIaigCACIFIANJBEAgBUEcbCACaiIDKgIQIRogAyoCDCEdIAMqAgghEiADKgIEIRsgAyoCACEVIANBGGoiBioCACEeIANBFGoiByoCACEtIARBHGwgAmoiBCoCACEWIARBBGoiCCoCACEXIARBCGoiCSoCACEYIARBDGoiCioCACEcIARBEGoiCyoCACEhIARBFGoiDCoCACElIARBGGoiDSoCACEoIABByAFqLQAAIgIEQCABQSBqKgIAITAgAkEMbCEOQQAhAkHsACEBA0ACQCACQTBHBEAgFiAAKgKAASIUlCAXIAAqAnwiH5STIhMgE5IhECAYIB+UIBYgACoChAEiE5STIhEgEZIhDyAAIAJqIgVBxABqKgIAIREgFiAFQRBqKgIAIiOUIBcgBUEMaioCACIklJMiIiAikiEiIBggJJQgFiAFQRRqKgIAIiCUkyIZIBmSIRkgEyAcIBCUIBYgD5QgFyAXIBOUIBggFJSTIhMgE5IiJ5STkpIiEyAeIBEgHSAVIAVBQGsqAgAiKZQgGyAFQTxqKgIAIiqUkyImICaSIiaUIBUgEiAqlCAVIBGUkyIrICuSIiuUIBsgGyARlCASICmUkyIRIBGSIiyUk5KSkiIuICggICAcICKUIBYgGZQgFyAXICCUIBggI5STIhEgEZIiIJSTkpKSk5QgHyAcICeUIBcgEJQgGCAPlJOSkiIRIBogKiAdICyUIBsgJpQgEiArlJOSkpIiKiAhICQgHCAglCAXICKUIBggGZSTkpKSk5QgFCAcIA+UIBggJ5QgFiAQlJOSkiIPIC0gKSAdICuUIBIgLJQgFSAmlJOSkpIiJCAlICMgHCAZlCAYICCUIBYgIpSTkpKSk5SSkiIQIAAgAWoqAgCMIDCTIiBdRQ0BQwAAAAAhIiATICQgDyAQlJMgJZMiH5QgDyAuIBMgEJSTICiTIhSUkyIZIAAqApABlCAAKgKUASInIBEgFJQgEyAqIBEgEJSTICGTIiOUkyIUlJIgACoCmAEiJiAPICOUIBEgH5STIh+UkiEpIAAqAsQBjCIjICMgECAgkyAAKgLAAZQiECAQICNdGyAQIBBcGyAZICmUIBQgGSAnlCAUIAAqApwBlJIgHyAAKgKgASIQlJIiK5SSIB8gGSAmlCAUIBCUkiAfIAAqAqQBlJIiJpSSIAAqAogBIh8gACoCjAEiI5KSIAAqArQBIBEgLiAekyIZlCATICogGpMiFJSTjCIQlCAAKgKsASIgIBMgJCAtkyIklCAPIBmUkyIZlJMgACoCuAEiJyAPIBSUIBEgJJSTIhSUkyIsIBCUIBkgICAQlCAZIAAqAqgBlJMgFCAAKgKwASIklJMiLpSTIBQgJyAQlCAZICSUkyAUIAAqArwBlJMiL5STkpUhECAfIBCUISAgIyAQjJQhJ0MAAIA/IRlDAAAAACEUQwAAAAAhH0MAAAAAISNDAACAPyEkICYgEJRDAAAAP5QiKiAqlCApIBCUQwAAAD+UIikgKZQgKyAQlEMAAAA/lCImICaUkpJDAAAAAJIiK0MAAIAoX0UEQCMAQRBrIgVDAAAAfzgCDCAFKgIMGiArELMBIhQQ4AEhH0MAAIA/IBQQ4wGUISQgKkMAAIA/IB+UIBSVIhSUISMgJiAUlCEfICkgFJQhFAsgEyAglCEpIA8gIJQhKiARICCUISYgEyAnlCErIA8gJ5QhMSARICeUISdDAAAAACERQwAAAAAhEyAvIBCUQwAAAD+UIg8gD5QgLiAQlEMAAAA/lCIgICCUICwgEJRDAAAAP5QiECAQlJKSQwAAAACSIixDAACAKF9FBEAjAEEQayIFQwAAAH84AgwgBSoCDBogLBCzASITEOABIRFDAACAPyATEOMBlCEZIA9DAACAPyARlCATlSIRlCETICAgEZQhIiAQIBGUIRELIBsgIpQhECAVIBGUIQ8gHSATlCAdIBGUISwgFSATlCAdICKUIS8gHSAZlCAVICKUkyAbIBGUkyASIBOUkyEdIBwgI5QgGCAUlCEzIBwgH5QhNCAcIBSUITUgGCAflCE2IBcgI5QhNyAcICSUIBYgFJSTIBcgH5STIBggI5STIRwgHiArkiEeIC0gMZIhLSAaICeSIRogKCApkiEoICUgKpIhJSAhICaSISEgFyAUlCAYICSUkiAWIB+Uk5IhGCAWICOUIDQgFyAklCAzk5KSIRcgNiA1IBYgJJSSkiA3kyEWIBIgEZQgLyAVIBmUkpIgGyATlJMhFSAsIBsgGZQgEiAilJOSkiEbIBAgEiAZlJIgD5OSIRIMAQtBBEEEQYSIwQAQzQgACyABQQRqIQEgDiACQQxqIgJHDQALCyAIIBc4AgAgCSAYOAIAIAogHDgCACALICE4AgAgDCAlOAIAIA0gKDgCACAEIBY4AgAgA0EEaiAbOAIAIANBCGogEjgCACADQQxqIB04AgAgA0EQaiAaOAIAIAcgLTgCACAGIB44AgAgAyAVOAIADwsgBSADQfSHwQAQzQgACyAEIANB5IfBABDNCAALlxgDEX8Bfgx9IwBBkAJrIgckACAAKAIAKAIAIglBBGooAgAhBSAFIAAoAggoAgAoAgAiDSAAKAIEKAIAIg5BufPd8XlsQQV3c0G5893xeWwiEiAJKAIAIhBxIgRqKAAAIgogEkEZdiIUQYGChAhsIg9zIghBf3MgCEH//ft3anFBgIGChHhxIQsgCUEYaigCACEMIAlBEGooAgAhEQJAAkACQAJAAkACQAJAAkADQCALRQRAA0AgCkEBdCAKcUGAgYKEeHENAyAEIAZqIQQgBkEEaiEGIA8gBSAEQQRqIBBxIgRqKAAAIgpzIghBf3MgCEH//ft3anFBgIGChHhxIgtFDQALCyALaEEDdiAEaiAQcUF/c0ECdCAFaigCACIIIAxPDQIgC0F/aiALcSELIAhBFGwgEWoiE0EEaigCACAORw0AIBNBCGooAgAgDUcNAAsgACgCDCINKAIIIg4gCEEUbCARaiIEKAIMIgVNDQIgB0EIaiANKAIAIAVBtAFsahCMAiAEQQxqIgogACgCECIRKAIAQQhqKAIANgIAIARBEGogACgCFC0AADoAACARKAIAIgUoAggiBCAFQQRqKAIARgRAIAUgBBD7BSAFKAIIIQQLIAUoAgAgBEG0AWxqIAdBCGpBtAEQ5AYaIAUgBEEBajYCCAwFCyAAKAIQIhEoAgAiCkEIaigCACEQIAAoAhQtAAAhEwJ/IAAoAhgtAABFBEBBACEMQQAhCyABBEAgB0EIaiIEQRhqIAFBGGooAgA2AgAgBEEQaiABQRBqKQIANwMAIARBCGogAUEIaikCADcDACAHIAEpAgA3AwhBASELCyAHQcABaiIEQRhqIAdBCGoiBUEYaigCADYCACAEQRBqIAVBEGopAwA3AwAgBEEIaiAFQQhqKQMANwMAIAcgBykDCDcDwAEgDSEFIA4MAQtBACEMIAEEQCAHQQhqIgRBGGogAUEYaigCADYCACAEQRBqIAFBEGopAgA3AwAgBEEIaiABQQhqKQIANwMAIAcgASkCADcDCEEBIQwLIAdB4AFqIgRBGGogB0EIaiIFQRhqKAIANgIAIARBEGogBUEQaikDADcDACAEQQhqIAVBCGopAwA3AwAgByAHKQMINwPgAUEAIQsgDiEFIA0LIQhBvMHAACgCACEPIBAiBCAKQQRqKAIARgRAIAogEBD7BSAKQQhqKAIAIQQLIAooAgAgBEG0AWxqIgZCADcCBCAGIA82AgAgBiAMNgIsIAYgBTYCKCAGIAg2AiQgBiALNgJMIAZBDGpCADcCACAGQRRqQgA3AgAgBkEcakIANwIAIAZBMGogBykD4AE3AgAgBkE4aiAHQeABaiIFQQhqKQMANwIAIAZBQGsgBUEQaikDADcCACAGQcgAaiAFQRhqKAIANgIAIAZBiAFqQgA3AgAgBkGQAWpCADcCACAGQZgBakIANwIAIAZBpAFqQgA3AgAgBkGqAWpCADcBACAGQdAAaiAHKQPAATcCACAGQdgAaiAHQcABaiIFQQhqKQMANwIAIAZB4ABqIAVBEGopAwA3AgAgBkHoAGogBUEYaigCADYCACAGQQA2AmwgBkH4AGpBADYCACAGQYQBakGAgID8AzYCACAGQaABaiAPNgIAIApBCGogBEEBajYCACAJQQRqKAIAIgQgEiAJKAIAIgtxIgZqKAAAQYCBgoR4cSIMRQRAQQQhCgNAIAYgCmogCkEEaiEKIAtxIgYgBGooAABBgIGChHhxIgxFDQALCyAJQRhqKAIAIQggDGhBA3YgBmogC3EiBiAEaiwAACIFQX9KBEAgBCgCAEGAgYKEeHFoQQN2IgYgBGotAAAhBQsgBUEBcSEMAkAgCUEIaiIPKAIADQAgDEUNACAHQQhqIAkgCSgCECAIELABIAlBBGooAgAiBCASIAkoAgAiC3EiCmooAABBgIGChHhxIgVFBEBBBCEGA0AgBiAKaiAGQQRqIQYgC3EiCiAEaigAAEGAgYKEeHEiBUUNAAsLIAVoQQN2IApqIAtxIgYgBGosAABBf0wNACAEKAIAQYCBgoR4cWhBA3YhBgsgBCAGaiAUOgAAIAZBfGogC3EgBGpBBGogFDoAACAPIA8oAgAgDGsiCzYCACAJQQxqIgooAgBBAWohBSAKIAU2AgAgBkF/c0ECdCAEaiAINgIAIAggCUEUaigCACIERwRAIAlBGGooAgAhBgwECyAFIAtqIAlBGGooAgAiBmshBCAIIAZrIARPBEAgCCEEDAQLIAQgBmoiBCAGSQ0CIAStQhR+IhVCIIinRUECdCEEIBWnIQUCQCAIBEAgB0EQakEENgIAIAcgCEEUbDYCDCAHIAkoAhA2AggMAQsgB0EANgIICyAHQYACaiAFIAQgB0EIahCcByAHKAKAAkEBRwRAIAcoAoQCIQUgCUEUaiAHQYgCaigCAEEUbiIENgIAIAkgBTYCEAwECyAHQYgCaigCACIARQ0CIAcoAoQCIABBoJ3DACgCACIAQa8GIAAbEQAAAAsgCCAMQcTewAAQzQgACyAFIA5B6NHAABDNCAALEJEMAAsgBCAGRgRAIAlBEGogBBD8BSAJQRhqKAIAIQYLIAlBGGogBkEBaiIFNgIAIAkoAhAgBkEUbGoiBCAQNgIMIAQgDjYCBCAEIBI2AgAgBEEQaiATOgAAIARBCGogDTYCACAFIAhNDQEgCSgCECAIQRRsakEMaiEKCyARKAIAIgUoAggiDSAKKAIAIgRNDQEgBSgCACAEQbQBbGohBSAAKAIcIgQoAgQhDSAEKAIAIQ4CQCAAKAIYLQAARQRAIAAoAiwoAgAhBAJAIAEEQCABQRRqKgIAIhwgBCoCACIYlCABKgIQIh8gBEEEaioCACIZlJMhGiAfIARBCGoqAgAiG5QgAUEYaioCACIXIBiUkyIWIBaSIR0gB0EIaiIIQRhqIARBGGoqAgAgFyAEQQxqKgIAIhYgGiAakiIglCAYIB2UIBkgFyAZlCAcIBuUkyIaIBqSIiGUk5KSkjgCACAIQRRqIARBFGoqAgAgHCAWIB2UIBsgIZQgGCAglJOSkpI4AgAgByAWIAEqAgwiHJQgGCABKgIAIhqUkyAZIAEqAgQiF5STIBsgASoCCCIelJM4AhQgByAbIByUIBggF5QgFiAelJIgGSAalJOSOAIQIAcgGyAalCAZIByUIBYgF5QgGCAelJOSkjgCDCAHIBkgHpQgFiAalCAYIByUkpIgGyAXlJM4AgggByAEQRBqKgIAIB8gFiAhlCAZICCUIBsgHZSTkpKSOAIYDAELIAdBCGoiAUEYaiAEQRhqKAIANgIAIAFBEGogBEEQaikCADcDACABQQhqIARBCGopAgA3AwAgByAEKQIANwMICyAOIAdBCGogACgCJEGsy8AAIAIgAyAAKAIoKgIAIAUgDSgCMBEXABoMAQsgACgCICgCACEEAkAgAQRAIAFBBGoqAgAiGCAEQRBqKgIAIAEqAhCTIhyUIAEqAgAiGSAEQRRqKgIAIAFBFGoqAgCTIhqUkyEXIAFBCGoqAgAiGyAalCAYIARBGGoqAgAgAUEYaioCAJMiHpSTIhYgFpIhHSAHQQhqIghBGGogHiABKgIMIhYgFyAXkiIXlCAYIB2UIBkgGSAelCAbIByUkyIeIB6SIh6Uk5KSOAIAIAhBFGogGiAWIB6UIBkgF5QgGyAdlJOSkjgCACAHIBwgFiAdlCAbIB6UIBggF5STkpI4AhggByAbIAQqAggiHZQgGCAEKgIEIhyUIBkgBCoCACIalCAWIAQqAgwiF5SSkpI4AhQgByAYIBqUIBYgHZQgGSAclJOSIBsgF5STOAIQIAcgFiAclCAZIB2UkiAYIBeUkyAbIBqUkzgCDCAHIBsgHJQgFiAalCAZIBeUkyAYIB2Uk5I4AggMAQsgB0EIaiIBQRhqIARBGGooAgA2AgAgAUEQaiAEQRBqKQIANwMAIAFBCGogBEEIaikCADcDACAHIAQpAgA3AwgLIA4gB0EIaiACIAMgACgCJEGsy8AAIAAoAigqAgAgBSANKAIwERcAGgsgB0GQAmokAA8LIAggBUH03sAAEM0IAAsgBCANQfjRwAAQzQgAC8IaAwd/An4NfSMAQbADayIGJAAgBkGQAWogAiADKAJYIggRAAAgBigCkAEiByAGKAKUASgCDBEEACENIAZBiAFqIAQgBSgCWCIKEQAAIAYoAogBIgkgBigCjAEoAgwRBAAhDgJAAkACQAJAIAdBACANQrGO+/nBtc6AOlEbIgcEQCAJQQAgDkKxjvv5wbXOgDpRGyIJDQELIAZBgAFqIAIgCBEAACAGKAKAASIHIAYoAoQBKAIMEQQAIQ0gBkH4AGogBCAKEQAAIAYoAngiCSAGKAJ8KAIMEQQAIQ4CQAJAAkACQCAHQQAgDULjuoeA3Yn6uNcAURsiBwRAIAlBACAOQuO6h4Ddifq41wBRGyIJDQELIAZB8ABqIAIgCBEAACAGKAJwIgcgBigCdCgCDBEEACENIAZB6ABqIAQgChEAACAGKAJoIgkgBigCbCgCDBEEACEOIAdBACANQsSgofH/mKCvkX9RGyIHBEAgCUEAIA5C47qHgN2J+rjXAFEbIgkNAgsgBkHgAGogAiAIEQAAIAYoAmAiByAGKAJkKAIMEQQAIQ0gBkHYAGogBCAKEQAAIAYoAlgiCSAGKAJcKAIMEQQAIQ4gB0EAIA1C47qHgN2J+rjXAFEbIgcEQCAJQQAgDkLEoKHx/5igr5F/URsiCQ0DCyAGQdAAaiACIAgRAAAgBigCUCIHIAYoAlQoAgwRBABCsY77+cG1zoA6Ug0DIAdFDQMgBiABKgIMIhMgASoCACIPIAFBFGoqAgAiEZQgASoCBCISIAEqAhAiFZSTIhAgEJIiFpQgEiASIAFBGGoqAgAiGJQgASoCCCIQIBGUkyIXIBeSIheUIA8gECAVlCAPIBiUkyIUIBSSIhSUk5IgGJM4AvACIAYgEyAUlCAPIBaUIBAgF5STkiARkzgC7AIgBiATIBeUIBAgFJQgEiAWlJOSIBWTOALoAkEBIQAgBkGYAWogBCAGQegCakEBIAUoAiQRAgAgBi0ApAENByAGKgLoAiAGKgKYAZMiDyAPlCAGKgLsAiAGKgKcAZMiDyAPlJIgBioC8AIgBioCoAGTIg8gD5SSQwAAAACSIAcqAgAiDyAPlF8hAAwHCyAGQZgBaiAHIAkgARD8AUEAIQAgBioCmAFDAAAAAF4NBiAGQZgBaiICQQhqIgMgAUEIaikCADcDACACQRhqIgQgAUEYaigCADYCACADIAMqAgAiD4w4AgAgBiABKQIQNwOoASAGIAEpAgA3A5gBIA8gBioCqAEiFZQgBioCmAEiEiAEKgIAIhaUkyIQIBCSIRMgEiAGQawBaiIDKgIAIhiUIAYqApwBIhAgFZSTIhEgEZIhESADIAYqAqQBIhcgE5QgEiARlCAPIBAgFpQgDyAYlJMiFCAUkiIUlJOSIBiTOAIAIAQgFyARlCAQIBSUIBIgE5STkiAWkzgCACAGIBKMOAKYASAGIBCMOAKcASAGIBcgFJQgDyATlCAQIBGUk5IgFZM4AqgBIAZB6AJqIAkgByACEPwBIAYqAugCQwAAAABeDQYgBkHoAmogByAJIAEQkgIgBioC6AJDAAAAAF8hAAwGCyAGQZgBaiIAQQhqIgIgAUEIaikCADcDACAAQRhqIgMgAUEYaigCADYCACACIAIqAgAiD4w4AgAgBiABKQIQNwOoASAGIAEpAgA3A5gBIA8gBioCqAEiFZQgBioCmAEiEiADKgIAIhaUkyIQIBCSIRMgEiAGQawBaiIBKgIAIhiUIAYqApwBIhAgFZSTIhEgEZIhESABIAYqAqQBIhcgE5QgEiARlCAPIBAgFpQgDyAYlJMiFCAUkiIUlJOSIBiTOAIAIAMgFyARlCAQIBSUIBIgE5STkiAWkzgCACAGIBKMOAKYASAGIBCMOAKcASAGIBcgFJQgDyATlCAQIBGUk5IgFZM4AqgBIAAgCSAHEIQBIQAMBQsgASAHIAkQhAEhAAwECyAGQcgAaiAEIAoRAAACQCAGKAJIIgcgBigCTCgCDBEEAEKxjvv5wbXOgDpSDQAgB0UNACAGQfACaiABQRhqKAIANgIAIAYgASkCEDcD6AJBASEAIAZBmAFqIAIgBkHoAmpBASADKAIkEQIAIAYtAKQBDQQgBioC6AIgBioCmAGTIg8gD5QgBioC7AIgBioCnAGTIg8gD5SSIAYqAvACIAYqAqABkyIPIA+UkkMAAAAAkiAHKgIAIg8gD5RfIQAMBAsgBkFAayACIAgRAAAgBigCQCIIIAYoAkQoAgwRBAAhDSAGQThqIAQgBSgCoAEiCREAACAIQQAgDUKvmtbbqfnbiO4AURsiCARAIAYoAjgiBw0CCyAGQTBqIAIgAygCoAEiCxEAACAGKAI0IQwgBigCMCEHIAZBKGogBCAKEQAAIAYoAigiCCAGKAIsKAIMEQQAIQ0gBwRAIAhBACANQq+a1tup+duI7gBRGyIIDQMLIAZBIGogAiALEQAAIAYoAiQhCiAGKAIgIQggBkEYaiAEIAkRAAACQAJAIAgEQCAGKAIYIgcNAQsgBkEQaiACIAMoAqQBEQAAIAYoAhAiCEUNASAAIAEgCCAGKAIUIAQgBRB1IQAMBQsgBigCHCEAIAZBsAFqQQA2AgAgBkHQAmpCADcDACAGQgA3A6gBIAZCADcDyAIgBkKCgICAMDcDoAEgBkKAgICAEDcDmAEgBkG0AWpBAEGUARDoBhpDAACAPyEPIAEqAhAiEyATlCABQRRqKgIAIhEgEZSSIAFBGGoqAgAiFSAVlJJDAAAAAJIiFkMAAIAoXgRAIBUgFhCzASIPlSEQIBEgD5UhEiATIA+VIQ8LIAZB2AJqIgJBCGoiBCAQOAIAIAYgEjgC3AIgBiAPOALYAiAGQZADaiAIIAIgCigCDBEBACAGQegCaiICQQhqIgMgBCgCADYCACADIAMqAgCMOAIAIAYgBikD2AI3A+gCIAYgBioC6AKMOALoAiAGIAYqAuwCjDgC7AIgBkGgA2ogByABIAIgACgCFBECACAGQdgBaiAGKgKoAyIPOAIAIAZB1AFqIAYqAqQDIhI4AgAgBkHQAWogBioCoAMiEDgCACAGQcwBaiAGKgKYAyITOAIAIAZByAFqIAYqApQDIhE4AgAgBkHEAWogBioCkAMiFTgCACAGQZgBaiIDQShqIBMgD5M4AgAgBkG8AWogESASkzgCACAGQQA2AtQCIAZBADYCtAEgBiAVIBCTOAK4ASACIAEgCCAKIAcgAEMAAAAAQQAgAxDAAUEBIQACQAJAIAYoAugCQQFrDgMAAQEGC0GszcEAQShBnOTBABDbCQALQQAhAAwECyAGQQhqIAQgBSgCpAERAAAgBigCCCIKRQRAQQIhAAwECyAGKAIMIQcgBkGYAWoiBEEIaiIFIAFBCGopAgA3AwAgBEEYaiIIIAFBGGooAgA2AgAgBSAFKgIAIg+MOAIAIAYgASkCEDcDqAEgBiABKQIANwOYASAPIAYqAqgBIhWUIAYqApgBIhIgCCoCACIWlJMiECAQkiETIBIgBkGsAWoiASoCACIYlCAGKgKcASIQIBWUkyIRIBGSIREgASAGKgKkASIXIBOUIBIgEZQgDyAQIBaUIA8gGJSTIhQgFJIiFJSTkiAYkzgCACAIIBcgEZQgECAUlCASIBOUk5IgFpM4AgAgBiASjDgCmAEgBiAQjDgCnAEgBiAXIBSUIA8gE5QgECARlJOSIBWTOAKoASAAIAQgCiAHIAIgAxB1IQAMAwsgASoCECIPIA+UIAFBFGoqAgAiDyAPlJIgAUEYaioCACIPIA+UkkMAAAAAkiAHKgIAIAkqAgCSIg8gD5RfIQAMAgsgBigCPCEAIAYgCEEIaioCACIPjDgCoAEgBiAIQQRqKgIAIhKMOAKcASAGIAgqAgAiEIw4ApgBIAZB6AJqIAcgASAGQZgBaiAAKAIYEQIAIBAgBioC6AKUIBIgBioC7AKUkiAPIAYqAvAClJJDAAAAAF8hAAwBCyAIQQRqKgIAIRUgCEEIaioCACEWIAgqAgAhGCAGQZgBaiIAQQhqIgIgAUEIaikCADcDACAAQRhqIgMgAUEYaigCADYCACACIAIqAgAiD4w4AgAgBiABKQIQNwOoASAGIAEpAgA3A5gBIA8gBioCqAEiF5QgBioCmAEiEiADKgIAIhSUkyIQIBCSIRMgEiAGQawBaiIBKgIAIhqUIAYqApwBIhAgF5STIhEgEZIhESABIAYqAqQBIhsgE5QgEiARlCAPIBAgFJQgDyAalJMiGSAZkiIZlJOSIBqTOAIAIAMgGyARlCAQIBmUIBIgE5STkiAUkzgCACAGIBKMOAKYASAGIBCMOAKcASAGIBsgGZQgDyATlCAQIBGUk5IgF5M4AqgBIAYgFow4AvACIAYgFYw4AuwCIAYgGIw4AugCIAZBoANqIAcgACAGQegCaiAMKAIYEQIAIBggBioCoAOUIBUgBioCpAOUkiAWIAYqAqgDlJJDAAAAAF8hAAsgBkGwA2okACAAC+kXAhB/DH0jAEGQAmsiBiQAIAAoAgAoAgAiCUEEaigCACEIIAggACgCBCgCACgCACILQbnz3fF5bCIRIAkoAgAiDHEiBGooAAAiByARQRl2IhJBgYKECGwiD3MiDUF/cyANQf/9+3dqcUGAgYKEeHEhCiAJQRhqKAIAIQ4gCUEQaigCACEQAkACQAJAAkACQAJAAkACQANAIApFBEADQCAHQQF0IAdxQYCBgoR4cQ0DIAQgBWohBCAFQQRqIQUgDyAIIARBBGogDHEiBGooAAAiB3MiDUF/cyANQf/9+3dqcUGAgYKEeHEiCkUNAAsLIApoQQN2IARqIAxxQX9zQQJ0IAhqKAIAIg0gDk8NAiAKQX9qIApxIQogDUEEdCAQaigCBCALRw0ACyAAKAIIIgcoAggiCCANQQR0IBBqIgQoAggiC00NAiAGQQhqIAcoAgAgC0G0AWxqEIwCIARBCGoiByAAKAIMIhAoAgBBCGooAgA2AgAgBEEMaiAAKAIQLQAAOgAAIBAoAgAiCygCCCIEIAtBBGooAgBGBEAgCyAEEPsFIAsoAgghBAsgCygCACAEQbQBbGogBkEIakG0ARDkBhogCyAEQQFqNgIIDAULIAAoAgwiECgCACIOQQhqKAIAIQ0gACgCEC0AACETAn8gACgCFC0AAEUEQEEAIQhBACEKIAEEQCAGQQhqIgRBGGogAUEYaigCADYCACAEQRBqIAFBEGopAgA3AwAgBEEIaiABQQhqKQIANwMAIAYgASkCADcDCEEBIQoLIAZB4AFqIgRBGGogBkEIaiIHQRhqKAIANgIAIARBEGogB0EQaikDADcDACAEQQhqIAdBCGopAwA3AwAgBiAGKQMINwPgAUEAIQwgCwwBC0EAIQwgAQRAIAZBCGoiBEEYaiABQRhqKAIANgIAIARBEGogAUEQaikCADcDACAEQQhqIAFBCGopAgA3AwAgBiABKQIANwMIQQEhDAsgBkHAAWoiBEEYaiAGQQhqIgdBGGooAgA2AgAgBEEQaiAHQRBqKQMANwMAIARBCGogB0EIaikDADcDACAGIAYpAwg3A8ABIAshCEEAIQpBAAshB0G8wcAAKAIAIQ8gDSIEIA5BBGooAgBGBEAgDiANEPsFIA5BCGooAgAhBAsgDigCACAEQbQBbGoiBUIANwIEIAUgDzYCACAFIAo2AiwgBSAINgIoIAUgBzYCJCAFIAw2AkwgBUEMakIANwIAIAVBFGpCADcCACAFQRxqQgA3AgAgBUEwaiAGKQPgATcCACAFQThqIAZB4AFqIgdBCGopAwA3AgAgBUFAayAHQRBqKQMANwIAIAVByABqIAdBGGooAgA2AgAgBUGIAWpCADcCACAFQZABakIANwIAIAVBmAFqQgA3AgAgBUGkAWpCADcCACAFQaoBakIANwEAIAVB0ABqIAYpA8ABNwIAIAVB2ABqIAZBwAFqIgdBCGopAwA3AgAgBUHgAGogB0EQaikDADcCACAFQegAaiAHQRhqKAIANgIAIAVBADYCbCAFQfgAakEANgIAIAVBhAFqQYCAgPwDNgIAIAVBoAFqIA82AgAgDkEIaiAEQQFqNgIAIAlBBGooAgAiBCARIAkoAgAiCnEiBWooAABBgIGChHhxIgxFBEBBBCEHA0AgBSAHaiAHQQRqIQcgCnEiBSAEaigAAEGAgYKEeHEiDEUNAAsLIAlBGGooAgAhByAMaEEDdiAFaiAKcSIFIARqLAAAIghBf0oEQCAEKAIAQYCBgoR4cWhBA3YiBSAEai0AACEICyAIQQFxIQwCQCAJQQhqIg4oAgANACAMRQ0AIAZBCGogCSAJKAIQIAcQrwEgCUEEaigCACIEIBEgCSgCACIKcSIIaigAAEGAgYKEeHEiD0UEQEEEIQUDQCAFIAhqIAVBBGohBSAKcSIIIARqKAAAQYCBgoR4cSIPRQ0ACwsgD2hBA3YgCGogCnEiBSAEaiwAAEF/TA0AIAQoAgBBgIGChHhxaEEDdiEFCyAEIAVqIBI6AAAgBUF8aiAKcSAEakEEaiASOgAAIA4gDigCACAMayIKNgIAIAlBDGoiDCgCAEEBaiEIIAwgCDYCACAFQX9zQQJ0IARqIAc2AgAgByAJQRRqKAIAIgRHBEAgCUEYaigCACEFDAQLIAggCmogCUEYaigCACIFayEEIAcgBWsgBE8EQCAHIQQMBAsgBCAFaiIEIAVJDQIgBEEEdCEIIARB/////wBxIARGQQJ0IQQCQCAHBEAgBkEQakEENgIAIAYgB0EEdDYCDCAGIAkoAhA2AggMAQsgBkEANgIICyAGQYACaiAIIAQgBkEIahCcByAGKAKAAkEBRwRAIAYoAoQCIQggCUEUaiAGQYgCaigCAEEEdiIENgIAIAkgCDYCEAwECyAGQYgCaigCACIARQ0CIAYoAoQCIABBoJ3DACgCACIAQa8GIAAbEQAAAAsgDSAOQcTewAAQzQgACyALIAhB+M/AABDNCAALEJEMAAsgBCAFRgRAIAlBEGogBBCOBiAJQRhqKAIAIQULIAlBGGogBUEBaiIINgIAIAkoAhAgBUEEdGoiBCANNgIIIAQgCzYCBCAEIBE2AgAgBEEMaiATOgAAIAggB00NASAJKAIQIAdBBHRqQQhqIQcLIBAoAgAiCygCCCIIIAcoAgAiBE0NASALKAIAIARBtAFsaiELIAAoAhgiBCgCBCEHIAQoAgAhCAJAIAAoAhQtAABFBEAgACgCKCEEAkAgAQRAIAFBBGoqAgAiFiAEQRBqKgIAIAEqAhCTIhqUIAEqAgAiFyAEQRRqKgIAIAFBFGoqAgCTIhiUkyEVIAFBCGoqAgAiGSAYlCAWIARBGGoqAgAgAUEYaioCAJMiG5STIhQgFJIhHCAGQQhqIg1BGGogGyABKgIMIhQgFSAVkiIVlCAWIByUIBcgFyAblCAZIBqUkyIbIBuSIhuUk5KSOAIAIA1BFGogGCAUIBuUIBcgFZQgGSAclJOSkjgCACAGIBogFCAclCAZIBuUIBYgFZSTkpI4AhggBiAZIAQqAggiHJQgFiAEKgIEIhqUIBcgBCoCACIYlCAUIAQqAgwiFZSSkpI4AhQgBiAWIBiUIBQgHJQgFyAalJOSIBkgFZSTOAIQIAYgFCAalCAXIByUkiAWIBWUkyAZIBiUkzgCDCAGIBkgGpQgFCAYlCAXIBWUkyAWIByUk5I4AggMAQsgBkEIaiIBQRhqIARBGGooAgA2AgAgAUEQaiAEQRBqKQIANwMAIAFBCGogBEEIaikCADcDACAGIAQpAgA3AwgLIAggBkEIaiACIAMgACgCICIBKAIAIAEoAgQgACgCJCoCACALIAcoAjARFwAaDAELIAAoAhwhBAJAIAEEQCABQRRqKgIAIhogBCoCACIWlCABKgIQIh0gBEEEaioCACIXlJMhGCAdIARBCGoqAgAiGZQgAUEYaioCACIVIBaUkyIUIBSSIRwgBkEIaiINQRhqIARBGGoqAgAgFSAEQQxqKgIAIhQgGCAYkiIelCAWIByUIBcgFSAXlCAaIBmUkyIYIBiSIh+Uk5KSkjgCACANQRRqIARBFGoqAgAgGiAUIByUIBkgH5QgFiAelJOSkpI4AgAgBiAUIAEqAgwiGpQgFiABKgIAIhiUkyAXIAEqAgQiFZSTIBkgASoCCCIblJM4AhQgBiAZIBqUIBYgFZQgFCAblJIgFyAYlJOSOAIQIAYgGSAYlCAXIBqUIBQgFZQgFiAblJOSkjgCDCAGIBcgG5QgFCAYlCAWIBqUkpIgGSAVlJM4AgggBiAEQRBqKgIAIB0gFCAflCAXIB6UIBkgHJSTkpKSOAIYDAELIAZBCGoiAUEYaiAEQRhqKAIANgIAIAFBEGogBEEQaikCADcDACABQQhqIARBCGopAgA3AwAgBiAEKQIANwMICyAIIAZBCGogACgCICIBKAIAIAEoAgQgAiADIAAoAiQqAgAgCyAHKAIwERcAGgsgBkGQAmokAA8LIAcgCEH03sAAEM0IAAsgBCAIQYjQwAAQzQgAC8kZAwp/An4JfSMAQaAEayIKJAAgCkHUtcAANgIUIAogADYCECAKIAM2AhwgCiACNgIYIAogBTYCJCAKIAQ2AiAgCiAGOAIsIAogBzYCMCAKIAk6ADcgCBDOBgJAAkACQAJAIAgoAgAiAARAIApBCGogACAIKAIEKAIcEQAAIAooAggiACAKKAIMKAIMEQQAQpDswp/N1KarNFINASAARQ0BIAogADYCOCAAIAAtABxBAXMiADoAHCAKIAA6AD8gCkFAayIAQRhqIAFBGGooAgAiCDYCACAAQRBqIAFBEGopAgAiFDcDACAAQQhqIAFBCGoiBykCADcDACAKIAEpAgA3A0AgCkHgAGoiAkEIaiIDIAcpAgA3AwAgAkEYaiIHIAg2AgAgAyADKgIAIgaMOAIAIAogFDcDcCAKIAEpAgA3A2AgBiAKKgJwIhqUIAoqAmAiGCAHKgIAIhuUkyIWIBaSIRkgGCACQRRqIgEqAgAiHZQgCioCZCIWIBqUkyIXIBeSIRcgASAKKgJsIh4gGZQgGCAXlCAGIBYgG5QgBiAdlJMiHCAckiIclJOSIB2TOAIAIAcgHiAXlCAWIByUIBggGZSTkiAbkzgCACAKIBiMOAJgIAogFow4AmQgCiAeIByUIAYgGZQgFiAXlJOSIBqTOAJwIApBwAJqIAQgACAFKAKAAREBACAKKgIsIgZDAAAAAGBFDQIgCkHAAmoiAkEQaiIDKgIAIRggAkEUaiIEKgIAIRYgCioCwAIhGSAKKgLEAiEXIAoqAsgCIRogCioCzAIhGyAKQYABaiIFQQhqIAooAjAiAEEIaiIHKAIANgIAIAogACkCADcDgAFBACEBIABBADYCBCAHQQA2AgAgAEG8wcAAKAIAIgA2AgAgCiAKQUBrNgK4ASAKIApBLGo2ArQBIAogCkEgajYCsAEgCiAKQeAAajYCrAEgCiAKQRBqNgKoASAKIApBN2o2AqQBIAogCkE/ajYCoAEgCiAKQTBqNgKcASAKIAU2ApgBIAogCkE4ajYClAEgCiAKQRhqNgKQASAEIAYgFpI4AgAgAyAGIBiSOAIAIAogBiAbkjgCzAIgCiAaIAaTOALIAiAKIBcgBpM4AsQCIAogGSAGkzgCwAIgCkHAAWogAhDjBSAKIApBkAFqNgKgAiAKKAIYIAooAhwoAhARBgAhAiAKQgA3ArQCIAogADYCsAIgAkEgaigCACIDDQMMBAtBpL/AAEErQcTPwAAQ2wkAC0Gkv8AAQStB1M/AABDbCQALQaSzwABBJkG0tMAAEPsKAAsgCkGwAmpBAEEBEJQGIAooArACIgAgCigCuAIiAUECdGpBADYCACABQQFqIQELAkAgAUUNACACQTxqKAIAIQQgAigCNCEFIAIoAhghEwNAIAogAUF/aiIBNgK4AgJAAkACQCADIAFBAnQgAGooAgAiAksEQCAKQcACaiACQQd0IBNqQYABEOQGGiAKLQC4AyINBEAgCigCrAMiByAESSECIAdBDGwgBWpBACACG0EIakEAIAIbIQwgCigCqAMiByAESSECIAdBDGwgBWpBACACG0EIakEAIAIbIQ8gCigCpAMiByAESSECIAdBDGwgBWpBACACG0EIakEAIAIbIRAgCigCoAMiByAESSECIAdBDGwgBWpBACACG0EIakEAIAIbIRELIApBwANqIApBwAJqIApBwAFqEIkDIAotAMMDIQggCi0AwgMhCSAKLQDBAyESIAotAMADIQcgDUUNAyASQQF0IAdyIAlBAnRyIAhBA3RyrSIVQv8BgyEUIBVCAYNQDQIgEQ0BDAILIAIgA0Gwx8AAEM0IAAsgCigCoAIhAiAKIBE2AtwDIBEoAgAhDSACKAIAIgsoAgAgCygCBCELIAogAigCKDYCiAQgCiACKQIgNwOABCAKIAIpAhg3A/gDIAogAikCEDcD8AMgCiACKQIINwPoAyAKIAIoAgQ2AuADIAogCkHcA2o2AuQDIA0gCkHgA2pB5M/AACALKAIMEQIACwJAIBRCAoNQDQAgEEUNACAKKAKgAiECIAogEDYC3AMgECgCACENIAIoAgAiCygCACALKAIEIQsgCiACKAIoNgKIBCAKIAIpAiA3A4AEIAogAikCGDcD+AMgCiACKQIQNwPwAyAKIAIpAgg3A+gDIAogAigCBDYC4AMgCiAKQdwDajYC5AMgDSAKQeADakHkz8AAIAsoAgwRAgALAkAgFEIEg1ANACAPRQ0AIAooAqACIQIgCiAPNgLcAyAPKAIAIQ0gAigCACILKAIAIAsoAgQhCyAKIAIoAig2AogEIAogAikCIDcDgAQgCiACKQIYNwP4AyAKIAIpAhA3A/ADIAogAikCCDcD6AMgCiACKAIENgLgAyAKIApB3ANqNgLkAyANIApB4ANqQeTPwAAgCygCDBECAAsgFEIIg1ANACAMRQ0AIAooAqACIQIgCiAMNgLcAyAMKAIAIQ0gAigCACILKAIAIAsoAgQhCyAKIAIoAig2AogEIAogAikCIDcDgAQgCiACKQIYNwP4AyAKIAIpAhA3A/ADIAogAikCCDcD6AMgCiACKAIENgLgAyAKIApB3ANqNgLkAyANIApB4ANqQeTPwAAgCygCDBECAAsgB0H/AXFBAkYNASASQQF0IAdyIAlBAnRyIAhBA3RyrSIVQv8BgyEUIAotALgDIQgCQCAVQgGDUA0AIAhB/wFxDQBBACEIIAooAqADIgIgA0sNACAKKAK0AiABRgRAIApBsAJqIAFBARCUBiAKKAK4AiEBIAooArACIQALIAFBAnQgAGogAjYCACAKIAFBAWoiATYCuAIgCi0AuAMhCAsCQCAUQgKDUA0AIAhB/wFxDQBBACEIIAooAqQDIgIgA0sNACAKKAK0AiABRgRAIApBsAJqIAFBARCUBiAKKAK4AiEBIAooArACIQALIAFBAnQgAGogAjYCACAKIAFBAWoiATYCuAIgCi0AuAMhCAsCQCAUQgSDUA0AIAhB/wFxDQBBACEIIAooAqgDIgIgA0sNACAKKAK0AiABRgRAIApBsAJqIAFBARCUBiAKKAK4AiEBIAooArACIQALIAFBAnQgAGogAjYCACAKIAFBAWoiATYCuAIgCi0AuAMhCAsCQCAUQgiDUA0AIAhB/wFxDQAgCigCrAMiAiADSw0AIAooArQCIAFGBEAgCkGwAmogAUEBEJQGIAooArgCIQEgCigCsAIhAAsgAUECdCAAaiACNgIAIAogAUEBaiIBNgK4AgsgAQ0ACwsCQCAKKAK0AiIARQ0AIAooArACIgFFDQAgAEECdEUNACABEOEBCwJAIAooAjgiBUEYaigCACIARQ0AIABBf2ohAkEAIQQgCi0AP0EARyEJIAVBEGooAgAiByEBQQAhCANAAkACQAJAAkAgAUEMai0AAEUgCUcEQCAEDQFBACEEIAIgCEcNAwwGCyAEQQFqIQQMAQsgCCAEayIDIABJBEAgASkCACEUIAEgASAEQQR0ayIDKQIANwIAIAMgFDcCACABQQhqIgwpAgAhFCAMIANBCGoiAykCADcCACADIBQ3AgAMAQsgAyAAQZC/wAAQzQgACyACIAhGDQELIAhBAWohCCABQRBqIQEMAQsLIARFDQAgACAETwRAIAVBGGogACAEayIANgIACyAFQQRqKAIAIQQgBSgCACIMBEAgBEH/ASAMQQVqEOgGGgtBACECIAVBADYCDCAFIAwgDEEBakEDdkEHbCAMQQhJGyIDNgIIIABFDQAgAEEEdCIAIAdqIQ8DQCAEIAcoAgAiECAMcSIIaigAAEGAgYKEeHEiCUUEQEEEIQEDQCABIAhqIQggAUEEaiEBIAQgCCAMcSIIaigAAEGAgYKEeHEiCUUNAAsLIAdBEGohByAEIAloQQN2IAhqIAxxIgFqLAAAIghBf0oEQCAEIAQoAgBBgIGChHhxaEEDdiIBai0AACEICyABIARqIBBBGXYiCToAACABQXxqIAxxIARqQQRqIAk6AAAgAUF/c0ECdCAEaiACNgIAIAMgCEEBcWshAyACQQFqIQIgByAPRw0ACyAFIAM2AgggBSAAQXBqQQR2QQFqNgIMCyAKKAKAASEBIAooAogBIgAEQCAAQbQBbCABaiEAA0ACQCABQQRqKAIAIgJFDQAgASgCACIDRQ0AIAJBNGxFDQAgAxDhAQsCQCABQaQBaigCACICRQ0AIAFBoAFqKAIAIgNFDQAgAkE4bEUNACADEOEBCyAAIAFBtAFqIgFHDQALIAooAoABIQELAkAgCigChAEiAEUNACABRQ0AIABBtAFsRQ0AIAEQ4QELIApBoARqJAAL2BcDEX8Cfgp9IwBBgANrIgUkACAFIAI2AoQBIAVB3ABqIAIqAgwiGTgCACAFQdgAaiAZOAIAIAVB1ABqIBk4AgAgBUEgaiIGQSxqIAIqAggiHDgCACAFQcgAaiAcOAIAIAVBxABqIBw4AgAgBUE8aiACKgIEIho4AgAgBUE4aiAaOAIAIAZBFGogGjgCACAFQfwAaiACQRRqKgIAIhg4AgAgBUH4AGogGDgCACAFQfQAaiAYOAIAIAVB8ABqIBg4AgAgBUHsAGogAkEQaioCACIYOAIAIAVB6ABqIBg4AgAgBUHkAGogGDgCACAFQeAAaiAYOAIAIAUgATYCgAEgBSAEOgCMASAFIAM4AogBIAUgGTgCUCAFIBw4AkAgBSAaOAIwIAUgAioCACIDOAIsIAUgAzgCKCAFIAM4AiQgBSADOAIgAn9BACABQSxqKAIAIgxFDQAaIAVCADcClAEgBUHsuMEAKAIANgKQASAFQZABaiICQQAQkAYgBSgCkAEgBSgCmAEiBEEDdGpCgICAgPD///9+NwIAIAUgBEEBajYCmAEgBUGgAWogAhCcAwJAIAUoAqABQQFHDQAgBUHwAmpBBHIhECAFQcACakEEciERQ///f38hGQNAIBkgBSoCqAGMXw0BAkACQCAMIAUoAqQBIgJLBEAgBUGwAWogASgCJCACQQd0akGAARDkBhogBS0AqAIiEgRAIAUoApwCIgcgASgCSCICSSEGIAEoAkAiBCAHQQxsakEAIAYbQQhqQQAgBhshEyAFKAKYAiIHIAJJIQYgB0EMbCAEakEAIAYbQQhqQQAgBhshFCAFKAKUAiIHIAJJIQYgB0EMbCAEakEAIAYbQQhqQQAgBhshFSAFKAKQAiIGIAJJIQIgBkEMbCAEakEAIAIbQQhqQQAgAhshDgsgBSAFKgKIASIYOAL8AiAFIBg4AvgCIAUgGDgC9AIgBSAYOALwAiAFQcACaiAFQbABaiAFQSBqIAVB8AJqEIcCIAVBuAJqIgQgEUEIaigCADYCACAFIBEpAgA3A7ACIAUoAsACIQIgBSoC0AIhGyAFKgLUAiEdIAUqAtgCIQMgBSoC3AIhGiASRQRAQQAhB0EAIQRBACEIQQAhBgwDCyAQIAUpA7ACNwIAIBBBCGogBCgCADYCACAFIAI2AvACIAUgGiAZXToAwwIgBSADIBldOgDCAiAFIB0gGV06AMECIAUgGyAZXToAwAIgBUHgAmogBUHwAmogBUHAAmoQiAkgBS0A4AIgBS0A4QJBAXRyIAUtAOICQQJ0ciAFLQDjAkEDdHKtIhdC/wGDIRZDAAAAACEdQQAhCCAFLQCMASEJIAUoAoQBIQogBSgCgAEhAkEAIQZDAAAAACEbIBdCAYNQDQEgDkUNASACKAIIIgcgDigCACIETQ0BIAIoAgAgBEEkbGpBACAHIARLGyIEQSBqKAIAIQcgBUEYaiAEKAIcIAcoAghBB2pBeHFqIAQgCiAYIAlB/wFxQQBHIAcoAhgRCQAgBSgCGEEBRw0BQQEhBiAFKgIcIh4hGwwBCyACIAxBqMjBABDNCAALAkAgFkICg1ANACAVRQ0AIAIoAggiByAVKAIAIgRNDQAgAigCACAEQSRsakEAIAcgBEsbIgRBIGooAgAhByAFQRBqIAQoAhwgBygCCEEHakF4cWogBCAKIBggCUH/AXFBAEcgBygCGBEJACAFKAIQQQFHDQBBASEIIAUqAhQiHyEdC0MAAAAAIRpBACEHQQAhBEMAAAAAIQMCQCAWQgSDUA0AIBRFDQAgAigCCCINIBQoAgAiC00NACACKAIAIAtBJGxqQQAgDSALSxsiC0EgaigCACENIAVBCGogCygCHCANKAIIQQdqQXhxaiALIAogGCAJQf8BcUEARyANKAIYEQkAIAUoAghBAUcNAEEBIQQgBSoCDCIDISALAkAgFkIIg1ANACATRQ0AIAIoAggiDSATKAIAIgtNDQAgAigCACALQSRsakEAIA0gC0sbIgJBIGooAgAhCyAFIAIoAhwgCygCCEEHakF4cWogAiAKIBggCUH/AXFBAEcgCygCGBEJACAFKAIAQQFHDQBBASEHIAUqAgQiGiEhCyAHQRh0IARBEHRyIAhBCHRyIAZyIQILIAJBFXZB+AFxIAJBDnZB/AFxIAJBB3ZB/gFxIAJB/wFxcnJyrSIWQgGDIRcCQAJAIBIEQCAWpyIKQQF2IB0gGyAZIBdCAFIgGyAZXXEgBkEAR3EgBSgCkAIgASgCSCICSXEiCRsiGV1xIAhBAEdxIAUoApQCIAJJcSEGIApBAnYgAyAdIBkgBhsiGV1xIARBAEdxIAUoApgCIAJJcSEEIAMgGSAEGyEZQQFBAUEBIA8gCRsgBhsgBBshDyAgIB8gHiAcIAkbIAYbIAQbIRwgB0UNAiAWQgiDUA0CIBogGV1FDQIgBSgCnAIgAkkNAQwCCwJAIBdQDQAgBSgCkAIiByAMTw0AIBuMIRggBSgCmAEiAiEGIAUoApQBIAJGBEAgBUGQAWogAhCQBiAFKAKYASEGCyAFKAKQASIEIAZBA3RqIgggGDgCBCAIIAc2AgAgBSAGQQFqNgKYASACQQN0IARqIgYqAgQhGCAGKAIAIQcCQCACRQRAQQAhBgwBCwNAQQBBfyAYIAJBf2oiCEEBdiIGQQN0IARqIglBBGoqAgAiG2AiChtBAUECIAobIBggG18bQX9qQf8BcUEBSwRAIAIhBgwCCyACQQN0IARqIAkpAgA3AgAgBiECIAhBAUsNAAsLIAZBA3QgBGoiAiAYOAIEIAIgBzYCAAsCQCAWQgKDUA0AIAUoApQCIgcgDE8NACAdjCEYIAUoApgBIgIhBiAFKAKUASACRgRAIAVBkAFqIAIQkAYgBSgCmAEhBgsgBSgCkAEiBCAGQQN0aiIIIBg4AgQgCCAHNgIAIAUgBkEBajYCmAEgAkEDdCAEaiIGKgIEIRggBigCACEHAkAgAkUEQEEAIQYMAQsDQEEAQX8gGCACQX9qIghBAXYiBkEDdCAEaiIJQQRqKgIAIhtgIgobQQFBAiAKGyAYIBtfG0F/akH/AXFBAUsEQCACIQYMAgsgAkEDdCAEaiAJKQIANwIAIAYhAiAIQQFLDQALCyAGQQN0IARqIgIgGDgCBCACIAc2AgALAkAgFkIEg1ANACAFKAKYAiIHIAxPDQAgA4whAyAFKAKYASICIQYgBSgClAEgAkYEQCAFQZABaiACEJAGIAUoApgBIQYLIAUoApABIgQgBkEDdGoiCCADOAIEIAggBzYCACAFIAZBAWo2ApgBIAJBA3QgBGoiBioCBCEDIAYoAgAhBwJAIAJFBEBBACEGDAELA0BBAEF/IAMgAkF/aiIIQQF2IgZBA3QgBGoiCUEEaioCACIYYCIKG0EBQQIgChsgAyAYXxtBf2pB/wFxQQFLBEAgAiEGDAILIAJBA3QgBGogCSkCADcCACAGIQIgCEEBSw0ACwsgBkEDdCAEaiICIAM4AgQgAiAHNgIACyAWQgiDUA0BIAUoApwCIgcgDE8NASAajCEDIAUoApgBIgIhBiAFKAKUASACRgRAIAVBkAFqIAIQkAYgBSgCmAEhBgsgBSgCkAEiBCAGQQN0aiIIIAM4AgQgCCAHNgIAIAUgBkEBajYCmAEgAkEDdCAEaiIGKgIEIQMgBigCACEHAkAgAkUEQEEAIQYMAQsDQEEAQX8gAyACQX9qIghBAXYiBkEDdCAEaiIJQQRqKgIAIhpgIgobQQFBAiAKGyADIBpfG0F/akH/AXFBAUsEQCACIQYMAgsgAkEDdCAEaiAJKQIANwIAIAYhAiAIQQFLDQALCyAGQQN0IARqIgIgAzgCBCACIAc2AgAMAQtBASEPICEhHCAaIRkLIAVBoAFqIAVBkAFqEJwDIAUoAqABQQFGDQALCwJAIAUoApQBIgFFDQAgBSgCkAEiAkUNACABQQN0RQ0AIAIQ4QELIA9BAUYLIQIgACAcOAIEIAAgAjYCACAFQYADaiQAC/UXAw9/A342fSMAQbADayIGJAAgBkGgAWoiCSAEIAEgBSgCgAERAQAgBkH0AGogBTYCACAGQewAaiADNgIAIAZB3ABqIAlBFGoqAgAiGSAGKgKoASIak0MAAAA/lCIYOAIAIAZB2ABqIBg4AgAgBkHUAGogGDgCACAGQdAAaiAYOAIAIAZBzABqIAZBsAFqKgIAIhsgBioCpAEiHJNDAAAAP5QiGDgCACAGQcgAaiAYOAIAIAZBxABqIBg4AgAgBkFAayAYOAIAIAZBPGogBioCrAEiHSAGKgKgASIek0MAAAA/lCIYOAIAIAZBOGogGDgCACAGQTRqIBg4AgAgBkEsaiAaIBmSQwAAAL+UIhk4AgAgBkEoaiAZOAIAIAZBJGogGTgCACAGQRxqIBwgG5JDAAAAv5QiGjgCACAGQRhqIBo4AgAgBkEUaiAaOAIAIAYgBDYCcCAGIAI2AmggBiABNgJkIAYgADYCYCAGIBg4AjAgBiAZOAIgIAYgGjgCECAGIB4gHZJDAAAAv5QiGDgCDCAGIBg4AgggBiAYOAIEIAYgGDgCAAJAIAIgAygCEBEGACIJQSBqKAIABEAgBkIANwKEASAGQey4wQAoAgA2AoABIAZBgAFqIgBBABCQBiAGKAKAASAGKAKIASIBQQN0akKAgICA8P///343AgAgBiABQQFqNgKIASAGQZABaiAAEJwDAkAgBigCkAFBAUcNAEP//39/IRggCUEgaiELA0AgGCAGKgKYAYxfDQECQAJ/An8CQAJAIAsoAgAiASAGKAKUASIASwRAIAZBoAFqIAkoAhggAEEHdGpBgAEQ5AYaIAYtAJgCIgMEQCAGKAKMAiIEIAkoAjwiAEkhAiAJKAI0IgEgBEEMbGpBACACG0EIakEAIAIbIQwgBigCiAIiBCAASSECIARBDGwgAWpBACACG0EIakEAIAIbIQ0gBigChAIiBCAASSECIARBDGwgAWpBACACG0EIakEAIAIbIQ4gBigCgAIiAiAASSEAIAJBDGwgAWpBACAAG0EIakEAIAAbIQoLIAYqAvwBITIgBioCLCEZIAYqAlwhGiAGIAY2AqwCIAYqAqABITMgBioCpAEhNCAGKgKoASE1IAYqAqwBITYgBioCsAEhNyAGKgK0ASE4IAYqArgBITkgBioCvAEhOiAGKgLAASE7IAYqAsQBITwgBioCyAEhPSAGKgLMASE+IAYqAjAhGyAGKgIAIRwgBioC0AEhPyAGKgI0IR0gBioCBCEeIAYqAtQBIUAgBioCOCEfIAYqAgghICAGKgLYASFBIAYqAjwhISAGKgIMISIgBioC3AEhQiAGKgJAISMgBioCECEkIAYqAuABIUMgBioCRCElIAYqAhQhJiAGKgLkASFEIAYqAkghJyAGKgIYISggBioC6AEhRSAGKgJMISkgBioCHCEqIAYqAuwBIUYgBioCUCErIAYqAiAhLCAGKgLwASFHIAYqAlQhLSAGKgIkIS4gBioC9AEhSCAGKgJYIS8gBioCKCEwIAYqAvgBIUkgBiAaIBkgMpKSOAKMAyAGIC8gMCBJkpI4AogDIAYgLSAuIEiSkjgChAMgBiArICwgR5KSOAKAAyAGICkgKiBGkpI4AvwCIAYgJyAoIEWSkjgC+AIgBiAlICYgRJKSOAL0AiAGICMgJCBDkpI4AvACIAYgISAiIEKSkjgC7AIgBiAfICAgQZKSOALoAiAGIB0gHiBAkpI4AuQCIAYgGyAcID+SkjgC4AIgBiA+IBmSIBqTOALcAiAGID0gMJIgL5M4AtgCIAYgPCAukiAtkzgC1AIgBiA7ICySICuTOALQAiAGIDogKpIgKZM4AswCIAYgOSAokiAnkzgCyAIgBiA4ICaSICWTOALEAiAGIDcgJJIgI5M4AsACIAYgNiAikiAhkzgCvAIgBiA1ICCSIB+TOAK4AiAGIDQgHpIgHZM4ArQCIAYgMyAckiAbkzgCsAIgBkGQA2ogBkGwAmoQyAIgBioCkAMiHCAYXSECIAYqApwDIRkgBioCmAMhGiAGKgKUAyEbIANFDQEgGyAYXUEBdCACciEAQQAhCEMAAAAAIRtDAAAAACEcQQAhA0EAIBogGF1BAnQgAHIgGSAYXUEDdHKtIhVCAYNQDQMaQQAgCkUNAxogCigCACEPIAZCADcDoAMgBigCrAIiACgCaCAAQewAaigCACgCDCEAIAYgBkGsAmo2AqwDIAYgBkGgA2o2AqgDIA8gBkGoA2pBzO7BACAAEQIAQQAgBigCoANBAUYNAxogBioCpAMiHEMAAAAAXA0CDAULIAAgAUGoyMEAEM0IAAsgGiAYXSEIIBkgGF0hAEEAIQVBACEEQQAhAUEAIQMgGyAYXQwCC0EBIQMgHCFKIBwgGF0LIQICf0EAIBVCAoNQDQAaQQAgDkUNABogDigCACEQIAZCADcDoAMgBigCrAIiACgCaCAAQewAaigCACgCDCEAIAYgBkGsAmo2AqwDIAYgBkGgA2o2AqgDIBAgBkGoA2pBzO7BACAAEQIAQQAgBigCoANBAUYNABogBioCpAMiG0MAAAAAWw0CIBsgGF0hCCAbIUtBAQshAUEAIQdDAAAAACEZQwAAAAAhGkEAIQQCf0EAIBVCBINQDQAaQQAgDUUNABogDSgCACERIAZCADcDoAMgBigCrAIiACgCaCAAQewAaigCACgCDCEAIAYgBkGsAmo2AqwDIAYgBkGgA2o2AqgDIBEgBkGoA2pBzO7BACAAEQIAIAYoAqADQQFGBEBBACEEQQAMAQsgBioCpAMiGkMAAAAAWw0CQQEhBCAaIUwgGiAYXQshAAJ/QQAgFUIIg1ANABpBACAMRQ0AGiAMKAIAIRIgBkIANwOgAyAGKAKsAiIFKAJoIAVB7ABqKAIAKAIMIQUgBiAGQawCajYCrAMgBiAGQaADajYCqAMgEiAGQagDakHM7sEAIAURAgAgBigCoANBAUYEQEEAIQdBAAwBCyAGKgKkAyIZQwAAAABbDQIgGSAYXSEHIBkhTUEBCyEFIAdBGHQgAEEQdHIgCEEIdHIgAnIiB0EYdiEAIAdBEHYhCCAHQQh2CyAGIE04AtwCIAYgEjYC2AIgBiAFNgLUAiAGIEw4AtACIAYgETYCzAIgBiAENgLIAiAGIEs4AsQCIAYgEDYCwAIgBiABNgK8AiAGIEo4ArgCIAYgDzYCtAIgBiADNgKwAiAGIBk4ApwDIAYgGjgCmAMgBiAbOAKUAyAGIBw4ApADQQF0IAJyIAhBAnRyIABBA3RyrUL/AYMhFyALKAIAIQEgCSgCPCEDQgAhFQNAIBUiFkIBfCEVAkAgFyAWiEIBg1ANACAWpyEAIAYtAJgCBEAgAEECdCICIAZBkANqaioCACIZIBhdRQ0BIAZBsAJqIABBDGxqIgAoAgBBAUcNASACIAZqQYACaigCACADTw0BIABBCGoqAgAhMUEBIRMgGSEYDAELIABBAnQiACAGakGAAmooAgAiBSABTw0AIAZBkANqIABqKgIAjCEZIAYoAogBIgIhBCAGKAKEASACRgRAIAZBgAFqIAIQkAYgBigCiAEhBAsgBigCgAEiACAEQQN0aiIIIBk4AgQgCCAFNgIAIAYgBEEBajYCiAEgAkEDdCAAaiIEKgIEIRkgBCgCACEFAkAgAkUEQEEAIQQMAQsDQEEAQX8gGSACQX9qIghBAXYiBEEDdCAAaiIHQQRqKgIAIhpgIhQbQQFBAiAUGyAZIBpfG0F/akH/AXFBAUsEQCACIQQMAgsgAkEDdCAAaiAHKQIANwIAIAQhAiAIQQFLDQALCyAEQQN0IABqIgAgGTgCBCAAIAU2AgALIBVCBFINAAsgBkGQAWogBkGAAWoQnAMgBigCkAFBAUYNAQwCCwsCQCAGKAKEASIARQ0AIAYoAoABIgFFDQAgAEEDdEUNACABEOEBC0MAAAAAITEMAgsCQCAGKAKEASIARQ0AIAYoAoABIgFFDQAgAEEDdEUNACABEOEBCyATQQFGDQELQbjLwQBBJkGw18EAEKIJAAsgBkGwA2okACAxC8MZAw1/BH4NfSMAQaABayIDJAACQAJAAkAgAigCACIIRQRAIAFBCGooAgBBf2oiB0H/////AXEhAiACIAdHDQIgB0EDdCIFQQBIDQIgAiAHRkECdCECAkAgBUUEQCACIggNAQwFCyAFIAIQxQsiCEUNBAsgA0EANgIIIAMgCDYCACADIAVBA3YiAjYCBAJAAkAgAiAHSQRAIANBACAHEI8GIAMoAgAhCCADKAIIIQQMAQsgB0UNAQsgB60iEkIDgyETIARBA3QgCGohAiASQn98QgNaBEAgEkL8////D4MhEkKAgICAICEQA0AgAkEYaiAQQoCAgIAgfCARQgN8hDcCACACQRBqIBBCgICAgBB8IBFCAnyENwIAIAJBCGogEUIBfCAQhDcCACACIBBCgICAgHB8IBGENwIAIAJBIGohAiAQQoCAgIBAfSEQIBIgEUIEfCIRUg0ACwsgE1BFBEAgEUIghkKAgICAEHwhEANAIAIgECARhDcCACAQQoCAgIAQfCEQIAJBCGohAiARQgF8IREgE0J/fCITQgBSDQALCyAEIAdqIQQgAygCACEICyADIAQ2AggMAQsgAikCBCESIAMgCDYCACADIBI3AgQgEkIgiKchBAtBBCENQSBBBBDFCyIFBEAgA0EsakIANwIAIANBEGoiAkEQakL////7////v383AwAgA0E0akIANwIAIANBQGtBCDYCACADQTxqIAU2AgAgA0HIAGpCADcDACACQSBqQQA2AgAgA0H0uMEAKAIANgIoIANC////+/f//79/NwMYIANC////+/f//7//ADcDECADQey4wQAoAgA2AkQCQCAEBEAgBEECdCICQQQQxQsiDUUNAQsgA0EANgJYIAMgBDYCVCADIA02AlAgA0HwAGoiAkEQakL////7////v383AwAgA0L////79///v383A3ggA0L////79///v/8ANwNwIANB4ABqIAIgBBDqAiADQX82AnggA0EAOgB0IANBfzYCcCADQcQAaiACIAQQkQNBACECAkACQAJAAkAgBARAIARBA3RBeGpBA3YhDiADQcQAaiEPQQAhBANAAkACQCABKAIIIgIgCCgCACIFSwRAIAIgCCgCBCIGTQ0BIARBAWohByABKAIAIgIgBUEMbGoiBSoCCCEYIAUqAgQhGSAFKgIAIRUgAyAGQQxsIAJqIgIqAgAiFDgClAEgAyACKgIEIho4ApABIAMgAioCCCIbOAKMASADIBg4ApgBIAMgGTgCnAEgAyAVOAJwIANB8ABqIgUgA0GUAWoiAiAZQwAAAACUIhcgFZMgGEMAAAAAlCIckiAaQwAAAACUIh8gFJMgG0MAAAAAlCIWkl4bKgIAISAgBSACIBUgF5IgHJIgFCAfkiAWkl4bKgIAIR0gA0GcAWoiBSADQZABaiICIBVDAAAAAJQiFSAZkyAckiAUQwAAAACUIhQgGpMgFpJeGyoCACEeIAUgAiAVIBmSIBySIBQgGpIgFpJeGyoCACEWIANBmAFqIgUgA0GMAWoiAiAVIBeSIhcgGJMgFCAfkiIUIBuTXhsqAgAhFSAFIAIgGCAXkiAbIBSSXhsqAgAhFCAEIAMoAkwiCUkNAiADKAJIIAkiBmsgByAGayILSQRAIA8gCSALEP0FIAMoAkwhBgsgAygCRCAGQQxsaiECIAtBAk8EQCAEIAlrIgVBA3EhCiAJQX9zIARqQQNPBEBBACAFQXxxayEJA0AgAkF/NgIAIAJBLGpBfzYCACACQShqQQA6AAAgAkEgakJ/NwIAIAJBHGpBADoAACACQRRqQn83AgAgAkEQakEAOgAAIAJBCGpCfzcCACACQQRqQQA6AAAgAkEwaiECIAlBBGoiCQ0ACwsgCgRAA0AgAkF/NgIAIAJBCGpBfzYCACACQQRqQQA6AAAgAkEMaiECIApBf2oiCg0ACwsgBiALakF/aiEGCyADIAsEfyACQX82AgggAkEAOgAEIAJBfzYCACAGQQFqBSAGCyIJNgJMIAMCfyAHIAQgAygCaCIGSQ0AGiAHIAYiBWshDCADKAJkIAVrIAxJBEAgA0HgAGogBiAMEIIGIAMoAmghBQsgAygCYCAFQRhsaiECIAxBAk8EQCAEIAZrIgtBA3EhCiAGQX9zIARqQQNPBEBBACALQXxxayEGA0AgAkL////79///v/8ANwIAIAJB2ABqQv////v///+/fzcCACACQdAAakL////79///v383AgAgAkHIAGpC////+/f//7//ADcCACACQUBrQv////v///+/fzcCACACQThqQv////v3//+/fzcCACACQTBqQv////v3//+//wA3AgAgAkEoakL////7////v383AgAgAkEgakL////79///v383AgAgAkEYakL////79///v/8ANwIAIAJBEGpC////+////79/NwIAIAJBCGpC////+/f//79/NwIAIAJB4ABqIQIgBkEEaiIGDQALCyAKBEADQCACQv////v3//+//wA3AgAgAkEQakL////7////v383AgAgAkEIakL////79///v383AgAgAkEYaiECIApBf2oiCg0ACwsgBSAMakF/aiEFCyAFIAxFDQAaIAJC////+/f//79/NwIIIAJC////+/f//7//ADcCACACQRBqQv////v///+/fzcCACAFQQFqCzYCaAwCCyAFIAJBoPHBABDNCAALIAYgAkGw8cEAEM0IAAsgCSAETQ0DIAMoAkQgBEEMbGogBDYCCCADKAJoIgIgBE0NBCADKAJgIARBGGxqIgIgHTgCDCACIBU4AgggAiAeOAIEIAIgIDgCACACQRRqIBQ4AgAgAkEQaiAWOAIAIAMoAlgiAiADKAJURgRAIANB0ABqIAJBARCUBiADKAJQIQ0gAygCWCECCyAIQQhqIQggAkECdCANaiAENgIAIAMgAkEBaiIKNgJYIAQgDkcgByEEDQALIAMoAiwiAiADKAIwIgRHDQELIANBKGogAhCSBiADKAIwIQQLIAMoAiggBEEHdGoiAkEAOwF4IAJC////+////79/NwMwIAJC////+/f//7//ADcDICACQv////v3//+//wA3AxAgAkL////79///v/8ANwMIIAJC////+/f//7//ADcDACACQdgAakL////7////v383AwAgAkHQAGpC////+////79/NwMAIAJByABqQv////v///+/fzcDACACQUBrQv////v///+/fzcDACACQThqQv////v///+/fzcDACACQShqQv////v3//+//wA3AwAgAkEYakL////79///v/8ANwMAIAJBATYCYCACQewAakJ/NwIAIAJB5ABqQn83AgAgAkH0AGpBADoAACADIARBAWo2AjAgA0HwAGoiAiADQRBqIAMoAlAiByAKIAMoAmAiBSADKAJoQQBBABBWIAMgAkEYaioCACIdOAIkIAMgA0GEAWoqAgAiHjgCICADIANBgAFqKgIAIhY4AhwgAyADQfwAaioCACIXOAIYIAMgA0H4AGoqAgAiFTgCFCADIAMqAnQiFDgCECADKAIwRQ0CIAMoAigiAkH///97NgJcIAJC////+////79/NwJUIAIgHTgCUCACQf///3s2AkwgAkL////7////v383AkQgAiAeOAJAIAJB////ezYCPCACQv////v///+/fzcCNCACIBY4AjAgAkH////7BzYCLCACQv////v3//+//wA3AiQgAiAXOAIgIAJB////+wc2AhwgAkL////79///v/8ANwIUIAIgFTgCECACQf////sHNgIMIAJC////+/f//7//ADcCBCACIBQ4AgACQCADKAJkIgJFDQAgAkEYbEUNACAFEOEBCwJAIAMoAlQiAkUNACAHRQ0AIAJBAnRFDQAgBxDhAQsgACADKQMQNwIAIAAgASkCADcCQCAAQThqIANBEGoiAkE4aikDADcCACAAQTBqIAJBMGopAwA3AgAgAEEoaiACQShqKQMANwIAIABBIGogAkEgaikDADcCACAAQRhqIAJBGGopAwA3AgAgAEEQaiACQRBqKQMANwIAIABBCGogAkEIaikDADcCACAAQcgAaiABQQhqKAIANgIAIABB1ABqIANBCGooAgA2AgAgACADKQMANwJMIANBoAFqJAAPCyAEIAlBmMfBABDNCAALIAQgAkGox8EAEM0IAAtBAEEAQYjHwQAQzQgACyACQQRBoJ3DACgCACIAQa8GIAAbEQAAAAtBIEEEQaCdwwAoAgAiAEGvBiAAGxEAAAALEJEMAAsgBSACQaCdwwAoAgAiAEGvBiAAGxEAAAALqhUCB38BfiMAQdAAayICJAACQAJAAkACQCAABEAgACgCAEUEQCAAQQA2AgAgAkEoaiIBQRBqIABBEGopAgA3AwAgAUEIaiAAQQhqKQIANwMAIAFBGGogAEEYaikCADcDACABQSBqIABBIGopAgA3AwAgACkCACEIIAJBCGogAkE0aikCADcDACACQRBqIgMgAUEUaikCADcDACACQRhqIAJBxABqKQIANwMAIAJBIGogAkHMAGooAgA2AgAgAiAINwMoIAIgAikCLDcDACAAEOEBIAIQiAECQCADKAIAIgBBAWsOBQQDBgYGAAsgAkEUaigCACIBKAKEAiEAIAEgAEF/ajYChAIgAEEBRw0EIAIoAhQiACgCQCEBIAAgACgCjAEiAyABcjYCQCABIANxRQRAIABBqAFqIgEtAAAgAUEBOgAABEBBACEBA0AgASABQQFqIAFBB09BACABQQpLGxshASAALQCoASAAQQE6AKgBDQALCyAAQZABaiEFIABBmAFqIgYoAgAiAQRAIAFBDGwhAyAFKAIAQQhqIQEDQCABKAIAIgcoAhAhBCAHIARBAiAEGzYCECAERQRAIAEoAgAoAhhBGGoQuwULIAFBDGohASADQXRqIgMNAAsLIAUQnQRBACEBIABBADoAqAEgAEHIAWoiAy0AACADQQE6AAAgAEGsAWogBigCACAAQaQBaigCAHJFOgAABEADQCABIAFBAWogAUEHT0EAIAFBCksbGyEBIAAtAMgBIABB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CEEQaikCADcDACAJQQhqIAhBCGopAgA3AwAgEiAIKQIANwNYIBMEQAJAICAtAAhFBEAgEkHwAWogE0E0aigCADYCACASQegBaiATQSxqKQIANwMAIBJB4AFqIBNBJGopAgA3AwAgEiATKQIcNwPYASASQYADaiASQdgBahC6CAwBCyAKKAIIIQggEkHYAWoiB0EYaiATQRhqKAIANgIAIAdBEGogE0EQaikCADcDACAHQQhqIBNBCGopAgA3AwAgEiATKQIANwPYASASQfACaiIJQQhqIAhBCGooAgA2AgAgEiAIKQIANwPwAiASQZgCaiIIQQhqIBVBCGooAgA2AgAgEiAVKQIANwOYAiASQbgCaiIKQQhqIBVBFGooAgA2AgAgEiAVKQIMNwO4AiASQYADaiAHIAkgCCAKEN0HCyASQdgBaiIHQThqIBJBgANqIghBOGopAwA3AwAgB0EwaiAIQTBqKQMANwMAIAdBKGogCEEoaikDADcDACAHQSBqIAhBIGopAwA3AwAgB0EYaiAIQRhqKQMANwMAIAdBEGogCEEQaikDADcDACAHQQhqIAhBCGopAwA3AwAgEiASKQOAAzcD2AEgByASQRhqIBMbIQcLIBJBmAFqIghBOGogB0E4aikCADcDACAIQTBqIAdBMGopAgA3AwAgCEEoaiAHQShqKQIANwMAIAhBIGogB0EgaikCADcDACAIQRhqIAdBGGopAgA3AwAgCEEQaiAHQRBqKQIANwMAIAhBCGogB0EIaikCADcDACASIAcpAgA3A5gBIAtBAUYEQCASQdgAaiAMEKgICyANQQFGBEAgEkGYAWogDhCoCAsgFwRAIBJBgANqIhpBGGogF0EgaigCADYCACAaQRBqIBdBGGopAgA3AwAgEkGIA2ogF0EQaikCADcDACASIBcpAgg3A4ADCyASQbgCaiIHQRhqIgkgGkEYaigCADYCACAHQRBqIgogGkEQaikCADcDACAHQQhqIgggGkEIaikCADcDACASIBopAgA3A7gCIBJB2AFqIBJB2ABqIAcQnQIgGARAIAkgGEEgaigCADYCACAKIBhBGGopAgA3AwAgCCAYQRBqKQIANwMAIBIgGCkCCDcDuAIgEkG4AmohGwsgEkGYAmoiB0EYaiAbQRhqKAIANgIAIAdBEGogG0EQaikCADcDACAHQQhq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IBOnIgBFDQMgAEEUbEUNAyALEOEBDAMLEIgLCyEEIAIoAgwiAUUNACACKAIIIgNFDQAgAUEUbEUNACADEOEBCyAAQQE2AgAgACAENgIECyASpyIARQ0BIABBA3RFDQEgChDhAQwBCyAAQQE2AgAgACAENgIECyARpyIARQ0AIABBDGxFDQAgDRDhAQsgAkEwaiQAC/EUAwh/AX4GfSMAQdAAayIFJAAgBUE4aiIGQQhqIAFBCGooAgA2AgAgBSABKQIANwM4IAUgAEEEaiAGEPgCAkACQAJAAkACQAJAAkACQAJAAkACQCAFKAIAQQFHBEAgBSgCBCIBQRhqKAIAIgIgBUEIaigCAEF8aigCACIATQ0BIAEoAhAgAEEUbGooAhAhBgwJCyAFQSBqIAVBFGooAgA2AgAgBSAFQQxqKQIANwMYIAAqAgAiDSABKAIIspQhDiANIA6SIQ8gDSANIAEoAgSylCIQkiERIA0gDSABKAIAspQiDZIhEiAFQQhqKAIAIQkgBSgCBCEIIAMoAggiAUUEQCAFQQA2AigMAwsgAyABQX9qIgE2AgggBSADKAIAIAFBAnRqKAIAIgE2AiggAUUNAiABQRBqQQA2AgAgAUEcakEANgIAIAFBDGoiAygCACIGRQRAIAFBCGpBAEEBEI8GIAMoAgAhBiABKAIQIQQLIAEgBEEBaiIDNgIQIAEoAggiByAEQQN0akL///97NwIAIAMgBkYEQCABQQhqIAZBARCPBiABKAIIIQcgASgCECEDCyADQQN0IAdqQv////v3/////wA3AgAgASADQQFqNgIQQQAhBCABQTBqQQA2AgAgASANOAIAIAEgEjgCBCABQTxqQQA2AgAgAUEsaiIDKAIAIgZFBEAgAUEoakEAQQEQjwYgAygCACEGIAEoAjAhBAsgASAEQQFqIgM2AjAgASgCKCIHIARBA3RqQv///3s3AgAgAyAGRgRAIAFBKGogBkEBEI8GIAEoAighByABKAIwIQMLIANBA3QgB2pC////+/f/////ADcCACABIANBAWo2AjBBACEEIAFB0ABqQQA2AgAgASAQOAIgIAFBJGogETgCACABQdwAakEANgIAIAFBzABqIgMoAgAiBkUEQCABQcgAakEAQQEQjwYgAygCACEGIAEoAlAhBAsgASAEQQFqIgM2AlAgASgCSCIHIARBA3RqQv///3s3AgAgAyAGRgRAIAFByABqIAZBARCPBiABKAJIIQcgASgCUCEDCyADQQN0IAdqQv////v3/////wA3AgAgASADQQFqNgJQIAEgDjgCQCABQcQAaiAPOAIAIAFBADoAkAFBvMHAACgCACEDAkAgAUHkAGoiBCgCACIGRQ0AIAFB4ABqKAIAIgdFDQAgBkECdEUNACAHEOEBCyABIAM2AmAgAUEAOgCRASABQewAakEANgIAIARCADcCACABQYQBakKAgICAcDcCACABKAKMAQ0BIAFB+ABqKAIARQ0DQZikwQBBKkHEpMEAENsJAAsgACACQejfwAAQzQgACyAFQQA2AjggAUGMAWpBoL/AACAFQThqQYikwQAQ3ggACwJAIA0gEl8EQEEQQQQQxQsiBA0BDAgLDAgLIARC////+/f/////ADcCCCAEQv///3s3AgACQCAQIBFfBEBBEEEEEMULIgYNAQwICwwICyAGQv////v3/////wA3AgggBkL///97NwIAAkAgDiAPXwRAQRBBBBDFCyIHDQEMCAsMCAsgB0L////79/////8ANwIIIAdC////ezcCAEGUAUEEEMULIgFFDQEgAUEAOwGQASABQv////8PNwKIASABQgA3AoABIAFBvMHAACgCACIDNgJ8IAFCADcCdCABIAM2AnAgAUEANgJsIAFCADcCZCABIAM2AmAgAUIANwJYIAEgAzYCVCABQoKAgIAgNwJMIAEgBzYCSCABIA84AkQgASAOOAJAIAFCADcCOCABIAM2AjQgAUKCgICAIDcCLCABIAY2AiggASAROAIkIAEgEDgCICABQgA3AhggASADNgIUIAFCgoCAgCA3AgwgASAENgIIIAEgEjgCBCABIA04AgAgBSgCKEUNACAFQShqENoDCyAALQA4IQMgAC0AOSEEAkAgAigCDCIGQX9GBEAgAigCCCIGIAJBBGooAgBGBEAgAiAGEP8FIAIoAgghBgsgAiAGQQFqNgIIIAIoAgAgBkEsbGoiAiADOgApIAIgBDoAKCACQX82AiQgAiANOAIMIAIgATYCBCACQQE2AgAMAQsgAigCCCIHIAZNDQIgAiACKAIAIAZBLGxqIgIoAiQ2AgwgAkEkagJAIAIoAgBFDQAgAigCBEUNACACQQRqENoDCyACQQE2AgBBfzYC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/////w83AgAgAUEQakL/////DzcCACABQQhqQv////8PNwIAIAFBQGshASAFQQhqIgUNAAsLIAIEQANAIAFC/////w83AgAgAUEIaiEBIAJBf2oiAg0ACwsgByAJakF/agUgBwsiBSAJRQ0AGiABQv////8PNwIAIAVBAWoLIgU2AgAMAgsgBCABQdSlwAAQzQgAC0GkpMAAQTpB4KTAABDbCQALIAUgCE0EQCAIIAVB5KXAABDNCAALIAAoAgAgCEEDdGoiASADNgIEIAEgCzYCAAsgBEF/RgRAAkAgAEEwaigCACIEQX9HBEAgBCIBIABBLGooAgBGBEAgAEEoaiAEEI4GIABBMGooAgAhAQsgAEEwaiABQQFqNgIAIAAoAiggAUEEdGoiAUJ/NwIIIAEgDjYCBCABIA82AgAgBkEIaiIBIA42AgQgASAPNgIAIAYoAgwhCyAGKAIIIgggAEEIaigCACIFSQ0BIABBCGoCfyAIQQFqIgEgBU0EQCABDAELIAUhByAAQQRqKAIAIAVrIAEgBWsiCUkEQCAAIAUgCRCPBiAAQQhqKAIAIQcLIAAoAgAgB0EDdGohASAJQQJPBH8gCCAFayIRQQdxIQIgBUF/cyAIakEHTwRAQQAgEUF4cWshBQNAIAFC/////w83AgAgAUE4akL/////DzcCACABQTBqQv////8PNwIAIAFBKGpC/////w83AgAgAUEgakL/////DzcCACABQRhqQv////8PNwIAIAFBEGpC/////w83AgAgAUEIakL/////DzcCACABQUBrIQEgBUEIaiIFDQALCyACBEADQCABQv////8PNwIAIAFBCGohASACQX9qIgINAAsLIAcgCWpBf2oFIAcLIgUgCUUNABogAUL/////DzcCACAFQQFqCyIFNgIADAELQaSkwABBOkHgpMAAENsJAAsgBSAITQRAIAggBUHkpcAAEM0IAAsgACgCACAIQQN0aiIBIAQ2AgQgASALNgIACyAAQTxqKAIAIgFBf0cEQAJAIAMgBCADIARLGyAAQTBqKAIAIgJJBEAgACgCKCEHIAQiBSADRw0BIAIgAyIFSw0BIAMgAkGMo8AAEM0IAAtB6KPAAEErQZSkwAAQ+goACyADQQR0IAdqIgIoAgghCCACIAE2AgggBUEEdCAHakEMaiICKAIAIQcgAiAB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CCEACyACKAIAIgUgAEECdGogBzYCACACIABBAWoiADYCCCAELQDIAiEBCwJAIBVCCINQBEAgACEBDAELIAFB/wFxBEAgACEBDAELIAQoArwCIgcgA0sEQCAAIQEMAQsgACAQKAIARgRAIAIgAEEBEJQGIAIoAgghAAsgAiAAQQFqIgE2AgggAigCACIFIABBAnRqIAc2AgALIAENAAsLIARBoANqJAALxxACCH8XfiMAQTBrIgUkAAJAAkACQAJAAkAgASkDACIMUEUEQCABKQMIIg1QRQRAIAEpAxAiC1BFBEAgCyAMfCILIAxaBEAgDCANfSINIAxYBEACQAJAIAtC//////////8fWARAIAUgAS8BGCIBOwEIIAUgDTcDACABIAFBYGogASALQoCAgIAQVCIEGyIDQXBqIAMgC0IghiALIAQbIgtCgICAgICAwABUIgQbIgNBeGogAyALQhCGIAsgBBsiC0KAgICAgICAgAFUIgQbIgNBfGogAyALQgiGIAsgBBsiC0KAgICAgICAgBBUIgQbIgNBfmogAyALQgSGIAsgBBsiC0KAgICAgICAgMAAVCIEGyALQgKGIAsgBBsiD0I/h6dBf3NqIgRrQRB0QRB1IgNBAEgNAiAFQn8gA60iDogiCyANgzcDECANIAtWDQwgBSABOwEIIAUgDDcDACAFIAsgDIM3AxAgDCALVg0MQaB/IARrQRB0QRB1QdAAbEGwpwVqQc4QbSIBQdEATw0BIAwgDkI/gyIShiIQQiCIIhcgAUEEdCIBQfjnwgBqKQMAIg5C/////w+DIgx+IQsgDkIgiCIOIBBC/////w+DIhB+IhFCIIgiHiALQiCIIh8gDiAXfnx8IAtC/////w+DIAwgEH5CIIh8IBFC/////w+DfEKAgICACHxCIIghGUIBQQAgAUGA6MIAai8BACAEamtBP3GtIhGGIhBCf3whFSANIBKGIg1CIIghCyANQv////8PgyISIA5+IQ0gCyAMfiITQv////8PgyAMIBJ+QiCIfCANQv////8Pg3xCgICAgAh8QiCIIRIgCyAOfiEWIA1CIIghGCATQiCIISAgAUGC6MIAai8BACEBAn8gDCAPIA9Cf4VCP4iGIg1CIIgiGn4hCyANQv////8PgyIPIA5+IQ0CQAJAIAtC/////w+DIAwgD35CIIh8IA1C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aiQAC8QVAg5/CX0jAEGAAWsiBCQAIAJBCGooAgAiCQRAIAIoAgAhDEEgQQQQxQsiAwRAIARBHGpCADcCACAEQRBqQv////v///+/fzcDACAEQSRqQgA3AgAgBEEwakEINgIAIARBLGogAzYCACAEQThqQgA3AwAgBEEgakEANgIAIARB9LjBACgCADYCGCAEQv////v3//+/fzcDCCAEQv////v3//+//wA3AwAgBEHsuMEAKAIANgI0IAlBAnQiBkEEEMULIg4EQCAEQQA2AkggBCAJNgJEIAQgDjYCQCAEQeAAaiIDQRBqQv////v///+/fzcDACAEQv////v3//+/fzcDaCAEQv////v3//+//wA3A2AgBEHQAGogAyAJEOoCIARBfzYCaCAEQQA6AGQgBEF/NgJgIARBNGoiDyADIAkQkQMgBkF8akECdiEQAkACQAJAA0ACQAJAAkAgASgCCCIDIAwoAgAiCksEQCADIAwoAgQiCE0NASADIAwoAggiBk0NAiAHQQFqIQkgASgCACIDIApBDGxqIgoqAgQhEyAIQQxsIANqIggqAgQhFCAGQQxsIANqIgYqAgAhFyAKKgIIIhYgCCoCCCISXSEDIAYqAggiFSAVIBIgEiAWIAMbIBYgFlwbIhEgESAVXRsgESARXBshGCAWIBYgEiADGyASIBJcGyIRIBEgFSARIBVdGyAVIBVcGyEZIAYqAgQiEiASIBQgFCATIBMgFF0iAxsgEyATXBsiESARIBJdGyARIBFcGyEVIBMgEyAUIAMbIBQgFFwbIhEgESASIBEgEl0bIBIgElwbIRYgCioCACITIAgqAgAiFF0hAyAXIBcgFCAUIBMgAxsgEyATXBsiESARIBddGyARIBFcGyESIBMgEyAUIAMbIBQgFFwbIhEgESAXIBEgF10bIBcgF1wbIREgByAEKAI8IghJDQMgBCgCOCAIIgZrIAkgBmsiCkkEQCAPIAggChD9BSAEKAI8IQYLIAQoAjQgBkEMbGohBSAKQQJPBEAgByAIayIDQQNxIQsgCEF/cyAHakEDTwRAQQAgA0F8cWshCANAIAVBfzYCACAFQSxqQX82AgAgBUEoakEAOgAAIAVBIGpCfzcCACAFQRxqQQA6AAAgBUEUakJ/NwIAIAVBEGpBADoAACAFQQhqQn83AgAgBUEEakEAOgAAIAVBMGohBSAIQQRqIggNAAsLIAsEQANAIAVBfzYCACAFQQhqQX82AgAgBUEEakEAOgAAIAVBDGohBSALQX9qIgsNAAsLIAYgCmpBf2ohBgsgBCAKBEAgBUF/NgIIIAVBADoABCAFQX82AgAgBkEBaiEGCyAGIgg2AjwgBAJ/IAkgByAEKAJYIgZJDQAaIAkgBiIDayENIAQoAlQgA2sgDUkEQCAEQdAAaiAGIA0QggYgBCgCWCEDCyAEKAJQIANBGGxqIQUgDUECTwRAIAcgBmsiCkEDcSELIAZBf3MgB2pBA08EQEEAIApBfHFrIQYDQCAFQv////v3//+//wA3AgAgBUHYAGpC////+////79/NwIAIAVB0ABqQv////v3//+/fzcCACAFQcgAakL////79///v/8ANwIAIAVBQGtC////+////79/NwIAIAVBOGpC////+/f//79/NwIAIAVBMGpC////+/f//7//ADcCACAFQShqQv////v///+/fzcCACAFQSBqQv////v3//+/fzcCACAFQRhqQv////v3//+//wA3AgAgBUEQakL////7////v383AgAgBUEIakL////79///v383AgAgBUHgAGohBSAGQQRqIgYNAAsLIAsEQANAIAVC////+/f//7//ADcCACAFQRBqQv////v///+/fzcCACAFQQhqQv////v3//+/fzcCACAFQRhqIQUgC0F/aiILDQALCyADIA1qQX9qIQMLIAMgDUUNABogBUL////79///v383AgggBUL////79///v/8ANwIAIAVBEGpC////+////79/NwIAIANBAWoLNgJYDAMLIAogA0G8osIAEM0IAAsgCCADQcyiwgAQzQgACyAGIANB3KLCABDNCAALIAggB00NASAEKAI0IAdBDGxqIAc2AgggBCgCWCIDIAdNDQIgBCgCUCAHQRhsaiIDIBI4AgwgAyAZOAIIIAMgFjgCBCADIBE4AgAgA0EUaiAYOAIAIANBEGogFTgCACAMQQxqIQwgBCgCSCIFIAQoAkRGBEAgBEFAayAFQQEQlAYgBCgCSCEFIAQoAkAhDgsgBUECdCAOaiAHNgIAIAQgBUEBaiIGNgJIIAcgEEcgCSEHDQALIAQoAiAiByAEKAIcIgNGBEAgBEEYaiADEJIGIAQoAiAhBwsgBCgCGCAHQQd0aiIDQQA7AXggA0L////7////v383AzAgA0L////79///v/8ANwMgIANC////+/f//7//ADcDECADQv////v3//+//wA3AwggA0L////79///v/8ANwMAIANB2ABqQv////v///+/fzcDACADQdAAakL////7////v383AwAgA0HIAGpC////+////79/NwMAIANBQGtC////+////79/NwMAIANBOGpC////+////79/NwMAIANBKGpC////+/f//7//ADcDACADQRhqQv////v3//+//wA3AwAgA0EBNgJgIANB7ABqQn83AgAgA0HkAGpCfzcCACADQfQAakEAOgAAIAQgB0EBajYCICAEQeAAaiIDIAQgBCgCQCIJIAYgBCgCUCIGIAQoAlhBAEEAEFYgBCADQRhqKgIAIhg4AhQgBCAEQfQAaioCACIZOAIQIAQgBEHwAGoqAgAiFTgCDCAEIARB7ABqKgIAIhY4AgggBCAEQegAaioCACISOAIEIAQgBCoCZCIROAIAIAQoAiBFDQIgBCgCGCIDQf///3s2AlwgA0L////7////v383AlQgAyAYOAJQIANB////ezYCTCADQv////v///+/fzcCRCADIBk4AkAgA0H///97NgI8IANC////+////79/NwI0IAMgFTgCMCADQf////sHNgIsIANC////+/f//7//ADcCJCADIBY4AiAgA0H////7BzYCHCADQv////v3//+//wA3AhQgAyASOAIQIANB////+wc2AgwgA0L////79///v/8ANwIEIAMgETgCAAJAIAQoAlQiA0UNACADQRhsRQ0AIAYQ4QELAkAgBCgCRCIDRQ0AIAlFDQAgA0ECdEUNACAJEOEBCyAAIAQpAwA3AgAgACABKQIANwJAIABBOGogBEE4aikDADcCACAAQTBqIARBMGopAwA3AgAgAEEoaiAEQShqKQMANwIAIABBIGogBEEgaikDADcCACAAQRhqIARBGGopAwA3AgAgAEEQaiAEQRBqKQMANwIAIABBCGogBEEIaikDADcCACAAQcgAaiABQQhqKAIANgIAIABB1ABqIAJBCGooAgA2AgAgACACKQIANwJMIARBgAFqJAAPCyAHIAhBmMfBABDNCAALIAcgA0Gox8EAEM0IAAtBAEEAQYjHwQAQzQgACyAGQQRB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IgM2ApgCIAgtAJgDIQYLAkAgGUIIg1ANACAGQf8BcQ0AIAgoAowDIgIgBUsNACAIKAKUAiADRgRAIAhBkAJqIANBARCUBiAIKAKYAiEDIAgoApACIQELIANBAnQgAWogAjYCACAIIANBAWoiAzYCmAILIAMNAAsLAkAgCCgClAIiAEUNACAIKAKQAiIBRQ0AIABBAnRFDQAgARDhAQsgCCgCPCIAQSRPBEAgABAACyAIQeADaiQADwsgAiAFQcCdwAAQzQgAC5wPAgh/HX4jAEEga0FgcSEGIAFBFGooAgAiBCACSyIDRQRAIABBBDYCGA8LIAEoAgAhCQJAIAEoAggiCiABQQxqKAIAIgggAkHkAWxqQQAgAxsiAykC3AEiDKciB00NACADKQLUASELIAxCIIinIQUCQAJ/IAIgB0EEdCAJaiIHKAIIIgNGBEAgB0EIagwBCwNAIAMgBE8NAiADQeQBbCAIaiIHKALUASIDIAJHDQALIAdB1AFqCyALPgIACyAKIAVNDQACfyACIAVBBHQgCWoiBSgCDCIDRgRAIAVBDGoMAQsDQCADIARPDQIgA0HkAWwgCGoiBSgC2AEiAyACRw0ACyAFQdgBagsgC0IgiD4CAAsgAUEUaiAEQX9qIgQ2AgAgAkHkAWwgCGoiAUEYaiIFKQIAIQsgBEHkAWwgCGoiA0HAAWopAgAhIyADQcgBaikCACEkIANB0AFqKQIAISUgA0HYAWopAgAhJiADQaABaikCACEnIANBqAFqKQIAIQ0gA0GwAWopAgAhDiADQbgBaikCACEPIANB4AFqKAIAIQcgA0GAAWopAgAhECADQYgBaikCACERIANBkAFqKQIAIRIgA0GYAWopAgAhEyADQeAAaikCACEUIANB6ABqKQIAIRUgA0HwAGopAgAhFiADQfgAaikCACEXIANBQGspAgAhGCADQcgAaikCACEZIANB0ABqKQIAIRogA0HYAGopAgAhGyADQSBqKQIAIRwgA0EoaikCACEdIANBMGopAgAhHiADQThqKQIAIR8gAykCACEgIAMpAgghISADKQIQISIgBSADQRhqKQIANwIAIAEpAhAhDCABICI3AhAgASkCCCEiIAEgITcCCCABKQIAISEgASAgNwIAIAFBOGoiAykCACEgIAMgHzcCACABQTBqIgMpAgAhHyADIB43AgAgAUEoaiIDKQIAIR4gAyAdNwIAIAFBIGoiAykCACEdIAMgHDcCACABQdgAaiIDKQIAIRwgAyAbNwIAIAFB0ABqIgMpAgAhGyADIBo3AgAgAUHIAGoiAykCACEaIAMgGTcCACABQUBrIgMpAgAhGSADIBg3AgAgAUH4AGoiAykCACEYIAMgFzcCACABQfAAaiIDKQIAIRcgAyAWNwIAIAFB6ABqIgMpAgAhFiADIBU3AgAgAUHgAGoiAykCACEVIAMgFDcCACABQZgBaiIDKQIAIRQgAyATNwIAIAFBkAFqIgMpAgAhEyADIBI3AgAgAUGIAWoiAykCACESIAMgETcCACABQYABaiIDKQIAIREgAyAQNwIAIAFB4AFqIAc2AgAgAUG4AWoiAykCACEQIAMgDzcCACABQbABaiIDKQIAIQ8gAyAONwIAIAFBqAFqIgMpAgAhDiADIA03AgAgAUGgAWoiAykCACENIAMgJzcCACABQdgBaiIDKQIAIScgAyAmNwIAIAFB0AFqIgMpAgAhJiADICU3AgAgAUHIAWoiAykCACElIAMgJDcCACABQcABaiIDKQIAISQgAyAjNwIAIAYgJDcDACAGICU3AwggBiAmNwMQIAYgJzcDGCAEIAJNBEAgACAhNwIAIABBqAFqIA43AgAgAEGgAWogDTcCACAAQYgBaiASNwIAIABBgAFqIBE3AgAgAEHoAGogFjcCACAAQeAAaiAVNwIAIABByABqIBo3AgAgAEFAayAZNwIAIABBKGogHjcCACAAQSBqIB03AgAgACAiNwIIIABB0AFqIAYoAhA2AgAgAEHIAWogBikDCDcCACAAQcABaiAGKQMANwIAIABBsAFqIA83AgAgAEGQAWogEzcCACAAQfAAaiAXNwIAIABB0ABqIBs3AgAgAEEwaiAfNwIAIAAgDDcCECAAQbgBaiAQNwIAIABBmAFqIBQ3AgAgAEH4AGogGDcCACAAQdgAaiAcNwIAIABBOGogIDcCACAAQRhqIAs3AgAPCwJAIAogASkC3AEiI6ciA00NACAjQiCIpyEBAkACfyADQQR0IAlqIgUoAggiAyAERgRAIAVBCGoMAQsDQCADIARPDQIgBCADQeQBbCAIaiIFKALUASIDRw0ACyAFQdQBagsgAjYCAAsgCiABTQ0AAn8gAUEEdCAJaiIBKAIMIgMgBEYEQCABQQxqDAELA0AgAyAETw0CIAQgA0HkAWwgCGoiASgC2AEiA0cNAAsgAUHYAWoLIAI2AgALIAAgITcCACAAQagBaiAONwIAIABBoAFqIA03AgAgAEGIAWogEjcCACAAQYABaiARNwIAIABB6ABqIBY3AgAgAEHgAGogFTcCACAAQcgAaiAaNwIAIABBQGsgGTcCACAAQShqIB43AgAgAEEgaiAdNwIAIAAgIjcCCCAAQdABaiAGKAIQNgIAIABByAFqIAYpAwg3AgAgAEHAAWogBikDADcCACAAQbABaiAPNwIAIABBkAFqIBM3AgAgAEHwAGogFzcCACAAQdAAaiAbNwIAIABBMGogHzcCACAAIAw3AhAgAEG4AWogEDcCACAAQZgBaiAUNwIAIABB+ABqIBg3AgAgAEHYAGogHDcCACAAQThqICA3AgAgAEEYaiALNwIAC80OAQt/IwBB8ABrIggkAAJAAkACQCABIAAoAgAiCRClBSIGDQAgAUEMaiAJEKUFIgYNACABQSBqKAIAIQIgASgCGCEAIAkoAgAiA0EIaiIFKAIAIQQgA0EEaigCACAEa0EHTQRAIAMgBEEIEOkGIAUoAgAhBAsgBSAEQQhqNgIAIAMoAgAgBGogAq03AAAgAgRAIAJBB3QgAGohBwNAIAggACkDADcDCCAIIABBKGopAwA3AzAgCCAAQSBqKQMANwMoIAggAEEYaikDADcDICAIIABBEGopAwA3AxggCCAAQQhqKQMANwMQIAggAEHYAGopAwA3A2AgCCAAQdAAaikDADcDWCAIIABByABqKQMANwNQIAggAEFAaykDADcDSCAIIABBOGopAwA3A0AgCCAAQTBqKQMANwM4IAggCTYCbCAIQewAaiAIQQhqEJYCIgYNAiAIQewAaiAIQThqEJYCIgYNAiAAQeAAaigCACEGIAkoAgAiA0EEaiIFKAIAIANBCGoiBCgCACICa0EDTQRAIAMgAkEEEOkGIAQoAgAhAgsgAygCACACaiAGNgAAIAQgAkEEaiICNgIAIABB5ABqKAIAIQYgBSgCACACa0EDTQRAIAMgAkEEEOkGIAQoAgAhAgsgAygCACACaiAGNgAAIAQgAkEEaiICNgIAIABB6ABqKAIAIQYgBSgCACACa0EDTQRAIAMgAkEEEOkGIAQoAgAhAgsgAygCACACaiAGNgAAIAQgAkEEaiICNgIAIABB7ABqKAIAIQYgBSgCACACa0EDTQRAIAMgAkEEEOkGIAQoAgAhAgsgBCACQQRqNgIAIAMoAgAgAmogBjYAACAAQfQAai0AACEFIABB8ABqKAIAIQYgCSgCACICQQRqIgooAgAgAkEIaiIDKAIAIgRrQQNNBEAgAiAEQQQQ6QYgAygCACEECyACKAIAIARqIAY2AAAgAyAEQQRqIgQ2AgAgBCAKKAIARgRAIAIgBEEBEOkGIAMoAgAhBAsgAyAEQQFqNgIAIAIoAgAgBGogBToAACAAQfgAai0AACEFIAkoAgAiAkEIaiIEKAIAIgMgAkEEaigCAEYEQCACIANBARDpBiAEKAIAIQMLIAQgA0EBajYCACACKAIAIANqIAVB/wFxQQBHOgAAIABB+QBqLQAAIQUgCSgCACICQQhqIgQoAgAiAyACQQRqKAIARgRAIAIgA0EBEOkGIAQoAgAhAwsgBCADQQFqNgIAIAIoAgAgA2ogBUH/AXFBAEc6AAAgByAAQYABaiIARw0ACwsgAUEwaigCACIDQX9qIAFBKGooAgAiByABQSRqKAIAIgprcSEGIAFBLGooAgAhBCAJKAIAIgVBCGoiACgCACECIAVBBGooAgAgAmtBB00EQCAFIAJBCBDpBiAAKAIAIQILIAAgAkEIaiIANgIAIAUoAgAgAmogBq03AAACQAJAIAcgCkkEQCADIApJDQQgAyAKRwRAIANBAnQgCkECdCICayEGIAIgBGohAiAFQQhqIQsDQCACKAIAIQwgAkEEaiECIAsCfyAAIAVBBGooAgAgAGtBA0sNABogBSAAQQQQ6QYgCygCAAsiA0EEaiIANgIAIAUoAgAgA2ogDDYAACAGQXxqIgYNAAsLIAcgCk0NASAHIApB+ILAABDPCAALIAcgA0sNBCAHIApGDQEgB0ECdCAKQQJ0IgJrIQMgAiAEaiEEIAVBCGohBwNAIAQoAgAhBiAEQQRqIQQgBwJ/IAAgBUEEaigCACAAa0EDSw0AGiAFIABBBBDpBiAHKAIACyICQQRqIgA2AgAgBSgCACACaiAGNgAAIANBfGoiAw0ACwwBCyAHRQ0AIAdBAnQhAyAFQQhqIQcDQCAEKAIAIQYgBEEEaiEEIAcCfyAAIAVBBGooAgAgAGtBA0sNABogBSAAQQQQ6QYgBygCAAsiAkEEaiIANgIAIAUoAgAgAmogBjYAACADQXxqIgMNAAsLIAFBPGooAgAhBCABKAI0IQAgCSgCACIBQQhqIgMoAgAhAiABQQRqKAIAIAJrQQdNBEAgASACQQgQ6QYgAygCACECCyADIAJBCGoiAzYCACABKAIAIAJqIAStNwAAQQAhBiAERQ0AIARBDGwgAGohCSABQQhqIQIDQCAAQQRqLQAAIQQgACgCACEHIAFBBGoiBSgCACADa0EDTQRAIAEgA0EEEOkGIAIoAgAhAwsgASgCACADaiAHNgAAIAIgA0EEaiIDNgIAIAMgBSgCAEYEQCABIANBARDpBiACKAIAIQMLIAEoAgAgA2ogBDoAACACIANBAWoiBDYCACAAQQhqKAIAIQcgBSgCACAEa0EDTQRAIAEgBEEEEOkGIAIoAgAhBAsgAiAEQQRqIgM2AgAgASgCACAEaiAHNgAAIAkgAEEMaiIARw0ACwsgCEHwAGokACAGDwtB9JjAAEEjQfSZwAAQ2wkACyAHIANB6ILAABDPCAALzQ4DFH8CfgF9IwBBoAJrIgIkACACQgA3AgQgAkHsuMEAKAIAIgc2AgAgAEEgaigCACIJBEAgAkEAQQEQlAYgAigCACIHIAIoAggiBEECdGpBADYCACAEQQFqIQQLAkACQAJAAkAgBEUNACAAQTxqKAIAIQsgAkHkAWohCCAAKAI0IQwgACgCGCEVAkADQCACIARBf2oiBDYCCAJAAkAgCSAEQQJ0IAdqKAIAIgNLBEAgAkEQaiADQQd0IBVqQYABEOQGGiACLQCIASIKBEAgAigCfCIGIAtJIQMgBkEMbCAMakEAIAMbQQhqQQAgAxshDyACKAJ4IgYgC0khAyAGQQxsIAxqQQAgAxtBCGpBACADGyEQIAIoAnQiBiALSSEDIAZBDGwgDGpBACADG0EIakEAIAMbIREgAigCcCIGIAtJIQMgBkEMbCAMakEAIAMbQQhqQQAgAxshDQsgAiABKgIIIhg4ArwBIAIgGDgCuAEgAiAYOAK0ASACIBg4ArABIAIgASoCBCIYOAKsASACIBg4AqgBIAIgGDgCpAEgAiAYOAKgASACIAEqAgAiGDgCnAEgAiAYOAKYASACIBg4ApQBIAIgGDgCkAEgAkHAAWogAkEQaiACQZABahCjAyACLQDDASESIAItAMIBIRMgAi0AwQEhFCACLQDAASEOIApFDQIgFEEBdCAOciATQQJ0ciASQQN0cq0iFkIBg1ANASANRQ0BIAAoAlQiBiANKAIAIgNNDQYgACgCSCIGIAAoAkwgA0EDdGoiBSgCACIDTQ0HIAYgBSgCBCIFTQ0IIAggACgCQCIGIAVBDGxqIgUpAgA3AgAgCEEIaiAFQQhqKAIANgIAIAJB2AFqIgVBCGogA0EMbCAGaiIDQQhqKAIANgIAIAIgAykCADcD2AEgAkHwAWoiA0EIaiABQQhqKAIANgIAIAIgASkCADcD8AEgAkGAAmogBSADEPUCIAItAIwCRQ0BDAQLIAMgCUGYyMEAEM0IAAsCQCAWQv8BgyIWQgKDUA0AIBFFDQAgACgCVCIGIBEoAgAiA00NBSAAKAJIIgYgACgCTCADQQN0aiIFKAIAIgNNDQYgBiAFKAIEIgVNDQcgCCAAKAJAIgYgBUEMbGoiBSkCADcCACAIQQhqIAVBCGooAgA2AgAgAkHYAWoiBUEIaiADQQxsIAZqIgNBCGooAgA2AgAgAiADKQIANwPYASACQfABaiIDQQhqIAFBCGooAgA2AgAgAiABKQIANwPwASACQYACaiAFIAMQ9QIgAi0AjAINAwsCQCAWQgSDUA0AIBBFDQAgACgCVCIGIBAoAgAiA00NBSAAKAJIIgYgACgCTCADQQN0aiIFKAIAIgNNDQYgBiAFKAIEIgVNDQcgCCAAKAJAIgYgBUEMbGoiBSkCADcCACAIQQhqIAVBCGooAgA2AgAgAkHYAWoiBUEIaiADQQxsIAZqIgNBCGooAgA2AgAgAiADKQIANwPYASACQfABaiIDQQhqIAFBCGooAgA2AgAgAiABKQIANwPwASACQYACaiAFIAMQ9QIgAi0AjAINAwsgFkIIg1ANACAPRQ0AIAAoAlQiBiAPKAIAIgNNDQQgACgCSCIGIAAoAkwgA0EDdGoiBSgCACIDTQ0FIAYgBSgCBCIFTQ0GIAggACgCQCIGIAVBDGxqIgUpAgA3AgAgCEEIaiAFQQhqKAIANgIAIAJB2AFqIgVBCGogA0EMbCAGaiIDQQhqKAIANgIAIAIgAykCADcD2AEgAkHwAWoiA0EIaiABQQhqKAIANgIAIAIgASkCADcD8AEgAkGAAmogBSADEPUCIAItAIwCDQILIA5BAkcEQCAUQQF0IA5yIBNBAnRyIBJBA3RyrSIXQv8BgyEWAkAgF0IBg1ANACAKDQAgAigCcCIDIAlLDQAgAigCBCAERgRAIAIgBEEBEJQGIAIoAgAhByACKAIIIQQLIARBAnQgB2ogAzYCACACIARBAWoiBDYCCAsCQCAWQgKDUA0AIAoNACACKAJ0IgMgCUsNACACKAIEIARGBEAgAiAEQQEQlAYgAigCACEHIAIoAgghBAsgBEECdCAHaiADNgIAIAIgBEEBaiIENgIICwJAIBZCBINQDQAgCg0AIAIoAngiAyAJSw0AIAIoAgQgBEYEQCACIARBARCUBiACKAIAIQcgAigCCCEECyAEQQJ0IAdqIAM2AgAgAiAEQQFqIgQ2AggLAkAgFkIIg1ANACAKDQAgAigCfCIDIAlLDQAgAigCBCAERgRAIAIgBEEBEJQGIAIoAgAhByACKAIIIQQLIARBAnQgB2ogAzYCACACIARBAWoiBDYCCAsgBA0BCwtBACEDDAELQQEhAwsCQCACKAIEIgBFDQAgAigCACIBRQ0AIABBAnRFDQAgARDhAQsgAkGgAmokACADDwsgAyAGQcDxwQAQzQgACyADIAZB0PHBABDNCAALIAUgBkHg8cEAEM0IAAuiDwMSfwJ+B30jAEGgA2siAyQAIAMgATYCBCADQQhqIgFBIGogAkEgaigCADYCACABQRhqIAJBGGopAgA3AwAgAUEQaiACQRBqKQIANwMAIAFBCGogAkEIaikCADcDACADIAIpAgA3AwggA0HQAWogAiAAKAIAIgEoAgAQoAwCQCAAKAIEIgIqAgAiF0MAAAAAYARAIANB0AFqIghBEGoiBSoCACEYIANB5AFqIgoqAgAhGSADKgLQASEaIAMqAtQBIRsgAyoC2AEhHCADKgLcASEdIAMgAjYCWCADIAE2AlAgAyAAKAIkNgJcIAMgACgCIDYCTCADIAApAhg3AkQgAyAAKQIQNwI8IAMgACkCCDcDMCADIANBCGo2AlQgAyADQQRqNgI4IAogFyAZkjgCACAFIBcgGJI4AgAgAyAXIB2SOALcASADIBwgF5M4AtgBIAMgGyAXkzgC1AEgAyAaIBeTOALQASADQeAAaiAIEOMFIAMgA0EwajYCwAEgACgCKCgCACEFQQAhAiAAKAIsIgFBADYCCCAFQSBqKAIAIghFDQFBACEAIAFBBGooAgBFBEAgAUEAQQEQlAYgASgCCCEACyABIABBAWoiAjYCCCABKAIAIABBAnRqQQA2AgAMAQtBpLPAAEEmQbS0wAAQ+woACwJAIAJFDQAgBUE8aigCACEKIAUoAjQhDyAFKAIYIRQgASgCACEFIAFBBGohEANAIAEgAkF/aiIANgIIAkACQAJAIAggAEECdCAFaigCACICSwRAIANB0AFqIAJBB3QgFGpBgAEQ5AYaIAMtAMgCIgcEQCADKAK8AiIMIApJIQIgDEEMbCAPakEAIAIbQQhqQQAgAhshDCADKAK4AiINIApJIQIgDUEMbCAPakEAIAIbQQhqQQAgAhshDSADKAK0AiIOIApJIQIgDkEMbCAPakEAIAIbQQhqQQAgAhshDiADKAKwAiILIApJIQIgC0EMbCAPakEAIAIbQQhqQQAgAhshCwsgA0HQAmogA0HQAWogA0HgAGoQiQMgAy0A0wIhESADLQDSAiESIAMtANECIRMgAy0A0AIhBiAHRQ0DIBNBAXQgBnIgEkECdHIgEUEDdHKtIhZC/wGDIRUgFkIBg1ANAiALDQEMAgsgAiAIQbDHwAAQzQgACyADKALAASECIAMgCzYC7AIgCygCACEHIAIoAgAiBCgCACAEKAIEIQQgAyACKAIsNgKcAyADIAIpAiQ3ApQDIAMgAikCHDcCjAMgAyACKQIUNwKEAyADIAIpAgw3AvwCIAMgAikCBDcD8AIgAyADQewCajYC+AIgByADQfACakHU0cAAIAQoAgwRAgALAkAgFUICg1ANACAORQ0AIAMoAsABIQIgAyAONgLsAiAOKAIAIQcgAigCACIEKAIAIAQoAgQhBCADIAIoAiw2ApwDIAMgAikCJDcClAMgAyACKQIcNwKMAyADIAIpAhQ3AoQDIAMgAikCDDcC/AIgAyACKQIENwPwAiADIANB7AJqNgL4AiAHIANB8AJqQdTRwAAgBCgCDBECAAsCQCAVQgSDUA0AIA1FDQAgAygCwAEhAiADIA02AuwCIA0oAgAhByACKAIAIgQoAgAgBCgCBCEEIAMgAigCLDYCnAMgAyACKQIkNwKUAyADIAIpAhw3AowDIAMgAikCFDcChAMgAyACKQIMNwL8AiADIAIpAgQ3A/ACIAMgA0HsAmo2AvgCIAcgA0HwAmpB1NHAACAEKAIMEQIACyAVQgiDUA0AIAxFDQAgAygCwAEhAiADIAw2AuwCIAwoAgAhByACKAIAIgQoAgAgBCgCBCEEIAMgAigCLDYCnAMgAyACKQIkNwKUAyADIAIpAhw3AowDIAMgAikCFDcChAMgAyACKQIMNwL8AiADIAIpAgQ3A/ACIAMgA0HsAmo2AvgCIAcgA0HwAmpB1NHAACAEKAIMEQIACyAGQf8BcUECRg0BIBNBAXQgBnIgEkECdHIgEUEDdHKtIhZC/wGDIRUgAy0AyAIhAgJAIBZCAYNQDQAgAkH/AXENAEEAIQIgAygCsAIiBiAISw0AIAAgECgCAEYEQCABIABBARCUBiABKAIAIQUgASgCCCEACyAAQQJ0IAVqIAY2AgAgASAAQQFqIgA2AgggAy0AyAIhAgsCQCAVQgKDUA0AIAJB/wFxDQBBACECIAMoArQCIgYgCEsNACAAIBAoAgBGBEAgASAAQQEQlAYgASgCCCEACyABKAIAIgUgAEECdGogBjYCACABIABBAWoiADYCCCADLQDIAiECCwJAIBVCBINQDQAgAkH/AXENAEEAIQIgAygCuAIiBiAISw0AIAAgECgCAEYEQCABIABBARCUBiABKAIIIQALIAEoAgAiBSAAQQJ0aiAGNgIAIAEgAEEBaiIANgIIIAMtAMgCIQILAkAgFUIIg1AEQCAAIQIMAQsgAkH/AXEEQCAAIQIMAQsgAygCvAIiBiAISwRAIAAhAgwBCyAAIBAoAgBGBEAgASAAQQEQlAYgASgCCCEACyABIABBAWoiAjYCCCABKAIAIgUgAEECdGogBjYCAAsgAg0ACwsgA0GgA2okAAuuDQIMfwF9IwBB8ABrIgkkACACKAIAIgwgBCgCACIPQaABbGpBACACKAIIIgsgD0sbIQIgBCgCBCEQAn9BACALIA9NIhMNABpBACACKAIAQQFHDQAaIAJBCGpBACACKAIEIBBGGwshCgJAAkAgCyAEKAIIIhFNDQAgEUGgAWwgDGpBACALIBFLGyILKAIAQQFHDQAgCkUNACAEQQxqKAIAIgwgCygCBEYiDUUNACAAKAI4IRJBACEEIABBQGsoAgAiCCAPSwRAIA9BDGwgEmpBACAIIA9LGyIEQQRqQQAgBCgCACAQRhshBAsgCCARTQ0AIARFDQAgEUEMbCASakEAIAggEUsbIggoAgAiDiAMRw0AIAtBCGohEiAIQQRqIQgCQAJAAkACQAJAAkACQCAHQf8BcUF/ag4CAgABCyAKLQCUAQ0BIBJBACANGy0AlAENAQsgAEEQaigCACAEKAIAIgRNDQUgCCgCACEKIABBFGooAgAhCCAAKAIIIARBBHRqIg0oAggiBCAAQRxqKAIAIgdJBEADQCAEQThsIAhqIg4oAjQgCkYNAyAOKAIoIgQgB0kNAAsLIA0oAgwiBCAHTw0FA0AgBEE4bCAIaiINKAIwIApGDQIgDSgCLCIEIAdJDQALDAULIABBKGooAgAgBCgCBCIBTQ0EIAhBACAMIA5GGygCBCEDIABBLGooAgAhBwJAIAAoAiAgAUEEdGoiCigCCCIEIABBNGooAgAiAUkEQANAIARBFGwgB2oiCCgCDCADRg0CIAgoAgAiBCABSQ0ACwsgCigCDCIEIAFPDQUDQCAEQRRsIAdqIgooAgggA0YNASAKKAIEIgQgAUkNAAsMBQsgAEEgaiAEEI4DQf8BcSIAQQNHQQAgAEEBaxsNBCATDQUgAigCAEEBRw0FIAIoAgQgEEcNBSALKAIAQQFHDQUgCygCBCAMRw0FIBJBiAFqKAIAIAIoApABckEBcUUNBCAJQTxqIAw2AgAgCUEAOgBAIAkgETYCOCAJIBA2AjQgCSAPNgIwIAUgCUEwaiAGKAIQEQAADAQLIAlBCGogAEEIaiAEEMECIAktACxBAkYNAyAJQTBqIgBBIGogCUEIaiIEQSBqKQMANwMAIABBGGogBEEYaikDADcDACAAQRBqIARBEGopAwA3AwAgAEEIaiAEQQhqKQMANwMAIAkgCSkDCDcDMCAJLQBURQ0BQQAhCgJ/QQAgEw0AGkEAIAIoAgBBAUcNABpBACACKAIEIBBHDQAaIAJBMGpBACACQSxqKAIAQQFGGwshBAJAIAsoAgBBAUcNACALKAIEIAxHDQAgC0EwakEAIAsoAixBAUYbIQoLIAFFDQACQCAERQ0AIAMoAggiACAEKAIAIghNDQAgAygCACAIQaACbGpBACAAIAhLGyIAKAIAQQFHDQAgBCgCBCINIAAoAgRHDQAgAEGcAmotAAANACAAQQA6AJQCIAAgACoCjAKLIhQgFJI4ApACIAEoAgAhBAJAIAAoAvQBIg4gAUEIaigCACIHTw0AIA5BA3QgBGpBACAOIAdJGyIOKAIAIAhHDQAgDkEEaigCACANRg0BCyAAIAc2AvQBIAcgAUEEaigCAEYEQCABIAcQkAYgAUEIaigCACEHIAEoAgAhBAsgAUEIaiAHQQFqNgIAIAdBA3QgBGoiACANNgIEIAAgCDYCAAsgCkUNACADKAIIIgAgCigCACIETQ0AIAMoAgAgBEGgAmxqQQAgACAESxsiAygCAEEBRw0AIAooAgQiCiADKAIERw0AIANBnAJqLQAADQAgA0EAOgCUAiADIAMqAowCiyIUIBSSOAKQAiABKAIAIQcCQCADKAL0ASIIIAFBCGooAgAiAE8NACAIQQN0IAdqQQAgCCAASRsiCCgCACAERw0AIAhBBGooAgAgCkYNAQsgAyAANgL0ASAAIAFBBGooAgBGBEAgASAAEJAGIAEoAgAhByABQQhqKAIAIQALIAFBCGogAEEBajYCACAAQQN0IAdqIgAgCjYCBCAAIAQ2AgAMAAsgEw0DIAIoAgBBAUcNAyACKAIEIBBHDQMgCygCAEEBRw0BIAsoAgQgDEcNASASQYgBaigCACACKAKQAXJBAnFFDQAgCUHoAGogDDYCACAJQeQAaiARNgIAIAlB4ABqIBA2AgAgCSAPNgJcIAlBATYCWCAFIAlB2ABqIAlBMGogBigCFBEBAAsgCUEwahDYBQwBCwwBCyAJQfAAaiQADwtBpL/AAEErQZTmwAAQ2wkAC+IOAxJ/An4CfSMAQYADayIFJAAgBSAENgIoIAVBITYCLCAFQTBqIgRBCGoiCSACQQhqKAIANgIAIAUgAikCADcDMCAFQSBqIgIgA0H//wNxNgIEIAIgA0EQdjYCACAFKQMgIRdBACEDIAVBADYCUCAFIBc3A0ggBSABNgJAIAUgBUEsajYCXCAFIAVBKGo2AlggBSAENgJEIAUgBUHoAGo2AmQgBSAFQdgAajYCeCAFIAVBxABqNgJ0IAUgBUHQAGo2AnAgBSAFQcgAajYCbCAFIAVBQGs2AmggBUGsAWogCSoCACIZOAIAIAVBqAFqIBk4AgAgBUGkAWogGTgCACAFQZwBaiAFKgI0Iho4AgAgBUGYAWogGjgCACAFQZQBaiAaOAIAIAUgGTgCoAEgBSAaOAKQASAFIAUqAjAiGTgCjAEgBSAZOAKIASAFIBk4AoQBIAUgGTgCgAEgBSAFQeQAajYCsAEgBUIANwLEASAFQeybwAAoAgAiATYCwAEgAEEoaigCACIEBEAgBUHAAWpBAEEBEJQGIAUoAsABIgEgBSgCyAEiAkECdGpBADYCACACQQFqIQMLAkAgA0UNACAAQcQAaigCACEJIABBPGooAgAhCyAAKAIgIRMDQCAFIANBf2oiAzYCyAECQCAEIANBAnQgAWooAgAiAEsEQCAFQdABaiAAQQd0IBNqQYABEOQGGiAFLQDIAiICBEAgBSgCvAIiBiAJSSEAIAZBBHQgC2pBACAAG0EIakEAIAAbIRQgBSgCuAIiBiAJSSEAIAZBBHQgC2pBACAAG0EIakEAIAAbIRUgBSgCtAIiBiAJSSEAIAZBBHQgC2pBACAAG0EIakEAIAAbIRYgBSgCsAIiBiAJSSEAIAZBBHQgC2pBACAAG0EIakEAIAAbIQ8LIAVB0AJqIAVB0AFqIAVBgAFqEKMDIAJFBEAgBS0A0wIhECAFLQDSAiERIAUtANECIRIgBS0A0AIhDQwCCyAFIBQ2AvQCIAUgFTYC8AIgBSAWNgLsAiAFIA82AugCIAUtANACIg0gBS0A0QIiEkEBdHIgBS0A0gIiEUECdHIgBS0A0wIiEEEDdHKtQv8BgyEYQgAhFyAFQegCaiEAA0ACQCAYIBeIQgGDUA0AIAAoAgAiCEUNACAFKAKwASgCACICKAIAIgcoAgAgCCgCACIGIAhBBGooAgAiCBCPCSIMRQ0AAkACQCAHKAIAIg4gBiAIEJEJIgcEQCAOIAYgCBCQCSIORQ0BIAIoAgQiCigCBCAHKAIAcUUNAyAKKAIAIAcoAgRxRQ0DIAIoAggiBygCACIKBEAgCiAGIAggBygCBCgCFBEFAEUNBAsgBUEYaiIHIAxBBGooAgAiCjYCBCAHIAwoAgAgCigCCEEHakF4cWo2AgAgBSgCGCAOIAIoAgwoAgAgBSgCHCgCQBEFAEUNAyACKAIQIgIoAgQhDCACKAIAKAIAIQIgBUEQaiIHIAg2AgQgByAGNgIAIAUgBSgCELgQATYC+AIgBUEIaiACIAwgBUH4AmoQwAkgBSgCDCEGIAUoAghFBEAgBSAGNgL8AiAFQfwCahCaC0H/AXEiAkEBcSEGIAJBAkYgBSgC/AIiCEEkTwRAIAgQAAsgBnIhAgwDC0EBIQIgBkEkSQ0CIAYQAAwCC0GEmsAAQStBgKHAABDbCQALQYSawABBK0GAocAAENsJAAsgBSgC+AIiBkEkTwRAIAYQAAsgAkUNBQsgAEEEaiEAIBdCAXwiF0IEUg0ACwwBCyAAIARBwJ3AABDNCAALIA1BAkYNASARQQJ0IBBBA3RyIA1yIBJBAXRyrSIYQv8BgyEXIAUtAMgCIQACQCAYQgGDUA0AIABB/wFxDQBBACEAIAUoArACIgIgBEsNACAFKALEASADRgRAIAVBwAFqIANBARCUBiAFKALIASEDIAUoAsABIQELIANBAnQgAWogAjYCACAFIANBAWoiAzYCyAEgBS0AyAIhAAsCQCAXQgKDUA0AIABB/wFxDQBBACEAIAUoArQCIgIgBEsNACAFKALEASADRgRAIAVBwAFqIANBARCUBiAFKALIASEDIAUoAsABIQELIANBAnQgAWogAjYCACAFIANBAWoiAzYCyAEgBS0AyAIhAAsCQCAXQgSDUA0AIABB/wFxDQBBACEAIAUoArgCIgIgBEsNACAFKALEASADRgRAIAVBwAFqIANBARCUBiAFKALIASEDIAUoAsABIQELIANBAnQgAWogAjYCACAFIANBAWoiAzYCyAEgBS0AyAIhAAsCQCAXQgiDUA0AIABB/wFxDQAgBSgCvAIiACAESw0AIAUoAsQBIANGBEAgBUHAAWogA0EBEJQGIAUoAsgBIQMgBSgCwAEhAQsgA0ECdCABaiAANgIAIAUgA0EBaiIDNgLIAQsgAw0ACwsCQCAFKALEASIARQ0AIAUoAsABIgFFDQAgAEECdEUNACABEOEBCyAFKAIsIgBBJE8EQCAAEAALIAVBgANqJAALhA4DDn8NfQF8IwBBkAJrIgUkACAFQThqIAFBMGopAgA3AwAgBUEwaiABQShqKQIANwMAIAUgASkCIDcDKCAFQUBrIAVBKGogAiACQQxqEMgBAkACQAJAIAUoAkBBAUcNACAFQdgAaioCACITQwAAAABdDQAgAkEUaioCACEVIAIqAgghFiABQRxqKgIAIRogAUEMaigCACEEIAFBEGooAgAhCCATIBMgAyATIANdGyADIANcGyEdAn8CQAJAIAIqAgAiG0MAAAAAQwAAAAAgBSoCRCITIBNDAAAAAF0bIBMgE1wbIhQgAioCDCIXlJIgAUEUaioCACIe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IAYgATYCACAFQQE2AgAgAEEYaiIFIAUoAgBBAWo2AgAgAEEkaiIFIAUoAgBBf2o2AgAgAUEMbCAOakEIaiIBKAIAIQUgASAHNgIAIABBPGooAgAiCSAFTQ0AIABBNGooAgAiByAFQeQBbGoiC0EAIAkgBUsbIQECQCAERQRAIABBMGooAgAhBCAAKAIoIQYMAQsgAUHgAWooAgAhDCAAKAIoIQYgAEEwaigCACIEIAFB3AFqKAIAIgpLBEAgAiADIApBBHQgBmpBACAEIApLGyIKKAIAIAooAgQQgQYLIAQgDE0NACACIAMgDEEEdCAGakEAIAQgDEsbIgIoAgAgAigCBBCBBgsCQCAEIAFB3AFqKQIAIhCnIgNNDQAgASkC1AEhDyAQQiCIpyECAkACfyADQQR0IAZqIgMoAggiASAFRgRAIANBCGoMAQsDQCABIAlPDQIgBSABQeQBbCAHaiIDKALUASIBRw0ACyADQdQBagsgDz4CAAsgBCACTQ0AAn8gAkEEdCAGaiICKAIMIgEgBUYEQCACQQxqDAELA0AgASAJTw0CIAUgAUHkAWwgB2oiAigC2AEiAUcNAAsgAkHYAWoLIA9CIIg+AgALIABBPGogCUF/aiICNgIAIAJB5AFsIAdqIgBB4AFqKAIAIQMgACkCACEPIAApAgghECAAKQIQIREgAEEYaikCACESIABBIGopAgAhEyAAQShqKQIAIRQgAEEwaikCACEVIABBOGopAgAhFiAAQUBrKQIAIRcgAEHIAGopAgAhGCAAQdAAaikCACEZIABB2ABqKQIAIRogAEHgAGopAgAhGyAAQegAaikCACEcIABB8ABqKQIAIR0gAEH4AGopAgAhHiAAQYABaikCACEfIABBiAFqKQIAISAgAEGQAWopAgAhISAAQZgBaikCACEiIABBoAFqKQIAISMgAEGoAWopAgAhJCAAQbABaikCACElIABBuAFqKQIAISYgAEHAAWopAgAhJyAAQcgBaikCACEoIABB0AFqKQIAISkgBUHkAWwgB2oiAUHYAWogAEHYAWopAgA3AgAgAUHQAWogKTcCACABQcgBaiAoNwIAIAFBwAFqICc3AgAgAUG4AWogJjcCACABQbABaiAlNwIAIAFBqAFqICQ3AgAgAUGgAWogIzcCACABQZgBaiAiNwIAIAFBkAFqICE3AgAgAUGIAWogIDcCACABQYABaiAfNwIAIAFB+ABqIB43AgAgAUHwAGogHTcCACABQegAaiAcNwIAIAFB4ABqIBs3AgAgAUHYAGogGjcCACABQdAAaiAZNwIAIAFByABqIBg3AgAgAUFAayAXNwIAIAFBOGogFjcCACABQTBqIBU3AgAgAUEoaiAUNwIAIAFBIGogEzcCACABQRhqIBI3AgAgASARNwIQIAEgEDcCCCABIA83AgAgAUHgAWogAzYCACACIAVNDQACQCAEIAspAtwBIg+nIgBNDQAgD0IgiKchAQJAAn8gAEEEdCAGaiIDKAIIIgAgAkYEQCADQQhqDAELA0AgACACTw0CIAIgAEHkAWwgB2oiAygC1AEiAEcNAAsgA0HUAWoLIAU2AgALIAQgAU0NAAJ/IAFBBHQgBmoiASgCDCIAIAJGBEAgAUEMagwBCwNAIAAgAk8NAiACIABB5AFsIAdqIgEoAtgBIgBHDQALIAFB2AFqCyAFNgIACwJAAkAgDSALKAIQIgBNDQAgAEEMbCAOakEAIA0gAEsbIgAoAgBBAUcNACAAKAIEIAsoAhRGDQELQZmDwABBE0H0psAAEKIJAAsgACAFNgIICyAIQRBqJAALxAsCA38YfSMAQUBqIgckAEMAAKA1ELMBISECQAJAAkACQAJAIAVBDGoqAgAiCyALlCAFQRBqKgIAIgogCpSSIAVBFGoqAgAiDCAMlJJDAAAAAJIQswEiFkMAAAAAWw0AIBa8Qf////8Hcb5DAACAf1wEQCAWiyIOQwAAADRfDQEgDiAOQwAAADSUXw0BCyAFKgIIIRcgBSoCBCEYIAUqAgAhGSAKIBaVIhqMIhQgDCAWlSIbIBuUIAsgFpUiHCAclCAaIBqUkpJDAAAAAJIQswEiCpUhDEMAAAAAIQ4gG4wiFSAKlSILIAuUIByMIiAgCpUiCiAKlEMAAAAAkpJDAAAAAJIQswEiEUMAAAAAXARAIAogEZUgApQhDSALIBGVIAKUIQ4LIARBADYCHCAEQQA2ArwBIARBQGtBADYCACAEQThqQgA3AgAgBEE0aiALIAOUIA6SIgs4AgAgBEEwaiABIAyYIAwgA5SSIgw4AgAgBEEsaiAKIAOUIA2SIgo4AgAgBEEoaiALIBeTOAIAIARBJGogDCAYkzgCACAEIAogGZM4AiAgB0EIaiAEEE1D//9/fyELQZDOACEJA0AgByoCCCINIA2UIAcqAgwiDyAPlJIgByoCECISIBKUkkMAAAAAkiIKQwAAyCteRQ0DIBKMIAoQswEiCpUhDCAPjCAKlSEOIA2MIAqVIRECfSAKIAtgIghFBEBDAAAAACESIA4gDCAMlCARIBGUIA4gDpSSkkMAAAAAkhCzASILlSEQQwAAAAAhDyAMIAuVIg0gDZQgESALlSITIBOUQwAAAACSkkMAAAAAkhCzASILQwAAAABcBEAgEyALlSAClCEPIA0gC5UgApQhEgsgASAQmCAQIAOUkiELIBMgA5QgD5IhDyANIAOUIBKSDAELIB1DAAAAAF4NBCAYIA+SIQsgGSANkiEPIBcgEpILIhIgF5MhDSALIBiTIR4gDyAZkyEfAkACQAJAIBsgDJQgHCARlCAaIA6UkpIiE0MAAAAAWw0AIBO8Qf////8Hcb5DAACAf1wEQCATiyIQQwAAADRfDQEgECAQQwAAADSUXw0BCyAMIA2UIA4gHpQgESAflJKSIBOVIhBDAAAAAGANAQtBACEFIBNDAACgNV4NBiAIDQYMAQsCQAJAIBNDAAAAAF1FDQAgEEMAAAAAXkUNACAdIBCSIh0gFpUgBl4EQCAAQQA2AgAMCQsgGyAQlCEKIBogEJQhFCAcIBCUIRUCQCAEKAK8ASIIQQFqIgUgCEkNACAEIAQqAiAgFZM4AiAgBCAEKgIkIBSTOAIkIAQgBCoCKCAKkzgCKCAIRQ0AIAQgBCoCRCAVkzgCRCAEIAQqAkggFJM4AkggBCAEKgJMIAqTOAJMIAVBAkYNACAEIAQqAmggFZM4AmggBCAEKgJsIBSTOAJsIAQgBCoCcCAKkzgCcCAFQQNGDQAgBCAEKgKMASAVkzgCjAEgBCAEKgKQASAUkzgCkAEgBCAEKgKUASAKkzgClAEgBUEERw0CCyASIBcgCpIiF5MhDSALIBggFJIiGJMhHiAPIBkgFZIiGZMhH0P//39/IQogDCEVIA4hFCARISAMAgsgCEUNASAAQQA2AgAMBwtBBEEEQfTiwQAQzQgACyAMIA2UIA4gHpQgESAflJKSIgwgDFsEQEEAIQUgCiAMkiAhIAqUXw0FIAdBADYCOCAHQgA3AzAgByASOAIsIAcgCzgCKCAHIA84AiQgByANOAIgIAcgHjgCHCAHIB84AhggBCAHQRhqEJkCGiAHQQhqIAQQTSAEKAK8AUEDRg0DIAohCyAJQX9qIgkNAQwFCwtB7N/BAEEoQaTgwQAQ2wkACyAAQQA2AgAMAwsgDEMAAKC1Xw0BCyAAQRBqIBU4AgAgAEEMaiAUOAIAIABBCGogIDgCACAAIB0gFpU4AgRBASEFCyAAIAU2AgALIAdBQGskAAv4CwIBfxh9IwBBQGoiAyQAAkACQAJAIAEqAgAiBkMAAAAAXA0AIAFBBGoqAgBDAAAAAFwNACABQQhqKgIAQwAAAABcDQAgASoCDEMAAAAAXA0AIAEqAhBDAAAAAFwNACABQRRqKgIAQwAAAABcDQAgAUEYaioCAEMAAAAAXA0AIAEqAhxDAAAAAFwNACABQSBqKgIAQwAAAABcDQAgAUEkaioCACIEQwAAAABbBH0gAUEoaioCAEMAAIA/Ww0CIAFBJGoqAgAFIAQLQwAAAABcDQAgAUEoaioCAEMAAIC/Ww0BCwJAIAIqAgAiDUMAAAAAXARAIAJBBGoqAgAhCgwBCyACQQRqKgIAIgpDAAAAAFwNACACQQhqKgIAQwAAAABcDQAgAioCDEMAAAAAXA0AIAIqAhBDAAAAAFwNACACQRRqKgIAQwAAAABcDQAgAkEYaioCAEMAAAAAXA0AIAIqAhxDAAAAAFwNACACQSBqKgIAQwAAAABcDQAgAkEkaioCACIEQwAAAABbBH0gAkEoaioCAEMAAIA/Ww0CIAJBJGoqAgAFIAQLQwAAAABcDQAgAkEoaioCAEMAAIC/Ww0BCyABQQRqKgIAIQcgASoCCCEJIAIqAgghDCABKgIMIQQgAioCDCEIIANBGGogARCnAkMAAAAAQwAAgD9DAAAAAEMAAAAAQwAAgD8gBJUgBEMAAAAAWxsiBEMAAAAAQwAAgD8gCJUgCEMAAAAAWxsiCJMiBSAFQwAAADRdGyISlSASQwAAAABbGyEFIAkgBJQgDCAIlJMgBZQhDCAHIASUIAggCpSTIAWUIQogBiAElCANIAiUkyAFlCEIAn0gASoCDCIEQwAAAABbBEAgA0E0aioCACENIANBLGoqAgAhEyADQShqKgIAIQsgAyoCMCEUIAMqAiQhFSADKgIgIRYgAyoCHCEXIAMqAhghGCADQThqKgIADAELQwAAgD8gBJUiBCAKIAeTIgUgDCAJkyIHlEMAAAAAkpQiCSADQTRqKgIAkiENIAQgCCAGkyIGIAeUQwAAAACSlCILIAMqAjCSIRQgCSADQSxqKgIAkiETIAQgBiAFlEMAAAAAkpQiCSADKgIkkiEVIAsgAyoCIJIhFiAJIAMqAhySIRcgByAHlCIHIAYgBpQiBiAFIAWUIguSkkMAAAAAkiEFIAQgCyAFkpQgA0EoaioCAJIhCyAEIAYgBZKUIAMqAhiSIRggBCAHIAWSlCADQThqKgIAkgshCSACQQRqKgIAIQQgAioCACEGIAIqAgghByADQRhqIAIQpwICfSACKgIMIg5DAAAAAFsEQCADQThqKgIAIQcgA0E0aioCACEOIANBLGoqAgAhDyADQShqKgIAIQYgAyoCMCEZIAMqAiQhGiADKgIgIRAgAyoCHCERIAMqAhgMAQsgCiAEkyIFIAwgB5MiB5RDAAAAAJJDAACAPyAOlSIElCIPIANBNGoqAgCSIQ4gCCAGkyIGIAeUQwAAAACSIASUIhAgAyoCMJIhGSAPIANBLGoqAgCSIQ8gBiAFlEMAAAAAkiAElCIRIAMqAiSSIRogECADKgIgkiEQIBEgAyoCHJIhESAHIAeUIgcgBiAGlCIbIAUgBZQiBpKSQwAAAACSIQUgBCAHIAWSlCADQThqKgIAkiEHIAQgBiAFkpQgA0EoaioCAJIhBiAEIBsgBZKUIAMqAhiSCyEEIAMgDDgCECADIAo4AgwgAyAIOAIIIANBOGogCSAHkzgCACADQTRqIA0gDpM4AgAgA0EsaiATIA+TOAIAIANBKGogCyAGkzgCACADIBQgGZM4AjAgAyAVIBqTOAIkIAMgFiAQkzgCICADIBcgEZM4AhwgAyAYIASTOAIYIAAgA0EIaiASIANBGGoQngEMAQsgACABKQIANwIAIABBKGogAUEoaigCADYCACAAQSBqIAFBIGopAgA3AgAgAEEYaiABQRhqKQIANwIAIABBEGogAUEQaikCADcCACAAQQhqIAFBCGopAgA3AgALIANBQGskAAvZCgMMfwF+Gn0jAEHwAGsiCCQAIABBBGoqAgAhGiABQQhqKgIAIR8gAEEIaioCACEbIAFBBGoqAgAhICABKgIAISEgACoCACEcIABBDGoqAgAhHSAIQQhqIgoQygggCCAfIB0gISAalCAgIByUkyIWIBaSIhaUIBogICAblCAfIBqUkyIXIBeSIheUIBwgHyAclCAhIBuUkyIVIBWSIhWUk5KSIhmMIiQ4AmggCCAgIB0gFZQgHCAWlCAbIBeUk5KSIhiMIiU4AmQgCCAhIB0gF5QgGyAVlCAaIBaUk5KSIhaMIiY4AmAgAiAIQeAAaiAKIAMoAhwRAQAgBkEEaiIMKAIAIQ8gBigCCCENIAxCADcCACAGKAIAIQogBkG8wcAAKAIAIg42AgAgCCgCXCIQBEAgFiAElCEnIBkgBJQhKCAYIASUISkgAEEYaioCACEqIABBFGoqAgAhKyAAQRBqKgIAISwgCEE4aiELIAhBCGohAkEAIQMDQAJAIANBBEcEQCADQQFqIQMgHCACQQRqKgIAIhaUIBogAioCACIXlJMiFSAVkiEVIBsgF5QgHCACQQhqKgIAIhmUkyIYIBiSIRggHyAqIBkgHSAVlCAcIBiUIBogGiAZlCAbIBaUkyIeIB6SIh6Uk5KSkiIilCAhICwgFyAdIB6UIBogFZQgGyAYlJOSkpIiI5QgICArIBYgHSAYlCAbIB6UIBwgFZSTkpKSIhiUkpIiFSAEkyIeIAVfRQ0BIAhB6ABqIhFCADcDACAIQgA3A2BBACALKAIAIgAgBxshEiAAQQAgBxshEyAiIBUgH5STIiIgGSAokyIZIAcbIS0gGCAVICCUkyIYIBYgKZMiFiAHGyEuICMgFSAhlJMiFSAXICeTIhcgBxshIyAZICIgBxshGSAWIBggBxshFiAXIBUgBxshFyAMKAIAIAlGBEAgBiAJEPkFIAYoAgAhDiAGKAIIIQkLIAlBNGwgDmoiACASNgIgIAAgEzYCHCAAIB44AhggACAjOAIMIAAgGTgCCCAAIBY4AgQgACAXOAIAIABBFGogLTgCACAAQRBqIC44AgAgBiAJQQFqIgk2AgggACAIKQNgNwIkIABBLGogESkDADcCAAwBC0EEQQRBzMjAABDNCAALIAJBDGohAiALQQRqIQsgAyAQRw0ACwsCQCAHRQRAIAYgJjgCGCAGIAEpAgA3AgwgBkEgaiAkOAIAIAZBHGogJTgCACAGQRRqIAFBCGooAgA2AgAMAQsgBiAmOAIMIAZBFGogJDgCACAGQRBqICU4AgAgBiABKQIANwIYIAZBIGogAUEIaigCADYCAAsCQCAJRQ0AIA1FDQAgDUE0bCIAIApqIQsgBigCACIDIAlBNGxqIQwgCkEkaiEJIApBNGohASAAQUxqIg1BNG5BAXEhDgNAIANBJGohAiADKAIcIQYCfyAKIA4NABogASAKKAIcIAZHDQAaIAEgAygCICAKKAIgRw0AGiAJKQIAIRQgAkEIaiAJQQhqKQIANwIAIAIgFDcCACABCyEAIA1BNE8EQCAAQdgAaiEHA0ACQCAHIgBBRGooAgAgBkcNACADKAIgIABBSGooAgBHDQAgAEFMaiIHKQIAIRQgAkEIaiAHQQhqKQIANwIAIAIgFDcCAAsCQCAAQXhqKAIAIAZHDQAgAygCICAAQXxqKAIARw0AIAApAgAhFCACQQhqIABBCGopAgA3AgAgAiAUNwIACyAAQegAaiEHIABBEGogC0cNAAsLIAwgA0E0aiIDRw0ACwsCQCAPRQ0AIA9BNGxFDQAgChDhAQsgCEHwAGokAAvYCgIbfwR9IwBBIGsiBCQAIARCADcDCCABQSRqIRUgAUEUaiEWQQEhAwNAIAMhECAEQQIgAiIJayILNgIcIAQgAkECdCIFIAFqIAJBDGxqIgNBBGoiCDYCGCAEQRhqIgIgAhCBAkMAAAAAkiIdELMBIh4gHowgCCoCACIgQwAAAABgIgIbIR8gCCAgIB+SOAIAAkAgHSAeICAgIIwgAhuUkiIdIB2SIh1DAAAAAFwiBkUEQCAEIAVqIB84AgAMAQsgHRCzASEdIAggCCoCACAdlTgCACALQQFHIg0EQCAIQQRqIgIgAioCACAdlTgCAAsgBCAFaiAfjDgCACAGRQ0AIARBCGogBWoiBSAIKgIAIh0gHZIiHSADQRBqIgcqAgCUOAIAIA0EQCAFIB0gByoCBJQ4AgQLIAQgCUEBcyIRNgIUIAQgB0EEajYCECAEIBE2AhwgBCAIQQRqIg42AhggBEEQaiAEQRhqEIECIR0gBSAFKgIAIB0gHZKSOAIAIBBBAXEiFARAQQAhD0EAIAlrIRIgCUF/cyEXIAlBBHQgAWohE0EBIQwgBSECA0AgBCALIAxrIgY2AhQgBCAMQQxsIAdqIhggDEECdCIKajYCECAEIAY2AhwgBCAIIApqIgM2AhggBSAKaiIGIARBEGogBEEYahCBAiIdIB2SIAYqAgCSOAIAAkAgDEEBaiIMIAtGDQAgAyoCACIdIB2SIR1BACAJIA9qa0EBcUEAIQYgDyAXRwRAIBJBfnEhGkEAIQMDQCACIANqIhtBCGoiCiAdIAMgE2oiHEEkaioCAJQgCioCAJI4AgAgG0EMaiIKIB0gHEEoaioCAJQgCioCAJI4AgAgA0EIaiEDIBogBkECaiIGRw0ACwtFDQAgBkECdCIKIAxBAnQiAyAFamoiBiAdIAMgGGogCmoqAgCUIAYqAgCSOAIACyASQX9qIRIgE0EQaiETIAJBBGohAiAPQQFqIQ8gCyAMRw0ACwsgCCoCACAFKgIAlEMAAAAAkiEeIA0EQCAeIA4qAgAgBUEEaioCAJSSIR4LAkAgCwRAIAcgByoCACAIKgIAIh0gBSoCAJSTOAIAIA1FDQEgByAHKgIEIB0gBSoCBJSTOAIECyAJDQAgB0EQaiICIAIqAgAgDioCACIdIAVBBGoqAgCUkzgCACAUDQAgB0EUaiICIAIqAgAgHSAFQQhqKgIAlJM4AgALAkAgCwRAIAcgByoCACAFKgIAIh0gCCoCAJSTOAIAIA1FDQEgByAHKgIEIB0gCCoCBJSTOAIECyAJDQAgB0EQaiICIAIqAgAgBUEEaioCACIdIA4qAgCUkzgCACAUDQAgB0EUaiICIAIqAgAgHSAIQQhqKgIAlJM4AgALIB4gHpIhHyALBEAgByAfIAgqAgAiHpQiHSAelCAHKgIAkjgCACALQQFGIgoNASAJQX9qIQYgCUEEdCAWaiEDA0AgAyAdIANBdGoqAgCUIAMqAgCSOAIAIANBBGohAyAGQQFqIgIgBk8gAiEGDQALIAoNAQsgEUUNACAHQRBqIgIgHyAOKgIAIh6UIh0gHpQgAioCAJI4AgBBASECQQAhAyAQQQFxDQEgEUF/aiEGIAlBBHQgFWohAwNAIAMgHSADQWhqKgIAlCADKgIAkjgCACADQQRqIQMgBkF/aiIGDQALC0EBIQJBACEDIBBBAXENAAsgACAEKQMANwIkIAAgASkCADcCACAAQQhqIAFBCGopAgA3AgAgAEEQaiABQRBqKQIANwIAIABBGGogAUEYaikCADcCACAAQSBqIAFBIGooAgA2AgAgBEEgaiQAC94KAg9/AX4jAEEgayIOJAACQCABQQxqKAIAIghBAWoiBCAISQRAEKILIA4pAwAhEyAAQQE2AgAgACATNwIEDAELAkACQAJAAn8gASgCACIKQQFqIQkCQCAEIAogCUEDdkEHbCAKQQhJGyINQQF2SwRAIAQgDUEBaiIFIAQgBUsbIgRBCEkNASAEQf////8BcSAERgRAQX8gBEEDdEEHbkF/amd2QQFqDAMLEKILIA4oAhghBSAOKAIcIQEMBAsgAUEEaigCACEGQQAhBANAAkACQCAFQQFxRQRAIAQgCU8NAQwCCyAEQQNqIgUgBEkNACAFIgQgCUkNAQsCQAJAIAlBBE8EQCAGIAlqIAYoAAA2AAAMAQsgBkEEaiAGIAkQvwQaIAlFDQELQQAhBANAAkAgBiAEIgdqIgwtAABBgAFHDQACQAJAIAdBf3NBAnQgBmoiCSgCACIEIANJBEADQCAGIARBBHQgAmooAgAiDyAKcSILIgVqKAAAQYCBgoR4cSIQRQRAQQQhBCALIQUDQCAEIAVqIQUgBEEEaiEEIAYgBSAKcSIFaigAAEGAgYKEeHEiEEUNAAsLIAYgEGhBA3YgBWogCnEiBGosAABBf0oEQCAGKAIAQYCBgoR4cWhBA3YhBAsgBCALayAHIAtrcyAKcUEESQ0DIAQgBmoiBS0AACAFIA9BGXYiBToAACAEQXxqIApxIAZqQQRqIAU6AABB/wFGDQIgBEF/c0ECdCAGaiIFKAIAIQQgBSAJKAIANgIAIAkgBDYCACAEIANJDQALCyAEIANBwJ7AABDNCAALIAxB/wE6AAAgB0F8aiAKcSAGakEEakH/AToAACAEQX9zQQJ0IAZqIAkoAgA2AgAMAQsgDCAPQRl2IgQ6AAAgB0F8aiAKcSAGakEEaiAEOgAACyAHQQFqIQQgByAKRw0ACwsgAEEANgIAIAEgDSAIazYCCAwHCyAEIAZqIgcoAgAhBSAHIAVBB3ZBf3NBgYKECHEgBUH//v37B3JqNgIAQQEhBSAEQQFqIQQMAAsAC0EEQQggBEEESRsLIgQgBEH/////A3FGBEAgBEECdCIFIARBBGoiC2oiByAFTw0BCxCiCyAOKAIIIQUgDigCDCEBDAELIAdBBBDFCyIGDQEgB0EEQaCdwwAoAgAiAEGvBiAAGxEAAAALIAAgBTYCBCAAQQE2AgAgAEEIaiABNgIADAELIAUgBmpB/wEgCxDoBiEGIARBf2oiDSAEQQN2QQdsIA1BCEkbIAhrrSAIrUIghoQhEyABQQRqKAIAIgdBBGohBSAHIAlqIRAgBygCAEF/c0GAgYKEeHEhCCAHIQsDQAJAAkAgCEUEQANAIAUgEE8NAiALQXBqIQsgBSgCACAFQQRqIgQhBUGAgYKEeHEiCEGAgYKEeEYNAAsgCEGAgYKEeHMhCCAEIQULIAhoQQN2QX9zQQJ0IAtqIhEoAgAiBCADSQ0BIAQgA0HAnsAAEM0IAAsgASATNwIIIAEgDTYCACAAQQA2AgAgAUEEaiAGNgIAIApFDQIgByAJQQJ0axDhAQwCCyAGIA0gBEEEdCACaigCACIScSIMaigAAEGAgYKEeHEiD0UEQEEEIQQDQCAEIAxqIQwgBEEEaiEEIAYgDCANcSIMaigAAEGAgYKEeHEiD0UNAAsLIAhBf2ogCHEhCCAGIA9oQQN2IAxqIA1xIgRqLAAAQX9KBEAgBigCAEGAgYKEeHFoQQN2IQQLIAQgBmogEkEZdiIMOgAAIARBfGogDXEgBmpBBGogDDoAACAEQX9zQQJ0IAZqIBEoAgA2AgAMAAsACyAOQSBqJAAL3goCD38BfiMAQSBrIg4kAAJAIAFBDGooAgAiCEEBaiIEIAhJBEAQogsgDikDACETIABBATYCACAAIBM3AgQMAQsCQAJAAkACfyABKAIAIgpBAWohCQJAIAQgCiAJQQN2QQdsIApBCEkbIg1BAXZLBEAgBCANQQFqIgUgBCAFSxsiBEEISQ0BIARB/////wFxIARGBEBBfyAEQQN0QQduQX9qZ3ZBAWoMAwsQogsgDigCGCEFIA4oAhwhAQwECyABQQRqKAIAIQZBACEEA0ACQAJAIAVBAXFFBEAgBCAJTw0BDAILIARBA2oiBSAESQ0AIAUiBCAJSQ0BCwJAAkAgCUEETwRAIAYgCWogBigAADYAAAwBCyAGQQRqIAYgCRC/BBogCUUNAQtBACEEA0ACQCAGIAQiB2oiDC0AAEGAAUcNAAJAAkAgB0F/c0ECdCAGaiIJKAIAIgQgA0kEQANAIAYgBEEUbCACaigCACIPIApxIgsiBWooAABBgIGChHhxIhBFBEBBBCEEIAshBQNAIAQgBWohBSAEQQRqIQQgBiAFIApxIgVqKAAAQYCBgoR4cSIQRQ0ACwsgBiAQaEEDdiAFaiAKcSIEaiwAAEF/SgRAIAYoAgBBgIGChHhxaEEDdiEECyAEIAtrIAcgC2tzIApxQQRJDQMgBCAGaiIFLQAAIAUgD0EZdiIFOgAAIARBfGogCnEgBmpBBGogBToAAEH/AUYNAiAEQX9zQQJ0IAZqIgUoAgAhBCAFIAkoAgA2AgAgCSAENgIAIAQgA0kNAAsLIAQgA0HAnsAAEM0IAAsgDEH/AToAACAHQXxqIApxIAZqQQRqQf8BOgAAIARBf3NBAnQgBmogCSgCADYCAAwBCyAMIA9BGXYiBDoAACAHQXxqIApxIAZqQQRqIAQ6AAALIAdBAWohBCAHIApHDQALCyAAQQA2AgAgASANIAhrNgIIDAcLIAQgBmoiBygCACEFIAcgBUEHdkF/c0GBgoQIcSAFQf/+/fsHcmo2AgBBASEFIARBAWohBAwACwALQQRBCCAEQQRJGwsiBCAEQf////8DcUYEQCAEQQJ0IgUgBEEEaiILaiIHIAVPDQELEKILIA4oAgghBSAOKAIMIQEMAQsgB0EEEMULIgYNASAHQQRBoJ3DACgCACIAQa8GIAAbEQAAAAsgACAFNgIEIABBATYCACAAQQhqIAE2AgAMAQsgBSAGakH/ASALEOgGIQYgBEF/aiINIARBA3ZBB2wgDUEISRsgCGutIAitQiCGhCETIAFBBGooAgAiB0EEaiEFIAcgCWohECAHKAIAQX9zQYCBgoR4cSEIIAchCwNAAkACQCAIRQRAA0AgBSAQTw0CIAtBcGohCyAFKAIAIAVBBGoiBCEFQYCBgoR4cSIIQYCBgoR4Rg0ACyAIQYCBgoR4cyEIIAQhBQsgCGhBA3ZBf3NBAnQgC2oiESgCACIEIANJDQEgBCADQcCewAAQzQgACyABIBM3AgggASANNgIAIABBADYCACABQQRqIAY2AgAgCkUNAiAHIAlBAnRrEOEBDAILIAYgDSAEQRRsIAJqKAIAIhJxIgxqKAAAQYCBgoR4cSIPRQRAQQQhBANAIAQgDGohDCAEQQRqIQQgBiAMIA1xIgxqKAAAQYCBgoR4cSIPRQ0ACwsgCEF/aiAIcSEIIAYgD2hBA3YgDGogDXEiBGosAABBf0oEQCAGKAIAQYCBgoR4cWhBA3YhBAsgBCAGaiASQRl2Igw6AAAgBEF8aiANcSAGakEEaiAMOgAAIARBf3NBAnQgBmogESgCADYCAAwACwALIA5BIGokAAveCgIPfwF+IwBBIGsiDiQAAkAgAUEMaigCACIIQQFqIgQgCEkEQBCiCyAOKQMAIRMgAEEBNgIAIAAgEzcCBAwBCwJAAkACQAJ/IAEoAgAiCkEBaiEJAkAgBCAKIAlBA3ZBB2wgCkEISRsiDUEBdksEQCAEIA1BAWoiBSAEIAVLGyIEQQhJDQEgBEH/////AXEgBEYEQEF/IARBA3RBB25Bf2pndkEBagwDCxCiCyAOKAIYIQUgDigCHCEBDAQLIAFBBGooAgAhBkEAIQQDQAJAAkAgBUEBcUUEQCAEIAlPDQEMAgsgBEEDaiIFIARJDQAgBSIEIAlJDQELAkACQCAJQQRPBEAgBiAJaiAGKAAANgAADAELIAZBBGogBiAJEL8EGiAJRQ0BC0EAIQQDQAJAIAYgBCIHaiIMLQAAQYABRw0AAkACQCAHQX9zQQJ0IAZqIgkoAgAiBCADSQRAA0AgBiAEQQR0IAJqKAIAIg8gCnEiCyIFaigAAEGAgYKEeHEiEEUEQEEEIQQgCyEFA0AgBCAFaiEFIARBBGohBCAGIAUgCnEiBWooAABBgIGChHhxIhBFDQALCyAGIBBoQQN2IAVqIApxIgRqLAAAQX9KBEAgBigCAEGAgYKEeHFoQQN2IQQLIAQgC2sgByALa3MgCnFBBEkNAyAEIAZqIgUtAAAgBSAPQRl2IgU6AAAgBEF8aiAKcSAGakEEaiAFOgAAQf8BRg0CIARBf3NBAnQgBmoiBSgCACEEIAUgCSgCADYCACAJIAQ2AgAgBCADSQ0ACwsgBCADQfjfwAAQzQgACyAMQf8BOgAAIAdBfGogCnEgBmpBBGpB/wE6AAAgBEF/c0ECdCAGaiAJKAIANgIADAELIAwgD0EZdiIEOgAAIAdBfGogCnEgBmpBBGogBDoAAAsgB0EBaiEEIAcgCkcNAAsLIABBADYCACABIA0gCGs2AggMBwsgBCAGaiIHKAIAIQUgByAFQQd2QX9zQYGChAhxIAVB//79+wdyajYCAEEBIQUgBEEBaiEEDAALAAtBBEEIIARBBEkbCyIEIARB/////wNxRgRAIARBAnQiBSAEQQRqIgtqIgcgBU8NAQsQogsgDigCCCEFIA4oAgwhAQwBCyAHQQQQxQsiBg0BIAdBBEGgncMAKAIAIgBBrwYgABsRAAAACyAAIAU2AgQgAEEBNgIAIABBCGogATYCAAwBCyAFIAZqQf8BIAsQ6AYhBiAEQX9qIg0gBEEDdkEHbCANQQhJGyAIa60gCK1CIIaEIRMgAUEEaigCACIHQQRqIQUgByAJaiEQIAcoAgBBf3NBgIGChHhxIQggByELA0ACQAJAIAhFBEADQCAFIBBPDQIgC0FwaiELIAUoAgAgBUEEaiIEIQVBgIGChHhxIghBgIGChHhGDQALIAhBgIGChHhzIQggBCEFCyAIaEEDdkF/c0ECdCALaiIRKAIAIgQgA0kNASAEIANB+N/AABDNCAALIAEgEzcCCCABIA02AgAgAEEANgIAIAFBBGogBjYCACAKRQ0CIAcgCUECdGsQ4QEMAgsgBiANIARBBHQgAmooAgAiEnEiDGooAABBgIGChHhxIg9FBEBBBCEEA0AgBCAMaiEMIARBBGohBCAGIAwgDXEiDGooAABBgIGChHhxIg9FDQALCyAIQX9qIAhxIQggBiAPaEEDdiAMaiANcSIEaiwAAEF/SgRAIAYoAgBBgIGChHhxaEEDdiEECyAEIAZqIBJBGXYiDDoAACAEQXxqIA1xIAZqQQRqIAw6AAAgBEF/c0ECdCAGaiARKAIANgIADAALAAsgDkEgaiQAC94KAg9/AX4jAEEgayIOJAACQCABQQxqKAIAIghBAWoiBCAISQRAEKILIA4pAwAhEyAAQQE2AgAgACATNwIEDAELAkACQAJAAn8gASgCACIKQQFqIQkCQCAEIAogCUEDdkEHbCAKQQhJGyINQQF2SwRAIAQgDUEBaiIFIAQgBUsbIgRBCEkNASAEQf////8BcSAERgRAQX8gBEEDdEEHbkF/amd2QQFqDAMLEKILIA4oAhghBSAOKAIcIQEMBAsgAUEEaigCACEGQQAhBANAAkACQCAFQQFxRQRAIAQgCU8NAQwCCyAEQQNqIgUgBEkNACAFIgQgCUkNAQsCQAJAIAlBBE8EQCAGIAlqIAYoAAA2AAAMAQsgBkEEaiAGIAkQvwQaIAlFDQELQQAhBANAAkAgBiAEIgdqIgwtAABBgAFHDQACQAJAIAdBf3NBAnQgBmoiCSgCACIEIANJBEADQCAGIARBFGwgAmooAgAiDyAKcSILIgVqKAAAQYCBgoR4cSIQRQRAQQQhBCALIQUDQCAEIAVqIQUgBEEEaiEEIAYgBSAKcSIFaigAAEGAgYKEeHEiEEUNAAsLIAYgEGhBA3YgBWogCnEiBGosAABBf0oEQCAGKAIAQYCBgoR4cWhBA3YhBAsgBCALayAHIAtrcyAKcUEESQ0DIAQgBmoiBS0AACAFIA9BGXYiBToAACAEQXxqIApxIAZqQQRqIAU6AABB/wFGDQIgBEF/c0ECdCAGaiIFKAIAIQQgBSAJKAIANgIAIAkgBDYCACAEIANJDQALCyAEIANB+N/AABDNCAALIAxB/wE6AAAgB0F8aiAKcSAGakEEakH/AToAACAEQX9zQQJ0IAZqIAkoAgA2AgAMAQsgDCAPQRl2IgQ6AAAgB0F8aiAKcSAGakEEaiAEOgAACyAHQQFqIQQgByAKRw0ACwsgAEEANgIAIAEgDSAIazYCCAwHCyAEIAZqIgcoAgAhBSAHIAVBB3ZBf3NBgYKECHEgBUH//v37B3JqNgIAQQEhBSAEQQFqIQQMAAsAC0EEQQggBEEESRsLIgQgBEH/////A3FGBEAgBEECdCIFIARBBGoiC2oiByAFTw0BCxCiCyAOKAIIIQUgDigCDCEBDAELIAdBBBDFCyIGDQEgB0EEQaCdwwAoAgAiAEGvBiAAGxEAAAALIAAgBTYCBCAAQQE2AgAgAEEIaiABNgIADAELIAUgBmpB/wEgCxDoBiEGIARBf2oiDSAEQQN2QQdsIA1BCEkbIAhrrSAIrUIghoQhEyABQQRqKAIAIgdBBGohBSAHIAlqIRAgBygCAEF/c0GAgYKEeHEhCCAHIQsDQAJAAkAgCEUEQANAIAUgEE8NAiALQXBqIQsgBSgCACAFQQRqIgQhBUGAgYKEeHEiCEGAgYKEeEYNAAsgCEGAgYKEeHMhCCAEIQULIAhoQQN2QX9zQQJ0IAtqIhEoAgAiBCADSQ0BIAQgA0H438AAEM0IAAsgASATNwIIIAEgDTYCACAAQQA2AgAgAUEEaiAGNgIAIApFDQIgByAJQQJ0axDhAQwCCyAGIA0gBEEUbCACaigCACIScSIMaigAAEGAgYKEeHEiD0UEQEEEIQQDQCAEIAxqIQwgBEEEaiEEIAYgDCANcSIMaigAAEGAgYKEeHEiD0UNAAsLIAhBf2ogCHEhCCAGIA9oQQN2IAxqIA1xIgRqLAAAQX9KBEAgBigCAEGAgYKEeHFoQQN2IQQLIAQgBmogEkEZdiIMOgAAIARBfGogDXEgBmpBBGogDDoAACAEQX9zQQJ0IAZqIBEoAgA2AgAMAAsACyAOQSBqJAAL3goCD38BfiMAQSBrIg4kAAJAIAFBDGooAgAiCEEBaiIEIAhJBEAQogsgDikDACETIABBATYCACAAIBM3AgQMAQsCQAJAAkACfyABKAIAIgpBAWohCQJAIAQgCiAJQQN2QQdsIApBCEkbIg1BAXZLBEAgBCANQQFqIgUgBCAFSxsiBEEISQ0BIARB/////wFxIARGBEBBfyAEQQN0QQduQX9qZ3ZBAWoMAwsQogsgDigCGCEFIA4oAhwhAQwECyABQQRqKAIAIQZBACEEA0ACQAJAIAVBAXFFBEAgBCAJTw0BDAILIARBA2oiBSAESQ0AIAUiBCAJSQ0BCwJAAkAgCUEETwRAIAYgCWogBigAADYAAAwBCyAGQQRqIAYgCRC/BBogCUUNAQtBACEEA0ACQCAGIAQiB2oiDC0AAEGAAUcNAAJAAkAgB0F/c0ECdCAGaiIJKAIAIgQgA0kEQANAIAYgBEEMbCACaigCACIPIApxIgsiBWooAABBgIGChHhxIhBFBEBBBCEEIAshBQNAIAQgBWohBSAEQQRqIQQgBiAFIApxIgVqKAAAQYCBgoR4cSIQRQ0ACwsgBiAQaEEDdiAFaiAKcSIEaiwAAEF/SgRAIAYoAgBBgIGChHhxaEEDdiEECyAEIAtrIAcgC2tzIApxQQRJDQMgBCAGaiIFLQAAIAUgD0EZdiIFOgAAIARBfGogCnEgBmpBBGogBToAAEH/AUYNAiAEQX9zQQJ0IAZqIgUoAgAhBCAFIAkoAgA2AgAgCSAENgIAIAQgA0kNAAsLIAQgA0H438AAEM0IAAsgDEH/AToAACAHQXxqIApxIAZqQQRqQf8BOgAAIARBf3NBAnQgBmogCSgCADYCAAwBCyAMIA9BGXYiBDoAACAHQXxqIApxIAZqQQRqIAQ6AAALIAdBAWohBCAHIApHDQALCyAAQQA2AgAgASANIAhrNgIIDAcLIAQgBmoiBygCACEFIAcgBUEHdkF/c0GBgoQIcSAFQf/+/fsHcmo2AgBBASEFIARBAWohBAwACwALQQRBCCAEQQRJGwsiBCAEQf////8DcUYEQCAEQQJ0IgUgBEEEaiILaiIHIAVPDQELEKILIA4oAgghBSAOKAIMIQEMAQsgB0EEEMULIgYNASAHQQRBoJ3DACgCACIAQa8GIAAbEQAAAAsgACAFNgIEIABBATYCACAAQQhqIAE2AgAMAQsgBSAGakH/ASALEOgGIQYgBEF/aiINIARBA3ZBB2wgDUEISRsgCGutIAitQiCGhCETIAFBBGooAgAiB0EEaiEFIAcgCWohECAHKAIAQX9zQYCBgoR4cSEIIAchCwNAAkACQCAIRQRAA0AgBSAQTw0CIAtBcGohCyAFKAIAIAVBBGoiBCEFQYCBgoR4cSIIQYCBgoR4Rg0ACyAIQYCBgoR4cyEIIAQhBQsgCGhBA3ZBf3NBAnQgC2oiESgCACIEIANJDQEgBCADQfjfwAAQzQgACyABIBM3AgggASANNgIAIABBADYCACABQQRqIAY2AgAgCkUNAiAHIAlBAnRrEOEBDAILIAYgDSAEQQxsIAJqKAIAIhJxIgxqKAAAQYCBgoR4cSIPRQRAQQQhBANAIAQgDGohDCAEQQRqIQQgBiAMIA1xIgxqKAAAQYCBgoR4cSIPRQ0ACwsgCEF/aiAIcSEIIAYgD2hBA3YgDGogDXEiBGosAABBf0oEQCAGKAIAQYCBgoR4cWhBA3YhBAsgBCAGaiASQRl2Igw6AAAgBEF8aiANcSAGakEEaiAMOgAAIARBf3NBAnQgBmogESgCADYCAAwACwALIA5BIGokAAveCgIPfwF+IwBBIGsiDiQAAkAgAUEMaigCACIIQQFqIgQgCEkEQBCiCyAOKQMAIRMgAEEBNgIAIAAgEzcCBAwBCwJAAkACQAJ/IAEoAgAiCkEBaiEJAkAgBCAKIAlBA3ZBB2wgCkEISRsiDUEBdksEQCAEIA1BAWoiBSAEIAVLGyIEQQhJDQEgBEH/////AXEgBEYEQEF/IARBA3RBB25Bf2pndkEBagwDCxCiCyAOKAIYIQUgDigCHCEBDAQLIAFBBGooAgAhBkEAIQQDQAJAAkAgBUEBcUUEQCAEIAlPDQEMAgsgBEEDaiIFIARJDQAgBSIEIAlJDQELAkACQCAJQQRPBEAgBiAJaiAGKAAANgAADAELIAZBBGogBiAJEL8EGiAJRQ0BC0EAIQQDQAJAIAYgBCIHaiIMLQAAQYABRw0AAkACQCAHQX9zQQJ0IAZqIgkoAgAiBCADSQRAA0AgBiAEQQR0IAJqKAIAIg8gCnEiCyIFaigAAEGAgYKEeHEiEEUEQEEEIQQgCyEFA0AgBCAFaiEFIARBBGohBCAGIAUgCnEiBWooAABBgIGChHhxIhBFDQALCyAGIBBoQQN2IAVqIApxIgRqLAAAQX9KBEAgBigCAEGAgYKEeHFoQQN2IQQLIAQgC2sgByALa3MgCnFBBEkNAyAEIAZqIgUtAAAgBSAPQRl2IgU6AAAgBEF8aiAKcSAGakEEaiAFOgAAQf8BRg0CIARBf3NBAnQgBmoiBSgCACEEIAUgCSgCADYCACAJIAQ2AgAgBCADSQ0ACwsgBCADQai6wQAQzQgACyAMQf8BOgAAIAdBfGogCnEgBmpBBGpB/wE6AAAgBEF/c0ECdCAGaiAJKAIANgIADAELIAwgD0EZdiIEOgAAIAdBfGogCnEgBmpBBGogBDoAAAsgB0EBaiEEIAcgCkcNAAsLIABBADYCACABIA0gCGs2AggMBwsgBCAGaiIHKAIAIQUgByAFQQd2QX9zQYGChAhxIAVB//79+wdyajYCAEEBIQUgBEEBaiEEDAALAAtBBEEIIARBBEkbCyIEIARB/////wNxRgRAIARBAnQiBSAEQQRqIgtqIgcgBU8NAQsQogsgDigCCCEFIA4oAgwhAQwBCyAHQQQQxQsiBg0BIAdBBEGgncMAKAIAIgBBrwYgABsRAAAACyAAIAU2AgQgAEEBNgIAIABBCGogATYCAAwBCyAFIAZqQf8BIAsQ6AYhBiAEQX9qIg0gBEEDdkEHbCANQQhJGyAIa60gCK1CIIaEIRMgAUEEaigCACIHQQRqIQUgByAJaiEQIAcoAgBBf3NBgIGChHhxIQggByELA0ACQAJAIAhFBEADQCAFIBBPDQIgC0FwaiELIAUoAgAgBUEEaiIEIQVBgIGChHhxIghBgIGChHhGDQALIAhBgIGChHhzIQggBCEFCyAIaEEDdkF/c0ECdCALaiIRKAIAIgQgA0kNASAEIANBqLrBABDNCAALIAEgEzcCCCABIA02AgAgAEEANgIAIAFBBGogBjYCACAKRQ0CIAcgCUECdGsQ4QEMAgsgBiANIARBBHQgAmooAgAiEnEiDGooAABBgIGChHhxIg9FBEBBBCEEA0AgBCAMaiEMIARBBGohBCAGIAwgDXEiDGooAABBgIGChHhxIg9FDQALCyAIQX9qIAhxIQggBiAPaEEDdiAMaiANcSIEaiwAAEF/SgRAIAYoAgBBgIGChHhxaEEDdiEECyAEIAZqIBJBGXYiDDoAACAEQXxqIA1xIAZqQQRqIAw6AAAgBEF/c0ECdCAGaiARKAIANgIADAALAAsgDkEgaiQAC6sKATJ/IAC8IgJBgICA/AdxQYCAgPwHRgRAIAAgAJQgAJIPCyACQQFOBEACQCACQf///wNLBEAgAkEXdiEDDAELQQEhAyACQYCAgARxDQBBCSACZyIBayEDIAIgAUF4anQhAgsgAkH///8DcUGAgIAEciADQYF/aiIyQQFxdCIDQf///wNLIgFBGHQhAiADQQF0IAJrQQF0IgMgAUEZdCIBQYCAgARyIhpIIQQgA0EAIBogBBtrQQF0IhsgASABQYCAgAhyIAQbIgFBgICAAnIiBEghBSAbQQAgBCAFG2tBAXQiHCABIAFBgICABHIgBRsiAUGAgIABciIFSCEGIBxBACAFIAYba0EBdCIdIAEgAUGAgIACciAGGyIBQYCAQGsiBkghByAdQQAgBiAHG2tBAXQiHiABIAFBgICAAWogBxsiAUGAgCBqIgdIIQggHkEAIAcgCBtrQQF0Ih8gASABQYCAQGsgCBsiAUGAgBBqIghIIQkgH0EAIAggCRtrQQF0IiAgASABQYCAIGogCRsiAUGAgAhqIglIIQogIEEAIAkgChtrQQF0IiEgASABQYCAEGogChsiAUGAgARqIgpIIQsgIUEAIAogCxtrQQF0IiIgASABQYCACGogCxsiAUGAgAJqIgtIIQwgIkEAIAsgDBtrQQF0IiMgASABQYCABGogDBsiAUGAgAFqIgxIIQ0gI0EAIAwgDRtrQQF0IiQgASABQYCAAmogDRsiAUGAQGsiDUghDiAkQQAgDSAOG2tBAXQiJSABIAFBgIABaiAOGyIBQYAgaiIOSCEPICVBACAOIA8ba0EBdCImIAEgAUGAQGsgDxsiAUGAEGoiD0ghECAmQQAgDyAQG2tBAXQiJyABIAFBgCBqIBAbIgFBgAhqIhBIIREgJ0EAIBAgERtrQQF0IiggASABQYAQaiARGyIBQYAEaiIRSCESIChBACARIBIba0EBdCIpIAEgAUGACGogEhsiAUGAAmoiEkghEyApQQAgEiATG2tBAXQiKiABIAFBgARqIBMbIgFBgAFqIhNIIRQgKkEAIBMgFBtrQQF0IisgASABQYACaiAUGyIBQUBrIhRIIRUgK0EAIBQgFRtrQQF0IiwgASABQYABaiAVGyIBQSBqIhVIIRYgLEEAIBUgFhtrQQF0Ii0gASABQUBrIBYbIgFBEGoiFkghFyAtQQAgFiAXG2tBAXQiLiABIAFBIGogFxsiAUEIaiIXSCEYIC5BACAXIBgba0EBdCIvIAEgAUEQaiAYGyIBQQRqIhhIIRkgL0EAIBggGRtrQQF0IjAgASABQQhqIBkbIgFBAmoiGUghMSAyQRZ0QYCAgPgDakGAgIB8cSADIBpOQRd0IAJyIBsgBE5BFnRyIBwgBU5BFXRyIB0gBk5BFHRyIB4gB05BE3RyIB8gCE5BEnRyICAgCU5BEXRqICEgCk5BEHRqICIgC05BD3RqICMgDE5BDnRqICQgDU5BDXRqICUgDk5BDHRqICYgD05BC3RqICcgEE5BCnRqICggEU5BCXRqICkgEk5BCHRqICogE05BB3RqICsgFE5BBnRqICwgFU5BBXRqIC0gFk5BBHRqIC4gF05BA3RqIC8gGE5BAnRqIDAgGU5BAXRqIDBBACAZIDEba0EBdCICIAEgAUEEaiAxG0EBaiIDTmoiASABQQFxQQAgAkEAIAMgAiADSBtrQf////8HcRtqQQF1ar4PCyACQf////8HcQR9IAAgAJMiACAAlQUgAAsLuwsCA38ZfSMAQUBqIgYkAEMAAKA1ELMBISECQAJAAkACQCAEQQxqKgIAIgsgC5QgBEEQaioCACIUIBSUkiAEQRRqKgIAIgkgCZSSQwAAAACSELMBIhNDAAAAAFsNACATvEH/////B3G+QwAAgH9cBEAgE4siCkMAAAA0Xw0BIAogCkMAAAA0lF8NAQtDAAAAACEKIAQqAgghFiAEKgIEIRcgBCoCACEYIAkgE5UiGYwhHyAUIBOVIiCMIQ4gCyATlSIajCEPAkACfQJAIBkgGZQgGiAalEMAAAAAkpJDAAAAAJIQswEiC0MAAAAAXARAIAGMIRQgDyALlSAClCIJIA+UIA4gAZQiEJMgGSAfIAuVIAKUIgqUkyAQXQ0BIBQhCwwDCyABjCEUIAEgDpgMAQtDAAAAACEKIAELIQtDAAAAACEJCyADQQA2AhwgA0EANgK8ASADQUBrQQA2AgAgA0E4akIANwIAIANBNGogCjgCACADQTBqIAs4AgAgA0EsaiAJOAIAIANBKGogCiAWkzgCACADQSRqIAsgF5M4AgAgAyAJIBiTOAIgIAZBCGogAxBNQ///f38hC0GQzgAhCAJAA0AgBioCCCIMIAyUIAYqAgwiDSANlJIgBioCECIRIBGUkkMAAAAAkiIJQwAAyCteRQ0DIBGMIAkQswEiCZUhCiANjCAJlSEVIAyMIAmVIRACfQJAAkAgCSALYCIHBEAgG0MAAAAAXkUNAQwHCyAKIAqUIBAgEJRDAAAAAJKSQwAAAACSELMBIgxDAAAAAFsNASAUIAogCiAMlSAClCIRlCAQIBAgDJUgApQiDJQgFSABlCINk5IgDV1FDQIaQwAAAAAhEUMAAAAAIQwgAQwCCyAWIBGSIREgGCAMkiEMIBcgDZIMAQtDAAAAACERQwAAAAAhDCABIBWYCyELIBEgFpMhHCALIBeTIR0gDCAYkyEeAkACQAJAIBkgCpQgGiAQlCAgIBWUkpIiDUMAAAAAWw0AIA28Qf////8Hcb5DAACAf1wEQCANiyISQwAAADRfDQEgEiASQwAAADSUXw0BCyAKIByUIBUgHZQgECAelJKSIA2VIhJDAAAAAGANAQtBACEEIA1DAACgNV4NBiAHDQYMAQsCQAJAIA1DAAAAAF1FDQAgEkMAAAAAXkUNACAbIBKSIhsgE5UgBV4EQCAAQQA2AgAMCQsgGSASlCEJICAgEpQhDiAaIBKUIQ8CQCADKAK8ASIHQQFqIgQgB0kNACADIAMqAiAgD5M4AiAgAyADKgIkIA6TOAIkIAMgAyoCKCAJkzgCKCAHRQ0AIAMgAyoCRCAPkzgCRCADIAMqAkggDpM4AkggAyADKgJMIAmTOAJMIARBAkYNACADIAMqAmggD5M4AmggAyADKgJsIA6TOAJsIAMgAyoCcCAJkzgCcCAEQQNGDQAgAyADKgKMASAPkzgCjAEgAyADKgKQASAOkzgCkAEgAyADKgKUASAJkzgClAEgBEEERw0CCyARIBYgCZIiFpMhHCALIBcgDpIiF5MhHSAMIBggD5IiGJMhHkP//39/IQkgCiEfIBUhDiAQIQ8MAgsgB0UNASAAQQA2AgAMBwtBBEEEQfTiwQAQzQgACyAKIByUIBUgHZQgECAelJKSIgogClwNAUEAIQQgCSAKkiAhIAmUXw0EIAZBADYCOCAGQgA3AzAgBiAROAIsIAYgCzgCKCAGIAw4AiQgBiAcOAIgIAYgHTgCHCAGIB44AhggAyAGQRhqEJkCGiAGQQhqIAMQTSADKAK8AUEDRwRAIAkhCyAIQX9qIggNAQwFCwsgCkMAAKC1X0UNAgwDC0Hs38EAQShBpODBABDbCQALIABBADYCAAwCCyAAQRBqIB84AgAgAEEMaiAOOAIAIABBCGogDzgCACAAIBsgE5U4AgRBASEECyAAIAQ2AgALIAZBQGskAAvWCgIQfwF+IwBBIGsiDiQAAkAgAUEMaigCACIIQQFqIgQgCEkEQBCiCyAOKQMAIRQgAEEBNgIAIAAgFDcCBAwBCwJAAkACQAJ/IAEoAgAiCkEBaiEJAkAgBCAKIAlBA3ZBB2wgCkEISRsiDUEBdksEQCAEIA1BAWoiBSAEIAVLGyIEQQhJDQEgBEH/////AXEgBEYEQEF/IARBA3RBB25Bf2pndkEBagwDCxCiCyAOKAIYIQUgDigCHCEBDAQLIAFBBGooAgAhBkEAIQQDQAJAAkAgBUEBcUUEQCAEIAlPDQEMAgsgBEEDaiIFIARJDQAgBSIEIAlJDQELAkACQCAJQQRPBEAgBiAJaiAGKAAANgAADAELIAZBBGogBiAJEL8EGiAJRQ0BC0EAIQQDQAJAIAYgBCIHaiIMLQAAQYABRw0AAkACQCAHQX9zQQJ0IAZqIgkoAgAiBCADSQRAA0AgBiAEQQR0IAJqKAIAIg8gCnEiCyIFaigAAEGAgYKEeHEiEEUEQEEEIQQgCyEFA0AgBCAFaiEFIARBBGohBCAGIAUgCnEiBWooAABBgIGChHhxIhBFDQALCyAGIBBoQQN2IAVqIApxIgRqLAAAQX9KBEAgBigCAEGAgYKEeHFoQQN2IQQLIAQgC2sgByALa3MgCnFBBEkNAyAEIAZqIgUtAAAgBSAPQRl2IgU6AAAgBEF8aiAKcSAGakEEaiAFOgAAQf8BRg0CIARBf3NBAnQgBmoiBSgCACEEIAUgCSgCADYCACAJIAQ2AgAgBCADSQ0ACwsgBCADQcCewAAQzQgACyAMQf8BOgAAIAdBfGogCnEgBmpBBGpB/wE6AAAgBEF/c0ECdCAGaiAJKAIANgIADAELIAwgD0EZdiIEOgAAIAdBfGogCnEgBmpBBGogBDoAAAsgB0EBaiEEIAcgCkcNAAsLIABBADYCACABIA0gCGs2AggMBwsgBCAGaiIHKAIAIQUgByAFQQd2QX9zQYGChAhxIAVB//79+wdyajYCAEEBIQUgBEEBaiEEDAALAAtBBEEIIARBBEkbCyIEIARB/////wNxRgRAIARBAnQiBSAEQQRqIgtqIgcgBU8NAQsQogsgDigCCCEFIA4oAgwhAQwBCyAHQQQQxQsiBg0BIAdBBEGgncMAKAIAIgBBrwYgABsRAAAACyAAIAU2AgQgAEEBNgIAIABBCGogATYCAAwBCyAFIAZqQf8BIAsQ6AYhBiAEQX9qIg0gBEEDdkEHbCANQQhJGyAIayEQIAFBBGooAgAiB0EEaiEFIAcgCWohESAHKAIAQX9zQYCBgoR4cSEIIAchCwNAAkACQCAIRQRAA0AgBSARTw0CIAtBcGohCyAFKAIAIAVBBGoiBCEFQYCBgoR4cSIIQYCBgoR4Rg0ACyAIQYCBgoR4cyEIIAQhBQsgCGhBA3ZBf3NBAnQgC2oiEigCACIEIANJDQEgBCADQcCewAAQzQgACyABIBA2AgggASANNgIAIABBADYCACABQQRqIAY2AgAgCkUNAiAHIAlBAnRrEOEBDAILIAYgDSAEQQR0IAJqKAIAIhNxIgxqKAAAQYCBgoR4cSIPRQRAQQQhBANAIAQgDGohDCAEQQRqIQQgBiAMIA1xIgxqKAAAQYCBgoR4cSIPRQ0ACwsgCEF/aiAIcSEIIAYgD2hBA3YgDGogDXEiBGosAABBf0oEQCAGKAIAQYCBgoR4cWhBA3YhBAsgBCAGaiATQRl2Igw6AAAgBEF8aiANcSAGakEEaiAMOgAAIARBf3NBAnQgBmogEigCADYCAAwACwALIA5BIGokAAvWCgIQfwF+IwBBIGsiDiQAAkAgAUEMaigCACIIQQFqIgQgCEkEQBCiCyAOKQMAIRQgAEEBNgIAIAAgFDcCBAwBCwJAAkACQAJ/IAEoAgAiCkEBaiEJAkAgBCAKIAlBA3ZBB2wgCkEISRsiDUEBdksEQCAEIA1BAWoiBSAEIAVLGyIEQQhJDQEgBEH/////AXEgBEYEQEF/IARBA3RBB25Bf2pndkEBagwDCxCiCyAOKAIYIQUgDigCHCEBDAQLIAFBBGooAgAhBkEAIQQDQAJAAkAgBUEBcUUEQCAEIAlPDQEMAgsgBEEDaiIFIARJDQAgBSIEIAlJDQELAkACQCAJQQRPBEAgBiAJaiAGKAAANgAADAELIAZBBGogBiAJEL8EGiAJRQ0BC0EAIQQDQAJAIAYgBCIHaiIMLQAAQYABRw0AAkACQCAHQX9zQQJ0IAZqIgkoAgAiBCADSQRAA0AgBiAEQQR0IAJqKAIAIg8gCnEiCyIFaigAAEGAgYKEeHEiEEUEQEEEIQQgCyEFA0AgBCAFaiEFIARBBGohBCAGIAUgCnEiBWooAABBgIGChHhxIhBFDQALCyAGIBBoQQN2IAVqIApxIgRqLAAAQX9KBEAgBigCAEGAgYKEeHFoQQN2IQQLIAQgC2sgByALa3MgCnFBBEkNAyAEIAZqIgUtAAAgBSAPQRl2IgU6AAAgBEF8aiAKcSAGakEEaiAFOgAAQf8BRg0CIARBf3NBAnQgBmoiBSgCACEEIAUgCSgCADYCACAJIAQ2AgAgBCADSQ0ACwsgBCADQfjfwAAQzQgACyAMQf8BOgAAIAdBfGogCnEgBmpBBGpB/wE6AAAgBEF/c0ECdCAGaiAJKAIANgIADAELIAwgD0EZdiIEOgAAIAdBfGogCnEgBmpBBGogBDoAAAsgB0EBaiEEIAcgCkcNAAsLIABBADYCACABIA0gCGs2AggMBwsgBCAGaiIHKAIAIQUgByAFQQd2QX9zQYGChAhxIAVB//79+wdyajYCAEEBIQUgBEEBaiEEDAALAAtBBEEIIARBBEkbCyIEIARB/////wNxRgRAIARBAnQiBSAEQQRqIgtqIgcgBU8NAQsQogsgDigCCCEFIA4oAgwhAQwBCyAHQQQQxQsiBg0BIAdBBEGgncMAKAIAIgBBrwYgABsRAAAACyAAIAU2AgQgAEEBNgIAIABBCGogATYCAAwBCyAFIAZqQf8BIAsQ6AYhBiAEQX9qIg0gBEEDdkEHbCANQQhJGyAIayEQIAFBBGooAgAiB0EEaiEFIAcgCWohESAHKAIAQX9zQYCBgoR4cSEIIAchCwNAAkACQCAIRQRAA0AgBSARTw0CIAtBcGohCyAFKAIAIAVBBGoiBCEFQYCBgoR4cSIIQYCBgoR4Rg0ACyAIQYCBgoR4cyEIIAQhBQsgCGhBA3ZBf3NBAnQgC2oiEigCACIEIANJDQEgBCADQfjfwAAQzQgACyABIBA2AgggASANNgIAIABBADYCACABQQRqIAY2AgAgCkUNAiAHIAlBAnRrEOEBDAILIAYgDSAEQQR0IAJqKAIAIhNxIgxqKAAAQYCBgoR4cSIPRQRAQQQhBANAIAQgDGohDCAEQQRqIQQgBiAMIA1xIgxqKAAAQYCBgoR4cSIPRQ0ACwsgCEF/aiAIcSEIIAYgD2hBA3YgDGogDXEiBGosAABBf0oEQCAGKAIAQYCBgoR4cWhBA3YhBAsgBCAGaiATQRl2Igw6AAAgBEF8aiANcSAGakEEaiAMOgAAIARBf3NBAnQgBmogEigCADYCAAwACwALIA5BIGokAAuoCwIFfxl9IwBBQGoiBSQAQwAAoDUQswEhIgJAAkACQAJAAkAgA0EMaioCACILIAuUIANBEGoqAgAiCiAKlJIgA0EUaioCACIMIAyUkkMAAAAAkhCzASITQwAAAABbDQAgE7xB/////wdxvkMAAIB/XARAIBOLIg9DAAAANF8NASAPIA9DAAAANJRfDQELIAMqAgAhFSADKgIEIRYgAyoCCCEXIAwgE5UiGSAZlCALIBOVIhogGpQgCiATlSIbIBuUkpJDAAAAAJIQswEhCyACQQA2ArwBIAJBQGtBADYCACACQThqQgA3AgAgAkEANgIcIAJBNGogGYwiECALlSIKIAEqAgwiGJQgASgCCEH/////B3EiByAKvEGAgICAeHFyvpIiCjgCACACQTBqIBggG4wiESALlSIMlCABKAIEQf////8HcSIIIAy8QYCAgIB4cXK+kiIMOAIAIAJBLGogGCAajCIhIAuVIguUIAEoAgBB/////wdxIgkgC7xBgICAgHhxcr6SIgs4AgAgAkEoaiAKIBeTOAIAIAJBJGogDCAWkzgCACACIAsgFZM4AiAgBUEIaiACEE1D//9/fyELQZDOACEBA0AgBSoCCCINIA2UIAUqAgwiDiAOlJIgBSoCECISIBKUkkMAAAAAkiIKQwAAyCteRQ0DIBKMIAoQswEiCpUhDCAOjCAKlSEPIA2MIAqVIRQCfSAKIAtgIgZFBEAgGCAMIAwgDJQgFCAUlCAPIA+UkpJDAAAAAJIQswEiDZUiC5QgC7xBgICAgHhxIAdyvpIhCyAYIA8gDZUiDpQgDrxBgICAgHhxIAhyvpIhEiAYIBQgDZUiDZQgDbxBgICAgHhxIAlyvpIMAQsgHEMAAAAAXg0EIBcgEpIhCyAWIA6SIRIgFSANkgshICALIBeTIR0gEiAWkyEeICAgFZMhHwJAAkACQCAZIAyUIBogFJQgGyAPlJKSIg1DAAAAAFsNACANvEH/////B3G+QwAAgH9cBEAgDYsiDkMAAAA0Xw0BIA4gDkMAAAA0lF8NAQsgDCAdlCAPIB6UIBQgH5SSkiANlSIOQwAAAABgDQELQQAhAyANQwAAoDVeDQYgBg0GDAELAkACQCANQwAAAABdRQ0AIA5DAAAAAF5FDQAgHCAOkiIcIBOVIAReBEAgAEEANgIADAkLIBkgDpQhCiAbIA6UIRAgGiAOlCERAkAgAigCvAEiBkEBaiIDIAZJDQAgAiACKgIgIBGTOAIgIAIgAioCJCAQkzgCJCACIAIqAiggCpM4AiggBkUNACACIAIqAkQgEZM4AkQgAiACKgJIIBCTOAJIIAIgAioCTCAKkzgCTCADQQJGDQAgAiACKgJoIBGTOAJoIAIgAioCbCAQkzgCbCACIAIqAnAgCpM4AnAgA0EDRg0AIAIgAioCjAEgEZM4AowBIAIgAioCkAEgEJM4ApABIAIgAioClAEgCpM4ApQBIANBBEcNAgsgCyAXIAqSIheTIR0gEiAWIBCSIhaTIR4gICAVIBGSIhWTIR9D//9/fyEKIAwhECAPIREgFCEhDAILIAZFDQEgAEEANgIADAcLQQRBBEH04sEAEM0IAAsgDCAdlCAPIB6UIBQgH5SSkiIMIAxbBEBBACEDIAogDJIgIiAKlF8NBSAFQQA2AjggBUIANwMwIAUgCzgCLCAFIBI4AiggBSAgOAIkIAUgHTgCICAFIB44AhwgBSAfOAIYIAIgBUEYahCZAhogBUEIaiACEE0gAigCvAFBA0YNAyAKIQsgAUF/aiIBDQEMBQsLQezfwQBBKEGk4MEAENsJAAsgAEEANgIADAMLIAxDAACgtV8NAQsgAEEQaiAQOAIAIABBDGogETgCACAAQQhqICE4AgAgACAcIBOVOAIEQQEhAwsgACADNgIACyAFQUBrJAALtwsCCH8EfiMAQaABayICJAAgAkEDNgIEIAIgATYCAAJAAkACQAJAIAEoAgQiA0EHTQRAEIgLIQMMAQsgASADQXhqNgIEIAEgASgCACIDQQhqNgIAIAMpAAAQpgYiC0IgiKchAyALp0UNAQsgAiADNgJMDAELIAJByABqIAEgAxCGAyACKAJIQQFGDQAgAigCTCIIRQRAQQBBnIfAAEHshcAAEM0FIQEgAEEBNgIAIAAgATYCBAwCCyACQdAAaikDACELIAJByABqIAIQYgJAAkACfyACKAJIQQFHBEAgAkHkAGooAgAiAQ0CQQFBnIfAAEHshcAAEM0FDAELIAIoAkwLIQEgAEEBNgIAIAAgATYCBAwBCyACQRhqIAJB3ABqKQIANwMAIAJBEGogAkHUAGopAgA3AwAgAkEkaiACQegAaikDADcCACACQSxqIAJB8ABqKQMANwIAIAJBNGogAkH4AGopAwA3AgAgAkE8aiACQYABaikDADcCACACQcQAaiACQYgBaigCADYCACACIAIpAkw3AwggAiABNgIgAkACQAJAAkACQCACKAIEIgEEQCACIAFBf2o2AgQgAigCACIHKAIEIgFBB00EQBCICyEDDAULIAcgAUF4ajYCBCAHIAcoAgAiAUEIajYCACABKQAAEKYGIgpCIIinIQQgCqcEQCAEIQMMBQsCQCAEQYAgIARBgCBJGyIDRQRAQQQhBQwBCyADQRhsIgFBBBDFCyIFRQ0DC0EAIQEgAkEANgKYASACIAM2ApQBIAIgBTYCkAEgBARAA0AgAkHIAGogBxCYAyACKAJMIQMCQCACKAJIQQFHBEAgAikDUCEKIAJByABqIAcQmAMgAigCTCEGIAIoAkhBAUcNASAGIQMLIAIoApQBIgFFDQcgAigCkAEiBEUNByABQRhsRQ0HIAQQ4QEMBwsgBEF/aiEEIAIpA1AhDCACKAKUASABRgRAIAJBkAFqIAEQ+AUgAigCkAEhBSACKAKYASEBCyABQRhsIAVqIgkgBjYCDCAJIAo3AgQgCSADNgIAIAlBEGogDDcCACACIAFBAWoiATYCmAEgBA0ACyACKAKQASEFCyAFDQELQQJBnIfAAEHshcAAEM0FIQEgAEEBNgIAIAAgATYCBAwECyACKQKUASEKAkAgAigCBCIBBEAgAiABQX9qNgIEIAJByABqIAIoAgAiAxCYAyACKAJMIQEgAigCSEEBRwRAIAJByABqIgRBCGoiBikDACEMIAQgAxCYAyACKAJMIQMgAigCSEEBRw0CIAMhAQsgACABNgIEDAMLIABBA0Gch8AAQeyFwAAQzQU2AgQMAgsgBikDACENIABBCGogCzcCACAAIAg2AgQgAEEQaiACKQMINwIAIABBGGogAkEIaiIEQQhqKQMANwIAIABBIGogBEEQaikDADcCACAAQShqIARBGGopAwA3AgAgAEEwaiAEQSBqKQMANwIAIABBOGogBEEoaikDADcCACAAQUBrIARBMGopAwA3AgAgAEHIAGogBEE4aikDADcCACAAQewAaiANNwIAIABB6ABqIAM2AgAgAEHgAGogDDcCACAAQdwAaiABNgIAIABB1ABqIAo3AgAgAEHQAGogBTYCACAAQQA2AgAMBgsgAUEEQaCdwwAoAgAiAEGvBiAAGxEAAAALIABBATYCACAKpyIARQ0BIABBGGxFDQEgBRDhAQwBCyAAQQE2AgAgACADNgIECyACQQhqEK0GCyALQiCIpyIABEAgAEEkbCEAIAhBIGohAQNAIAFBfGoiBCgCACIGKAIAIQMgBiADQX9qNgIAIANBAUYEQCAEKAIAIAEoAgAQhggLIAFBJGohASAAQVxqIgANAAsLIAunIgBFDQEgAEEkbEUNASAIEOEBDAELIAIoAkwhASAAQQE2AgAgACABNgIECyACQaABaiQAC/MKARt/IwBBMGsiCCQAIAAgBSAGEM4BAkACQCAERQ0AIABBHGohHiAEQQN0IANqIR8gAigCCCERIAIoAgAhFSAAQSBqIRYgAEE0aiEPIABBJGohEiAAQTBqIRcgAEEsaiEgA0ACQCARIAMoAgAiCksiAkUNACAKQaABbCAVaiIEQQAgAhsiAigCAEEBRw0AIAMoAgQiCSACKAIERw0AAkACQAJAAkACQAJAIAQoAgBBAUcNACAEKAIEIAlHDQAgAi0AKEEWcUUNCSAIIAIoApgBNgIMIAggAkEoajYCKCAIIARBGGo2AiQgCCAEQdQAajYCICAAIAEgCiAJIAhBDGogCEEgahCHASEhIAgoAgwiEyACKAKYAUYNBSAWKAIAIgsgACgCHCINIAMoAgQiGCADKAIAIhlBufPd8XlsQQV3c0G5893xeWwiFHEiDmooAAAiGiAUQRl2IhtBgYKECGwiInMiAkF/cyACQf/9+3dqcUGAgYKEeHEhDCAPKAIAIQogACgCLCEcQQAhAiAOIQkgGiEEAkADQCAMRQRAA0AgBEEBdCAEcUGAgYKEeHENAyACIAlqIQQgAkEEaiECICIgCyAEQQRqIA1xIglqKAAAIgRzIgxBf3MgDEH//ft3anFBgIGChHhxIgxFDQALCyAMaEEDdiAJaiANcUF/c0ECdCALaigCACIQIApPDQMgDEF/aiAMcSEMIBBBBHQgHGoiEEEEaigCACAZRw0AIBBBCGooAgAgGEcNAAsgECATNgIMDAULIBpBgIGChHhxIgJFBEBBBCEEA0AgBCAOaiAEQQRqIQQgDXEiDiALaigAAEGAgYKEeHEiAkUNAAsLIAsgAmhBA3YgDmogDXEiBGosAAAiAkF/SgRAIAsgCygCAEGAgYKEeHFoQQN2IgRqLQAAIQILIAJBAXEhAgJAIBIoAgANACACRQ0AIAhBIGogHiAcIAoQrwEgFCAAKAIcIg1xIgkgFigCACILaigAAEGAgYKEeHEiDEUEQEEEIQQDQCAEIAlqIQkgBEEEaiEEIAsgCSANcSIJaigAAEGAgYKEeHEiDEUNAAsLIAsgDGhBA3YgCWogDXEiBGosAABBf0wNACALKAIAQYCBgoR4cWhBA3YhBAsgBCALaiAbOgAAIARBfGogDXEgC2pBBGogGzoAACASIBIoAgAgAmsiDjYCACAAQShqIgIoAgBBAWohCSACIAk2AgAgBEF/c0ECdCALaiAKNgIAIAogFygCACICRwRAIA8oAgAhBAwECyAJIA5qIA8oAgAiBGshAiAKIARrIAJPBEAgCiECDAQLIAIgBGoiAiAESQ0CIAJBBHQhCSACQf////8AcSACRkECdCECAkAgCgRAIAggACgCLDYCICAIQQQ2AiggCCAKQQR0NgIkDAELIAhBADYCIAsgCEEQaiAJIAIgCEEgahCcByAIKAIQQQFHBEAgCCgCFCEKIBcgCCgCGEEEdiICNgIAIAAgCjYCLAwECyAIKAIYIgBFDQIgCCgCFCAAQaCdwwAoAgAiAEGvBiAAGxEAAAALQaS/wABBK0GU5sAAENsJAAsgECAKQcTewAAQzQgACxCRDAALIAIgBEYEQCAgIAIQjgYgDygCACEECyAPIARBAWo2AgAgACgCLCAEQQR0aiICIBM2AgwgAiAZNgIEIAIgFDYCACACQQhqIBg2AgALIBEgAygCACICTQ0AIAJBoAFsIBVqQQAgESACSxsiAigCAEEBRw0AIAIoAgQgAygCBEcNACACIBM2ApgBCyAdICFyIR0LIB8gA0EIaiIDRw0ACyAdQQFxRQ0AIAAQ2gULIAAgBxBDIAAgBSAGEMYBCyAIQTBqJAAL4wkBFH0gAUE0aioCACEXIAFBMGoqAgAhGCABQSxqKgIAIRkgAUEoaioCACELIAFBJGoqAgAhCCABQSBqKgIAIQkgASoCHCEGAn8gBUUEQCAAIAQpAgw3AiwgACACKQIANwI4IABBNGogBEEUaigCADYCACAAQUBrIAJBCGooAgA2AgAgBiAEKgIEIg6UIAkgBCoCACIPlJMiByAHkiEHIAggD5QgBiAEKgIIIgyUkyIKIAqSIQogDCALIAeUIAYgCpQgCSAJIAyUIAggDpSTIgwgDJIiDJSTkpIhEyAOIAsgCpQgCCAMlCAGIAeUk5KSIQ4gDyALIAyUIAkgB5QgCCAKlJOSkiEPIAIqAjghDCAGIARB3ABqKgIAIhCUIAkgBCoCWCIRlJMiByAHkiEHIAggEZQgBiAEQeAAaioCACINlJMiCiAKkiEKIA0gCyAHlCAGIAqUIAkgCSANlCAIIBCUkyINIA2SIg2Uk5KSIRQgECALIAqUIAggDZQgBiAHlJOSkiEQIBEgCyANlCAJIAeUIAggCpSTkpIhESACKgJAIgggAioCRCIJlCACKgJIIgsgAioCTCIGlJIgBiACKgJQIgeUkiENIAIqAjwiCiAJlCAIIAaUkiAJIAeUkiEVIAogCJQgCCALlJIgCSAGlJIhFiAEQeQAaiECIAkgCZQiEiAGIAaUIgaSIAcgB5SSIQkgCCAIlCIHIAsgC5SSIAaSIQggCiAKlCAHkiASkiEGIAMoAggMAQsgACAEKQIANwIsIAAgAikCADcCOCAAQTRqIARBCGooAgA2AgAgAEFAayACQQhqKAIANgIAIAYgBEEQaioCACIOlCAJIAQqAgwiD5STIgcgB5IhByAIIA+UIAYgBEEUaioCACIMlJMiCiAKkiEKIAwgCyAHlCAGIAqUIAkgCSAMlCAIIA6UkyIMIAySIgyUk5KSIRMgDiALIAqUIAggDJQgBiAHlJOSkiEOIA8gCyAMlCAJIAeUIAggCpSTkpIhDyACKgI4IQwgBiAEQegAaioCACIQlCAJIAQqAmQiEZSTIgcgB5IhByAIIBGUIAYgBEHsAGoqAgAiDZSTIgogCpIhCiANIAsgB5QgBiAKlCAJIAkgDZQgCCAQlJMiDSANkiINlJOSkiEUIBAgCyAKlCAIIA2UIAYgB5STkpIhECARIAsgDZQgCSAHlCAIIAqUk5KSIREgAioCQCIIIAIqAkQiCZQgAioCSCILIAIqAkwiBpSSIAYgAioCUCIHlJIhDSACKgI8IgogCZQgCCAGlJIgCSAHlJIhFSAKIAiUIAggC5SSIAkgBpSSIRYgBEHYAGohAiAJIAmUIhIgBiAGlCIGkiAHIAeUkiEJIAggCJQiByALIAuUkiAGkiEIIAogCpQgB5IgEpIhBiADKAIICyEBIAAgBjgCFCAAIAw4AhAgACABNgIAIAAgAikCADcCVCAAIAQtAHk6AGAgAEEoaiAJOAIAIABBJGogDTgCACAAQSBqIAg4AgAgAEEcaiAVOAIAIABBGGogFjgCACAAQQxqIBcgE5I4AgAgAEEIaiAYIA6SOAIAIAAgGSAPkjgCBCAAQdwAaiACQQhqKAIANgIAIAQqAnAhCCAAQdAAaiAUOAIAIABBzABqIBA4AgAgACAROAJIIAAgCDgCRAvnCgIDfxh9IwBB0ABrIgUkAEMAAKA1ELMBIR8CQAJAAkACQAJAIANBDGoqAgAiCSAJlCADQRBqKgIAIgggCJSSIANBFGoqAgAiCiAKlJJDAAAAAJIQswEiEUMAAAAAWw0AIBG8Qf////8Hcb5DAACAf1wEQCARiyIMQwAAADRfDQEgDCAMQwAAADSUXw0BCyADKgIAIRMgAyoCBCEUIAMqAgghFSAFIAogEZUiFowiDiAWIBaUIAkgEZUiFyAXlCAIIBGVIhggGJSSkkMAAAAAkhCzASIJlTgCICAFIBiMIg8gCZU4AhwgBSAXjCIeIAmVOAIYIAVBQGsgASAFQRhqEKIFIAUqAkAhCSAFKgJEIQggBSoCSCEKIAJBQGtBADYCACACQThqQgA3AgAgAkE0aiAKOAIAIAJBMGogCDgCACACQSxqIAk4AgAgAkEoaiAKIBWTOAIAIAJBJGogCCAUkzgCACACIAkgE5M4AiAgAkEANgIcIAJBADYCvAEgBUEIaiACEE1D//9/fyEJQZDOACEHA0AgBSoCCCINIA2UIAUqAgwiCyALlJIgBSoCECIQIBCUkkMAAAAAkiIIQwAAyCteRQ0DIBCMIAgQswEiCJUhCiALjCAIlSEMIA2MIAiVIRICfSAIIAlgIgZFBEAgBSAKIAogCpQgEiASlCAMIAyUkpJDAAAAAJIQswEiCZU4AiAgBSAMIAmVOAIcIAUgEiAJlTgCGCAFQUBrIAEgBUEYahCiBSAFKgJEIRAgBSoCSCEaIAUqAkAMAQsgGUMAAAAAXg0EIBUgEJIhGiAUIAuSIRAgEyANkgshCSAaIBWTIRsgECAUkyEcIAkgE5MhHQJAAkACQCAWIAqUIBcgEpQgGCAMlJKSIg1DAAAAAFsNACANvEH/////B3G+QwAAgH9cBEAgDYsiC0MAAAA0Xw0BIAsgC0MAAAA0lF8NAQsgCiAblCAMIByUIBIgHZSSkiANlSILQwAAAABgDQELQQAhAyANQwAAoDVeDQYgBg0GDAELAkACQCANQwAAAABdRQ0AIAtDAAAAAF5FDQAgGSALkiIZIBGVIAReBEAgAEEANgIADAkLIBYgC5QhCCAYIAuUIQ4gFyALlCEPAkAgAigCvAEiBkEBaiIDIAZJDQAgAiACKgIgIA+TOAIgIAIgAioCJCAOkzgCJCACIAIqAiggCJM4AiggBkUNACACIAIqAkQgD5M4AkQgAiACKgJIIA6TOAJIIAIgAioCTCAIkzgCTCADQQJGDQAgAiACKgJoIA+TOAJoIAIgAioCbCAOkzgCbCACIAIqAnAgCJM4AnAgA0EDRg0AIAIgAioCjAEgD5M4AowBIAIgAioCkAEgDpM4ApABIAIgAioClAEgCJM4ApQBIANBBEcNAgsgGiAVIAiSIhWTIRsgECAUIA6SIhSTIRwgCSATIA+SIhOTIR1D//9/fyEIIAohDiAMIQ8gEiEeDAILIAZFDQEgAEEANgIADAcLQQRBBEH04sEAEM0IAAsgCiAblCAMIByUIBIgHZSSkiIKIApbBEBBACEDIAggCpIgHyAIlF8NBSAFQQA2AjggBUIANwMwIAUgGjgCLCAFIBA4AiggBSAJOAIkIAUgGzgCICAFIBw4AhwgBSAdOAIYIAIgBUEYahCZAhogBUEIaiACEE0gAigCvAFBA0YNAyAIIQkgB0F/aiIHDQEMBQsLQezfwQBBKEGk4MEAENsJAAsgAEEANgIADAMLIApDAACgtV8NAQsgAEEQaiAOOAIAIABBDGogDzgCACAAQQhqIB44AgAgACAZIBGVOAIEQQEhAwsgACADNgIACyAFQdAAaiQAC9AKAgR/Hn0jAEFAaiIFJABDAACgNRCzASEhAkACQAJAAkACQCADQQxqKgIAIgsgC5QgA0EQaioCACIJIAmUkiADQRRqKgIAIgogCpSSQwAAAACSELMBIhFDAAAAAFsNACARvEH/////B3G+QwAAgH9cBEAgEYsiDUMAAAA0Xw0BIA0gDUMAAAA0lF8NAQsgAkEANgK8ASACQQA2AhwgAkFAa0EANgIAIAJBOGpCADcCACABQQxqIggqAgAhHiACQTRqIAEgCCABQQRqKgIAIiIgCSARlSIfjCIOlCALIBGVIhQgASoCACIjlJMgCiARlSIVIAFBCGoqAgAiJJSTIAFBEGoqAgAiJSAOlCAUIB6UkyAVIAFBFGoqAgAiJpSTXhsiBioCCCILOAIAIAJBMGogBioCBCIJOAIAIAJBLGogBioCACIKOAIAIAJBKGogCyADKgIIIhaTOAIAIAJBJGogCSADKgIEIheTOAIAIAIgCiADKgIAIhiTOAIgIAVBCGogAhBNIBWMIRAgFIwhIEP//39/IQtBkM4AIQYDQCAFKgIIIg8gD5QgBSoCDCIMIAyUkiAFKgIQIhIgEpSSQwAAAACSIglDAADIK15FDQMgEowgCRCzASIJlSEKIAyMIAmVIQ0gD4wgCZUhEwJ9IAkgC2AiB0UEQCABIAggJCAKlCAjIBOUICIgDZSSkiAmIAqUIB4gE5QgJSANlJKSXhsiAyoCCCELIAMqAgAhGiADKgIEDAELIBlDAAAAAF4NBCAWIBKSIQsgGCAPkiEaIBcgDJILIRIgCyAWkyEbIBIgF5MhHCAaIBiTIR0CQAJAAkAgFSAKlCAUIBOUIB8gDZSSkiIPQwAAAABbDQAgD7xB/////wdxvkMAAIB/XARAIA+LIgxDAAAANF8NASAMIAxDAAAANJRfDQELIAogG5QgDSAclCATIB2UkpIgD5UiDEMAAAAAYA0BC0EAIQMgD0MAAKA1Xg0GIAcNBgwBCwJAAkAgD0MAAAAAXUUNACAMQwAAAABeRQ0AIBkgDJIiGSARlSAEXgRAIABBADYCAAwJCyAVIAyUIQkgHyAMlCEOIBQgDJQhEAJAIAIoArwBIgdBAWoiAyAHSQ0AIAIgAioCICAQkzgCICACIAIqAiQgDpM4AiQgAiACKgIoIAmTOAIoIAdFDQAgAiACKgJEIBCTOAJEIAIgAioCSCAOkzgCSCACIAIqAkwgCZM4AkwgA0ECRg0AIAIgAioCaCAQkzgCaCACIAIqAmwgDpM4AmwgAiACKgJwIAmTOAJwIANBA0YNACACIAIqAowBIBCTOAKMASACIAIqApABIA6TOAKQASACIAIqApQBIAmTOAKUASADQQRHDQILIAsgFiAJkiIWkyEbIBIgFyAOkiIXkyEcIBogGCAQkiIYkyEdQ///f38hCSAKIRAgDSEOIBMhIAwCCyAHRQ0BIABBADYCAAwHC0EEQQRB9OLBABDNCAALIAogG5QgDSAclCATIB2UkpIiCiAKWwRAQQAhAyAJIAqSICEgCZRfDQUgBUEANgI4IAVCADcDMCAFIAs4AiwgBSASOAIoIAUgGjgCJCAFIBs4AiAgBSAcOAIcIAUgHTgCGCACIAVBGGoQmQIaIAVBCGogAhBNIAIoArwBQQNGDQMgCSELIAZBf2oiBg0BDAULC0Hs38EAQShBpODBABDbCQALIABBADYCAAwDCyAKQwAAoLVfDQELIABBEGogEDgCACAAQQxqIA44AgAgAEEIaiAgOAIAIAAgGSARlTgCBEEBIQMLIAAgAzYCAAsgBUFAayQAC+MJAQp/IAAoAhAhAwJAAkACQAJAIAAoAggiDEEBRwRAIANBAUYNASAAKAIYIAEgAiAAQRxqKAIAKAIMEQUAIQMMAwsgA0EBRw0BCyABIAJqIQQCQAJAIABBFGooAgAiBkUEQCABIQMMAQsgASEDA0AgAyAERg0CIAMiCEEBaiEDAkAgCCwAACIFQX9KDQAgBUH/AXEhCQJ/IAMgBEYEQEEAIQogBAwBCyAILQABQT9xIQogCEECagshAyAJQeABSQ0AAn8gAyAERgRAQQAhCyAEDAELIAMtAABBP3EhCyADQQFqCyEFIAlB8AFJBEAgBSEDDAELAn8gBCAFRgRAIAQhA0EADAELIAVBAWohAyAFLQAAQT9xCyAJQRJ0QYCA8ABxIApBDHRyIAtBBnRyckGAgMQARg0DCyAHIAhrIANqIQcgBkF/aiIGDQALCyADIARGDQACQCADLAAAIghBf0oNAAJ/IAQgA0EBakYEQCAEIQZBAAwBCyADQQJqIQYgAy0AAUE/cUEMdAshAyAIQf8BcUHgAUkNAAJ/IAQgBkYEQCAEIQVBAAwBCyAGQQFqIQUgBi0AAEE/cUEGdAshBiAIQf8BcUHwAUkNACAIQf8BcSEIIAQgBUYEf0EABSAFLQAAQT9xCyAIQRJ0QYCA8ABxIANyIAZyckGAgMQARg0BCwJAAkAgB0UEQEEAIQQMAQsgByACTwRAQQAhAyAHIAIiBEYNAQwCC0EAIQMgByIEIAFqLAAAQUBIDQELIAQhByABIQMLIAcgAiADGyECIAMgASADGyEBCyAMQQFGDQAMAgsCQCACBEAgAkEDcSEHAkAgAkF/akEDSQRAQQAhBCABIQMMAQtBACEEQQAgAkF8cWshBSABIQMDQCADLQAAQcABcUGAAUcgBGogA0EBai0AAEHAAXFBgAFHaiADQQJqLQAAQcABcUGAAUdqIANBA2otAABBwAFxQYABR2ohBCADQQRqIQMgBUEEaiIFDQALCyAHBEADQCADLQAAQcABcUGAAUcgBGohBCADQQFqIQMgB0F/aiIHDQALCyAEIAAoAgwiBk8NAyACQQNxIQcCQCACQX9qQQNJBEBBACEEIAEhAwwBC0EAIQRBACACQXxxayEFIAEhAwNAIAMtAABBwAFxQYABRyAEaiADQQFqLQAAQcABcUGAAUdqIANBAmotAABBwAFxQYABR2ogA0EDai0AAEHAAXFBgAFHaiEEIANBBGohAyAFQQRqIgUNAAsLIAdFDQEDQCADLQAAQcABcUGAAUcgBGohBCADQQFqIQMgB0F/aiIHDQALDAELQQAhBCAAKAIMIgYNAAwCC0EAIQMgBiAEayIEIQYCQAJAAkBBACAALQAgIgUgBUEDRhtBA3FBAWsOAgABAgtBACEGIAQhAwwBCyAEQQF2IQMgBEEBakEBdiEGCyADQQFqIQMgAEEcaigCACEFIAAoAgQhBCAAKAIYIQACQANAIANBf2oiA0UNASAAIAQgBSgCEBEDAEUNAAtBAQ8LQQEhAyAEQYCAxABGDQAgACABIAIgBSgCDBEFAA0AQQAhAwNAIAMgBkYEQEEADwsgA0EBaiEDIAAgBCAFKAIQEQMARQ0ACyADQX9qIAZJDwsgAw8LIAAoAhggASACIABBHGooAgAoAgwRBQALhwoCDX8ffSMAQZABayIGJAAgAyoCOCEjIAEqAjghJCABKgI8IhkgASoCRCITlCABKgJAIhQgASoCTCIYlJIgEyABKgJQIhqUkiIqIAMqAjwiGyADKgJEIhWUIAMqAkAiFiADKgJMIheUkiAVIAMqAlAiHJSSIiuSIh0gGSAUlCAUIAEqAkgiHpSSIBMgGJSSIiwgGyAWlCAWIAMqAkgiH5SSIBUgF5SSIi2SIiAgFCATlCAeIBiUkiAYIBqUkiIuIBYgFZQgHyAXlJIgFyAclJIiL5IiIZQgHSAUIBSUIhQgHiAelJIgGCAYlCIekiIwIBYgFpQiFiAfIB+UkiAXIBeUIheSIh+SIhiUkyIxlCAZIBmUIBSSIBMgE5QiE5IiGSAbIBuUIBaSIBUgFZQiFZIiFpIiFCAYIBMgHpIgGiAalJIiGiAVIBeSIBwgHJSSIheSIhWUICEgIZSTIhuUICAgICAVlCAhIB2UkyIclJOSIhNDAAAAAFwEQCAgIB2UIBQgIZSTIBOVISUgMSATlSEnIBsgE5UhKSAcjCATlSEoIBQgFZQgHSAdlJMgE5UhJiAUIBiUICAgIJSTIBOVISILIAZB6ABqIgFBCGoiAyAFQSBqIgwoAgA2AgAgAUEUaiINIAVBOGooAgA2AgAgBkFAayIHQRhqIgggBUE8aikCADcDACAHQSBqIgkgBUHEAGooAgA2AgAgBiAFKQIwNwJ0IAdBCGoiCiADKQMANwMAIAdBEGoiByABQRBqIgspAwA3AwAgBiAFKQIYNwNAIAFBIGoiDiAJKAIANgIAIAFBGGoiDyAIKQMANwMAIAsgBykDADcDACADIAopAwA3AwAgBiAGKQNANwNoIAYgARDuASAGQRhqIhAgBUEIaigCADYCACAGQRBqIhEgBSkCADcDACADIAVBLGoiEigCADYCACANIAVB0ABqKAIANgIAIAggBUHUAGopAgA3AwAgCSAFQdwAaigCADYCACAGIAUpAkg3AnQgCiADKQMANwMAIAcgCykDADcDACAGIAUpAiQ3A0AgDiAJKAIANgIAIA8gCCkDADcDACALIAcpAwA3AwAgAyAKKQMANwMAIAYgBikDQDcDaCAGQSBqIgMgARDuASADQRhqIgEgBUEUaigCADYCACADQRBqIgcgBSkCDDcDACAAQdgAaiAiOAIAIABB1ABqICU4AgAgAEHQAGogJjgCACAAQcwAaiAnOAIAIABByABqICg4AgAgACApOAJEIABDAACAPyAkICOSlTgCQCAAQTxqIBc4AgAgAEE4aiAvOAIAIABBNGogHzgCACAAQTBqICs4AgAgAEEsaiAtOAIAIAAgFjgCKCAAQSRqIBo4AgAgAEEgaiAuOAIAIABBHGogMDgCACAAQRhqICo4AgAgAEEUaiAsOAIAIAAgGTgCECAAICM4AgwgACAkOAIIIABBpAFqIAwoAgA2AgAgACAFKQIYNwKcASAAIAUpAiQ3AqgBIABBsAFqIBIoAgA2AgAgACAFKQJ0NwJcIAAgBCgCCDYCBCAAIAIoAgg2AgAgAEH8AGogECgCADYCACAAQfQAaiARKQMANwIAIABB7ABqIAZBCGopAwA3AgAgACAGKQMANwJkIABBmAFqIAEoAgA2AgAgAEGQAWogBykDADcCACAAQYgBaiADQQhqKQMANwIAIAAgBikDIDcCgAEgBkGQAWokAAvRCgIDfxh9IwBBQGoiBiQAQwAAoDUQswEhIAJAAkACQAJAAkAgBEEMaioCACIJIAmUIARBEGoqAgAiCyALlJIgBEEUaioCACIKIAqUkkMAAAAAkhCzASISQwAAAABbDQAgErxB/////wdxvkMAAIB/XARAIBKLIg5DAAAANF8NASAOIA5DAAAANJRfDQELIAQqAgghEyAEKgIEIRQgBCoCACEVIAogEpUiF4whDyALIBKVIh+MIRAgCSASlSIYjCEeQwAAAAAhCUMAAAAAIQsgFyAXlCAYIBiUQwAAAACSkkMAAAAAkhCzASIKQwAAAABcBEAgHiAKlSAClCELIA8gCpUgApQhCQsgA0EANgIcIANBADYCvAEgA0FAa0EANgIAIANBOGpCADcCACADQTRqIAk4AgAgA0EwaiABIBCYIgo4AgAgA0EsaiALOAIAIANBKGogCSATkzgCACADIAsgFZM4AiAgA0EkaiAKIBSTOAIAIAZBCGogAxBNQ///f38hC0GQzgAhCANAIAYqAggiESARlCAGKgIMIgwgDJSSIAYqAhAiDSANlJJDAAAAAJIiCUMAAMgrXkUNAyANjCAJELMBIgmVIQogDIwgCZUhFiARjCAJlSEOAn0gCSALYCIHRQRAQwAAAAAhC0MAAAAAIREgASAWmCEaIAogCpQgDiAOlEMAAAAAkpJDAAAAAJIQswEiDEMAAAAAXAR9IA4gDJUgApQhESAKIAyVIAKUBUMAAAAACwwBCyAZQwAAAABeDQQgFCAMkiEaIBUgEZIhESATIA2SCyILIBOTIRsgGiAUkyEcIBEgFZMhHQJAAkACQCAXIAqUIBggDpQgHyAWlJKSIgxDAAAAAFsNACAMvEH/////B3G+QwAAgH9cBEAgDIsiDUMAAAA0Xw0BIA0gDUMAAAA0lF8NAQsgCiAblCAWIByUIA4gHZSSkiAMlSINQwAAAABgDQELQQAhBCAMQwAAoDVeDQYgBw0GDAELAkACQCAMQwAAAABdRQ0AIA1DAAAAAF5FDQAgGSANkiIZIBKVIAVeBEAgAEEANgIADAkLIBcgDZQhCSAfIA2UIQ8gGCANlCEQAkAgAygCvAEiB0EBaiIEIAdJDQAgAyADKgIgIBCTOAIgIAMgAyoCJCAPkzgCJCADIAMqAiggCZM4AiggB0UNACADIAMqAkQgEJM4AkQgAyADKgJIIA+TOAJIIAMgAyoCTCAJkzgCTCAEQQJGDQAgAyADKgJoIBCTOAJoIAMgAyoCbCAPkzgCbCADIAMqAnAgCZM4AnAgBEEDRg0AIAMgAyoCjAEgEJM4AowBIAMgAyoCkAEgD5M4ApABIAMgAyoClAEgCZM4ApQBIARBBEcNAgsgCyATIAmSIhOTIRsgGiAUIA+SIhSTIRwgESAVIBCSIhWTIR1D//9/fyEJIAohDyAWIRAgDiEeDAILIAdFDQEgAEEANgIADAcLQQRBBEH04sEAEM0IAAsgCiAblCAWIByUIA4gHZSSkiIKIApbBEBBACEEIAkgCpIgICAJlF8NBSAGQQA2AjggBkIANwMwIAYgCzgCLCAGIBo4AiggBiAROAIkIAYgGzgCICAGIBw4AhwgBiAdOAIYIAMgBkEYahCZAhogBkEIaiADEE0gAygCvAFBA0YNAyAJIQsgCEF/aiIIDQEMBQsLQezfwQBBKEGk4MEAENsJAAsgAEEANgIADAMLIApDAACgtV8NAQsgAEEQaiAPOAIAIABBDGogEDgCACAAQQhqIB44AgAgACAZIBKVOAIEQQEhBAsgACAENgIACyAGQUBrJAALywoCB38PfSMAQfAAayIJJABDAACgNRCzASEYIAlBCGogCBBNAkAgCSoCCCISIBKUIAkqAgwiEyATlJIgCSoCECIQIBCUkkMAAAAAkiIUQwAAAABeBEAgFBCzASERAkAgFEMAAMgrXkUNACAHQQFzIQ4gEowgEZUhFSATjCARlSEWIBCMIBGVIRdD//9/fyERQZDOACEMAkACQANAAkAgCSAQjCAUELMBIhCVOAIgIAkgE4wgEJU4AhwgCSASjCAQlTgCGAJAAkACQAJAAkACQCAQIBFgRQRAIAlB0ABqIAIgCUEYaiIKIAMoAgwRAQAgCUEoaiIPQQhqIg0gCkEIaiIKKAIANgIAIA0gDSoCAIw4AgAgCSAJKQMYNwMoIAkgCSoCKIw4AiggCSAJKgIsjDgCLCAJQeAAaiAEIAEgDyAFKAIUEQIAIAkqAlAiEiAJKgJgIhOTIhQgCSoCGJQgCSoCVCIZIAkqAmQiGpMiGyAJKgIclJIgCSoCWCIcIAkqAmgiHZMiHiAKKgIAlJIiESARXA0BIBGMIAZeDQIgEUMAAAAAXSAOcUEBRkEAIBAgBl8bDQMgECARkiAYIBCUXw0EIAkgHTgCSCAJIBo4AkQgCSATOAJAIAkgHDgCPCAJIBk4AjggCSASOAI0IAkgHjgCMCAJIBs4AiwgCSAUOAIoIAggCUEoahCZAkUNBSAJKgIgIRcgCSoCHCEWIAkqAhghFSAJQQhqIAgQTSAIKAK8AUEDRw0GIBFDAACgtV9FDQsgBw0HIAAgFTgCBCAAQQxqIBc4AgAgAEEIaiAWOAIADAoLIAdFBEAgACAVOAIEIABBDGogFzgCACAAQQhqIBY4AgAMCgsgCUEoaiAIQQEQ+AEgAEEMaiAJQTBqKAIANgIAIAAgCSkDKDcCBCAAQRBqIAkpAjQ3AgAgAEEYaiAJQTxqKAIANgIAIABBJGogFzgCACAAQSBqIBY4AgAgAEEcaiAVOAIAIABBATYCAAwMC0Hs38EAQShBlODBABDbCQALIAAgCSkDGDcCBCAAQQxqIAlBIGooAgA2AgAgAEEDNgIADAoLIAAgFTgCBCAAQQxqIBc4AgAgAEEIaiAWOAIADAYLIAdFBEAgACAJKQMYNwIEIABBDGogCUEgaigCADYCAAwGCyAJQShqIgEgCEEAEPgBIABBDGogAUEIaigCADYCACAAIAkpAyg3AgQgAEEQaiAJKQI0NwIAIABBGGogCUE8aigCADYCACAAQSRqIAlBIGooAgA2AgAgAEEcaiAJKQMYNwIAIABBATYCAAwICyAHRQRAIAAgCSkDGDcCBCAAQQxqIAlBIGooAgA2AgAMBQsgCUEoaiIBIAhBABD4ASAAQQxqIAFBCGooAgA2AgAgACAJKQMoNwIEIABBEGogCSkCNDcCACAAQRhqIAlBPGooAgA2AgAgAEEkaiAJQSBqKAIANgIAIABBHGogCSkDGDcCACAAQQE2AgAMBwsgDEF/aiIMRQ0CIBAhESAJKgIIIhIgEpQgCSoCDCITIBOUkiAJKgIQIhAgEJSSQwAAAACSIhRDAADIK14NAQwECwsgCUEoaiAIQQEQ+AEgAEEMaiAJQTBqKAIANgIAIAAgCSkDKDcCBCAAQRBqIAkpAjQ3AgAgAEEYaiAJQTxqKAIANgIAIABBJGogFzgCACAAQSBqIBY4AgAgAEEcaiAVOAIAIABBATYCAAwECyAAQoCAgPwDNwIEIABBDGpBADYCACAAQQM2AgAMAwtBAiELCyAAIAs2AgAMAQsgAEEANgIACyAJQfAAaiQAC+QJAgl/An0jAEGQAWsiAiQAIAIgAUGQARDkBiEJQQAhASAAAn8DQCAJIApqIQICQCABRQ0AIAIgAioCACABIAlqIgMqAgAiCyALlJMiDDgCAAJAIAFBFEYiBA0AIAJBBGoiBSAFKgIAIAsgA0EEaioCAJSTOAIAIAFBEEYNACACQQhqIgUgBSoCACALIANBCGoqAgCUkzgCACABQQxGDQAgAkEMaiIFIAUqAgAgCyADQQxqKgIAlJM4AgAgAUEIRg0AIAJBEGoiBSAFKgIAIAsgA0EQaioCAJSTOAIAIAFBBEYNACACQRRqIgUgBSoCACALIANBFGoqAgCUkzgCAAsgAUEERiIFDQAgAiAMIANBGGoqAgAiCyALlJM4AgACQCAEDQAgAkEEaiIGIAYqAgAgCyADQRxqKgIAlJM4AgAgAUEQRg0AIAJBCGoiBiAGKgIAIAsgA0EgaioCAJSTOAIAIAFBDEYNACACQQxqIgYgBioCACALIANBJGoqAgCUkzgCACABQQhGDQAgAkEQaiIGIAYqAgAgCyADQShqKgIAlJM4AgAgBQ0AIAJBFGoiBiAGKgIAIAsgA0EsaioCAJSTOAIACyABQQhGIgYNACACIAIqAgAgA0EwaioCACILIAuUkzgCAAJAIAQNACACQQRqIgcgByoCACALIANBNGoqAgCUkzgCACABQRBGDQAgAkEIaiIHIAcqAgAgCyADQThqKgIAlJM4AgAgAUEMRg0AIAJBDGoiByAHKgIAIAsgA0E8aioCAJSTOAIAIAYNACACQRBqIgcgByoCACALIANBQGsqAgCUkzgCACAFDQAgAkEUaiIHIAcqAgAgCyADQcQAaioCAJSTOAIACyABQQxGIgcNACACIAIqAgAgA0HIAGoqAgAiCyALlJM4AgACQCAEDQAgAkEEaiIIIAgqAgAgCyADQcwAaioCAJSTOAIAIAFBEEYNACACQQhqIgggCCoCACALIANB0ABqKgIAlJM4AgAgBw0AIAJBDGoiCCAIKgIAIAsgA0HUAGoqAgCUkzgCACAGDQAgAkEQaiIIIAgqAgAgCyADQdgAaioCAJSTOAIAIAUNACACQRRqIgggCCoCACALIANB3ABqKgIAlJM4AgALIAFBEEYiCA0AIAIgAioCACADQeAAaioCACILIAuUkzgCACAEDQAgAkEEaiIEIAQqAgAgCyADQeQAaioCAJSTOAIAIAgNACACQQhqIgQgBCoCACALIANB6ABqKgIAlJM4AgAgBw0AIAJBDGoiBCAEKgIAIAsgA0HsAGoqAgCUkzgCACAGDQAgAkEQaiIEIAQqAgAgCyADQfAAaioCAJSTOAIAIAUNACACQRRqIgQgBCoCACALIANB9ABqKgIAlJM4AgALQQAgAioCACILQwAAAABeRQ0BGiACIAsQswEiCzgCAAJAIAFBFEYNACACQQRqIgMgAyoCACALlTgCACABQRBGDQAgAkEIaiIDIAMqAgAgC5U4AgAgAUEMRg0AIAJBDGoiAyADKgIAIAuVOAIAIAFBCEYNACACQRBqIgMgAyoCACALlTgCACABQQRGDQAgAkEUaiICIAIqAgAgC5U4AgALIApBHGohCiABQQRqIgFBGEcNAAsgAEEEaiAJQZABEOQGGkEBCzYCACAJQZABaiQAC6AKAxB/An4BfSMAQYACayICJAAgAkEAOgAIIAIgATYCBCACIAA2AgAgAkIANwIUIAJB7LjBACgCACIBNgIQIABBIGooAgAiBgRAIAJBEGpBAEEBEJQGIAIoAhAiASACKAIYIgNBAnRqQQA2AgAgA0EBaiEDCwJAIANFDQAgAEE8aigCACEIIAAoAjQhCSAAKAIYIREDQCACIANBf2oiAzYCGAJAAkAgBiADQQJ0IAFqKAIAIgBLBEAgAkEgaiAAQQd0IBFqQYABEOQGGiACLQCYASIHBEAgAigCjAEiBCAISSEAIARBDGwgCWpBACAAG0EIakEAIAAbIQsgAigCiAEiBCAISSEAIARBDGwgCWpBACAAG0EIakEAIAAbIQwgAigChAEiBCAISSEAIARBDGwgCWpBACAAG0EIakEAIAAbIQ0gAigCgAEiBCAISSEAIARBDGwgCWpBACAAG0EIakEAIAAbIQoLIAIgAjYCrAEgAiACKAIEIgAqAggiFDgC3AEgAiAUOALYASACIBQ4AtQBIAIgFDgC0AEgAiAAKgIEIhQ4AswBIAIgFDgCyAEgAiAUOALEASACIBQ4AsABIAIgACoCACIUOAK8ASACIBQ4ArgBIAIgFDgCtAEgAiAUOAKwASACQeABaiACQSBqIAJBsAFqEKMDIAItAOMBIQ4gAi0A4gEhDyACLQDhASEQIAItAOABIQQgB0UNAiACIQAgEEEBdCAEciAPQQJ0ciAOQQN0cq0iEkIBg1ANASAKRQ0BIAooAgAhACACKAIAIAIgAkGsAWo2AvwBIAAgAkH8AWpBkO7BABC2BSACKAKsASIALQAIRQ0BDAQLIAAgBkGYyMEAEM0IAAsCQCASQv8BgyISQgKDUA0AIA1FDQAgDSgCACEFIAAoAgAgAiACQawBajYC/AEgBSACQfwBakGQ7sEAELYFIAIoAqwBIgAtAAgNAwsCQCASQgSDUA0AIAxFDQAgDCgCACEFIAAoAgAgAiACQawBajYC/AEgBSACQfwBakGQ7sEAELYFIAIoAqwBIgAtAAgNAwsgEkIIg1ANACALRQ0AIAsoAgAhBSAAKAIAIAIgAkGsAWo2AvwBIAUgAkH8AWpBkO7BABC2BSACKAKsAS0ACA0CCyAEQf8BcUECRg0BIBBBAXQgBHIgD0ECdHIgDkEDdHKtIhNC/wGDIRICQCATQgGDUA0AIAcNACACKAKAASIAIAZLDQAgAigCFCADRgRAIAJBEGogA0EBEJQGIAIoAhghAyACKAIQIQELIANBAnQgAWogADYCACACIANBAWoiAzYCGAsCQCASQgKDUA0AIAcNACACKAKEASIAIAZLDQAgAigCFCADRgRAIAJBEGogA0EBEJQGIAIoAhghAyACKAIQIQELIANBAnQgAWogADYCACACIANBAWoiAzYCGAsCQCASQgSDUA0AIAcNACACKAKIASIAIAZLDQAgAigCFCADRgRAIAJBEGogA0EBEJQGIAIoAhghAyACKAIQIQELIANBAnQgAWogADYCACACIANBAWoiAzYCGAsCQCASQgiDUA0AIAcNACACKAKMASIAIAZLDQAgAigCFCADRgRAIAJBEGogA0EBEJQGIAIoAhghAyACKAIQIQELIANBAnQgAWogADYCACACIANBAWoiAzYCGAsgAw0ACwsCQCACKAIUIgBFDQAgAigCECIBRQ0AIABBAnRFDQAgARDhAQsgAi0ACCACQYACaiQAC+EJAgJ/BH0CQAJAAkACQAJAAkACQAJAIAAoAgBBAWsOAgECAAsgAEHQAmooAgAiAyACTw0DIABB2AJqLQAAIgRFDQIgA0ECdCABaigCACIDKAIIIgEgAEHUAmotAAAiAk0NBCAAQcwCaioCACEFIABByAJqKgIAIQYgAygCACACQTRsaiIBIABBOGoqAgA4AiQgAUEwaiAAQTRqKgIAOAIAIAFBKGogBiAAQeQAaioCACIHlCAFIABB4ABqKgIAIgiUk7ytQiCGIAYgCJQgBSAHlJK8rYQ3AgAgBEEBRg0CIAMoAggiASAALQDVAiICTQ0EIAMoAgAgAkE0bGoiASAAQYABaioCADgCJCABQTBqIABB/ABqKgIAOAIAIAFBKGogBiAAQawBaioCACIHlCAFIABBqAFqKgIAIgiUk7ytQiCGIAYgCJQgBSAHlJK8rYQ3AgAgBEECRg0CIAMoAggiASAALQDWAiICTQ0EIAMoAgAgAkE0bGoiASAAQcgBaioCADgCJCABQTBqIABBxAFqKgIAOAIAIAFBKGogBiAAQfQBaioCACIHlCAFIABB8AFqKgIAIgiUk7ytQiCGIAYgCJQgBSAHlJK8rYQ3AgAgBEEDRg0CIAMoAggiASAALQDXAiICTQ0EIAMoAgAgAkE0bGoiASAAQZACaioCADgCJCABQTBqIABBjAJqKgIAOAIAIAFBKGogBiAAQbwCaioCACIHlCAFIABBuAJqKgIAIgiUk7ytQiCGIAYgCJQgBSAHlJK8rYQ3AgAgBEEERg0CQQRBBEHAkcEAEM0IAAsgAEE4aigCACIDIAJPDQQgAEHwA2otAAAiBEUNASADQQJ0IAFqKAIAIgMoAggiASAAQewDai0AACICTQ0FIABBIGoqAgAhBSAAQRxqKgIAIQYgAygCACACQTRsaiIBIABB2ABqKgIAOAIkIAFBMGogAEHUAGoqAgA4AgAgAUEoaiAGIABBnAFqKgIAIgeUIAUgAEGYAWoqAgAiCJSTvK1CIIYgBiAIlCAFIAeUkrythDcCACAEQQFGDQEgAygCCCIBIAAtAO0DIgJNDQUgAygCACACQTRsaiIBIABBxAFqKgIAOAIkIAFBMGogAEHAAWoqAgA4AgAgAUEoaiAGIABBiAJqKgIAIgeUIAUgAEGEAmoqAgAiCJSTvK1CIIYgBiAIlCAFIAeUkrythDcCACAEQQJGDQEgAygCCCIBIAAtAO4DIgJNDQUgAygCACACQTRsaiIBIABBsAJqKgIAOAIkIAFBMGogAEGsAmoqAgA4AgAgAUEoaiAGIABB9AJqKgIAIgeUIAUgAEHwAmoqAgAiCJSTvK1CIIYgBiAIlCAFIAeUkrythDcCACAEQQNGDQEgAygCCCIBIAAtAO8DIgJNDQUgAygCACACQTRsaiIBIABBnANqKgIAOAIkIAFBMGogAEGYA2oqAgA4AgAgAUEoaiAGIABB4ANqKgIAIgeUIAUgAEHcA2oqAgAiCJSTvK1CIIYgBiAIlCAFIAeUkrythDcCACAEQQRGDQFBBEEEQZyPwQAQzQgAC0Hst8AAQShBuI3BABDbCQALDwsgAyACQbCRwQAQzQgACyACIAFB0JHBABDNCAALIAMgAkGMj8EAEM0IAAsgAiABQayPwQAQzQgAC6QJAgV/DX0jAEFAaiIEJAAgACgCACIHKAIAIgUoAmQhCCAFKAJoIQUCQCABBEAgAUEEaioCACIMIAVBEGoqAgAgASoCEJMiDpQgASoCACIPIAVBFGoqAgAgAUEUaioCAJMiEZSTIg0gDZIhECABQQhqKgIAIg0gEZQgDCAFQRhqKgIAIAFBGGoqAgCTIguUkyIJIAmSIQogBEEgaiIGQRhqIAsgASoCDCIJIBCUIAwgCpQgDyAPIAuUIA0gDpSTIgsgC5IiC5STkpI4AgAgBkEUaiARIAkgC5QgDyAQlCANIAqUk5KSOAIAIAQgDiAJIAqUIA0gC5QgDCAQlJOSkjgCMCAEIA0gBSoCCCIQlCAMIAUqAgQiCpQgDyAFKgIAIg6UIAkgBSoCDCIRlJKSkjgCLCAEIAwgDpQgCSAQlCAPIAqUk5IgDSARlJM4AiggBCAJIAqUIA8gEJSSIAwgEZSTIA0gDpSTOAIkIAQgDSAKlCAJIA6UIA8gEZSTIAwgEJSTkjgCIAwBCyAEQSBqIgZBGGogBUEYaigCADYCACAGQRBqIAVBEGopAgA3AwAgBkEIaiAFQQhqKQIANwMAIAQgBSkCADcDIAsgBCAIIARBIGogAiADIAcoAgAiAigCdCACQfgAaigCACACKgJgEC4CQAJAAkACQCAEKAIAQQFrDgMBAwMACyAAKAIYIQEMAQsgBEEMaioCACEMIARBCGoqAgAhDyAEKgIEIQ0gAQRAIAFBGGoqAgAgDCABQQxqKgIAIg4gDyABKgIAIgmUIA0gAUEEaioCACIQlJMiCiAKkiIRlCAJIA0gAUEIaioCACIKlCAMIAmUkyILIAuSIguUIBAgDCAQlCAPIAqUkyIMIAySIhOUk5KSkiEMIAEqAhAgDSAOIBOUIBAgEZQgCiALlJOSkpIhDSABQRRqKgIAIA8gDiALlCAKIBOUIAkgEZSTkpKSIQ8LIAcoAgAoAmgiAUEMaioCACEJIARBFGoqAgAiEyABKgIAIhCUIAQqAhAiFCABQQRqKgIAIgqUkyIOIA6SIQ4gFCABQQhqKgIAIhGUIARBGGoqAgAiEiAQlJMiCyALkiELIAFBGGoqAgAgEiAJIA6UIBAgC5QgCiASIAqUIBMgEZSTIhIgEpIiEpSTkpKSIAyTIhUgFZQgAUEQaioCACAUIAkgEpQgCiAOlCARIAuUk5KSkiANkyIKIAqUIAFBFGoqAgAgEyAJIAuUIBEgEpQgECAOlJOSkpIgD5MiCSAJlJKSQwAAAACSELMBIQkCQCAAKAIIIgIoAgAiAUEDTQRAIAAoAgQgAUECdGogCTgCACACKAIAIgFBBE8NASAAKAIQKAIAIQMgACgCDCABQQV0aiIBIA04AgggAUEBNgIEIAEgAzYCACABQRxqIARBEGoiA0EIaigCADYCACABQRRqIAMpAgA3AgAgAUEQaiAMOAIAIAFBDGogDzgCACACKAIAIgFBBEkEQCAAKAIUIAFqIQEMAwsgAUEEQZzNwQAQzQgACyABQQRB/MzBABDNCAALIAFBBEGMzcEAEM0IAAsgAUEBOgAACyAEQUBrJAAL3wkCDH8XfSMAQZACayIFJAAgBUEgakEANgIAIAVBwAFqQQA2AgAgBUIANwMYIAVCADcDuAEgBUKCgICAMDcDECAFQoCAgIAQNwMIIAVBzABqQQBB7AAQ6AYaIAJBDGoqAgAiFIwiHiAUIBSUIAJBEGoqAgAiFSAVlJIgAkEUaioCACIWIBaUkkMAAAAAkiIYELMBIhGVIhIgAUEYaiIGKgIAIhmUIBWMIh8gEZUiFyABQRxqIgcqAgAiGpSSIBaMIiAgEZUiESABQSBqIggqAgAiIZSSIRMCfyASIAEqAgAiIpQgFyABQQRqIgsqAgAiI5SSIBEgAUEIaiIMKgIAIiSUkiIbIBIgAUEMaiINKgIAIiWUIBcgAUEQaiIOKgIAIiaUkiARIAFBFGoiDyoCACInlJIiHF5FBEAgByEJIAYhCiAIIBwgE15FDQEaIA4hCSANIQogDwwBCyAHIQkgBiEKIAggGyATXkUNABogCyEJIAEhCiAMCyEQIAVByABqQQA2AgAgBUFAa0IANwMAIAVBPGogECoCACARIAEqAiQiEZSSIAIqAggiG5MiEzgCACAFQThqIAkqAgAgFyARlJIgAioCBCIckyIXOAIAIAVBNGogCioCACASIBGUkiACKgIAIh2TIhI4AgAgBUEwaiATOAIAIAVBLGogFzgCACAFQQA2AsQBIAVBADYCJCAFIBI4AiggBUHIAWogASAFQQhqIAIgAxCXASAFKALIASECAkAgBARAQQQhASAAIAJBAUYEfyAAIAUqAswBOAIAIAAgBUHQAWopAwA3AgQgAEEMaiAFQdgBaigCADYCAEEDBUEECzYCEAwBCyACQQFHBEAgAEEENgIQDAELIAUqAswBIhJDAAAAAFwEQCAAQQM2AhAgACASOAIAIAAgBUHQAWoiASkCADcCBCAAQQxqIAFBCGooAgA2AgAMAQsgISAWIBgQswEiEpUiFiAWIBaUIBQgEpUiFCAUlCAVIBKVIhUgFZSSkkMAAAAAkhCzASITlSISlCAZIBQgE5UiF5QgGiAVIBOVIhOUkpIhGAJAICQgEpQgIiAXlCAjIBOUkpIiGSAnIBKUICUgF5QgJiATlJKSIhpeRQRAIBogGF5FDQEgDyEIIA4hByANIQYMAQsgGSAYXkUNACAMIQggCyEHIAEhBgsgCCoCACEYIAYqAgAhGSAHKgIAIRogBUH0AWogIDgCACAFQfABaiAfOAIAIAVBADYCxAEgBUEANgJIIAVCADcDQCAFQQA2AiQgBSAeOALsASAFIBsgFiAUIBkgESAXlJIiFyAdk5QgFSAaIBEgE5SSIhMgHJOUkiAWIBggESASlJIiFiAbk5SSQ28SgzqSIhGUkiISOALoASAFIBYgEpMiFjgCPCAFIBwgFSARlJIiFTgC5AEgBSATIBWTIhU4AjggBSAdIBQgEZSSIhQ4AuABIAUgFyAUkyIUOAI0IAUgFjgCMCAFIBU4AiwgBSAUOAIoIAVB+AFqIAEgBUEIaiAFQeABaiARQ28SgzqSEJcBQQQhAQJAIAUoAvgBQQFHDQAgESAFKgL8AZMiESADX0UNACAAIBE4AgAgAEEMaiAFQYgCaigCADYCACAAIAVBgAJqKQMANwIEQQMhAQsgACABNgIQCyAFQZACaiQAC+wJAhN/AX4CQAJAAkACQCAAQRhqKAIAIgZFDQAgBiAALQBgIgNNBEAgAyEEDAQLIABBOGohByAAQRhqIQkgAEHIAGohCiADIQQDQCAAKAIQIgwgA0EGdGoiDS0APARAIARB/wFxIA1BPWotAAAiBEYNBCAGIANNDQMgBiAETQ0DIA0gBEEGdCAMaiAAIAcQXyAAKAJEIgMEQCAKKAIAQf8BIANBBWoQ6AYaCyAAQQA2AlwgAEEANgJQIAAgAyADQQFqQQN2QQdsIANBCEkbNgJMIAkoAgAiBiAEIgNLDQEMBQsLIA1BACAAIAcQXyAAKAJEIgMEQCAAQcgAaigCAEH/ASADQQVqEOgGGgsgAEEANgJcIABBADYCUCAAIAMgA0EBakEDdkEHbCADQQhJGzYCTCACRQ0AIAJBA3QgAWohEyAAQSBqKAIAIQggAEEcaigCACELIABBLGooAgAhECAAQShqIhQoAgAhDyAAKAIAIRUgACgCCCERIABBNGohEgNAAkAgD0UEQEEAIQ8MAQsgCCABQQRqKAIAIg0gASgCACIHQbnz3fF5bEEFd3NBufPd8XlsIgIgC3EiBmooAAAiBCACQRl2QYGChAhsIglzIgJBf3MgAkH//ft3anFBgIGChHhxIQUgEigCACEOQQAhAwJAAkACQAJAA0AgBUUEQANAIARBAXQgBHFBgIGChHhxDQcgAyAGaiECIANBBGohAyAJIAggAkEEaiALcSIGaigAACIEcyICQX9zIAJB//37d2pxQYCBgoR4cSIFRQ0ACwsgCCAFaEEDdiAGaiALcUECdGsiCkF8aiIMKAIAIgIgDk8NASAFQX9qIAVxIQUgAkEEdCAQaiICQQRqKAIAIAdHDQAgAkEIaigCACANRw0AC0GAASEEIAggCmtBAnYiAyAIaiIFKAAAIgIgAkEBdHFBgIGChHhxaEEDdiADQXxqIAtxIAhqIgMoAAAiAiACQQF0cUGAgYKEeHFnQQN2akEDTQRAIAAgACgCJEEBajYCJEH/ASEECyAFIAQ6AAAgA0EEaiAEOgAAIBQgD0F/aiIPNgIAIA4gDCgCACIJTQ0BIBIgDkF/aiIKNgIAIAlBBHQgEGoiAygCDCEHIApBBHQgEGoiAikCACEWIANBCGogAkEIaikCADcCACADIBY3AgAgCiAJSwRAIAMoAgAiAkEZdkGBgoQIbCEMIAwgCCACIAtxIgZqKAAAIgRzIgJBf3MgAkH//ft3anFBgIGChHhxIQJBACEDA0ACQCACBEAgAiEFDAELA0AgBEEBdCAEcUGAgYKEeHENBiADIAZqIQIgA0EEaiEDIAwgCCACQQRqIAtxIgZqKAAAIgRzIgJBf3MgAkH//ft3anFBgIGChHhxIgVFDQALCyAFQX9qIAVxIQIgBWhBA3YgBmogC3FBf3NBAnQgCGoiBSgCACAKRw0ACyAFIAk2AgALIAdBf0YNBCARIAdNDQMgACgCDCECIAAgBzYCDCAHQSxsIBVqIAI2AiQMBAsgAiAOQcTewAAQzQgACyAJIA4QywgAC0HU3sAAQQ9B5N7AABCiCQALIAcgEUH4osEAEM0IAAsgEyABQQhqIgFHDQALCw8LQaPgwABBFEHkrcEAEPsKAAtB0KzBAEEnQdStwQAQ+woACyAEIAZBxJXBABDNCAAL6QkCCX8BfSMAQUBqIgMkACADQTBqIAEgAhCZCQJAAkACQAJAAkAgAygCMCIBBEAgA0EoaiABEKAKAkACQCADKAIoIAMoAiwoAowBEQYAQf8BcUF7ag4NAQAAAAAEAAAAAAAAAwALIABBADYCAAwFCyADQRBqIAEQoAogAygCECADKAIUEOYJIgFFBEAgAEEANgIADAULIANBCGoiAiABQcgAaigCADYCBCACIAEoAkA2AgAgAygCDCIBBEAgAygCCCIEKgIAIQxBDEEEEMULIgYEQCABQQxsIARqIQsgBiAMOAIAIANCg4CAgBA3AjQgAyAGNgIwIARBBGohAUECIQJBBCEIQQEhBSAEQQxqIgkhBwNAAkAgAgRAIAIhCgwBCwJAIAdFDQAgByALRg0AQQMhCiAHIgEhBCABQQxqIgkhBwwBCyADKAI0IQEgAygCMCECDAcLIAEgCUYEQCABQQxqIQkgBEEMaiIBIQQLIAEqAgAhDCABQQRqIAEgCkF/aiICGyEBIAMoAjQgBUYEQCADQTBqIAUgChCUBiADKAIwIQYLIAYgCGogDDgCACADIAVBAWoiBTYCOCAIQQRqIQgMAAsACwwGC0Hsm8AAKAIAIQJBACEBDAMLQaiswABBzABBnK3AABCiCQALIANBIGogARCgCiADKAIgIAMoAiQQ7gkiAUUEQCAAQQA2AgAMAwsgAAJ/IAEoAggiAgRAIAEoAgAiBCoCACEMQQxBBBDFCyIGBEAgAkEMbCAEaiELIAYgDDgCACADQoOAgIAQNwI0IAMgBjYCMCAEQQRqIQFBAiECQQQhCEEBIQUgBEEMaiIJIQcDQAJAIAIEQCACIQoMAQsCQCAHRQ0AIAcgC0YNAEEDIQogByIBIQQgAUEMaiIJIQcMAQsgAygCMCECIAMoAjQMBAsgASAJRgRAIAFBDGohCSAEQQxqIgEhBAsgASoCACEMIAFBBGogASAKQX9qIgIbIQEgAygCNCAFRgRAIANBMGogBSAKEJQGIAMoAjAhBgsgBiAIaiAMOAIAIAMgBUEBaiIFNgI4IAhBBGohCAwACwALDAULQeybwAAoAgAhAkEACzYCBCAAIAI2AgAgAEEIaiAFNgIADAILIANBGGogARCgCiADKAIYIAMoAhwQ6gkiAUUEQCAAQQA2AgAMAgsgAAJ/IAEoAggiAgRAIAEoAgAiBCoCACEMQQxBBBDFCyIGBEAgAkEMbCAEaiELIAYgDDgCACADQoOAgIAQNwI0IAMgBjYCMCAEQQRqIQFBAiECQQQhCEEBIQUgBEEMaiIJIQcDQAJAIAIEQCACIQoMAQsCQCAHRQ0AIAcgC0YNAEEDIQogByIBIQQgAUEMaiIJIQcMAQsgAygCMCECIAMoAjQMBAsgASAJRgRAIAFBDGohCSAEQQxqIgEhBAsgASoCACEMIAFBBGogASAKQX9qIgIbIQEgAygCNCAFRgRAIANBMGogBSAKEJQGIAMoAjAhBgsgBiAIaiAMOAIAIAMgBUEBaiIFNgI4IAhBBGohCAwACwALDAQLQeybwAAoAgAhAkEACzYCBCAAIAI2AgAgAEEIaiAFNgIADAELIAAgATYCBCAAIAI2AgAgAEEIaiAFNgIACyADQUBrJAAPC0EMQQRBoJ3DACgCACIAQa8GIAAbEQAAAAuyCQIGfwt9IwBBEGsiBSQAAkACQAJ/AkACQCADKgIAIg9DAAAAAFwEQEMAAIA/IA+VIgsgASoCACACKgIAIg2TlCIMIAsgAUEMaioCACANk5QiC14hBCAMIAsgBBshCkP//3//IQ0gCyAMIAQbIgtD//9//14NASALQ///f/9bDQJBAAwDCyACKgIAIg0gASoCAF0NBCANIAFBDGoqAgBeBEAMBQtD//9/fyELQ///f/8hDQwDC0F/QQEgBBshBiALIQ1BAAwBC0EBCyEJQ///f38hCwJ/AkAgCkP//39/XUUEQCAKQ///f39bDQFBAAwCC0EBQX8gBBshByAKIQtBAAwBC0EBCyEIQQAhBCALQwAAAABdDQEgDSALXg0BCwJAIANBBGoqAgAiEEMAAAAAWwRAIAJBBGoqAgAiCiABQQRqKgIAXQ0CIAogAUEQaioCAF4NAgwBC0MAAIA/IBCVIgwgAUEEaioCACACQQRqKgIAIgqTlCIOIAwgAUEQaioCACAKk5QiCl4hBCAOIAogBBshDAJAIAogDiAEGyIKIA1eRQRAIAogDVwNAUEBIQkMAQtBfkECIAQbIQZBACEJIAohDQsCQCAMIAtdRQRAIAwgC1wNAUEBIQgMAQtBAkF+IAQbIQdBACEIIAwhCwtBACEEIAtDAAAAAF0NASANIAteDQELAkAgA0EIaioCACIRQwAAAABcBEBDAACAPyARlSIMIAFBCGoqAgAgAkEIaioCACIKk5QiDiAMIAFBFGoqAgAgCpOUIgpeIQEgDiAKIAEbIQwCQCAKIA4gARsiCiANXkUEQCAKIA1cDQFBASEJDAELQX1BAyABGyEGQQAhCSAKIQ0LAkAgDCALXUUEQCAMIAtcDQFBASEIDAELQQNBfSABGyEHQQAhCCAMIQsLIAtDAAAAAF0NAiANIAteDQIMAQsgAkEIaioCACIKIAFBCGoqAgBdDQEgCiABQRRqKgIAXg0BCwJ9An0CQAJAAkACfQJAIAlFBEAgBUIANwMAIAVBADYCCCAGQQBIDQFDAACAvyAGQX9qIgFBA0kNAhpBuLrBAEEbQdjJwQAQ/AoACyARjCAPIA+UIBAgEJSSIBEgEZSSQwAAAACSELMBIgqVIRIgEIwgCpUhEyAPjCAKlSEUIAhFDQIMAwsgBkF/cyEBQwAAgD8LIRIgAUECdCAFaiASOAIAIAUqAgghEiAFKgIEIRMgBSoCACEUIAgNAQsgBUIANwMAIAVBADYCCCAHQQBIDQFDAACAPyAHQX9qIgFBA0kNAhpBuLrBAEEbQejJwQAQ/AoACyARjCAPIA+UIBAgEJSSIBEgEZSSQwAAAACSELMBIg6VIQwgEIwgDpUhCiAPjCAOlQwCCyAHQX9zIQFDAACAvwshDiABQQJ0IAVqIA44AgAgBSoCCCEMIAUqAgQhCiAFKgIACyEOIAAgDTgCBCAAQShqIAc2AgAgAEEkaiAMOAIAIABBIGogCjgCACAAQRxqIA44AgAgAEEYaiALOAIAIABBFGogBjYCACAAQRBqIBI4AgAgAEEMaiATOAIAIABBCGogFDgCAEEBIQQLIAAgBDYCACAFQRBqJAALogkBB38CQCABQf8JTQRAIAFBBXYhBQJAAkACQCAAKAIAIgQEQCAEQQJ0IABqIQIgBCAFakECdCAAaiEGIARBf2oiA0EnSyEEA0AgBA0EIAMgBWoiB0EoTw0CIAYgAigCADYCACAGQXxqIQYgAkF8aiECIANBf2oiA0F/Rw0ACwsgAUEgSQ0EIABBADYCBCABQcAATw0BDAQLIAdBKEGIj8MAEM0IAAsgAEEIakEANgIAIAVBASAFQQFLGyICQQJGDQIgAEEMakEANgIAIAJBA0YNAiAAQRBqQQA2AgAgAkEERg0CIABBFGpBADYCACACQQVGDQIgAEEYakEANgIAIAJBBkYNAiAAQRxqQQA2AgAgAkEHRg0CIABBIGpBADYCACACQQhGDQIgAEEkakEANgIAIAJBCUYNAiAAQShqQQA2AgAgAkEKRg0CIABBLGpBADYCACACQQtGDQIgAEEwakEANgIAIAJBDEYNAiAAQTRqQQA2AgAgAkENRg0CIABBOGpBADYCACACQQ5GDQIgAEE8akEANgIAIAJBD0YNAiAAQUBrQQA2AgAgAkEQRg0CIABBxABqQQA2AgAgAkERRg0CIABByABqQQA2AgAgAkESRg0CIABBzABqQQA2AgAgAkETRg0CIABB0ABqQQA2AgAgAkEURg0CIABB1ABqQQA2AgAgAkEVRg0CIABB2ABqQQA2AgAgAkEWRg0CIABB3ABqQQA2AgAgAkEXRg0CIABB4ABqQQA2AgAgAkEYRg0CIABB5ABqQQA2AgAgAkEZRg0CIABB6ABqQQA2AgAgAkEaRg0CIABB7ABqQQA2AgAgAkEbRg0CIABB8ABqQQA2AgAgAkEcRg0CIABB9ABqQQA2AgAgAkEdRg0CIABB+ABqQQA2AgAgAkEeRg0CIABB/ABqQQA2AgAgAkEfRg0CIABBgAFqQQA2AgAgAkEgRg0CIABBhAFqQQA2AgAgAkEhRg0CIABBiAFqQQA2AgAgAkEiRg0CIABBjAFqQQA2AgAgAkEjRg0CIABBkAFqQQA2AgAgAkEkRg0CIABBlAFqQQA2AgAgAkElRg0CIABBmAFqQQA2AgAgAkEmRg0CIABBnAFqQQA2AgAgAkEnRg0CIABBoAFqQQA2AgAgAkEoRg0CQShBKEGIj8MAEM0IAAsgA0EoQYiPwwAQzQgAC0Gyj8MAQR1BiI/DABDbCQALIAAoAgAgBWohAiABQR9xIgdFBEAgACACNgIAIAAPCwJAIAJBf2oiA0EnTQRAIAIhBCADQQJ0IABqQQRqKAIAIgZBACABayIBdiIDRQ0BIAJBJ00EQCACQQJ0IABqQQRqIAM2AgAgAkEBaiEEDAILIAJBKEGIj8MAEM0IAAsgA0EoQYiPwwAQzQgACwJAIAVBAWoiCCACSQRAIAFBH3EhASACQQJ0IABqQXxqIQMDQCACQX5qQShPDQIgA0EEaiAGIAd0IAMoAgAiBiABdnI2AgAgA0F8aiEDIAggAkF/aiICSQ0ACwsgBUECdCAAakEEaiIBIAEoAgAgB3Q2AgAgACAENgIAIAAPC0F/QShBiI/DABDNCAALuAkBBX8jAEHwAGsiBSQAIAUgAzYCDCAFIAI2AggCQCAFAn8gBQJ/An8CQAJAIAFBgQJPBEADQCAHQYACaiAAIAdqIgZBgAJqLAAAQb9/Sg0EGiAHQf8BaiAGQf8BaiwAAEG/f0oNBBogBkH+AWosAABBv39KDQMgBkH9AWosAABBv39KDQIgB0F8aiIHQYB+Rw0AC0EADAQLIAUgATYCFCAFIAA2AhAgBUHY98IANgIYQQAMBAsgB0H9AWoMAQsgB0H+AWoLIgYgAU8EQCABIAEgBkYNARoMAwsgACAGaiwAAEG/f0wNAiAGCzYCFCAFIAA2AhAgBUGggcMANgIYQQULNgIcAkACQAJAAkACQAJAAkAgAiABSyIHDQAgAyABSw0AIAIgA0sNASACRQ0CAkAgAiABTwRAIAEgAkcNAQwECyAAIAJqLAAAQb9/Sg0DCyAFIAI2AiAgAiEDDAMLIAUgAiADIAcbNgIoIAVBMGoiAEEUakEDNgIAIAVByABqIgFBFGpBzgY2AgAgBUHUAGpBzgY2AgAgBUIDNwI0IAVByIHDADYCMCAFQQI2AkwgBSABNgJAIAUgBUEYajYCWCAFIAVBEGo2AlAgBSAFQShqNgJIIAAgBBDgCgALIAVB5ABqQc4GNgIAIAVByABqIgBBFGpBzgY2AgAgBUHUAGpBAjYCACAFQTBqIgFBFGpBBDYCACAFQgQ3AjQgBUGEgsMANgIwIAVBAjYCTCAFIAA2AkAgBSAFQRhqNgJgIAUgBUEQajYCWCAFIAVBDGo2AlAgBSAFQQhqNgJIIAEgBBDgCgALIAUgAzYCICADRQ0BCwNAAkAgAyABSSICRQRAIAEgA0YNBQwBCyAAIANqIgcsAABBQEgNAAJAIAJFBEAgASADRw0BDAYLIAcsAABBv39KDQQLIAAgASADIAEgBBDKAQALIANBf2oiAw0ACwtBACEDCyABIANGDQBBASEHAkACQAJAIAAgA2oiAiwAACIGQX9MBEAgACABaiIHIgAgAkEBakcEQCACLQABQT9xIQggAkECaiEACyAGQR9xIQkgBkH/AXFB3wFLDQEgCUEGdCAIciEGDAILIAUgBkH/AXE2AiQMAgtBACECIAAgByIBRwRAIAAtAABBP3EhAiAAQQFqIQELIAhBBnQgAnIhACAGQf8BcUHwAUkEQCAJQQx0IAByIQYMAQtBACEGIAEgB0cEfyABLQAAQT9xBUEACyAJQRJ0QYCA8ABxIABBBnRyciIGQYCAxABGDQILIAUgBjYCJEEBIQcgBkGAAUkNAEECIQcgBkGAEEkNAEEDQQQgBkGAgARJGyEHCyAFIAM2AiggBSADIAdqNgIsIAVBMGoiAEEUakEFNgIAIAVB7ABqQc4GNgIAIAVB5ABqQc4GNgIAIAVByABqIgFBFGpB0QY2AgAgBUHUAGpB0gY2AgAgBUIFNwI0IAVB2ILDADYCMCAFQQI2AkwgBSABNgJAIAUgBUEYajYCaCAFIAVBEGo2AmAgBSAFQShqNgJYIAUgBUEkajYCUCAFIAVBIGo2AkggACAEEOAKAAtBufjCAEErIAQQ2wkACyAAIAFBACAGQZCBwwAQygEAC78MAgJ/An0CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEoAgBBAWsOEgECAwQFBgcICQoLDA0ODxAREgALIAEqAgQhBEEMQQQQxQsiAkUNEiACIAQ4AgggAkKBgICAEDcCAEHU5sEAIQMMEQtBFEEEEMULIgJFDRsgAkKBgICAEDcCACACIAEpAgQ3AgggAkEQaiABQQxqKAIANgIAQdz2wQAhAwwQC0EkQQQQxQsiAkUNESACQoGAgIAQNwIAIAIgASkCBDcCCCACQSBqIAFBHGooAgA2AgAgAkEYaiABQRRqKQIANwIAIAJBEGogAUEMaikCADcCAEHQ+cEAIQMMDwtBIEEEEMULIgJFDREgAkKBgICAEDcCACACIAEpAgQ3AgggAkEYaiABQRRqKQIANwIAIAJBEGogAUEMaikCADcCAEH08sEAIQMMDgtBLEEEEMULIgJFDREgAkKBgICAEDcCACACIAEpAgQ3AgggAkEoaiABQSRqKAIANgIAIAJBIGogAUEcaikCADcCACACQRhqIAFBFGopAgA3AgAgAkEQaiABQQxqKQIANwIAQcT8wQAhAwwNC0HgAEEEEMULIgJFDRggAkEIaiABQQRqQdgAEOQGGiACQoGAgIAQNwIAQeyEwgAhAwwMC0HgAEEEEMULIgJFDRcgAkEIaiABQQRqQdgAEOQGGiACQoGAgIAQNwIAQaCCwgAhAwwLC0EUQQQQxQsiAkUNFSACQoGAgIAQNwIAIAIgASkCBDcCCCACQRBqIAFBDGooAgA2AgBB5JPCACEDDAoLQdgAQQQQxQsiAkUNDiACQQhqIAFBBGpB0AAQ5AYaIAJCgYCAgBA3AgBBuIfCACEDDAkLQfgAQQQQxQsiAkUNDiACQQhqIAFBBGpB8AAQ5AYaIAJCgYCAgBA3AgBB1P/BACEDDAgLQegAQQQQxQsiAkUNDiACQQhqIAFBBGpB4AAQ5AYaIAJCgYCAgBA3AgBB8InCACEDDAcLIAFBCGoqAgAhBCABKgIEIQVBEEEEEMULIgJFDRMgAiAEOAIMIAIgBTgCCCACQoGAgIAQNwIAQeSMwgAhAwwGCyABQQhqKgIAIQQgASoCBCEFQRBBBBDFCyICRQ0SIAIgBDgCDCACIAU4AgggAkKBgICAEDcCAEHYj8IAIQMMBQtBGEEEEMULIgJFDQwgAkKBgICAEDcCACACIAEpAgQ3AgggAkEQaiABQQxqKQIANwIAQZCuwgAhAwwEC0EwQQQQxQsiAkUNDCACQoGAgIAQNwIAIAIgASkCBDcCCCACQShqIAFBJGopAgA3AgAgAkEgaiABQRxqKQIANwIAIAJBGGogAUEUaikCADcCACACQRBqIAFBDGopAgA3AgBB2KvCACEDDAMLQRRBBBDFCyICRQ0NIAJCgYCAgBA3AgAgAiABKQIENwIIIAJBEGogAUEMaigCADYCAEHopsIAIQMMAgtBFEEEEMULIgJFDQwgAkKBgICAEDcCACACIAEpAgQ3AgggAkEQaiABQQxqKAIANgIAQaCpwgAhAwwBC0HsAEEEEMULIgJFDQogAkEIaiABQQRqQeQAEOQGGiACQoGAgIAQNwIAQbCkwgAhAwsgACADNgIEIAAgAjYCAA8LQQxBBEGgncMAKAIAIgBBrwYgABsRAAAAC0EkQQRBoJ3DACgCACIAQa8GIAAbEQAAAAtBIEEEQaCdwwAoAgAiAEGvBiAAGxEAAAALQSxBBEGgncMAKAIAIgBBrwYgABsRAAAAC0HYAEEEQaCdwwAoAgAiAEGvBiAAGxEAAAALQfgAQQRBoJ3DACgCACIAQa8GIAAbEQAAAAtB6ABBBEGgncMAKAIAIgBBrwYgABsRAAAAC0EYQQRBoJ3DACgCACIAQa8GIAAbEQAAAAtBMEEEQaCdwwAoAgAiAEGvBiAAGxEAAAALQewAQQRBoJ3DACgCACIAQa8GIAAbEQAAAAtBFEEEQaCdwwAoAgAiAEGvBiAAGxEAAAALQeAAQQRBoJ3DACgCACIAQa8GIAAbEQAAAAtBEEEEQaCdwwAoAgAiAEGvBiAAGxEAAAAL1QkCB38BfiMAQTBrIgMkACABLQAUIQUgAUECOgAUAkACQAJAAkACQAJAAkAgBUECRwRAIAFBIGooAgAhBCABQRxqKAIAIQYgAUEYaigCACEIIAEoAgAoAgAhByADQQhqIAFBDGopAgA3AwAgA0ETaiABQRdqLQAAOgAAIAMgBToAECADIAEpAgQ3AwAgAyABLwAVOwARIANBATsBFCACKAIAIgUoAgAhASAFIAFBAWo2AgAgAUF/TA0BIANBEWohCSAIKAIIIgEgCEEEaigCAEYEQCAIIAEQgAYgCCgCCCEBCyAIIAFBAWo2AgggCCgCACABQQxsaiIBIAU2AgggASAHNgIAIAEgAzYCBCAIQRhqEJ0EIAhBADoANCADQRhqIgFBEGogBkEQaikDADcDACABQQhqIAZBCGopAwA3AwAgAyAGKQMANwMYAkACQAJAAkACQCACIAEQxwRBAWsOAwECAwALQey3wABBKEG8vMAAENsJAAsgBCgCACIELQA0IARBAToANARAQQAhAQNAIAEgAUEBaiABQQdPQQAgAUEKSxsbIQEgBC0ANCAEQQE6ADQNAAsLIAQoAgBBdGohAiAEQQhqKAIAIgZBDGwhBSAGQf////8DcSEIQQAhAQNAIAEgCEYNByAFQXRqIQUgAUEBaiEBIAJBDGoiAigCACAHRw0ACyAGIAFBf2oiAU0NBSACQQhqKAIAIQcgAikCACEKIAIgAkEMaiAFEL8EGiAEQQhqIAZBf2o2AgAgB0UNBiAHIAcoAgAiAUF/ajYCACADIAc2AiAgAyAKNwMYIAFBAUYEQCADQSBqEJ0JCyAEQQA6ADQgAy0AECEBIANBAjoAECABQQJGDQcgAEEANgIAIAAgAykDADcCBCAAQRRqIAE6AAAgACAJLwAAOwAVIABBDGogA0EIaikDADcCACAAQRdqIAlBAmotAAA6AAAMAgsgBCgCACIELQA0IARBAToANARAQQAhAQNAIAEgAUEBaiABQQdPQQAgAUEKSxsbIQEgBC0ANCAEQQE6ADQNAAsLIAQoAgBBdGohAiAEQQhqKAIAIgZBDGwhBSAGQf////8DcSEIQQAhAQNAIAEgCEYNCSAFQXRqIQUgAUEBaiEBIAJBDGoiAigCACAHRw0ACyAGIAFBf2oiAU0NByACQQhqKAIAIQcgAikCACEKIAIgAkEMaiAFEL8EGiAEQQhqIAZBf2o2AgAgB0UNCCAHIAcoAgAiAUF/ajYCACADIAc2AiAgAyAKNwMYIAFBAUYEQCADQSBqEJ0JCyAEQQA6ADQgAy0AECEBIANBAjoAECABQQJGDQkgAEEBNgIAIAAgAykDADcCBCAAQRRqIAE6AAAgACAJLwAAOwAVIABBDGogA0EIaikDADcCACAAQRdqIAlBAmotAAA6AAAMAQsgAy0AFUUEQEEAIQEDQCABIAFBAWogAUEHT0EAIAFBCksbGyEBIAMtABVFDQALCyAAQQI2AgALIANBMGokAA8LQaS/wABBK0H0ucAAENsJAAsACyABIAYQzAgAC0Gkv8AAQStBnLzAABDbCQALQaS/wABBK0GsvMAAENsJAAsgASAGEMwIAAtBpL/AAEErQfy7wAAQ2wkAC0Gkv8AAQStBjLzAABDbCQALjwkCB38PfSMAQbABayIEJAACQCABBEAgACgCACIGKAIAIgUoAhghByAFKAIcIQggBEE4aiIFQRhqIgkgAUEYaigCADYCACAFQRBqIAFBEGopAgA3AwAgBUEIaiABQQhqKQIANwMAIAQgASkCADcDOCAEQfAAaiIKIAggBRCdAiAFIAcgCiACIAMgBigCACICKAIgIAIoAiwgAkEwaigCACACKgIQIAIqAhQgAi0ANBD9AUEEIQIgBC0AbCIDQQVHBEAgBEEwaiAJKAIANgIAIARBIGogBEHoAGooAgA2AgAgBCAEKQNINwMoIAQgBCkDYDcDGCAEKgJcIQsgBCoCWCEPIAQqAlQhECAEKgJEIRUgBCoCQCEWIAQqAjwhFyAEKgI4IRQgAyECCyACQQRGDQEgBEFAayAEQTBqKAIANgIAIARBEGogBEEgaigCADYCACAEIAQpAyg3AzggBCAEKQMYNwMIIAsgAUEMaioCACISIA8gASoCACIMlCAQIAFBBGoqAgAiDZSTIg4gDpIiE5QgDCAQIAFBCGoqAgAiDpQgCyAMlJMiESARkiIRlCANIAsgDZQgDyAOlJMiCyALkiILlJOSkiEYIA8gEiARlCAOIAuUIAwgE5STkpIhGSAQIBIgC5QgDSATlCAOIBGUk5KSIRMgAUEYaioCACAVIBIgFiAMlCAXIA2UkyILIAuSIguUIAwgFyAOlCAVIAyUkyIPIA+SIg+UIA0gFSANlCAWIA6UkyIQIBCSIhCUk5KSkiERIAFBFGoqAgAgFiASIA+UIA4gEJQgDCALlJOSkpIhDCABKgIQIBcgEiAQlCANIAuUIA4gD5STkpKSIQ0MAQsgBEHwAGogACgCACgCACIBKAIYIAEoAhwgAiADIAEoAiAgASgCLCABQTBqKAIAIAEqAhAgASoCFCABLQA0EP0BIAQtAKQBIgJBBUYEQEEEIQIMAQsgBEFAayAEQYgBaigCADYCACAEQRBqIARBoAFqKAIANgIAIARBKmogBEGnAWotAAA6AAAgBCAEKQOAATcDOCAEIAQpA5gBNwMIIAQgBC8ApQE7ASggBCoClAEhGCAEKgKQASEZIAQqAowBIRMgBCoCfCERIAQqAnghDCAEKgJ0IQ0gBCoCcCEUCwJAAkACQCACQQRHBEAgACgCCCIBKAIAIgNBBE8NAiAAKAIEIANBAnRqIBQ4AgAgASgCACIDQQRPDQMgACgCDCADaiAUIAAoAhAqAgBdOgAAIAEoAgAiAUEETw0BIAAoAhgoAgAhAyAAKAIUIAFBPGxqIgAgETgCECAAIAw4AgwgACANOAIIIAAgFDgCBCAAIAM2AgAgACAEKQM4NwIUIAAgGDgCKCAAIBk4AiQgACATOAIgIAAgBCkDCDcCLCAAQRxqIARBQGsoAgA2AgAgAEE0aiAEQRBqKAIANgIAIAAgAjoAOCAAIAQvASg7ADkgAEE7aiAEQSpqLQAAOgAACyAEQbABaiQADwsgAUEEQcjowQAQzQgACyADQQRBqOjBABDNCAALIANBBEG46MEAEM0IAAvVCQIWfwd9IwBBEGsiCCQAIAIEQCAAQRxqIREgAkEDdCABaiESIABBGGooAgAhDiAAQSxqKAIAIRMgAEE0aigCACEPIABBKGooAgAhFCAAKAIQIRUgACgCACEQIAAoAgghCQNAAkAgFEUNACAIQQhqIBEgAUEEaigCACABKAIAQbnz3fF5bEEFd3NBufPd8XlsIAEQ/wQgCCgCCEEBRw0AIAgoAgwiACAPSQRAIABBBHQgE2ooAgwiAEF/Rg0BIAkgAEsEQCAOIABBLGwgEGoiAC0AKCICSwRAIABBHGoiBCoCACEdIABBIGoqAgAhHCAEQv////f3/////gA3AgAgAEEUaiIEKgIAIR4gAEEYaioCACEZIARC////9/f////+ADcCACAAQRBqKgIAIR8gAEEMaiIAKgIAIABC////9/f////+ADcCAAJ/IBkgAkEGdCAVaiIKKgIAIhmVjiIbi0MAAABPXQRAIBuoDAELQYCAgIB4CyEAIBmVjiIaQwAAAM9gIQMgAEGAgICAeCAbQwAAAM9gGyEAIBtD////Tl4hBAJ/IBqLQwAAAE9dBEAgGqgMAQtBgICAgHgLQYCAgIB4IAMbIQIgGkP///9OXiEDAn8gHCAZlY4iHItDAAAAT10EQCAcqAwBC0GAgICAeAshC0H/////ByAAIAQbIQAgGyAbXCEEQf////8HIAIgAxshAiAaIBpcIQMCfyAdIBmVjiIbi0MAAABPXQRAIBuoDAELQYCAgIB4CyEMQQAgACAEGyEGQQAgAiADGyEDAn8gHiAZlY4iGotDAAAAT10EQCAaqAwBC0GAgICAeAshACADIAZKAn8gHyAZlY4iGYtDAAAAT10EQCAZqAwBC0GAgICAeAshAg0DAkBBAEH/////ByACQYCAgIB4IBlDAAAAz2AbIBlD////Tl4bIBkgGVwbIgRBAEH/////ByAMQYCAgIB4IBtDAAAAz2AbIBtD////Tl4bIBsgG1wbIgdMBEBBAEH/////ByAAQYCAgIB4IBpDAAAAz2AbIBpD////Tl4bIBogGlwbIgxBAEH/////ByALQYCAgIB4IBxDAAAAz2AbIBxD////Tl4bIBwgHFwbIg1MBEAgCkEEaiEWDAILA0AgBCEAA0AgACAHSARAIAAgB0ggAGoiACAHTA0BCwsgAyAGTg0GIAMgBkggA2oiAyAGTA0ACwwFCwNAIAMgBk4NBSADIAZIIANqIgMgBkwNAAsMBAsDQCADIgsgBk4hFyADIAZIIANqIQMgBCECA0AgAiIKIAdOIRggAiAHSCACaiECIAwhAAJAA0ACQCAWIAsgCiAAEJUDIgUEQCAJIAUoAgAiBU0NAQJAIAVBLGwgEGoiBSgCAEEBRgRAIAUoAgQiBQ0BQaS/wABBK0HYosEAENsJAAtBlKHBAEETQciiwQAQ+woACyAFIAUtAJABIgVBASAFQQFLGzoAkAELIAAgDU4gACANSCAAaiIAIA1KckUNAQwCCwsgBSAJQZSgwQAQzQgACyACIAdKIBhyRQ0ACyADIAZKIBdyRQ0ACwwDCyACIA5BtJXBABDNCAALIAAgCUGklcEAEM0IAAsgACAPQdTdwAAQzQgACyASIAFBCGoiAUcNAAsLIAhBEGokAAvmCAIRfwV9AkACQAJAAkAgAUEMaigCACIHQQJJDQAgAUEQaigCACIRQQJJDQAgByARbCILRQ0DIAEoAgAiAyAHQQJ0aiIEIAMgB0EAIAsbQQJ0IANqIgUgA0YiAxsiCCoCACEUIAtBf2oiEkUEQCAUIRUMBAsgBCAFIAMbIgQgEkEAR0ECdCAIaiINRiEKIAdBAnQiAyAIaiIJIA0gChshBiALQX5qIg5FDQECQCALQQFxRQRAIBQhFSAEIQUgCCEDDAELIBQgBioCACIVIBQgFWAbIRUgC0F9aiEOIAkgCCAEIA1GIgUbIQMgB0EAIAUbQQJ0IARqIgUgBkEEaiIMRiEKIAdBAnQgA2oiCSAMIAobIgwhBgsgC0EDRwRAA0AgCSADIApBAXEiDBshEyAGQQRqIgMgB0EAIAwbQQJ0IAVqIgVGIRAgFSAGKgIAIhYgFSAWYBsiFiATIAdBAnQiCWoiDyADIBAbIgMqAgAiFSAWIBVgGyEVIAdBACAQG0ECdCAFaiIFIANBBGoiDEYhCiAJIA8gEyAQGyIDaiIJIAwgChsiDCEGIA5BfmoiDg0ACwsgFSAMKgIAIhYgFSAWYBshFSASRQ0DIAdBAnQgCGoiCiANIAQgDUYiBhsiCSEDIAtBfmoiDkUNAiALQQFxBEAgFCAJKgIAIhYgFCAWXxshFCALQX1qIQ4gCiAIIAQgDUYiAxshCCAHQQAgAxtBAnQgBGoiBCAJQQRqIgNGIQYgB0ECdCAIaiIKIAMgBhsiBSEJCyAFIQMgC0EDRg0CA0AgCiAIIAZBAXEiBRshCCAJQQRqIgMgB0EAIAUbQQJ0IARqIgRGIQ8gFCAJKgIAIhYgFCAWXxsiFiAHQQJ0IgwgCGoiBSADIA8bIgMqAgAiFCAWIBRfGyEUIAdBACAPG0ECdCAEaiIEIANBBGoiA0YhBiAMIAUgCCAPGyIIaiIKIAMgBhsiAyEJIA5BfmoiDg0ACwwCC0GAnsIAQTxBpJ/CABD8CgALIBQgBioCACIVIBQgFWAbIRUgAyAIaiANIAQgDUYbIQMLIBQgAyoCACIWIBQgFl8bIRQLAkAgEUF/aiIFIAdBf2oiA2wiBEEATgRAIAIqAgghFiACKgIAIRggAioCBCEXQQEhBiAEBEAgBEEBEMULIgZFDQIgBkEAIAQQ6AYaCyAAIAY2AjwgACACKQIANwIUIAAgASkCADcCACAAQcwAaiAFNgIAIABByABqIAM2AgAgAEHEAGogBDYCACAAQUBrIAQ2AgAgACAEQQF0NgI4IABBNGogFkMAAAA/lCIWOAIAIABBMGogFSAXlDgCACAAQSxqIBhDAAAAP5QiFTgCACAAQShqIBaMOAIAIABBJGogFCAXlDgCACAAIBWMOAIgIABBHGogAkEIaigCADYCACAAQQhqIAFBCGopAgA3AgAgAEEQaiABQRBqKAIANgIADwsQkQwACyAEQQFBoJ3DACgCACIAQa8GIAAbEQAAAAuRCgIBfwJ9AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAAoAgBBAWsOCAECAwQFBgcRAAsgAEEMaigCACIDIAJPDQggA0HkAWwgAWoiASgCGA0HIAFBPGogAEEkaigCADYCACABQTRqIABBHGopAgA3AgAgAUHoAGogAEHkAGopAgA3AgAgAUHwAGogAEHsAGooAgA2AgAgAUGQAWogAEGYAWoqAgA4AgAPCyAAQQhqKAIAIgMgAk8NCCADQeQBbCABaiIBKAIYDQYgAUE8aiAAQSxqKAIANgIAIAFBNGogAEEkaikCADcCACABQegAaiAAQdQAaikCADcCACABQfAAaiAAQdwAaigCADYCACABQZABaiAAQYgBaioCADgCAA8LIABBDGooAgAiAyACTw0IIANB5AFsIAFqIgEoAhhBAUcNBSABQeQAaiAAQSBqKQIANwIAIAFB3ABqIABBGGopAgA3AgAgAUHUAGogAEEQaikCADcCAA8LIABBCGooAgAiAyACTw0IIANB5AFsIAFqIgEoAhhBAUcNBCABQeQAaiAAQRxqKQIANwIAIAFB3ABqIABBFGopAgA3AgAgAUHUAGogAEEMaikCADcCAA8LIABBDGooAgAiAyACTw0IIANB5AFsIAFqIgEoAhhBAkcNAyABQYwBaiAAQbABaigCADYCACABQYQBaiAAQagBaikCADcCACABQfwAaiAAQaABaikCADcCACABQbABaiAAQcwBaioCADgCACABQZgBaiAAQdwBaioCADgCAA8LIABBCGooAgAiAyACTw0IIANB5AFsIAFqIgEoAhhBAkcNAiABQYwBaiAAQaABaigCADYCACABQYQBaiAAQZgBaikCADcCACABQfwAaiAAQZABaikCADcCACABQbABaiAAQcwBaioCADgCACABQZgBaiAAQbABaioCADgCAA8LIABBDGooAgAiAyACTw0IIANB5AFsIAFqIgEoAhhBA0cNASABQYwBaiAAQbABaiICKAIANgIAIAFBhAFqIABBqAFqKQIANwIAIAFB/ABqIABBoAFqKQIANwIAIAFBwAFqIABBrAFqKgIAIgQgAEH8AWoqAgCUIAIqAgAiBSAAQYgCaioCAJSSOAIAIAFBvAFqIAQgAEH4AWoqAgCUIAUgAEGEAmoqAgCUkjgCACABQbgBaiAEIABB9AFqKgIAlCAFIABBgAJqKgIAlJI4AgAgAUHMAWogAEHQAWooAgA2AgAgAUHEAWogAEHIAWopAgA3AgAgAUG0AWogAEHEAWoqAgA4AgAgAUGwAWogAEG8AWoqAgA4AgAgAUGYAWogAEHgAWoqAgA4AgAPCyAAQQhqKAIAIgMgAk8NCCADQeQBbCABaiIBKAIYQQNHDQAgAUGMAWogAEGgAWooAgA2AgAgAUGEAWogAEGYAWopAgA3AgAgAUH8AGogAEGQAWopAgA3AgAgAUGwAWogAEG4AWoqAgA4AgAgAUG0AWogAEHAAWoqAgA4AgAgAUGYAWogAEHEAWoqAgA4AgALDwsgAyACQbz2wAAQzQgACyADIAJB/PbAABDNCAALIAMgAkHk+sAAEM0IAAsgAyACQaT7wAAQzQgACyADIAJB0IHBABDNCAALIAMgAkGAgsEAEM0IAAsgAyACQfiFwQAQzQgACyADIAJBqIbBABDNCAALQey3wABBKEHc/MAAENsJAAuXCAEPfwJAIAAEQCAAKAIADQEgAEEANgIAIAAoAtwDIQIgACgC5AMhAyAAKALoAyEHIAAoAuwDIQQgACgC8AMhCCAAKAL0AyEJIAAoAvwDIQogACgCgAQhCyAAKAKIBCEGIAAoAowEIQwgACgCkAQhDSAAKALYAyEBIAAoAuADIQUgABDhASAFBEAgBUEMbCABaiEFIAEhAANAAkAgAEEEaigCACIORQ0AIAAoAgAiD0UNACAOQQJ0RQ0AIA8Q4QELIAUgAEEMaiIARw0ACwsCQCACRQ0AIAJBDGxFDQAgARDhAQsgBARAIARBDGwgA2ohASADIQADQAJAIABBBGooAgAiAkUNACAAKAIAIgRFDQAgAkECdEUNACAEEOEBCyABIABBDGoiAEcNAAsLAkAgB0UNACAHQQxsRQ0AIAMQ4QELAkAgCUUNACAIRQ0AIAlBBHRFDQAgCBDhAQsCQCALRQ0AIApFDQAgC0EUbEUNACAKEOEBCyANBEAgDUGoAWwgBmohAyAGIQADQAJAIABBBGooAgAiAUUNACAAKAIAIgJFDQAgAUECdEUNACACEOEBCwJAIABBEGooAgAiAUUNACAAQQxqKAIAIgJFDQAgAUECdEUNACACEOEBCwJAIABBHGooAgAiAUUNACAAQRhqKAIAIgJFDQAgAUECdEUNACACEOEBCwJAIABBKGooAgAiAUUNACAAQSRqKAIAIgJFDQAgAUECdEUNACACEOEBCwJAIABBNGooAgAiAUUNACAAQTBqKAIAIgJFDQAgAUH0A2xFDQAgAhDhAQsCQCAAQUBrKAIAIgFFDQAgAEE8aigCACICRQ0AIAFBzAFsRQ0AIAIQ4QELAkAgAEHMAGooAgAiAUUNACAAQcgAaigCACICRQ0AIAFBAnRFDQAgAhDhAQsCQCAAQdgAaigCACIBRQ0AIABB1ABqKAIAIgJFDQAgAUECdEUNACACEOEBCwJAIABB5ABqKAIAIgFFDQAgAEHgAGooAgAiAkUNACABQQJ0RQ0AIAIQ4QELAkAgAEHwAGooAgAiAUUNACAAQewAaigCACICRQ0AIAFBAnRFDQAgAhDhAQsCQCAAQfwAaigCACIBRQ0AIABB+ABqKAIAIgJFDQAgAUHgAmxFDQAgAhDhAQsCQCAAQYgBaigCACIBRQ0AIABBhAFqKAIAIgJFDQAgAUHkAWxFDQAgAhDhAQsCQCAAQZQBaigCACIBRQ0AIABBkAFqKAIAIgJFDQAgAUEYbEUNACACEOEBCwJAIABBoAFqKAIAIgFFDQAgAEGcAWooAgAiAkUNACABQRxsRQ0AIAIQ4QELIAMgAEGoAWoiAEcNAAsLAkAgDEUNACAMQagBbEUNACAGEOEBCw8LEJ0MAAsQngwAC6MJAgd/DX0jAEGQAmsiBSQAIAVBIGpBADYCACAFQcABakIANwMAIAVCADcDGCAFQgA3A7gBIAVCgoCAgDA3AxAgBUKAgICAEDcDCCAFQSRqQQBBlAEQ6AYaIAJBFGoqAgAhDiACQRBqKgIAIhCMIRMgAkEMaioCACEPIAEoAgAhCAJAAkACQCABKAIIIgoOAgACAQtBAEEAQaTHwgAQzQgACyAIQQRqKgIAIBOUIA8gCCoCAJSTIA4gCEEIaioCAJSTIQwgCEEUaiEGQQEhCQNAIAZBfGoqAgAgE5QgDyAGQXhqKgIAlJMgDiAGKgIAlJMiDSAMXiELIA0gDCALGyEMIAkgByALGyEHIAZBDGohBiAJQQFqIgkgCkcNAAsLAkAgByAKSQRAIAVByABqQQA2AgAgBUFAa0IANwMAIAVBPGogB0EMbCAIaiIGKgIIIAIqAggiFJMiDDgCACAFQThqIAYqAgQgAioCBCIVkyINOAIAIAVBNGogBioCACACKgIAIhaTIhE4AgAgBUEwaiAMOAIAIAVBLGogDTgCACAFQQA2AsQBIAVBADYCJCAFIBE4AiggBUHIAWogASAFQQhqIAIgAxCaASAFKALIASECAkAgBARAQQQhCSAAIAJBAUYEfyAAIAUqAswBOAIAIAAgBUHQAWopAwA3AgQgAEEMaiAFQdgBaigCADYCAEEDBUEECzYCEAwBCyACQQFHBEAgAEEENgIQDAELIAUqAswBIgxDAAAAAFwEQCAAQQM2AhAgACAMOAIAIAAgBUHQAWoiASkCADcCBCAAQQxqIAFBCGooAgA2AgAMAQsgDiAPIA+UIBAgEJSSIA4gDpSSQwAAAACSELMBIgyVIQ0gECAMlSEQIA8gDJUhEUEAIQcgCkEBRwRAIBEgCCoCAJQgECAIQQRqKgIAlJIgDSAIQQhqKgIAlJIhDCAIQRRqIQZBASEJA0AgESAGQXhqKgIAlCAQIAZBfGoqAgCUkiANIAYqAgCUkiISIAxeIQIgEiAMIAIbIQwgCSAHIAIbIQcgBkEMaiEGIAlBAWoiCSAKRw0ACwsgByAKTw0CIAdBDGwgCGoiAioCCCESIAIqAgAhFyACKgIEIRggBUH0AWogDow4AgAgBUHwAWogEzgCACAFQQA2AsQBIAVBADYCSCAFQgA3A0AgBUEANgIkIAUgD4w4AuwBIAUgFCANIBEgFyAWk5QgECAYIBWTlJIgDSASIBSTlJJDbxKDOpIiDJSSIg44AugBIAUgEiAOkyIOOAI8IAUgFSAQIAyUkiIPOALkASAFIBggD5MiDzgCOCAFIBYgESAMlJIiDTgC4AEgBSAXIA2TIg04AjQgBSAOOAIwIAUgDzgCLCAFIA04AiggBUH4AWogASAFQQhqIAVB4AFqIAxDbxKDOpIQmgFBBCEGAkAgBSgC+AFBAUcNACAMIAUqAvwBkyIMIANfRQ0AIAAgDDgCACAAQQxqIAVBiAJqKAIANgIAIAAgBUGAAmopAwA3AgRBAyEGCyAAIAY2AhALIAVBkAJqJAAPCyAHIApBtMfCABDNCAALIAcgCkG0x8IAEM0IAAudCQIBfxJ9IwBBkAJrIgUkACAFQSBqQQA2AgAgBUHAAWpBADYCACAFQgA3AxggBUIANwO4ASAFQoKAgIAwNwMQIAVCgICAgBA3AwggBUHMAGpBAEHsABDoBhogAkEQaioCACIKjCIVIAJBDGoqAgAiDCAMlCAKIAqUkiACQRRqKgIAIg0gDZSSQwAAAACSIhEQswEiB5UhDgJAAn0CQCANjCIWIAeVIgsgC5QgDIwiFyAHlSIIIAiUQwAAAACSkkMAAAAAkhCzASIHQwAAAABcBEAgCyALIAeVIAEqAgQiD5QiCZQgCCAIIAeVIA+UIhCUIA4gASoCACIHlCIGk5IgBl0NASAHjCEGDAMLIAFBBGoqAgAhDyABKgIAIgcgDpgMAQtDAAAAACEJIAcLIQZDAAAAACEQCyAFQcgAakEANgIAIAVBQGtCADcDACAFQTxqIAkgCyABQQhqKgIAIguUkiACKgIIIhKTIgk4AgAgBUE4aiAGIA4gC5SSIAIqAgQiE5MiBjgCACAFQTRqIBAgCCALlJIgAioCACIUkyIIOAIAIAVBMGogCTgCACAFQSxqIAY4AgAgBUEANgLEASAFQQA2AiQgBSAIOAIoIAVByAFqIAcgDyALIAVBCGogAiADEKMBIAUoAsgBIQICQCAEBEBBBCEBIAAgAkEBRgR/IAAgBSoCzAE4AgAgACAFQdABaikDADcCBCAAQQxqIAVB2AFqKAIANgIAQQMFQQQLNgIQDAELIAJBAUcEQCAAQQQ2AhAMAQsgBSoCzAEiBkMAAAAAXARAIABBAzYCECAAIAY4AgAgACAFQdABaiIBKQIANwIEIABBDGogAUEIaigCADYCAAwBCyAKIBEQswEiBpUiCCANIAaVIgkgCZQgDCAGlSIKIAqUIAggCJSSkkMAAAAAkhCzASIGlSEOAkACfQJAIAkgBpUiDCAMlCAKIAaVIg0gDZRDAAAAAJKSQwAAAACSELMBIgZDAAAAAFwEQCAMIA8gDCAGlZQiEJQgDSAPIA0gBpWUIhGUIAcgDpQiBpOSIAZdDQEgB4whBgwDC0MAAAAAIRAgByAOmAwBC0MAAAAAIRAgBwshBkMAAAAAIRELIAVB9AFqIBY4AgAgBUHwAWogFTgCACAFIBc4AuwBIAVBADYCxAEgBUEANgJIIAVCADcDQCAFQQA2AiQgBSASIAkgCSALIAyUIBCSIgkgEpOUIAggCyAOlCAGkiIMIBOTlCAKIAsgDZQgEZIiDSAUk5SSkkNvEoM6kiIGlJIiDjgC6AEgBSAJIA6TIgk4AjwgBSATIAggBpSSIgg4AuQBIAUgDCAIkyIIOAI4IAUgFCAKIAaUkiIKOALgASAFIA0gCpMiCjgCNCAFIAk4AjAgBSAIOAIsIAUgCjgCKCAFQfgBaiAHIA8gCyAFQQhqIAVB4AFqIAZDbxKDOpIQowFBBCECAkAgBSgC+AFBAUcNACAGIAUqAvwBkyIHIANfRQ0AIAAgBzgCACAAQQxqIAVBiAJqKAIANgIAIAAgBUGAAmopAwA3AgRBAyECCyAAIAI2AhALIAVBkAJqJAALpAgDAX8DfhF9IwBBIGshBiABQTRqKgIAIRggAUEwaioCACEZIAFBLGoqAgAhGiABQShqKgIAIRAgAUEkaioCACEMIAFBIGoqAgAhDSABKgIcIQ4CfSAFRQRAIA4gBEEUaioCACIRlCANIAQqAhAiEpSTIgogCpIhCiAMIBKUIA4gBEEYaioCACIPlJMiCyALkiELIA8gECAKlCAOIAuUIA0gDSAPlCAMIBGUkyIPIA+SIg+Uk5KSIRMgESAQIAuUIAwgD5QgDiAKlJOSkiEUIBIgECAPlCANIAqUIAwgC5STkpIhDyAMIAQqAgwiCpQgDiAEKgIEIguUIBAgBCoCCCIRlJIgDSAEKgIAIhKUk5IhFSAMIBKUIA0gCpQgECALlCAOIBGUk5KSIRYgDSARlCAQIBKUIA4gCpSSkiAMIAuUkyEXIARBHGohBCAQIAqUIA4gEpSTIA0gC5STIAwgEZSTDAELIA4gBEEwaioCACIRlCANIARBLGoqAgAiEpSTIgogCpIhCiAMIBKUIA4gBEE0aioCACIPlJMiCyALkiELIA8gECAKlCAOIAuUIA0gDSAPlCAMIBGUkyIPIA+SIg+Uk5KSIRMgESAQIAuUIAwgD5QgDiAKlJOSkiEUIBIgECAPlCANIAqUIAwgC5STkpIhDyAMIARBKGoqAgAiCpQgDiAEQSBqKgIAIguUIBAgBEEkaioCACIRlJIgDSAEKgIcIhKUk5IhFSAMIBKUIA0gCpQgECALlCAOIBGUk5KSIRYgDSARlCAQIBKUIA4gCpSSkiAMIAuUkyEXIBAgCpQgDiASlJMgDSALlJMgDCARlJMLIREgACAEKQIAIgc3AiAgBkEYaiAEQRhqKAIAIgE2AgAgBkEQaiAEQRBqKQIAIgg3AwAgBkEIaiAEQQhqKQIAIgk3AwAgAEEoaiAJNwIAIABBMGogCDcCACAAQThqIAE2AgAgBiAHNwMAIAIqAjwhECACKgJAIQwgAioCSCEKIAIqAlAhCyACKgJEIQ0gAioCTCEOIAMoAgghASACKgI4IRIgAEEANgJkIAAgEjgCSCAAQRxqIBggE5I4AgAgAEEYaiAZIBSSOAIAIABBFGogGiAPkjgCACAAQRBqIBE4AgAgAEEMaiAVOAIAIABBCGogFjgCACAAIBc4AgQgACABNgIAIABBxABqIAJBCGooAgA2AgAgACACKQIANwI8IABB4ABqIA0gDZQiESAOIA6UIhKSIAsgC5SSOAIAIABB3ABqIAwgDZQgCiAOlJIgDiALlJI4AgAgAEHYAGogDCAMlCIPIAogCpSSIBKSOAIAIABB1ABqIBAgDZQgDCAOlJIgDSALlJI4AgAgAEHQAGogECAMlCAMIAqUkiANIA6UkjgCACAAIBAgEJQgD5IgEZI4AkwL3wgCGH8BfiMAQfAAayIDJAAgAyACNgIgIANBITYCJCADQShqIgQgACABEIMJIARBCGooAgAiC0EgaiEVIAMpAygiG0IgiKchDCADQegAaigCACENIANB5ABqLQAAIRkgA0HgAGooAgAhFiADQdwAaigCACEHIANB2ABqKAIAIRIgA0HUAGooAgAhEyAEQSRqKAIAIQogBEEgai0AACEOIANBxABqKAIAIQ8gA0FAaygCACEFIARBFGooAgAhAiAEQRBqKAIAIRAgAygCUCEaIAMoAjQhFCAbpyERA0BBAEEBIA5BAkcbIQADQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABFBEAgBSACTw0BIAVBFGwgEGooAgAhBAwCCwJAIBEOAwQABQALIAsoAjQhAiALKAIsIRAgCygCKCAMSyIADQJBACEOQX8hBSAMIRRBfyEPIBUhCkEAIRELA0AgDyIAIAJPBEBBASEADA4LIABBFGwgEGpBACAAIAJJGyIEKAIEIQ8gBCgCCCAURg0ACyAFIQQgACEFCyAKQRRqKAIAIAVLIgBFDQUgCigCCCIGIAVBFGwiBSAKKAIMakEAIAAbIgBBCGooAgAiCU0NBiAGIABBDGooAgAiCEsNAyAIIAZBmKjAABDNCAALIAsoAiAgDEEEdGpBACAAGyIAKAIMIQ8gACgCCCEFQQAhESAVIQpBACEOIAwhFAwJC0EAIRELAkAgGUECRg0AAkAgByASSQRAIAdBFGwgE2ooAgAhBAwBCwNAIBYiACASTw0CIABBFGwgE2pBACAAIBJJGyIEKAIEIRYgBCgCCCAaRg0ACyAHIQQgACEHCyANKAIUIAdLIgBFDQUgDSgCCCIGIAdBFGwiByANKAIMakEAIAAbIgBBCGooAgAiCU0NBiAGIABBDGooAgAiCE0NByAHIBNqQRBqIQAgDSgCACIHIAhBBHRqIhdBBGohCCAJQQR0IAdqIgZBBGohGEECIQ4gBCEHDAILIAMoAiQiAEEkTwRAIAAQAAsgAygCICIAQSRPBEAgABAACyADQfAAaiQADwsgBSAQakEQaiEAIAooAgAiBSAIQQR0aiIXQQRqIQggCUEEdCAFaiIGQQRqIRggBCEFCyAALQAARQ0HIAgoAgAhCSAXKAIAIQggBigCACEGIANBGGoiACAYKAIAIgQ2AgQgACAGNgIAIAMCfyADKAIYIAFHBEAgA0EQaiIAIAQ2AgQgACAGNgIAIAMoAhAMAQsgA0EIaiIAIAk2AgQgACAINgIAIAMoAggLuBABNgIoIAMgA0EgaiADQSRqIANBKGoQwAkgAygCBCIAQSRPBEAgABAACyADKAIoIgBBJEkNByAAEAAMBwtBhJrAAEErQfinwAAQ2wkACyAJIAZBiKjAABDNCAALQYSawABBK0H4p8AAENsJAAsgCSAGQYiowAAQzQgACyAIIAZBmKjAABDNCAALQQAhAAwACwALAAuoCQIGfwZ9IwBBIGsiBSQAIAUgATYCBAJAAkACQAJAAkAgAigCCCIGIAFNDQACQCACKAIAIgggAUEsbGpBACAGIAFLGyIEKAIAQQFGBEAgBCgCBCIHDQFBpL/AAEErQbiiwQAQ2wkAC0GUocEAQRNBqKLBABD7CgALIAcoAogBIgdBf0cEQCAEQRRqKgIAIARBIGoqAgCSQwAAAD+UIAAqAgAiC5WOIgpDAAAAz2AhAkH/////BwJ/IAqLQwAAAE9dBEAgCqgMAQtBgICAgHgLQYCAgIB4IAIbIApD////Tl4bIQMgCiAKXCECIARBEGoqAgAgBEEcaioCAJJDAAAAP5QgC5WOIgpDAAAAz2AhCUEAIAMgAhshA0EAQf////8HAn8gCotDAAAAT10EQCAKqAwBC0GAgICAeAtBgICAgHggCRsgCkP///9OXhsgCiAKXBshAiAEKgIMIAQqAhiSQwAAAD+UIAuVjiIKQwAAAM9gIQQCQAJAIABBBGpBAEH/////BwJ/IAqLQwAAAE9dBEAgCqgMAQtBgICAgHgLQYCAgIB4IAQbIApD////Tl4bIAogClwbIAIgAxCVAyIABEAgBiAAKAIAIgBNDQECQCAAQSxsIAhqIgAoAgBBAUYEQCAAKAIEIgANAQwJCwwJCyAHIABBhAFqKAIAIgJPDQIgACgCfCAHQQJ0aiIAKAIAIAFGDQQgBUEANgIIQQAgACAFQQRqIAVBCGpBxJ/BABDdCAALQaS/wABBK0GUn8EAENsJAAsgACAGQaSfwQAQzQgACyAHIAJBtJ/BABDNCAALIAQqAgwgBCoCGJJDAAAAP5QgACoCACILlY4iCkMAAADPYCEHIARBHGoqAgAhDCAEQRBqKgIAIARBIGoqAgAhDiAEQRRqKgIAIAVBAEH/////BwJ/IAqLQwAAAE9dBEAgCqgMAQtBgICAgHgLQYCAgIB4IAcbIApD////Tl4bIAogClwbNgIIIA6SQwAAAD+UIAuVjiIKQwAAAM9gIQYgBUEAQf////8HAn8gCotDAAAAT10EQCAKqAwBC0GAgICAeAtBgICAgHggBhsgCkP///9OXhsgCiAKXBs2AhAgDJJDAAAAP5QgC5WOIgpDAAAAz2AhBiAFQQBB/////wcCfyAKi0MAAABPXQRAIAqoDAELQYCAgIB4C0GAgICAeCAGGyAKQ////05eGyAKIApcGzYCDCAAIAVBCGogAiADEHohACACKAIIIgMgAE0NAQJAIAIoAgAiByAAQSxsaiIAKAIAQQFGBEAgACgCBCIADQEMBQsMBQsgAEGEAWoiBCgCACIGIgIgAEGAAWooAgBGBEAgAEH8AGogBkEBEJQGIAQoAgAhAgsgBCACQQFqNgIAIAAoAnwgAkECdGogATYCACAAIAFBARDAAiADIAUoAgQiAE0NAgJAIABBLGwgB2oiACgCAEEBRgRAIAAoAgQiAA0BDAULDAULIAAgBjYCiAELIAVBIGokAA8LIAAgA0H0nsEAEM0IAAsgACADQYSfwQAQzQgAC0Gkv8AAQStB2KLBABDbCQALQZShwQBBE0HIosEAEPsKAAvPCAIRfwF+IwBBQGoiBCQAIARBCGoiA0EQaiABQRBqKQIANwMAIANBCGogAUEIaikCADcDACAEIAEpAgA3AwgCQAJAAkAgAUEgaigCACILIAtB////D3EiA0cNACALQQd0Ig1BAEgNACADIAtGQQR0IQIgASgCGCEFAkAgDUUEQCACIgMNAQwDCyANIAIQxQsiA0UNAgsgAyAFIAtBB3QQ5AYhEAJAAkBBfyABQTBqKAIAQX9qIg8gAUEoaigCACIOIAFBJGooAgAiCGtxIgJndkEBakECIAJBAWpBAksbIgMgAksEQCADQf////8DcSIFIANHDQMgA0ECdCICQQBIDQMgAyAFRkECdCEDIAINASADIgUNAgwFC0GsssEAQRFBzLjBABDbCQALIAIgAxDFCyIFRQ0DCyACQQJ2IQwgCCAORwRAIAFBLGooAgAhESAMIQMDQCAIIgJBAWogD3EhCCACQQJ0IBFqKAIAIRICQCADQX9qIgIgBiAJayACcUcNAAJAIAYgCWsgAnFBAWoiB0F/IA4gCGsgD3EiAkEBaiIKIAogAkkbaiICIAdJDQBBAEF/IAJBf2pndiACQQJJGyICQQFqIgogAkkNACAKIANNDQECQAJAAn8gAyICIAIgB2sgCiAHayIKTw0AGiAHIApqIgIgB0kNByACQQJ0IQwgAkH/////A3EgAkZBAnQhAgJAIAMEQCAEQQQ2AjggBCAFNgIwIAQgA0ECdDYCNAwBCyAEQQA2AjALIARBIGogDCACIARBMGoQnAcgBCgCIEEBRg0BIAQoAiQhBSAEKAIoQQJ2IgwLIQIgBiAJSQ0BIAIhAwwDCyAEKAIoIgBFDQUgBCgCJCAAQaCdwwAoAgAiAEGvBiAAGxEAAAALIAYgAyAJayIHTwRAIAlBAnQhAyACIAdrIglBAnQgBWogAyAFaiAHQQJ0EOQGGiACIQMMAgsgA0ECdCAFaiAFIAZBAnQQ5AYaIAMgBmohBiACIQMMAQtBrLLBAEERQdy4wQAQogkACyAGQQJ0IAVqIBI2AgAgBkEBaiADQX9qcSEGIAggDkcNAAsLIAFBPGooAgAiCK1CDH4iE0IgiKciAw0AIBOnIgJBAEgNACADRUECdCEDIAEoAjQhBwJAIAJFBEAgAyIBDQEMBAsgAiADEMULIgFFDQMLIAEgByACEOQGIQEgAEE8aiAINgIAIABBOGogAkEMbjYCACAAIAE2AjQgAEEwaiAMNgIAIABBLGogBTYCACAAQShqIAY2AgAgACAJNgIkIABBIGogCzYCACAAQRxqIA1BB3Y2AgAgACAQNgIYIABBEGogBEEIaiIBQRBqKQMANwIAIABBCGogAUEIaikDADcCACAAIAQpAwg3AgAgBEFAayQADwsQkQwACyANIAJBoJ3DACgCACIAQa8GIAAbEQAAAAsgAiADQaCdwwAoAgAiAEGvBiAAGxEAAAAL0AkBBH8jAEHgBGsiGCQAIBhBOGoiGUEYaiIaIANBCGooAgA2AgAgGUEIaiIbIARBCGopAgA3AwAgGCADKQIANwNIIBggBCkCADcDOCACKAIAIhkoAgAhAyAZIANBAWo2AgACQAJAIANBf0oEQCAYQcgDaiIEIBkgAigCBBDlByAYQfABaiIZQRhqIBooAgA2AgAgGUEQaiIaIBhByABqKQMANwMAIBlBCGogGykDADcDACAYIBgpAzg3A/ABIBhBsAJqIgIgBCAZEMwJIAIgCzgCUCAEIAJBmAEQ5AYaIAQgDDgCVCACIARBmAEQ5AYaIBhBMGoiGSAQQf//A3E2AgQgGSAQQRB2NgIAIBgoAjQhECACIBgoAjA2AnwgAkGAAWogEDYCACAEIAJBmAEQ5AYaIBhBKGoiECARQf//A3E2AgQgECARQRB2NgIAIBgoAiwhECAEIBgoAig2AoQBIARBiAFqIBA2AgAgAiAEQZgBEOQGGiACQQAgEyATQQdLGzYCdCAEIAJBmAEQ5AYaIARBACAUIBRBA0sbNgJ4IAIgBEGYARDkBhogAkEAIBIgEkHQI3EbOwGMASAEIAJBmAEQ5AYaIAQgDzoAkAEgAiAEQZgBEOQGGiACIA1BAyANQQNJGzoAjgEgBCACQZgBEOQGGiAEIA5BAyAOQQNJGzoAjwEgGEHYAGogBEGYARDkBhoCQCAFRQRAIBhByANqIgIgGEHYAGoiBEGYARDkBhogAkEBNgIYIAJBHGogCjgCACAEIAJBmAEQ5AYaDAELIBhBoAJqIg1BCGogB0EIaigCADYCACAYIAcpAgA3A6ACIBhBsAJqIgJBCGoiAyAIQQhqKAIANgIAIBggCCkCADcDsAIgGEHIA2oiBUEIaiAJQQhqKQIANwMAIBggCSkCADcDyAMgGEHwAWoiBCANIAYgAiAFEIcHIAUgGEHYAGoiB0GYARDkBhogAkEoaiAEQShqKAIANgIAIAJBIGogBEEgaikDADcDACACQRhqIARBGGopAwA3AwAgAkEQaiAaKQMANwMAIAMgBEEIaikDADcDACAYIBgpA/ABNwOwAiAHIAUgAhCnCAsgGEGwAmogGEHYAGoQqAQgFUUEQCAYQcgDaiICIBhBsAJqQZgBEOQGGiAYQSBqIAEgAhD4BCAYKAIgIQEgGEEYaiICIBgoAiQ2AgQgAiABNgIAIBgoAhghAwwCCyAYQcgDaiAXIBYQmAkgGCgCyAMEQCAYQdADaigCACECIBgoAswDIQMgGEHIA2oiBCAYQbACakGYARDkBhogGEEQaiABIAQgAyACIBcQuwIgGCgCECEBIBhBCGoiAiAYKAIUNgIEIAIgATYCACAYKAIIIQMMAgsgGCgCwAIiAigCACEBIAIgAUF/ajYCACABQQFGBEAgGCgCwAIgGEHEAmooAgAQhggLIBgoAsgCBEAgGEHMAmooAgAQ4QELIBgoAmgiAigCACEBIAIgAUF/ajYCACABQQFGBEAgGCgCaCAYQewAaigCABCGCAtBACEEDAILAAsgGCgCaCICKAIAIQEgAiABQX9qNgIAQQEhBCABQQFHDQAgGCgCaCAYQewAaigCABCGCAsgACADNgIEIAAgBDYCACAYQeAEaiQAC4cJAgd/AX4jAEEwayIDJAAgASgCBCEFIAFBAjYCBAJAAkACQAJAAkACQAJAIAVBAkcEQCABQSBqKAIAIQQgAUEcaigCACEGIAFBGGooAgAhCCABKAIAKAIAIQcgA0EMaiABQRBqKQIANwIAIAMgBTYCACADIAEpAgg3AgQgA0EBOwEUIAIoAgAiBSgCACEBIAUgAUEBajYCACABQX9MDQEgA0EEciEJIAgoAggiASAIQQRqKAIARgRAIAggARCABiAIKAIIIQELIAggAUEBajYCCCAIKAIAIAFBDGxqIgEgBTYCCCABIAc2AgAgASADNgIEIAhBGGoQnQQgCEEAOgA0IANBGGoiAUEQaiAGQRBqKQMANwMAIAFBCGogBkEIaikDADcDACADIAYpAwA3AxgCQAJAAkACQAJAIAIgARDHBEEBaw4DAQIDAAtB7LfAAEEoQby8wAAQ2wkACyAEKAIAIgQtADQgBEEBOgA0BEBBACEBA0AgASABQQFqIAFBB09BACABQQpLGxshASAELQA0IARBAToANA0ACwsgBCgCAEF0aiECIARBCGooAgAiBkEMbCEFIAZB/////wNxIQhBACEBA0AgASAIRg0HIAVBdGohBSABQQFqIQEgAkEMaiICKAIAIAdHDQALIAYgAUF/aiIBTQ0FIAJBCGooAgAhByACKQIAIQogAiACQQxqIAUQvwQaIARBCGogBkF/ajYCACAHRQ0GIAcgBygCACIBQX9qNgIAIAMgBzYCICADIAo3AxggAUEBRgRAIANBIGoQnQkLIARBADoANCADKAIAIQEgA0ECNgIAIAFBAkYNByAAIAE2AgQgAEEANgIAIABBCGogCSkCADcCACAAQRBqIAlBCGopAgA3AgAMAgsgBCgCACIELQA0IARBAToANARAQQAhAQNAIAEgAUEBaiABQQdPQQAgAUEKSxsbIQEgBC0ANCAEQQE6ADQNAAsLIAQoAgBBdGohAiAEQQhqKAIAIgZBDGwhBSAGQf////8DcSEIQQAhAQNAIAEgCEYNCSAFQXRqIQUgAUEBaiEBIAJBDGoiAigCACAHRw0ACyAGIAFBf2oiAU0NByACQQhqKAIAIQcgAikCACEKIAIgAkEMaiAFEL8EGiAEQQhqIAZBf2o2AgAgB0UNCCAHIAcoAgAiAUF/ajYCACADIAc2AiAgAyAKNwMYIAFBAUYEQCADQSBqEJ0JCyAEQQA6ADQgAygCACEBIANBAjYCACABQQJGDQkgACABNgIEIABBATYCACAAQQhqIAkpAgA3AgAgAEEQaiAJQQhqKQIANwIADAELIAMtABVFBEBBACEBA0AgASABQQFqIAFBB09BACABQQpLGxshASADLQAVRQ0ACwsgAEECNgIACyADQTBqJAAPC0Gkv8AAQStB9LnAABDbCQALAAsgASAGEMwIAAtBpL/AAEErQZy8wAAQ2wkAC0Gkv8AAQStBrLzAABDbCQALIAEgBhDMCAALQaS/wABBK0H8u8AAENsJAAtBpL/AAEErQYy8wAAQ2wkAC6sJAgF/CX0jAEGQAWsiCyQAIAEgASgCAEEJcjYCACAHIAQqAgwiEiAIQRRqKgIAIg6UIAQqAgAiDSAIKgIIIhOUkyAEKgIEIgwgCEEMaioCACIUlJMgBCoCCCIQIAhBEGoqAgAiD5STOAIMIAcgECAOlCANIBSUIBIgD5SSIAwgE5STkjgCCCAHIBAgE5QgDCAOlCASIBSUIA0gD5STkpI4AgQgByAMIA+UIBIgE5QgDSAOlJKSIBAgFJSTOAIAIA0gCEEcaioCACITlCAMIAhBGGoqAgAiFJSTIQ8gECAUlCANIAhBIGoqAgAiEZSTIg4gDpIhDiAHQRhqIARBGGoqAgAgESASIA8gD5IiD5QgDSAOlCAMIAwgEZQgECATlJMiESARkiIRlJOSkpI4AgAgB0EUaiAEQRRqKgIAIBMgEiAOlCAQIBGUIA0gD5STkpKSOAIAIAcgBCoCECAUIBIgEZQgDCAPlCAQIA6Uk5KSkjgCECACKgIAIQ0gC0EYaiIBIAlBBGooAgAiBzYCBCABIAkoAgAgBygCCEEHakF4cWo2AgAgAiANIA0gCygCGCALKAIcKAKUAREKACIMIA0gDF0bIAwgDFwbOAIAIAtBEGoiASAJQQRqKAIAIgc2AgQgASAJKAIAIAcoAghBB2pBeHFqNgIAIAtBIGogCygCECAIQQhqIgcgCygCFCgChAERAQAgAioCBCENIAIgCyoCICIMIAyUIAsqAiQiDCAMlJIgCyoCKCIMIAyUkkMAAAAAkhCzASALKgIskiIMIAwgDSANIAxdGyANIA1cGzgCBCALQQhqIgEgCUEEaigCACICNgIEIAEgCSgCACACKAIIQQdqQXhxajYCAAJAIAooAgBBAUcEQCALQeAAaiALKAIIIAoqAgQgCygCDCgCiAEREgAMAQsgC0HgAGoiAkEIaiAKKAIEIgFBCGopAgA3AwAgAkEQaiABQRBqKQIANwMAIAJBGGogAUEYaikCADcDACACQSBqIAFBIGopAgA3AwAgAkEoaiABQShqKAIANgIAIAsgASkCADcDYAsgC0EwaiALQeAAaiAHEOcDIAAoAggiCCAAQQRqKAIARgRAIAAgCEEBEI8GIAAoAgghCAsgACAIQQFqNgIIIAAoAgAgCEEDdGoiACAGNgIEIAAgBTYCACALQeAAaiIAQShqIAtBMGoiAUEoaigCADYCACAAQSBqIAFBIGopAwA3AwAgAEEYaiABQRhqKQMANwMAIABBEGoiBSABQRBqKQMANwMAIABBCGoiAiABQQhqKQMANwMAIAsgCykDMDcDYCADIAAQnwYgACADIAQQqAYgA0E0aiACKAIANgIAIAMgCykDYDcCLCADIAMqAgw4AjggACADIAQQ0wIgA0HMAGogBSkDADcCACADQcQAaiACKQMANwIAIAMgCykDYDcCPCADLQBUIgBBAXEEQCADQQA2AjgLIABBAnEEQCADQgA3AjwgA0HEAGpBADYCAAsgAEEEcQRAIANBQGtBADYCACADQcgAakIANwIACyAAQQhxBEAgA0HEAGpBADYCACADQcwAakIANwIACyALQZABaiQAC9sIAgN/FH0jAEGQAmsiBSQAIAVBIGpBADYCACAFQcABakEANgIAIAVCADcDGCAFQgA3A7gBIAVCgoCAgDA3AxAgBUKAgICAEDcDCCAFQcwAakEAQewAEOgGGiACQRRqKgIAIgyMIRYgAkEQaioCACINjCEXIAJBDGoqAgAiDowhGEMAAIA/IQkgDiAOlCANIA2UkiAMIAyUkkMAAAAAkiIPQwAAAABeBEAgFiAPELMBIgiVIQogFyAIlSEJIBggCJUhCAsgBUHIAGpBADYCACAFQUBrQgA3AwBBBCEHIAggASoCACIQlCAJIAFBBGoqAgAiEZSSIAogAUEIaioCACISlJIgCCABQQxqKgIAIhOUIAkgAUEQaioCACIUlJIgCiABQRRqKgIAIhWUkl4hBiAFQTxqIAogASoCGCILlCASIBUgBhuSIAIqAggiGZMiCjgCACAFQThqIAkgC5QgESAUIAYbkiACKgIEIhqTIgk4AgAgBUE0aiAIIAuUIBAgEyAGG5IgAioCACIbkyIIOAIAIAVBMGogCjgCACAFQSxqIAk4AgAgBUEANgLEASAFQQA2AiQgBSAIOAIoIAVByAFqIAEgBUEIaiACIAMQpQEgBSgCyAEhAgJAIAQEQCAAIAJBAUYEfyAAIAUqAswBOAIAIAAgBUHQAWopAwA3AgQgAEEMaiAFQdgBaigCADYCAEEDBUEECzYCEAwBCyACQQFHBEAgAEEENgIQDAELQwAAAAAhCCAF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BEEEaiAJOgAAIARBQGshBCAFQQRqIgUNAAsLIA0EQANAIAQgCjYCACAEQQhqQn83AgAgBEEEaiAJOgAAIARBEGohBCANQX9qIg0NAAsLIAcgDGpBf2ohBwsgDEUNACAEQn83AgggBCAJOgAEIAQgCjYCACAHQQFqIQcLIAhBPGogBzYCAAJAIAYgACgCBCIFQQhqIgkoAgAiB00NACAGIAdrIQggBUEEaigCACAHIgZrIAhJBEAgBSAHIAgQggYgBUEIaigCACEGCyAFKAIAIAZBGGxqIQQgCEECTwRAIAEgB2siCkEDcSEFIAdBf3MgAWpBA08EQEEAIApBfHFrIQcDQCAEQv////v3//+//wA3AgAgBEHYAGpC////+////79/NwIAIARB0ABqQv////v3//+/fzcCACAEQcgAakL////79///v/8ANwIAIARBQGtC////+////79/NwIAIARBOGpC////+/f//79/NwIAIARBMGpC////+/f//7//ADcCACAEQShqQv////v///+/fzcCACAEQSBqQv////v3//+/fzcCACAEQRhqQv////v3//+//wA3AgAgBEEQakL////7////v383AgAgBEEIakL////79///v383AgAgBEHgAGohBCAHQQRqIgcNAAsLIAUEQANAIARC////+/f//7//ADcCACAEQRBqQv////v///+/fzcCACAEQQhqQv////v3//+/fzcCACAEQRhqIQQgBUF/aiIFDQALCyAGIAhqQX9qIQYLIAhFDQAgBEL////79///v383AgggBEL////79///v/8ANwIAIARBEGpC////+////79/NwIAIAZBAWohBgsgCSAGNgIAIAAoAgAoAgAiCEE8aigCACEECyAEIAFLBEAgCCgCNCABQQR0aiIGIAE2AgggBkEMaiACNgIAIAAoAgQiAigCCCIGIAFNDQEgAigCACABQRhsaiICIAMpAgA3AgAgAkEQaiADQRBqKQIANwIAIAJBCGogA0EIaikCADcCACAAKAIIIgAoAggiBSAAQQRqKAIARgRAIAAgBUEBEJQGIAAoAgghBQsgACAFQQFqNgIIIAAoAgAgBUECdGogATYCACALQRBqJAAPCyABIARBkMfAABDNCAALIAEgBkGgx8AAEM0IAAuLCQIFfwJ9IwBBEGshAwJAAkAC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ADcCfCAAIAUpAgw3AogBIAAgBSkCGDcClAEgAEEQaiABQQhqKAIANgIAIABBHGogA0EIaigCADYCACAAQYQBaiAFQQhqKAIANgIAIABBkAFqIAVBFGooAgA2AgAgAEGcAWogBUEgaigCADYCACAAQagBaiAFQSxqKAIANgIAIAAgBSkCJDcCoAEgACAFKQIwNwKsASAAQbQBaiAFQThqKQIANwIAIABBvAFqIAVBQGspAgA3AgAgACAFKQJINwLEASAAQcwBaiAFQdAAaikCADcCACAAQdQBaiAFQdgAaikCADcCACACKAIIIQEgBCgCCCECIABB7ABqIBY4AgAgAEHoAGogFzgCACAAQeQAaiAYOAIAIABB4ABqIBk4AgAgAEHcAGogGjgCACAAIBs4AlggAEHUAGogCzgCACAAQdAAaiAjOAIAIABBzABqIBM4AgAgAEHIAGogHzgCACAAQcQAaiAhOAIAIAAgCjgCQCAAQTxqIA44AgAgAEE4aiAiOAIAIABBNGogJDgCACAAQTBqIB44AgAgAEEsaiAgOAIAIAAgDTgCKCAAIBw4AiQgACAdOAIgIAAgAjYCBCAAIAE2AgAgACAFLQC0AToA3AEgBSkCdCEGIAAgBSoCmAE4AnggACAGNwJwC4MJAQF/IwBBMGsiAiQAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAC0AAEEBaw4RAQIDBAUGBwgJCgsMDQ4PEBEACyACIAAtAAE6AAggAkEsakEBNgIAIAJCAjcCHCACQcDPwgA2AhggAkGqBjYCFCACIAJBEGo2AiggAiACQQhqNgIQIAEgAkEYahDSCAwRCyACIABBCGopAwA3AwggAkEsakEBNgIAIAJCAjcCHCACQaTPwgA2AhggAkEjNgIUIAIgAkEQajYCKCACIAJBCGo2AhAgASACQRhqENIIDBALIAIgAEEIaikDADcDCCACQSxqQQE2AgAgAkICNwIcIAJBpM/CADYCGCACQasGNgIUIAIgAkEQajYCKCACIAJBCGo2AhAgASACQRhqENIIDA8LIAIgAEEIaisDADkDCCACQSxqQQE2AgAgAkICNwIcIAJBiM/CADYCGCACQawGNgIUIAIgAkEQajYCKCACIAJBCGo2AhAgASACQRhqENIIDA4LIAIgAEEEaigCADYCCCACQSxqQQE2AgAgAkICNwIcIAJB6M7CADYCGCACQa0GNgIUIAIgAkEQajYCKCACIAJBCGo2AhAgASACQRhqENIIDA0LIAIgAEEEaikCADcDCCACQSxqQQE2AgAgAkIBNwIcIAJB1M7CADYCGCACQa4GNgIUIAIgAkEQajYCKCACIAJBCGo2AhAgASACQRhqENIIDAwLIAJBLGpBADYCACACQfjMwgA2AiggAkIBNwIcIAJBxM7CADYCGCABIAJBGGoQ0ggMCwsgAkEsakEANgIAIAJB+MzCADYCKCACQgE3AhwgAkG8zsIANgIYIAEgAkEYahDSCAwKCyACQSxqQQA2AgAgAkH4zMIANgIoIAJCATcCHCACQajOwgA2AhggASACQRhqENIIDAkLIAJBLGpBADYCACACQfjMwgA2AiggAkIBNwIcIAJBlM7CADYCGCABIAJBGGoQ0ggMCAsgAkEsakEANgIAIAJB+MzCADYCKCACQgE3AhwgAkH8zcIANgIYIAEgAkEYahDSCAwHCyACQSxqQQA2AgAgAkH4zMIANgIoIAJCATcCHCACQezNwgA2AhggASACQRhqENIIDAYLIAJBLGpBADYCACACQfjMwgA2AiggAkIBNwIcIAJB4M3CADYCGCABIAJBGGoQ0ggMBQsgAkEsakEANgIAIAJB+MzCADYCKCACQgE3AhwgAkHUzcIANgIYIAEgAkEYahDSCAwECyACQSxqQQA2AgAgAkH4zMIANgIoIAJCATcCHCACQcDNwgA2AhggASACQRhqENIIDAMLIAJBLGpBADYCACACQfjMwgA2AiggAkIBNwIcIAJBqM3CADYCGCABIAJBGGoQ0ggMAgsgAkEsakEANgIAIAJB+MzCADYCKCACQgE3AhwgAkGQzcIANgIYIAEgAkEYahDSCAwBCyABKAIYIABBBGooAgAgAEEIaigCACABQRxqKAIAKAIMEQUACyACQTBqJAALyQcBA38jAEGAD2siAiQAIAIgATYCFCACQRhqIAJBFGoQtwcgAigCGCEDIAJBCGoiASACKAIgNgIEIAEgAzYCACACIAIpAwg3A6ALIAJBqAtqIAJBoAtqEB0gAigCrAshAQJAAkACQCACKAKoC0EBRgRAIAIgATYCzAcgAkEBNgLIByACQcgHakEEchChBwwBCyACQcgHaiIEQQhqIAJBsAtqQdADEOQGGiACIAE2AswHIAJBADYCyAcgAkGABWogBEEEckHIAhDkBhogAkGUCmooAgAhASACQfgDaiAEQdACakGIARDkBhogAUECRg0AIAJBsAFqIgMgAkGABWpByAIQ5AYaIAJBKGoiBCACQfgDakGIARDkBhogAEEMaiADQQhqKAIANgIAIAAgAikCsAE3AgQgAEHUAmogAikCKDcCACAAQdwCaiAEQQhqKQIANwIAIABB5AJqIARBEGooAgA2AgAgAEEQakEBNgIAIABBATYCACAAQRRqIANBDGpBxAAQ5AYaIABBkAFqIANBiAFqKQIANwIAIABBiAFqIANBgAFqKQIANwIAIABBgAFqIANB+ABqKQIANwIAIABB+ABqIANB8ABqKQIANwIAIABB8ABqIANB6ABqKQIANwIAIABB6ABqIANB4ABqKQIANwIAIABB4ABqIANB2ABqKQIANwIAIABB2ABqIAIpAoACNwIAIABBmAFqIANBkAFqQeQAEOQGGiAAQfwBaiACQaQDakHEABDkBhogAEHQAmogATYCACAAQcgCaiADQcACaikCADcCACAAQcACaiACKQLoAzcCACAAQegCaiACKQI8NwIAIABB8AJqIAJBxABqKQIANwIAIABB+AJqIAJBzABqKQIANwIAIABBgANqIAJB1ABqKQIANwIAIABBiANqIAJB3ABqKQIANwIAIABBkANqIAJB5ABqKQIANwIAIABBmANqIARBxABqKAIANgIAIABB1ANqIARBgAFqKQIANwIAIABBzANqIARB+ABqKQIANwIAIABBxANqIARB8ABqKQIANwIAIABBvANqIARB6ABqKQIANwIAIABBtANqIARB4ABqKQIANwIAIABBrANqIARB2ABqKQIANwIAIABBpANqIAJB+ABqKQIANwIAIABBnANqIAIpAnA3AgACQCACKAIcRQ0AIAIoAhgiAEUNACAAEOEBCyACKAIUIgBBI00NAgwBCyAAQQI2AgACQCACKAIcRQ0AIANFDQAgAxDhAQsgAigCFCIAQSRJDQELIAAQAAsgAkGAD2okAAuXBwICfwd9AkACQAJAAkAgAkUEQCABKAK8ASICQQFqIgMgAkkNBCABKgKwASIFIAFBQGsqAgCUQwAAAACSIQsgBSABQTxqKgIAlEMAAAAAkiEK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ACADQQhqIAFBNGopAgA3AwAgAiABKQIsNwMwIAJB0ABqIgNBGGogAUHkAGopAgA3AwAgA0EQaiABQdwAaikCADcDACADQQhqIAFB1ABqKQIANwMAIAIgASkCTDcDUAJAAkAgAUGoAWooAgAiCa1COH4iE0IgiKciAw0AIBOnIgRBAEgNACADRUECdCEDIAFBoAFqKAIAIQYgAUGQAWooAgAhCiABQYwBaigCACELIAFBiAFqKAIAIQwgAUGEAWoqAgAhFCABQYABaigCACENIAFB/ABqKAIAIQ4gAUH4AGooAgAhDyABQfQAaigCACEQIAFB8ABqKAIAIREgAUHsAGooAgAhEgJAIARFBEAgAyIFDQEMAwsgBCADEMULIgVFDQILIAUgBiAEEOQGIQMgAEGUAWogAUGUAWopAgA3AgAgAEGcAWogAUGcAWooAgA2AgAgACACKQMANwIAIABBCGogAkEIaigCADYCACAAIAIpAxA3AgwgAEEUaiACQRhqKAIANgIAIAAgAikDIDcCGCAAQSBqIAJBKGooAgA2AgAgAUGsAWooAgAhBSABQbABai8BACEGIAAgCDYCKCAAIAc2AiQgACACKQMwNwIsIABBNGogAkEwaiIBQQhqKQMANwIAIABBPGogAUEQaikDADcCACAAQcQAaiABQRhqKQMANwIAIAAgAikDUDcCTCAAQdQAaiACQdAAaiIBQQhqKQMANwIAIABB3ABqIAFBEGopAwA3AgAgAEHkAGogAUEYaikDADcCACAAQbABaiAGOwEAIABBrAFqIAU2AgAgAEGoAWogCTYCACAAQaQBaiAEQThuNgIAIABBoAFqIAM2AgAgAEGQAWogCjYCACAAQYwBaiALNgIAIABBiAFqIAw2AgAgAEGEAWogFDgCACAAQYABaiANNgIAIABB/ABqIA42AgAgAEH4AGogDzYCACAAQfQAaiAQNgIAIABB8ABqIBE2AgAgACASNgJsIAJB8ABqJAAPCxCRDAALIAQgA0GgncMAKAIAIgBBrwYgABsRAAAAC+kGAgZ/AX4jAEFAaiIFJAAgASgCACEIAkACQAJAAkACQAJ/QQAgASgCCCIDRQ0AGiADQQNuIANBA3BBAEdqC61CDH4iCUIgiKciBw0AIAmnIgRBAEgNACAHRUECdCEGAkAgBEUEQCAGIgcNAQwGCyAE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ACIHkyINlCAAQcgAaioCACAHkyIKIABB6ABqKgIAIAmTIg6UkyIGIAYgBpQgCiAAQfAAaioCACAFkyIGlCAAQcwAaioCACAFkyIKIA2UkyIFIAWUIAogDpQgCCAGlJMiBiAGlJKSQwAAAACSELMBIgiVlCAMIAmTIAUgCJWUIAsgB5MgBiAIlZSSkotDAACgNV0NAxogACAAKAK8AUEBaiIENgK8ASACQQhqIgNBIGogAUEgaigCADYCACADQRhqIAFBGGopAgA3AwAgA0EQaiABQRBqKQIANwMAIANBCGogAUEIaikCADcDACACIAEpAgA3AwggBEEESQ0CIARBBEG04cEAEM0IAAtBASEEQQAgACoCICABKgIAkyIFIAWUIABBJGoqAgAgASoCBJMiBSAFlJIgAEEoaioCACABKgIIkyIFIAWUkkMAAAAAkkMAAKA1XQ0CGgsgACAENgK8ASACQQhqIgNBIGogAUEgaigCADYCACADQRhqIAFBGGopAgA3AwAgA0EQaiABQRBqKQIANwMAIANBCGogAUEIaikCADcDACACIAEpAgA3AwgLIARBJGwgAGoiAEFAayACQShqKAIANgIAIABBOGogAkEgaikDADcCACAAQTBqIAJBGGopAwA3AgAgAEEoaiACQRBqKQMANwIAIABBIGogAikDCDcCAEEBCyACQTBqJAALwwYCCH8BfQNAIAEgCWohAgJAIARFDQAgAiACKgIAIAEgBGoiAyoCACIKIAqUkzgCAAJAIARBEEYiCA0AIAJBBGoiBSAFKgIAIAogA0EEaioCAJSTOAIAIARBDEYNACACQQhqIgUgBSoCACAKIANBCGoqAgCUkzgCACAEQQhGDQAgAkEMaiIFIAUqAgAgCiADQQxqKgIAlJM4AgAgBEEERg0AIAJBEGoiBSAFKgIAIAogA0EQaioCAJSTOAIACyAEQQRGIgUNACACIAIqAgAgA0EUaioCACIKIAqUkzgCAAJAIARBEEciB0UNACACQQRqIgYgBioCACAKIANBGGoqAgCUkzgCACAEQQxGDQAgAkEIaiIGIAYqAgAgCiADQRxqKgIAlJM4AgAgBEEIRg0AIAJBDGoiBiAGKgIAIAogA0EgaioCAJSTOAIAIAUNACACQRBqIgYgBioCACAKIANBJGoqAgCUkzgCAAsgBEEIRiIGDQAg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KgIAkiIHIAEqAgggAioCCJIiCSAJlCABQQxqKgIAIAJBDGoqAgCSIgggCJSSIAcgB5SSQwAAAACSELMBIgeVOAIAIABBCGogCCAHlTgCACAAIAkgB5U4AgQMAQsgAUEgaigCACICIANNDQggACABKAIYIANBFGxqIgEpAgg3AgQgAEEMaiABQRBqKAIANgIAC0EBIQQLIAAgBDYCAA8LIAMgAkHAm8IAEM0IAAsgBCADQdCbwgAQ0AgACyADIAVB0JvCABDPCAALIAMgAkGQm8IAEM0IAAsgAyACQaCbwgAQzQgACyAEIAJBsJvCABDNCAALIAMgAkGAm8IAEM0IAAsgASAFQeCbwgAQzQgAC7gFAQh/IwBB4AVrIgEkACABQYgBaiIFQQhqQgA3AwAgBUEgakIANwMAIAFCADcDiAEgAUIANwOgASABQeACaiICQQhqQgA3AwAgAkEgakIANwMAIAJBOGpCADcDACACQdAAakIANwMAIAJB6ABqQgA3AwAgAUIANwPgAiABQgA3A/gCIAFCADcDkAMgAUIANwOoAyABQgA3A8ADIAFB2ANqIgNBCGoiBkIANwMAIAFB8ANqIgdCADcDACADQSBqIghCADcDACABQgA3A9gDIAFBiARqIgNBIGpCADcDACADQQhqQgA3AwAgA0E4akIANwMAIANB0ABqQgA3AwAgA0HoAGpCADcDACABQgA3A6AEIAFCADcDiAQgAUIANwO4BCABQgA3A9AEIAFCADcD6AQgAUGABWoiBEEIakIANwMAIARBIGpCADcDACAEQThqQgA3AwAgBEHQAGpCADcDACABQgA3A4AFIAFCADcDmAUgAUIANwOwBSABQgA3A8gFIAFBuAFqIAJB+AAQ5AYaIAFB2AJqIAFBgARqKQMANwMAIAFB0AJqIAgpAwA3AwAgAUHIAmogBykDADcDACABQcACaiABQegDaikDADcDACABQbgCaiAGKQMANwMAIAEgASkD2AM3A7ACIAFBEGogA0H4ABDkBhogAEHgAmogBEHgABDkBhogACAFQdgBEOQGIgBB2AFqQQA2AgAgAEHcAWogAUEMakH8ABDkBhogAEGEBGpCADcCACAAQbzBwAAoAgAiAjYCgAQgAEH4A2pCADcDACAAIAI2AvQDIABB7ANqQgA3AgAgACACNgLoAyAAQeADakIA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TwRAIAEQAAsgAygCTCIBQSRPBEAgARAACyADKAJIIgFBJE8EQCABEAALIAMgA0FAaxCXCiADKQMAp0UNAyADKwMIIgZEAAAAAAAAAABmIgIgBkQAAAAAAADwQWNxRQ0BIAarDAILIAMoAkQiAUEkTwRAIAEQAAsgAygCTCIBQSRPBEAgARAACyADKAJIIgFBJEkNAyABEAAMAwtBAAsgAygCQCIEQSRPBEAgBBAAC0EAIAIbIQEgBkQAAOD////vQWQhAiADKAI8IgRBJE8EQCAEEAALQX8gASACGyECIAMoAjgiAUEkTwRAIAEQAAsgAkECSQwCCyADKAJAIgFBJEkNACABEAALIAMoAjwiAUEkTwRAIAEQAAsgAygCOCICQSRPBEAgAhAAC0EACyEBIAAgAjYCBCAAIAE2AgAgA0HQAGokAAu2BQICfwN+IwBB4ABrIgMkACADQQhqIgIQggogA0HcAGpBADoAACADQdQAakIANwIAIAJBxABqQgA3AgAgAkE8akIANwIAIAJBNGpCADcCACAAQgA3AtwBIABB5AFqQQA7AQAgAEIANwPoASAAQfABakIANwMAIANCADcCNCAAQcgAaiACQdgAEOQGGiAAQdABakIANwMAIABByAFqQgA3AwAgAEHAAWpCADcDACAAQR82ApACIABBjAJqQQA6AAAgAEKKro/ho+H1kT03AoQCIABB/AFqQgA3AgAgAEG8wcAAKAIANgL4ASAAQcQAaiABQShqKAIAIgI2AgAgAEE8aiABQSBqKQMAIgQ3AgAgAEE0aiABQRhqKQMAIgU3AgAgAEEsaiABKQMQIgY3AgAgACAGNwMQIABBGGogBTcDACAAQSBqIAQ3AwAgAEEoaiACNgIAIAAgASkCLDcCoAEgAEGoAWogAUE0aigCADYCACAAQbQBaiABQUBrKAIANgIAIABBrAFqIAEpAjg3AgAgACABLQB8OgCUAiAAIAEpAwA3AwAgACABQQhqKQMANwMIIAAgASkDUDcDSCAAQdAAaiABQdgAaikDADcDACAAQdgAaiABQeAAaikDADcDACAAQeAAaiABQegAaikDADcDACAAQegAaiABQfAAaikDADcDACAAQfAAaiABQfgAaigCADYCACAAQZwBaiABLQB9OgAAIAAgASkDSDcDuAEgAEHYAWogASoCRDgCACAA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IAIPCxCdDAALEJ4MAAtBxABBBEGgncMAKAIAIgBBrwYgABsRAAAAC8QDAgR/An4jAEEgayIDJAACQAJAAkACQCAAKAIAKAIQIgIOAwACAwELAkAgACgCACgCECICDgMAAgMBCwJAIAAoAgAoAhAiAg4DAAIDAQsCQCAAKAIAKAIQIgIOAwACAwELAkAgACgCACgCECICDgMAAgMBCwJAIAAoAgAoAhAiAg4DAAIDAQsCQCAAKAIAKAIQIgIOAwACAwELAkAgACgCACgCECICDgMAAgMBCwJAIAAoAgAoAhAiAg4DAAIDAQsCQCAAKAIAKAIQIgIOAwACAwELAkAgACgCACgCECICDgMAAgMBCwJAIAAoAgAoAhAiAg4DAAIDAQsDQCAAKAIAKAIQIgIEQCACQX9qDgIEBAILIAEpAwBCAVEEQCABKQMIIQYgASgCECECELAMQX8gAykDECIHIAZSIAcgBlQbIgVBfyACIAMoAhgiBEcgBCACSRsgBRtBf0cEQEEBIQIgACgCACIBKAIQIQAgASAAQQEgABs2AhAgAEUNBSAAQQMgAEEDSRshAgwFCyADIAYgAiAHIAQQnAkgAykDACADKAIIEJ8EBRChBAsMAAsAC0EDIQIMAQtBASECCyADQSBqJAAgAguEAwEEfyMAQUBqIgEkAAJAAkAgAARAIAAoAgANASAAQQA2AgAgAEHcAGoiBCgCACEDIARBADYCACABQThqIABBmAFqKAIANgIAIAFBMGogAEGQAWopAgA3AwAgAUEoaiAAQYgBaikCADcDACABQSBqIABBgAFqKQIANwMAIAFBGGogAEH4AGopAgA3AwAgAUEQaiAAQfAAaikCADcDACABQQhqIABB6ABqKQIANwMAIAEgAEHgAGopAgA3AwAgAwRAQcQAQQQQxQsiAkUNAyACIAM2AgQgAkEANgIAIAIgASkDADcCCCACQRBqIAFBCGopAwA3AgAgAkEYaiABQRBqKQMANwIAIAJBIGogAUEYaikDADcCACACQShqIAFBIGopAwA3AgAgAkEwaiABQShqKQMANwIAIAJBOGogAUEwaikDADcCACACQUBrIAFBOGooAgA2AgALIAFBQGskACACDwsQnQwACxCeDAALQcQAQQRBoJ3DACgCACIAQa8GIAAbEQAAAAuEAwEEfyMAQUBqIgEkAAJA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CCAGIAJBDGoqAgCUIAUgAkEQaioCAJSSIAcgAkEUaioCAJSSlSIJQwAAAABgQQAgCSADXxsNASAAQQQ2AhAPCyAAQgA3AgAgAEICNwIQIABBCGpCADcCAA8LIABCAjcCECAAIAk4AgAgACAHjCAHIAhDAAAAAF4iARs4AgwgACAFjCAFIAEbOAIIIAAgBowgBiABGzgCBAv2AQEDfwJAAkACQCABQdQAaigCACIDIAJLBEAgAUHIAGooAgAiAyABKAJMIAJBDGxqIgIoAgAiBE0NASADIAIoAgQiBU0NAiADIAIoAggiAk0NAyAAIAEoAkAiASACQQxsaiICKQIANwIYIAAgBEEMbCABaiIDKQIANwIAIAAgBUEMbCABaiIBKQIANwIMIABBIGogAkEIaigCADYCACAAQQhqIANBCGooAgA2AgAgAEEUaiABQQhqKAIANgIADwsgAiADQeyiwgAQzQgACyAEIANB/KLCABDNCAALIAUgA0GMo8IAEM0IAAsgAiADQZyjwgAQzQgAC9gBAQJ/IwBB4ABrIgIkACACQShqIABBKGooAgA2AgAgAkEgaiAAQSBqKQIANwMAIAJBGGogAEEYaikCADcDACACQRBqIABBEGopAgA3AwAgAkEIaiAAQQhqKQIANwMAIAIgACkCADcDACACQTBqIgNBKGogAUEoaigCADYCACADQSBqIAFBIGopAgA3AwAgA0EYaiABQRhqKQIANwMAIANBEGogAUEQaikCADcDACADQQhqIAFBCGopAgA3AwAgAiABKQIANwMwIAAgAiADEKoBIAJB4ABqJAAL2AEBAn8jAEHgAGsiAiQAIAJBKGogAEEoaigCADYCACACQSBqIABBIGopAgA3AwAgAkEYaiAAQRhqKQIANwMAIAJBEGogAEEQaikCADcDACACQQhqIABBCGopAgA3AwAgAiAAKQIANwMAIAJBMGoiA0EoaiABQShqKAIANgIAIANBIGogAUEgaikCADcDACADQRhqIAFBGGopAgA3AwAgA0EQaiABQRBqKQIANwMAIANBCGogAUEIaikCADcDACACIAEpAgA3AzAgACACIAMQpwEgAkHgAGokAAufAgEEfSABKgIEIgQgBJQiA0MAAEBAlCEFIAEqAgAiBCADQ9sPSUCUlCIDIAOSQwAAQECVIAKUIQIgBUMAAKBB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lJJDAAAAAJIiBEMAAIAoXkUNACAEELMBIAAqAhhfDQBBACEDCyACQUBrJAAgAwvcAQEEfyMAQSBrIgIkACACQSE2AhggAkEQaiIEIABBNGooAgAiAzYCACAEIABBPGooAgBB5AFsIANqNgIEAkAgAigCECIAIAIoAhQiBEYNAANAIABBEGooAgAhAyACQQhqIgUgAEEUaigCADYCBCAFIAM2AgAgAiACKAIIuBABNgIcIAIgASACQRhqIAJBHGoQwAkgAigCBCIDQSNLBEAgAxAACyAAQeQBaiEAIAIoAhwiA0EkTwRAIAMQAAsgACAERw0ACyACKAIYIgBBJEkNACAAEAALIAJBIGokAAvXAQECfyMAQSBrIgMkAAJAAkACQCAABEAgACgCACIEQX9GDQEgACAEQQFqNgIAIANBEGogAEEEaiABEJgJIAMoAhAiAUUNAiADQQhqIgQgAUGAAmooAgA2AgQgBCABKAL4ATYCACADKAIMIgEgAk0NAyADKAIIIAJBA3RqIgEoAgAhAiADIAEoAgQ2AgQgAyACNgIAIAMoAgAgACAAKAIAQX9qNgIAIANBIGokAA8LEJ0MAAsQngwAC0GQq8AAQc0AQYiswAAQogkACyACIAFBpK7AABDNCAALhAIBAn8CQEEIQQQQxQsiAQRAIAFCgYCAgBA3AgBBIEEEEMULIgJFDQEgAEEAOgBMIABBiq6P4QM2AkggAEL////79///v/8ANwIIIABB9JPBADYCBCAAIAE2AgAgAEEsakIANwIAIABBJGpCADcCACAAQUBrQgA3AgAgAEE8akG8wcAAKAIANgIAIABBOGpBCDYCACAAQTRqIAI2AgAgAEEgakHMwcAAKAIANgIAIABBGGpC////+////79/NwIAIABBEGpC////+/f//79/NwIADwtBCEEEQaCdwwAoAgAiAEGvBiAAGxEAAAALQSBBBEGgncMAKAIAIgBBrwYgABsRAAAAC4QCAQJ/AkBBCEEEEMULIgEEQCABQoGAgIAQNwIAQSBBBBDFCyICRQ0BIABBADoATCAAQv////v3//+//wA3AgggAEH0k8EANgIEIAAgATYCACAAQYquj+EDNgJIIABBLGpCADcCACAAQSRqQgA3AgAgAEFAa0IANwIAIABBPGpBvMHAACgCADYCACAAQThqQQg2AgAgAEE0aiACNgIAIABBIGpBzMHAACgCADYCACAAQRhqQv////v///+/fzcCACAAQRBqQv////v3//+/fzcCAA8LQQhBBEGgncMAKAIAIgBBrwYgABsRAAAAC0EgQQRBoJ3DACgCACIAQa8GIAAbEQAAAAumAQEJfSACKgIAIgQgASoCACIGlCACQQRqKgIAIgUgAUEEaioCACIHlJIgAUEIaioCACIIIAJBCGoqAgAiA5SSIAQgAUEMaioCACIJlCAFIAFBEGoqAgAiCpSSIAMgAUEUaioCACILlJJeIQIgACAIIAsgAhsgAyABKgIYIgOUkjgCCCAAIAcgCiACGyAFIAOUkjgCBCAAIAYgCSACGyAEIAOUkjgCAAuzAQEBfyMAQRBrIgYkAAJAAkACQAJAAkAgAARAIAAoAgANASAAQX82AgAgBiAAQQRqIAEQ8gYgBigCACIBRQ0CIAEtAJQCDQUgBQ0DDAQLEJ0MAAsQngwAC0GQq8AAQc0AQZiswAAQogkACyABEL8JCyABQZwBaiIFIAUtAABB8QFxIANBAEdBAnQgAkEAR0EBdHIgBEEAR0EDdHJyOgAAIAEQxwULIABBADYCACAGQRBqJAALswEBBH0CQAJAAkAgAioCACIDIAOUQwAAAACSIAJBCGoqAgAiBCAElJJDAAAAAJIQswEiBUMAAAAAXARAIAQgBCAFlSABKgIEIgSUIgaUIAMgAyAFlSAElCIElCABKgIAIgMgAkEEaioCAJQiBZOSIAVdDQEgA4whAwwDCyABKgIAIAJBBGoqAgCYIQMMAQtDAAAAACEGC0MAAAAAIQQLIAAgBjgCCCAAIAM4AgQgACAEOAIAC7MBAQZ9AkACQAJAIAIqAgAiAyADlEMAAAAAkiACQQhqKgIAIgUgBZSSQwAAAACSELMBIgZDAAAAAFwEQCADIAaVIAEqAgQiBJQiByADlCABKgIAIgMgAkEEaioCAJQiCJMgBSAGlSAElCIEIAWUkiAIXQ0BIAOMIQMMAwsgASoCACACQQRqKgIAmCEDDAELQwAAAAAhBAtDAAAAACEHCyAAIAQ4AgggACADOAIEIAAgBzgCAAvEAQECfyMAQRBrIgIkACAAAn9BASAALQAEDQAaIAAoAgAhASAALQAFRQRAIAEoAhhB2vvCAEEHIAFBHGooAgAoAgwRBQAMAQsgAS0AAEEEcUUEQCABKAIYQdT7wgBBBiABQRxqKAIAKAIMEQUADAELIAJBAToADyACQQhqIAJBD2o2AgAgAiABKQIYNwMAQQEgAkHQ+8IAQQMQkAMNABogASgCGEHT+8IAQQEgASgCHCgCDBEFAAsiADoABCACQRBqJAAgAAvDAQECfyMAQUBqIgAkACAAEIwJQcQAQQQQxQsiAUUEQEHEAEEEQaCdwwAoAgAiAEGvBiAAGxEAAAALIAFBADYCACABIAApAwA3AgQgAUEMaiAAQQhqKQMANwIAIAFBFGogAEEQaikDADcCACABQRxqIABBGGopAwA3AgAgAUEkaiAAQSBqKQMANwIAIAFBLGogAEEoaikDADcCACABQTRqIABBMGopAwA3AgAgAUE8aiAAQThqKQMANwIAIABBQGskACABC8MBAQJ/IwBBQGoiACQAIAAQpwRBxABBBBDFCyIBRQRAQcQAQQRBoJ3DACgCACIAQa8GIAAbEQAAAAsgAUEANgIAIAEgACkDADcCBCABQQxqIABBCGopAwA3AgAgAUEUaiAAQRBqKQMANwIAIAFBHGogAEEYaikDADcCACABQSRqIABBIGopAwA3AgAgAUEsaiAAQShqKQMANwIAIAFBNGogAEEwaikDADcCACABQTxqIABBOGopAwA3AgAgAEFAayQAIAELvwEBBH8jAEHwAGsiAiQAAkACQCAABEAgACgCAA0BIABBADYCACAAQf4BaiIDLQAAIQQgA0ECOgAAIABB/wFqLQAAIQMgAkEMaiAAQZwBakHiABDkBhogBEECRwRAQegAQQQQxQsiAUUNAyABQQA2AgAgAUEEaiACQQxqQeIAEOQGGiABIAM6AGcgASAEOgBmCyACQfAAaiQAIAEPCxCdDAALEJ4MAAtB6ABBBEGgncMAKAIAIgBBrwYgABsRAAAAC9MBACAAQgA3AkwgAEIANwIYIABBATsBeCAAQoCAgIDw//+//wA3AkQgACABKQIANwIAIAAgAikCADcCDCAAQdQAakEANgIAIABBIGpCADcCACAAQShqQgA3AgAgAEEwakIANwIAIABBOGpBADYCACAAQTxqQoCAgPwDNwIAIABBCGogAUEIaigCADYCACAAQRRqIAJBCGooAgA2AgAgAEL////7BzcCcCAAQegAakIANwIAIABBgICA/AM2AmQgAEHcAGpCADcCACAAQYCAgPwDNgJYC8YBAQJ/IwBBgAFrIgMkACADQdgAaiIEQRBqIAFBEGooAgA2AgAgBEEIaiABQQhqKQIANwMAIAMgASkCADcDWCADQfAAaiIBQQhqIAJBCGooAgA2AgAgAyACKQIANwNwIANBCGogBCABEM8BQdgAQQQQxQsiAUUEQEHYAEEEQaCdwwAoAgAiAEGvBiAAGxEAAAALIAFBCGogA0EIakHQABDkBhogAUKBgICAEDcCACAAQbiHwgA2AgQgACABNgIAIANBgAFqJAALtQEBBH8jAEEwayICJAAgAUEEaiEDIAEoAgRFBEAgASgCACEBIAJCADcCDCACQfDRwgAoAgA2AgggAiACQQhqIgU2AhQgAkEYaiIEQRBqIAFBEGopAgA3AwAgBEEIaiABQQhqKQIANwMAIAIgASkCADcDGCACQRRqQdjPwgAgBBDvAhogA0EIaiAFQQhqKAIANgIAIAMgAikDCDcCAAsgAEGQ1sIANgIEIAAgAzYCACACQTBqJAALmgEBA38gACgCACIBEI0FAkAgAUHkAGooAgAiAkUNACABQeAAaigCACIDRQ0AIAJBAnRFDQAgAxDhAQsCQCABQfQAaigCACICRQ0AIAFB8ABqKAIAIgNFDQAgAkECdEUNACADEOEBCwJAIAFBgAFqKAIAIgJFDQAgAUH8AGooAgAiAUUNACACQQJ0RQ0AIAEQ4QELIAAoAgAQ4QEL0wEBAn8jAEEgayICJAACQAJAIAAEQCAAKAIAIgNBf0YNASAAIANBAWo2AgAgAkEQaiAAQQRqIAEQmQkgAigCECIBRQ0CIAJBEGoiAyABKAIkQQFGBH8gAyABQShqKQMANwIEQQEFQQALNgIAAn8gAigCEEEBRgRAIAIoAhQhASACQQhqIgMgAkEYaigCADYCBCADIAE2AgAgAigCCAwBC0EACyAAIAAoAgBBf2o2AgAgAkEgaiQADwsQnQwACxCeDAALQaiswABBzABBnK3AABCiCQALpQEBA38jAEEgayIBJAACQCAABEAgACgCACICQX9GDQEgACACQQFqNgIAIAFBCGogAEEUaiICEHwgAEEEaiEDIAEtAAhFBEADQCABQQhqIAIQfCABLQAIRQ0ACwsgAUEIaiADQRhqIgIQdCABLQAIRQRAA0AgAUEIaiACEHQgAS0ACEUNAAsLIAAgACgCAEF/ajYCACABQSBqJAAPCxCdDAALEJ4MAAvOAQEDfSADKgIAELMBIQUgA0EEaioCABCzASEGIANBCGoqAgAQswEhByAAQRRqQwAAAABDAACAPyAGlSAGQwAAAABbGzgCACAAQwAAAABDAACAPyAFlSAFQwAAAABbGzgCECAAQwAAAABDAACAPyAClSACQwAAAABbGzgCDCAAQQhqIAFBCGooAgA2AgAgACABKQIANwIAIAAgBCkCADcCHCAAQSRqIARBCGopAgA3AgAgAEEYakMAAAAAQwAAgD8gB5UgB0MAAAAAWxs4AgALtQEBAn8jAEEQayIEJAACQAJAAkAgAEUNACAAKAIADQEgAEF/NgIAIAJFDQAgAigCACIFQX9GDQEgAiAFQQFqNgIAIAQgAEEEaiABEPIGIAQoAgAiAUUNAiAEQQhqIAJBDGooAgA2AgAgBCACKQIENwMAIAEgBCADQQBHEIIJIAIgAigCAEF/ajYCACAAQQA2AgAgBEEQaiQADwsQnQwACxCeDAALQZCrwABBzQBBmKzAABCiCQALtQEBAn8jAEEQayIEJAACQAJAAkAgAEUNACAAKAIADQEgAEF/NgIAIAJFDQAgAigCACIFQX9GDQEgAiAFQQFqNgIAIAQgAEEEaiABEPIGIAQoAgAiAUUNAiAEQQhqIAJBDGooAgA2AgAgBCACKQIENwMAIAEgBCADQQBHEOoIIAIgAigCAEF/ajYCACAAQQA2AgAgBEEQaiQADwsQnQwACxCeDAALQZCrwABBzQBBmKzAABCiCQALtQEBAn8jAEEQayIEJAACQAJAAkAgAEUNACAAKAIADQEgAEF/NgIAIAJFDQAgAigCACIFQX9GDQEgAiAFQQFqNgIAIAQgAEEEaiABEPIGIAQoAgAiAUUNAiAEQQhqIAJBDGooAgA2AgAgBCACKQIENwMAIAEgBCADQQBHEPsHIAIgAigCAEF/ajYCACAAQQA2AgAgBEEQaiQADwsQnQwACxCeDAALQZCrwABBzQBBmKzAABCiCQALtQEBAn8jAEEQayIEJAACQAJAAkAgAEUNACAAKAIADQEgAEF/NgIAIAJFDQAgAigCACIFQX9GDQEgAiAFQQFqNgIAIAQgAEEEaiABEPIGIAQoAgAiAUUNAiAEQQhqIAJBDGooAgA2AgAgBCACKQIENwMAIAEgBCADQQBHELoHIAIgAigCAEF/ajYCACAAQQA2AgAgBEEQaiQADwsQnQwACxCeDAALQZCrwABBzQBBmKzAABCiCQALtQEBAn8jAEEQayIEJAACQAJAAkAgAEUNACAAKAIADQEgAEF/NgIAIAJFDQAgAigCACIFQX9GDQEgAiAFQQFqNgIAIAQgAEEEaiABEPIGIAQoAgAiAUUNAiAEQQhqIAJBDGooAgA2AgAgBCACKQIENwMAIAEgBCADQQBHEOMHIAIgAigCAEF/ajYCACAAQQA2AgAgBEEQaiQADwsQnQwACxCeDAALQZCrwABBzQBBmKzAABCiCQALtQEBAn8jAEEQayIEJAACQAJAAkAgAEUNACAAKAIADQEgAEF/NgIAIAJFDQAgAigCACIFQX9GDQEgAiAFQQFqNgIAIAQgAEEEaiABEPIGIAQoAgAiAUUNAiAEQQhqIAJBDGooAgA2AgAgBCACKQIENwMAIAEgBCADQQBHEIkFIAIgAigCAEF/ajYCACAAQQA2AgAgBEEQaiQADwsQnQwACxCeDAALQZCrwABBzQBBmKzAABCiCQALuQEBAX8gAEEAOgBiIABBADsBYCAAQRRqQgA3AgAgAEG8wcAAKAIAIgE2AhAgAEF/NgIMIABCADcCBCAAIAE2AgAgAEHYAGpCADcCACAAQdQAaiABNgIAIABBzABqQgA3AgAgAEHIAGpB3MnCADYCACAAQQA2AkQgAEE8akIANwIAIAAgATYCOCAAQTBqQgA3AgAgAEEsaiABNgIAIABBJGpCADcCACAAQSBqQdzJwgA2AgAgAEEANgIcC7QBAgJ/AXwjAEEgayIAJAAgABCOCjYCFCAAQd6uwQBBCxADNgIYIABBCGogAEEUaiAAQRhqEM0JIAAoAgwhASAAKAIIRQRAIAAgATYCHCAAQRxqKAIAEAQgACgCHCIBQSRPBEAgARAACyAAKAIYIgFBJE8EQCABEAALIAAoAhQiAUEkTwRAIAEQAAsgAEEgaiQADwsgACABNgIcQemuwQBBLCAAQRxqQfStwQBBmK/BABCdCAALuQEBAX8jAEEQayIGJAACQCABBEAgBiABIAMgBCAFIAIoAhARCAAgBigCACEBAkAgBigCBCIDIAYoAggiAk0NACABRQ0AIANBAnQhAyACQQJ0IgRFBEAgA0UEQEEEIQEMAgsgARDhAUEEIQEMAQsgASADQQQgBBC0CyIBRQ0CCyAAIAI2AgQgACABNgIAIAZBEGokAA8LQaivwQBBMBCcDAALIARBBEGgncMAKAIAIgBBrwYgABsRAAAAC6gBAgF/AX0jAEFAaiIEJAAgBEEYaiABIAFBDGogAUEYaiACEK8CQQQhAQJAIAQoAigiAkEERwRAIARBEGoiBSAEQSRqKAIANgIAIAQgBCkCHDcDCCAAIAQqAhgiBiADXwR/IAQoAiwhASAAIAY4AgAgACAEKQMINwIEIAAgATYCFCAAQQxqIAUoAgA2AgAgAgVBBAs2AhAMAQsgAEEENgIQCyAEQUBrJAALnwEBBX0gACABKgIAIgIgASoCDCIDIAIgA2AbIAEqAhgiBJI4AgwgACACIAMgAiADXxsgBJM4AgAgAEEUaiAEIAEqAggiAiABQRRqKgIAIgMgAiADYBuSOAIAIABBEGogBCABKgIEIgUgAUEQaioCACIGIAUgBmAbkjgCACAAIAIgAyACIANfGyAEkzgCCCAAIAUgBiAFIAZfGyAEkzgCBAuoAQIDfwF9IwBBEGshASAAvCICQRd2Qf8BcSIDQZUBTQR9IANB/gBPBEACfSAAIACMIAJBf0obIgBDAAAAS5JDAAAAy5IgAJMiBEMAAAA/XkUEQCAAIASSIgAgBEMAAAC/X0UNARogAEMAAIA/kgwBCyAAIASSQwAAgL+SCyIAIACMIAJBf0obDwsgASAAQwAAAEuSOAIMIAEqAgwaIABDAAAAAJQFIAALC6QBAQd9IAEqAgAiBSACKgIAIgaUIAFBBGoqAgAiByACQQRqKgIAIgiUkiABQQhqKgIAIgkgAkEIaioCACIKlJIiBEMAAAAAXyIBRUVBACADG0UEQCAAIAogBCAJlJM4AgggACAIIAQgB5STOAIEIAAgBiAEIAWUkzgCACAAIAE6AAwPCyAAIAIpAgA3AgAgAEEIaiACQQhqKAIANgIAIABBAToADAuaAQEFfSABQQRqKgIAIgcgAioCBIyUIAIqAgAgASoCACIIlJMgAioCCCABQQhqKgIAIgmUkyEGAkACQCAEBEAgBkMAAAAAXg0BC0EAIQEgBiAIIAJBDGoqAgCUIAcgAkEQaioCAJSSIAkgAkEUaioCAJSSlSIFQwAAAABgRQ0BIAUgA19FDQELQQEhAQsgACAFOAIEIAAgATYCAAusAQEFfSACKgIAIgYgBpQgAioCBCIFIAWUkiACKgIIIgMgA5SSQwAAAACSELMBIQQgACADIASVIgcgASoCDCIDlCABKAIIQf////8HcSAHvEGAgICAeHFyvpI4AgggACADIAUgBJUiBZQgASgCBEH/////B3EgBbxBgICAgHhxcr6SOAIEIAAgAyAGIASVIgSUIAEoAgBB/////wdxIAS8QYCAgIB4cXK+kjgCAAu0AQECfyMAQUBqIgAkACAAQQhqEK8HQThBBBDFCyIBRQRAQThBBEGgncMAKAIAIgBBrwYgABsRAAAACyABQQA2AgAgASAAKQMINwIEIAFBDGogAEEQaikDADcCACABQRRqIABBGGopAwA3AgAgAUEcaiAAQSBqKQMANwIAIAFBJGogAEEoaikDADcCACABQSxqIABBMGopAwA3AgAgAUE0aiAAQThqKAIANgIAIABBQGskACABC7kBAgN/AX4jAEEQayIBJAACQAJAIAAEQCAAKAIAIgJBf0YNASAAIAJBAWo2AgAgACgCBCIDQZQBaikCACEEIANBnAFqKAIAIQMgACACNgIAIAFBCGoiAiADNgIAIAEgBDcDAEEQQQQQxQsiAEUNAiAAQQA2AgAgACABKQMANwIEIABBDGogAigCADYCACABQRBqJAAgAA8LEJ0MAAsQngwAC0EQQQRBoJ3DACgCACIAQa8GIAAbEQAAAAusAQEDfyMAQRBrIgEkAAJAAkAgAARAIAAoAgANASAAQQA2AgAgACgCBCAAQQA2AgQgAUEIaiAAQRBqKAIANgIAIAEgAEEIaikCADcDAEEBRgRAQRBBBBDFCyICRQ0DIAJBADYCACACIAEpAwA3AgQgAkEMaiABQQhqKAIANgIACyABQRBqJAAgAg8LEJ0MAAsQngwAC0EQQQRBoJ3DACgCACIAQa8GIAAbEQAAAAurAQIBfwF9IwBBIGsiAiQAIAJBCGogASoCACABQQRqKgIAEIEEIAEqAggiA0MAAAAAYEUEQEHdwMEAQSZBhMHBABD8CgALIAAgAyACKgIUkjgCDCAAIAIqAhAgA5M4AgggACACKgIMIAOTOAIEIAAgAioCCCADkzgCACAAQRRqIAMgAkEIaiIBQRRqKgIAkjgCACAAQRBqIAMgAUEQaioCAJI4AgAgAkEgaiQAC6MBAQF/IwBBQGoiAiQAIAAoAgAhACACQgA3AzggAkE4aiAAEBkgAkEcakEBNgIAIAIgAigCPCIANgIwIAIgADYCLCACIAIoAjg2AiggAkHwADYCJCACQgI3AgwgAkGwscEANgIIIAIgAkEoajYCICACIAJBIGo2AhggASACQQhqENIIAkAgAigCLEUNACACKAIoIgFFDQAgARDhAQsgAkFAayQAC50BAQJ/AkACfwJAAkACQAJ/IAIEQEEBIgQgAUEASA0BGiADKAIAIgVFDQMgAygCBCIDDQIgAQ0EIAIMBQsgACABNgIEQQELIQRBACEBDAQLIAUgAyACIAEQtAsMAgsgAQ0AIAIMAQsgASACEMULCyIDBEAgACADNgIEQQAhBAwBCyAAIAE2AgQgAiEBCyAAIAQ2AgAgAEEIaiABNgIAC70BAgJ/AX0jAEEgayIDJAACQAJAIAEEQCABKAIAIgRBf0YNASABIARBAWo2AgAgA0EQaiABQQRqIAIQmQkgAygCECICRQ0CIANBCGoiBCACQRxqKgIAOAIEIAQgAigCGEEBRzYCACADKgIMIQUgAygCCCECIAEgASgCAEF/ajYCACAAIAVDAAAAACACGzgCBCAAIAJBAEc2AgAgA0EgaiQADwsQnQwACxCeDAALQaiswABBzABBnK3AABCiCQALtAECBH8BfiMAQRBrIgEkAAJAAkAgAARAIAAoAgAiAkF/Rg0BIAAgAkEBajYCACAAKAIEIgNBFGooAgAhBCADKQIMIQUgACACNgIAIAFBCGoiAiAENgIAIAEgBTcDAEEQQQQQxQsiAEUNAiAAQQA2AgAgACABKQMANwIEIABBDGogAigCADYCACABQRBqJAAgAA8LEJ0MAAsQngwAC0EQQQRBoJ3DACgCACIAQa8GIAAbEQAAAAujAQEIfSABKgIYIQUgAUEMaioCACIGIAEqAgAiB5MiAiAClCABQRBqKgIAIgIgAUEEaioCACIIkyIDIAOUkiABQRRqKgIAIgMgAUEIaioCACIJkyIEIASUkkMAAAAAkhCzASEEIAAgAyAJkkMAAAA/lDgCCCAAIAIgCJJDAAAAP5Q4AgQgACAGIAeSQwAAAD+UOAIAIAAgBSAEQwAAAD+UkjgCDAusAQECfyMAQeADayICJAACQAJAIAAEQCAAKAIAIgNBf0YNASAAIANBAWo2AgAgAiABEPcBIAAgACgCAEF/ajYCAEEAIQAgAigCACIBQQJHBEBB4ANBBBDFCyIARQ0DIAAgATYCBCAAQQA2AgAgAEEIaiACQQRyQdgDEOQGGgsgAkHgA2okACAADwsQnQwACxCeDAALQeADQQRBoJ3DACgCACIAQa8GIAAbEQAAAAuPAQEDfwJAIAAoAgAiAS0AACICQX9qQQdJDQAgAgRAIAFBCGooAgBFDQEgAUEEaigCACIBRQ0BIAEQ4QEMAQsgAUEEai0AAEEDRw0AIAFBCGooAgAiAigCACACKAIEKAIAEQcAIAIoAgQiAygCBARAIAMoAggaIAIoAgAQ4QELIAEoAggQ4QELIAAoAgAQ4QELmQEBBX0gAioCACIFIAWUIAJBBGoqAgAiBiAGlJIgAkEIaioCACIEIASUkkMAAAAAkiIIIAEqAgAiByAHlF8iAUVFQQAgAxtFBEAgACAEIAcgCBCzAZUiBJQ4AgggACAGIASUOAIEIAAgBSAElDgCACAAIAE6AAwPCyAAIAIpAgA3AgAgAEEIaiACQQhqKAIANgIAIABBAToADAu5AgEHfSAAIAEqAhgiAyADIAEqAgwiAiACIAEqAgAiBSAFIAJdGyAFIAVcGyIEIAQgA10bIAQgBFwbOAIMIAAgBSAFIAIgBSACXRsgAiACXBsiAiACIAMgAiADXRsgAyADXBs4AgAgAEEUaiABQSBqKgIAIgMgAyABQRRqKgIAIgIgAiABKgIIIgUgBSACXRsgBSAFXBsiBCAEIANdGyAEIARcGzgCACAAQRBqIAFBHGoqAgAiBCAEIAFBEGoqAgAiBiAGIAEqAgQiByAHIAZdGyAHIAdcGyIIIAggBF0bIAggCFwbOAIAIAAgBSAFIAIgBSACXRsgAiACXBsiAiACIAMgAiADXRsgAyADXBs4AgggACAHIAcgBiAHIAZdGyAGIAZcGyIDIAMgBCADIARdGyAEIARcGzgCBAuyAQECfyMAQSBrIgMkACADQRBqIgQgAUEIaigCADYCACADQRxqIAJBCGooAgA2AgAgAyABKQIANwMIIAMgAikCADcCFEEgQQQQxQsiAUUEQEEgQQRBoJ3DACgCACIAQa8GIAAbEQAAAAsgASADKQMINwIIIAFCgYCAgBA3AgAgAUEYaiADQRhqKQMANwIAIAFBEGogBCkDADcCACAAQfTywQA2AgQgACABNgIAIANBIGokAAu1AQECfyMAQYABayIDJAAgA0HgAGoiBEEIaiABQQhqKAIANgIAIAMgASkCADcDYCADQfAAaiIBQQhqIAJBCGooAgA2AgAgAyACKQIANwNwIANBCGogBCABEHBB4ABBBBDFCyIBRQRAQeAAQQRBoJ3DACgCACIAQa8GIAAbEQAAAAsgAUEIaiADQQhqQdgAEOQGGiABQoGAgIAQNwIAIABBoILCADYCBCAAIAE2AgAgA0GAAWokAAu2AQECfyMAQYABayIDJAAgA0HgAGoiBEEIaiABQQhqKAIANgIAIAMgASkCADcDYCADQfAAaiIBQQhqIAJBCGooAgA2AgAgAyACKQIANwNwIANBCGogBCABEIoBQeAAQQQQxQsiAUUEQEHgAEEEQaCdwwAoAgAiAEGvBiAAGxEAAAALIAFBCGogA0EIakHYABDkBhogAUKBgICAEDcCACAAQeyEwgA2AgQgACABNgIAIANBgAFqJAALogECAX8BfSMAQSBrIgMkACADQQhqIAEgAhDSAiABKgIkIgRDAAAAAGBFBEBB3cDBAEEmQYTBwQAQ/AoACyAAIAQgAyoCFJI4AgwgACADKgIQIASTOAIIIAAgAyoCDCAEkzgCBCAAIAMqAgggBJM4AgAgAEEUaiAEIANBCGoiAUEUaioCAJI4AgAgAEEQaiAEIAFBEGoqAgCSOAIAIANBIGokAAuiAQIBfwF9IwBBIGsiAyQAIANBCGogASACEOsCIAEqAmAiBEMAAAAAYEUEQEHdwMEAQSZBhMHBABD8CgALIAAgBCADKgIUkjgCDCAAIAMqAhAgBJM4AgggACADKgIMIASTOAIEIAAgAyoCCCAEkzgCACAAQRRqIAQgA0EIaiIBQRRqKgIAkjgCACAAQRBqIAQgAUEQaioCAJI4AgAgA0EgaiQAC5gBAQN/IwBBgAFrIgMkACAALwEAIQJBACEAA0AgACADakH/AGogAkEPcSIEQTBB1wAgBEEKSRtqOgAAIABBf2ohACACQf//A3EiBEEEdiECIARBD0sNAAsgAEGAAWoiAkGBAU8EQCACQYABQYj8wgAQzggACyABQQFBmPzCAEECIAAgA2pBgAFqQQAgAGsQggIgA0GAAWokAAuXAQEDfyMAQYABayIDJAAgAC0AACECQQAhAANAIAAgA2pB/wBqIAJBD3EiBEEwQdcAIARBCkkbajoAACAAQX9qIQAgAkH/AXEiBEEEdiECIARBD0sNAAsgAEGAAWoiAkGBAU8EQCACQYABQYj8wgAQzggACyABQQFBmPzCAEECIAAgA2pBgAFqQQAgAGsQggIgA0GAAWokAAuWAQEDfyMAQYABayIDJAAgAC0AACECQQAhAANAIAAgA2pB/wBqIAJBD3EiBEEwQTcgBEEKSRtqOgAAIABBf2ohACACQf8BcSIEQQR2IQIgBEEPSw0ACyAAQYABaiICQYEBTwRAIAJBgAFBiPzCABDOCAALIAFBAUGY/MIAQQIgACADakGAAWpBACAAaxCCAiADQYABaiQAC5cBAQN/IwBBgAFrIgMkACAALwEAIQJBACEAA0AgACADakH/AGogAkEPcSIEQTBBNyAEQQpJG2o6AAAgAEF/aiEAIAJB//8DcSIEQQR2IQIgBEEPSw0ACyAAQYABaiICQYEBTwRAIAJBgAFBiPzCABDOCAALIAFBAUGY/MIAQQIgACADakGAAWpBACAAaxCCAiADQYABaiQAC6IBAQF/IwBBEGsiBCQAAkACQAJAAkACQCAABEAgACgCAA0BIABBfzYCACAEIABBBGogARDyBiAEKAIAIgFFDQIgAS0AlAINBSACQQBHIQIgAw0DDAQLEJ0MAAsQngwAC0GQq8AAQc0AQZiswAAQogkACyABEL8JCyABQZwBaiIDIAMtAABB/gFxIAJyOgAAIAEQxwULIABBADYCACAEQRBqJAALoAEBBH8jAEHQAGsiASQAAkACQCAABEAgACgCAA0BIABBADYCACAAQRRqIgMoAgAgA0EANgIAIAFBDGogAEEYakHEABDkBhpBAUYEQEHIAEEEEMULIgJFDQMgAkEANgIAIAJBBGogAUEMakHEABDkBhoLIAFB0ABqJAAgAg8LEJ0MAAsQngwAC0HIAEEEQaCdwwAoAgAiAEGvBiAAGxEAAAALpgEBA38jAEEgayIBJAAgAUEYaiICQQA2AgAgAUEMakIANwIAIAFCADcCBCABQcTBwAAoAgA2AgAgAUEEELkCIABBLGpCADcCACAAQbzBwAAoAgAiAzYCKCAAQSBqQgA3AgAgACADNgIcIABBGGogAigCADYCACAAQRBqIAFBEGopAwA3AgAgAEEIaiABQQhqKQMANwIAIAAgASkDADcCACABQSBqJAALjQEBA38jAEGAAWsiAyQAIAAoAgAhAANAIAIgA2pB/wBqIABBD3EiBEEwQdcAIARBCkkbajoAACACQX9qIQIgAEEPSyAAQQR2IQANAAsgAkGAAWoiAEGBAU8EQCAAQYABQYj8wgAQzggACyABQQFBmPzCAEECIAIgA2pBgAFqQQAgAmsQggIgA0GAAWokAAuMAQEDfyMAQYABayIDJAAgACgCACEAA0AgAiADakH/AGogAEEPcSIEQTBBNyAEQQpJG2o6AAAgAkF/aiECIABBD0sgAEEEdiEADQALIAJBgAFqIgBBgQFPBEAgAEGAAUGI/MIAEM4IAAsgAUEBQZj8wgBBAiACIANqQYABakEAIAJrEIICIANBgAFqJAALrAEBAX8jAEEwayIFJAAgBSABNgIYIAUgATYCFCAFIAA2AhAgBSADNgIoIAUgAzYCJCAFIAI2AiAgBUEIaiAFQRBqIAVBIGogBBCLAgJAAkAgBSgCCCIARQRAQQAhAwwBCyAFKAIMIQFBDEEEEMULIgNFDQEgAyABNgIIIAMgADYCBCADQQA2AgALIAVBMGokACADDwtBDEEEQaCdwwAoAgAiAEGvBiAAGxEAAAALnQEBA38jAEEgayICJAACQAJAIAAEQCAAKAIAIgNBf0YNASAAIANBAWo2AgAgAkEQaiAAQQRqIAEQ5wcgAigCECIBRQ0CIAFBCGooAgAhAyACQQhqIgQgAUEMaigCADYCBCAEIAM2AgAgAigCCCAAIAAoAgBBf2o2AgAgAkEgaiQADwsQnQwACxCeDAALQYCqwABByQBB8KrAABCiCQALlAEBAn8jAEEgayICJAACQAJAIAAEQCAAKAIAIgNBf0YNASAAIANBAWo2AgAgAkEQaiAAQQRqIAEQmQkgAigCECIBRQ0CIAJBCGogASkCdDcDACACKAIMIQEgAigCCCAAIAAoAgBBf2o2AgAgAkEgaiQAQRB0IAFyDwsQnQwACxCeDAALQaiswABBzABBnK3AABCiCQALmAEBAn8jAEEgayICJAACQAJAIAAEQCAAKAIAIgNBf0YNASAAIANBAWo2AgAgAkEQaiAAQQRqIAEQmQkgAigCECIBRQ0CIAJBCGogAUH8AGopAgA3AwAgAigCDCEBIAIoAgggACAAKAIAQX9qNgIAIAJBIGokAEEQdCABcg8LEJ0MAAsQngwAC0GorMAAQcwAQZytwAAQogkAC6oBAQF/IwBBMGsiBCQAIAQgATYCGCAEIAE2AhQgBCAANgIQIAQgAzYCKCAEIAM2AiQgBCACNgIgIARBCGogBEEQaiAEQSBqEI0CAkACQCAEKAIIIgBFBEBBACEDDAELIAQoAgwhAUEMQQQQxQsiA0UNASADIAE2AgggAyAANgIEIANBADYCAAsgBEEwaiQAIAMPC0EMQQRBoJ3DACgCACIAQa8GIAAbEQAAAAugAQEEfwJAAkACQCABKAIAIgMQFiIBQQBOBEAgAQ0BQQEhAgwCCxCRDAALIAFBARDFCyICRQ0BCyAAIAE2AgQgACACNgIAEBsiBBANIgUQFCEBIAVBJE8EQCAFEAALIAEgAyACEBUgAUEkTwRAIAEQAAsgBEEkTwRAIAQQAAsgACADEBY2AggPCyABQQFBoJ3DACgCACIAQa8GIAAbEQAAAAuZAQEDfyMAQRBrIgMkAAJAAkACQCAARQ0AIAAoAgANASAAQX82AgAgAkUNACACKAIADQEgAkEANgIAIAJBCGooAgAhBCACKAIEIQUgAhDhASADIABBBGogARDuBiADKAIAIgFFDQIgASAFIAQQsAkgAEEANgIAIANBEGokAA8LEJ0MAAsQngwAC0GorMAAQcwAQaytwAAQogkAC6oBAgR/An0jAEEwayICJAAgAiAAjDgCFCACIABDAAAAAJQiBowiBzgCGCACIAc4AhAgAiAGOAIoIAIgADgCJCACIAY4AiAgAkEIaiACQRBqIAJBIGogARDxBiACKAIMIQQgAigCCCEFQQxBBBDFCyIDRQRAQQxBBEGgncMAKAIAIgJBrwYgAhsRAAAACyADIAQ2AgggAyAFNgIEIANBADYCACACQTBqJAAgAwueAQIBfwF9AkAgAC0AlAINACAAIAAqAqABIAEqAgAgAEGAAWoqAgAiBJSSOAKgASAAQaQBaiIDIAQgASoCBJQgAyoCAJI4AgAgAEGoAWoiAyAEIAEqAgiUIAMqAgCSOAIAIAJFDQAgAEGMAmotAAAEQCAAIAAoApACQQRyNgKQAgsgAEEAOgCMAiAAQYgCaiAAKgKEAosiBCAEkjgCAAsLlgECAn8DfSMAQUBqIgQkACABQQhqIgUqAgAhBiABKgIAIQcgASoCBCEIIARBHGogBSgCADYCACAEIAaMOAIQIAQgCIw4AgwgBCAHjDgCCCAEIAEpAgA3AhQgBEEgaiIBIARBCGogAiADEPkCIAAgBCkDIDcCACAAQQhqIAFBCGooAgA2AgAgACAELQAsOgAMIARBQGskAAuYAQEHfSAAIAFB5ABqKgIAIgQgAUHYAGoqAgAiBZMiAiAClCABQegAaioCACICIAFB3ABqKgIAIgaTIgMgA5SSIAFB7ABqKgIAIgMgAUHgAGoqAgAiB5MiCCAIlJJDAAAAAJIQswE4AgwgACAHIAOSQwAAAD+UOAIIIAAgBiACkkMAAAA/lDgCBCAAIAUgBJJDAAAAP5Q4AgALmgEBA38jAEEgayICJAACQAJAIAAEQCAAKAIAIgNBf0YNASAAIANBAWo2AgAgAkEQaiAAQQRqIAEQ5wcgAigCECIBRQ0CIAEoAgAhAyACQQhqIgQgAUEEaigCADYCBCAEIAM2AgAgAigCCCAAIAAoAgBBf2o2AgAgAkEgaiQADwsQnQwACxCeDAALQYCqwABByQBB8KrAABCiCQALngEBAn8jAEEQayICJAACQAJAIAAEQCAAKAIAIgNBf0YNASAAIANBAWo2AgAgAiAAQQRqIAEQlgMgACAAKAIAQX9qNgIAQRRBBBDFCyIARQ0CIABBADYCACAAIAIpAwA3AgQgAEEMaiACQQhqKQMANwIAIAJBEGokACAADwsQnQwACxCeDAALQRRBBEGgncMAKAIAIgBBrwYgABsRAAAAC54BAQJ/IwBBEGsiAiQAAkACQCAABEAgACgCACIDQX9GDQEgACADQQFqNgIAIAIgAEEEaiABEJcDIAAgACgCAEF/ajYCAEEUQQQQxQsiAEUNAiAAQQA2AgAgACACKQMANwIEIABBDGogAkEIaikDADcCACACQRBqJAAgAA8LEJ0MAAsQngwAC0EUQQRBoJ3DACgCACIAQa8GIAAbEQAAAAuFAQICfwJ+IwBBQGoiAyQAIANBGGoiBCABIAJBARBIIANBEGogBEEIaikDACIFNwMAIAMgAykDGCIGNwMIIARBFGooAgAhAiADKAIoIQEgAEEIaiAFNwIAIAAgBjcCACAAQRRqIAJBACABQQNJIgIbNgIAIAAgAUECIAIbNgIQIANBQGskAAuSAQAgAEIANwI4IAAgASkCADcCACAAIAIpAgA3AhwgAEFAa0IANwIAIABByABqQgA3AgAgAEEYaiABQRhqKAIANgIAIABBEGogAUEQaikCADcCACAAQQhqIAFBCGopAgA3AgAgAEEkaiACQQhqKQIANwIAIABBLGogAkEQaikCADcCACAAQTRqIAJBGGooAgA2AgALhQECAn8CfiMAQUBqIgMkACADQRhqIgQgASACQQEQTiADQRBqIARBCGopAwAiBTcDACADIAMpAxgiBjcDCCAEQRRqKAIAIQIgAygCKCEBIABBCGogBTcCACAAIAY3AgAgAEEUaiACQQAgAUEDSSICGzYCACAAIAFBAiACGzYCECADQUBrJAALhgEBBX0gAioCACIFIAWUQwAAAACSIAIqAggiAyADlJJDAAAAAJIQswEiB0MAAAAAXARAIAMgB5UgASoCBCIElCEGIAUgB5UgBJQhBAsgACAGIAMgASoCCCIDlJI4AgggACAEIAUgA5SSOAIAIAAgASoCACACQQRqKgIAIgWYIAUgA5SSOAIEC60BAQJ/IwBB8ABrIgUkACAFQeAAaiIGQQhqIAFBCGooAgA2AgAgBSABKQIANwNgIAUgBiACIAMQOAJAAkAgBSgCAEUEQEEAIQEMAQtB7ABBBBDFCyIBRQ0BIAFBCGogBUHgABDkBhogAUKBgICAEDcCACABIAQ4AmgLIABBsKTCADYCBCAAIAE2AgAgBUHwAGokAA8LQewAQQRBoJ3DACgCACIAQa8GIAAbEQAAAAuLAQECfyMAQRBrIgIkAAJAAkAgAARAIAAoAgAiA0F/Rg0BIAAgA0EBajYCACACIABBBGogARDnByACKAIAIgFFDQIgAUG0AWotAAAhAyABKAIYIAAgACgCAEF/ajYCACACQRBqJABBAkYgA0EAR3EPCxCdDAALEJ4MAAtBgKrAAEHJAEHwqsAAEKIJAAvGAQEBfyMAQRBrIgYkAAJAAkAgAARAIAAoAgANASAAQX82AgAgBiAAQQRqIAEQ5wcgBigCACIBRQ0CAkACQAJAIAEoAhhBAmsOAgABAgsgAUEcaiIBIAU4AowBIAEgBDgCiAEgASACOAKEASABIAM4AoABDAELIAFBHGoiASAFOAKMASABIAQ4AogBIAEgAjgChAEgASADOAKAAQsgAEEA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RQ0BIAFBCGogBEHgABDkBhogAUKBgICAEDcCAAsgAEHwicIANgIEIAAgATYCACAEQfAAaiQADwtB6ABBBEGgncMAKAIAIgBBrwYgABsRAAAAC4QBAQF/AkACQCAARQ0AIAAoAgANASAAQX82AgAgAUUNACABKAIADQEgAUF/NgIAIAJFDQAgAigCACIFQX9GDQEgAiAFQQFqNgIAIABBBGogAUEEaiACQQRqIAMgBBB9IAIgAigCAEF/ajYCACABQQA2AgAgAEEANgIADwsQnQwACxCeDAALkwEBAn8jAEEgayIBJAAgAUEYaiICQQA2AgAgAUEMakIANwIAIAFCADcCBCABQcTBwAAoAgA2AgAgAUEEELoCIABBIGpCADcCACAAQbzBwAAoAgA2AhwgAEEYaiACKAIANgIAIABBEGogAUEQaikDADcCACAAQQhqIAFBCGopAwA3AgAgACABKQMANwIAIAFBIGokAAuAAQIBfwN9IAAgASABQQxqIgMgASoCACACKgIAIgSUIAFBBGoqAgAgAkEEaioCACIFlJIgAUEIaioCACACQQhqKgIAIgaUkiAEIAMqAgCUIAUgAUEQaioCAJSSIAYgAUEUaioCAJSSXhsiASkCADcCACAAQQhqIAFBCGooAgA2AgALewEDfyMAQSBrIgMkACADQQhqIAEQtAMgA0EYaigCACEBIAMoAgwhBCAAIAIgAygCCCIAIAMoAhAgAygCFCIFIANBHGooAgAQoAICQCABRQ0AIAFBDGxFDQAgBRDhAQsCQCAERQ0AIARBDGxFDQAgABDhAQsgA0EgaiQAC68BAQF/IwBBEGsiBiQAAkACQCAABEAgACgCAA0BIABBfzYCACAGIABBBGogARDnByAGKAIAIgFFDQIgASgCGEUEQCAGIAQ4AgggBiADOAIEIAYgAjgCACABQRxqIgEgBTgCRCABQQA2AkAgASAGKQIANwIkIAFBLGogBkEIaigCADYCAAsgAEEANgIAIAZBEGokAA8LEJ0MAAsQngwAC0GAqsAAQckAQYCrwAAQogkAC7YBAQF/IwBBEGsiBCQAAkACQCAABEAgACgCAA0BIABBfzYCACAEIABBBGogARDnByAEKAIAIgFFDQICQAJAAkAgASgCGEECaw4CAAECCyABQRxqIgEgAzgCjAEgAUEANgKIASABIAI4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KAIAQX9qNgIAIAAgBUMAAAAAIAIbOAIEIAAgAkEARzYCACADQRBqJAAPCxCdDAALEJ4MAAuAAQICfwF9IwBBEGsiAyQAAkAgAQRAIAEoAgAiBEF/Rg0BIAEgBEEBajYCACADQQhqIAFBBGogAhC9BSADKgIMIQUgAygCCCECIAEgASgCAEF/ajYCACAAIAVDAAAAACACGzgCBCAAIAJBAEc2AgAgA0EQaiQADwsQnQwACxCeDAALnQECBH8BfiMAQRBrIgAkABCUCyECIAAQlAs2AgwgAEEMaigCACkDCCEEQSBBCBDFCyIBBEAgASACNgIYIAFCADcDECABIAQ3AwggAUKBgICAEDcDACAAKAIMIgMoAgAhAiADIAJBf2o2AgAgAkEBRgRAIAAoAgwQqggLIABBEGokACABDwtBIEEIQaCdwwAoAgAiAEGvBiAAGxEAAAALewIBfwF9IwBBEGsiAyQAIAMgACABIAIQrQIgAyoCACABKgIAkyIEIASUIAMqAgQgAUEEaioCAJMiBCAElJIgAyoCCCABQQhqKgIAkyIEIASUkkMAAAAAkhCzASEEIAMtAAwhACADQRBqJAAgBCAEIASMIABBAUcbIAIbC3oCAX8BfSMAQRBrIgMkACADIAAgASACECsgAyoCACABKgIAkyIEIASUIAMqAgQgAUEEaioCAJMiBCAElJIgAyoCCCABQQhqKgIAkyIEIASUkkMAAAAAkhCzASEEIAMtAAwhACADQRBqJAAgBCAEIASMIABBAUcbIAIbC3oCAX8BfSMAQRBrIgMkACADIAAgASACEEsgAyoCACABKgIAkyIEIASUIAMqAgQgAUEEaioCAJMiBCAElJIgAyoCCCABQQhqKgIAkyIEIASUkkMAAAAAkhCzASEEIAMtAAwhACADQRBqJAAgBCAEIASMIABBAUcbIAIbC3oCAX8BfSMAQRBrIgMkACADIAAgASACECcgAyoCACABKgIAkyIEIASUIAMqAgQgAUEEaioCAJMiBCAElJIgAyoCCCABQQhqKgIAkyIEIASUkkMAAAAAkhCzASEEIAMtAAwhACADQRBqJAAgBCAEIASMIABBAUcbIAIbC3oCAX8BfSMAQRBrIgMkACADIAAgASACEFAgAyoCACABKgIAkyIEIASUIAMqAgQgAUEEaioCAJMiBCAElJIgAyoCCCABQQhqKgIAkyIEIASUkkMAAAAAkhCzASEEIAMtAAwhACADQRBqJAAgBCAEIASMIABBAUcbIAIbC3oCAX8BfSMAQRBrIgMkACADIAAgASACECkgAyoCACABKgIAkyIEIASUIAMqAgQgAUEEaioCAJMiBCAElJIgAyoCCCABQQhqKgIAkyIEIASUkkMAAAAAkhCzASEEIAMtAAwhACADQRBqJAAgBCAEIASMIABBAUcbIAIbC3oCAX8BfSMAQRBrIgMkACADIAAgASACEC0gAyoCACABKgIAkyIEIASUIAMqAgQgAUEEaioCAJMiBCAElJIgAyoCCCABQQhqKgIAkyIEIASUkkMAAAAAkhCzASEEIAMtAAwhACADQRBqJAAgBCAEIASMIABBAUcbIAIbC3sCAX8BfSMAQRBrIgMkACADIAAgASACEIsDIAMqAgAgASoCAJMiBCAElCADKgIEIAFBBGoqAgCTIgQgBJSSIAMqAgggAUEIaioCAJMiBCAElJJDAAAAAJIQswEhBCADLQAMIQAgA0EQaiQAIAQgBCAEjCAAQQFHGyACGwt7AgF/AX0jAEEQayIDJAAgAyAAIAEgAhDQAiADKgIAIAEqAgCTIgQgBJQgAyoCBCABQQRqKgIAkyIEIASUkiADKgIIIAFBCGoqAgCTIgQgBJSSQwAAAACSELMBIQQgAy0ADCEAIANBEGokACAEIAQgBIwgAEEBRxsgAhsLegIBfwF9IwBBEGsiAyQAIAMgACABIAIQXiADKgIAIAEqAgCTIgQgBJQgAyoCBCABQQRqKgIAkyIEIASUkiADKgIIIAFBCGoqAgCTIgQgBJSSQwAAAACSELMBIQQgAy0ADCEAIANBEGokACAEIAQgBIwgAEEBRxsgAhsLegIBfwF9IwBBEGsiAyQAIAMgACABIAIQKiADKgIAIAEqAgCTIgQgBJQgAyoCBCABQQRqKgIAkyIEIASUkiADKgIIIAFBCGoqAgCTIgQgBJSSQwAAAACSELMBIQQgAy0ADCEAIANBEGokACAEIAQgBIwgAEEBRxsgAhsLegIBfwF9IwBBEGsiAyQAIAMgACABIAIQLCADKgIAIAEqAgCTIgQgBJQgAyoCBCABQQRqKgIAkyIEIASUkiADKgIIIAFBCGoqAgCTIgQgBJSSQwAAAACSELMBIQQgAy0ADCEAIANBEGokACAEIAQgBIwgAEEBRxsgAhsLhwECAn8DfSMAQSBrIgUkACABQQhqIgYqAgAhByABKgIAIQggASoCBCEJIAVBHGogBigCADYCACAFIAeMOAIQIAUgCYw4AgwgBSAIjDgCCCAFIAEpAgA3AhQgBSAFQQhqIAIgAyAEELkDIAUoAgAhASAAIAUqAgQ4AgQgACABNgIAIAVBIGokAAuSAQECfyMAQSBrIgMkACADIAE2AhggAyABNgIUIAMgADYCECADQQhqIANBEGogAhDMAwJAAkAgAygCCCIARQRAQQAhAQwBCyADKAIMIQRBDEEEEMULIgFFDQEgASAENgIIIAEgADYCBCABQQA2AgALIANBIGokACABDwtBDEEEQaCdwwAoAgAiAEGvBiAAGxEAAAALjAECAX8BfQJAIAAtAJQCDQAgACABKgIAIAAqAsABkjgCwAEgAEHEAWoiAyABKgIEIAMqAgCSOAIAIABByAFqIgMgASoCCCADKgIAkjgCACACRQ0AIABBjAJqLQAABEAgACAAKAKQAkEEcjYCkAILIABBADoAjAIgAEGIAmogACoChAKLIgQgBJI4AgALC3oBB30gAEICNwIQIAAgASoCACIEIAIqAgAiBZQgAUEEaioCACIGIAJBBGoqAgAiB5SSIAFBCGoqAgAiCCACQQhqKgIAIgmUkiIDQwAAAABfOgAMIAAgCSAIIAOUkzgCCCAAIAcgBiADlJM4AgQgACAFIAQgA5STOAIAC3kCAX8BfSMAQSBrIgMkACADIAAgARD1AiADLQAMIQAgAyoCACABKgIAkyIEIASUIAMqAgQgAUEEaioCAJMiBCAElJIgAyoCCCABQQhqKgIAkyIEIASUkkMAAAAAkhCzASEEIANBIGokACAEIAQgBIwgAEEBRxsgAhsLegECfyMAQRBrIgIkAAJAAkAgAARAIAAoAgAiA0F/Rg0BIAAgA0EBajYCACACIABBBGogARDnByACKAIAIgFFDQIgAUEYaigCACAAIAAoAgBBf2o2AgAgAkEQaiQADwsQnQwACxCeDAALQYCqwABByQBB8KrAABCiCQALfQICfwF9IwBBEGsiAiQAAkACQCAABEAgACgCACIDQX9GDQEgACADQQFqNgIAIAIgAEEEaiABEJgJIAIoAgAiAUUNAiABQbgBaioCACAAIAAoAgBBf2o2AgAgAkEQaiQADwsQnQwACxCeDAALQZCrwABBzQBBiKzAABCiCQALfQICfwF9IwBBEGsiAiQAAkACQCAABEAgACgCACIDQX9GDQEgACADQQFqNgIAIAIgAEEEaiABEJgJIAIoAgAiAUUNAiABQbwBaioCACAAIAAoAgBBf2o2AgAgAkEQaiQADwsQnQwACxCeDAALQZCrwABBzQBBiKzAABCiCQALgAEBAn8jAEEQayICJAACQAJAIAAEQCAAKAIAIgNBf0YNASAAIANBAWo2AgAgAiAAQQRqIAEQmQkgAigCACIBRQ0CIAFBjAFqLwEAIAAgACgCAEF/ajYCACACQRBqJABB//8DcQ8LEJ0MAAsQngwAC0GorMAAQcwAQZytwAAQogkAC38BAn8jAEEQayICJAACQAJAIAAEQCAAKAIAIgNBf0YNASAAIANBAWo2AgAgAiAAQQRqIAEQmQkgAigCACIBRQ0CIAFB8ABqLQAAIAAgACgCAEF/ajYCACACQRBqJABB/wFxDwsQnQwACxCeDAALQaiswABBzABBnK3AABCiCQALfwECfyMAQRBrIgIkAAJAAkAgAARAIAAoAgAiA0F/Rg0BIAAgA0EBajYCACACIABBBGogARCZCSACKAIAIgFFDQIgAUHxAGotAAAgACAAKAIAQX9qNgIAIAJBEGokAEH/AXEPCxCdDAALEJ4MAAtBqKzAAEHMAEGcrcAAEKIJAAuQAQECfyMAQSBrIgIkACACIAE2AhggAiABNgIUIAIgADYCECACQQhqIAJBEGoQ0QMCQAJAIAIoAggiAEUEQEEAIQEMAQsgAigCDCEDQQxBBBDFCyIBRQ0BIAEgAzYCCCABIAA2AgQgAUEANgIACyACQSBqJAAgAQ8LQQxBBEGgncMAKAIAIgBBrwYgABsRAAAAC5EBACAAQgA3AiwgAEIANwM4IABBKGpBADYCACAAQSBqQgA3AwAgAEE0akEANgIAIABBQGtBADYCACAAQdAAahCCCiAAQgA3AwggAEIANwMAIABBADoAgQEgAEGAAjYAfSAAIAE6AHwgAEEANgJMIABCgICA/AM3AkQgAEEYakKAgICAgICAwD83AwAgAEIANwMQC2sBAX8gAUEIaigCAEEHakF4cSAAaiABKAIAEQcAAkAgAEF/Rg0AIAAgACgCBCICQX9qNgIEIAJBAUcNACABQQhqKAIAIgJBBCACQQRLGyICIAFBBGooAgBqQQdqQQAgAmtxRQ0AIAAQ4QELC30CAn8BfSMAQRBrIgIkAAJAAkAgAARAIAAoAgAiA0F/Rg0BIAAgA0EBajYCACACIABBBGogARCZCSACKAIAIgFFDQIgAUHoAGoqAgAgACAAKAIAQX9qNgIAIAJBEGokAA8LEJ0MAAsQngwAC0GorMAAQcwAQZytwAAQogkAC5QBAgF/AX0gASoCJCEDQShBBBDFCyICRQRAQShBBEGgncMAKAIAIgBBrwYgABsRAAAACyACIAM4AiQgAiABKQIANwIAIAJBIGogAUEgaigCADYCACACQRhqIAFBGGopAgA3AgAgAkEQaiABQRBqKQIANwIAIAJBCGogAUEIaikCADcCACAAQdirwgA2AgQgACACNgIAC3gAAkACQCAARQ0AIAAoAgANASAAQX82AgAgAkUNACACKAIADQEgAkF/NgIAIANFDQAgAygCAA0BIANBfzYCACAAQQRqIAEgAkEEaiADQQRqIARBAEcQqAEgA0EANgIAIAJBADYCACAAQQA2AgAPCxCdDAALEJ4MAAt7AQJ/IwBBEGsiAiQAAkACQCAABEAgACgCACIDQX9GDQEgACADQQFqNgIAIAIgAEEEaiABEJgJIAIoAgAiAUUNAiABQYwCai0AACAAIAAoAgBBf2o2AgAgAkEQaiQADwsQnQwACxCeDAALQZCrwABBzQBBiKzAABCiCQALdwECfyMAQRBrIgIkAAJAAkAgAARAIAAoAgAiA0F/Rg0BIAAgA0EBajYCACACIABBBGogARCYCSACKAIAIgFFDQIgARD4CCAAIAAoAgBBf2o2AgAgAkEQaiQADwsQnQwACxCeDAALQZCrwABBzQBBiKzAABCiCQALowEBAX8jAEEQayIFJAACQAJAIAAEQCAAKAIADQEgAEF/NgIAIAUgAEEEaiABEPIGIAUoAgAiAUUNAiAFIAQ4AgggBSADOAIEIAUgAjgCACABLQCUAkECcQRAIAFBPGogBSkCADcCACABQcQAaiAFQQhqKAIANgIACyAAQQA2AgAgBUEQaiQADwsQnQwACxCeDAALQZCrwABBzQBBmKzAABCiCQALkwECAn8BfSMAQRBrIgIkAAJAAkAgAARAIAAoAgAiA0F/Rg0BIAAg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ACACOAIEIABBADYCACAADwsQnQwACxCeDAALQRBBBEGgncMAKAIAIgBBrwYgABsRAAAAC4IBAQN9AkACQCAABEAgACgCAEF/Rg0BIABBDGoqAgAhASAAQQhqKgIAIQIgAEEEaioCACEDQRBBBBDFCyIARQ0CIAAgAjgCDCAAIAM4AgggACABOAIEIABBADYCACAADwsQnQwACxCeDAALQRBBBEGgncMAKAIAIgBBrwYgABsRAAAAC4IBAQN9AkACQCAABEAgACgCAEF/Rg0BIABBDGoqAgAhASAAQQhqKgIAIQIgAEEEaioCACEDQRBBBBDFCyIARQ0CIAAgAjgCDCAAIAE4AgggACADOAIEIABBADYCACAADwsQnQwACxCeDAALQRBBBEGgncMAKAIAIgBBrwYgABsRAAAAC4IBAQN9AkACQCAABEAgACgCAEF/Rg0BIABBDGoqAgAhASAAQQhqKgIAIQIgAEEEaioCACEDQRBBBBDFCyIARQ0CIAAgAzgCDCAAIAE4AgggACACOAIEIABBADYCACAADwsQnQwACxCeDAALQRBBBEGgncMAKAIAIgBBrwYgABsRAAAAC4IBAQN9AkACQCAABEAgACgCAEF/Rg0BIABBDGoqAgAhASAAQQhqKgIAIQIgAEEEaioCACEDQRBBBBDFCyIARQ0CIAAgAzgCDCAAIAI4AgggACABOAIEIABBADYCACAADwsQnQwACxCeDAALQRBBBEGgncMAKAIAIgBBrwYgABsRAAAAC3MAIAFBATYCICABQSRqIAIpAgA3AgAgAUHMAGogAkEoaigCADYCACABQcQAaiACQSBqKQIANwIAIAFBPGogAkEYaikCADcCACABQTRqIAJBEGopAgA3AgAgAUEsaiACQQhqKQIANwIAIAAgAUGYARDkBhoLcgEBfyMAQSBrIgIkACACIAAgARC4AiAAQRhqIAJBGGooAgA2AgAgAEEQaiACQRBqKQMANwIAIABBCGogAkEIaikDADcCACAAIAIpAwA3AgAgAEE4akIANwIAIABBMGpCADcCACAAQgA3AiggAkEgaiQAC20BBX0gAioCACIFIAWUQwAAAACSIAIqAggiBiAGlJJDAAAAAJIQswEiB0MAAAAAXARAIAYgB5UgASoCBCIDlCEEIAUgB5UgA5QhAwsgACAEOAIIIAAgAzgC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r8AAEM0IAAtrACAAQgA3AhwgACABKQIANwIAIABBJGpCADcCACAAQSxqQgA3AgAgAEE0akIANwIAIABBPGpBADYCACAAQRhqIAFBGGooAgA2AgAgAEEQaiABQRBqKQIANwIAIABBCGogAUEIaikCADcCAAthAgF/An0CQCABKgIAIgMgACoCACIEjF0NACADIAReDQAgAUEEaioCACIDIAAqAgQiBIxdDQAgAyAEXg0AIAFBCGoqAgAiAyAAKgIIIgSMXUF/cyADIAReQQFzcSECCyACC6kBAQJ/IwBBEGsiAiQAIAAoAgAiAEEIaigCACEDIAAoAgAhACACIAGtQoCAgIAQQgAgASgCGEHp+8IAQQEgAUEcaigCACgCDBEFABuENwMAIAMEQANAIAIgADYCDCACIAJBDGoQmQUgAEEBaiEAIANBf2oiAw0ACwsgAi0ABAR/QQEFIAIoAgAiACgCGEHq+8IAQQEgAEEcaigCACgCDBEFAAsgAkEQaiQAC2kCAn8CfUMAAKBAIQRDAACgQEMAAIA/IABBH3UiASAAIAFqcyIBQQFxGyEDIAFBAk8EQANAIAMgBCAElCIElCADIAFBAnEbIQMgAUEDSyABQQF2IQENAAsLQwAAgD8gA5UgAyAAQQBIGwtyAQF/IwBBEGsiAyQAAkACQCAABEAgACgCAA0BIABBfzYCACADIABBBGogARDyBiADKAIAIgFFDQIgAUHlAWogAkEARzoAACAAQQA2AgAgA0EQaiQADwsQnQwACxCeDAALQZCrwABBzQBBmKzAABCiCQALbwEBfyMAQRBrIgMkAAJAAkAgAARAIAAoAgANASAAQX82AgAgAyAAQQRqIAEQ8gYgAygCACIBRQ0CIAFBvAFqIAI4AgAgAEEANgIAIANBEGokAA8LEJ0MAAsQngwAC0GQq8AAQc0AQZiswAAQogkAC40BAQF/IwBBEGsiAyQAAkACQCAABEAgACgCAA0BIABBfzYCACADIABBBGogARDuBiADKAIAIgFFDQIgAkEARyICIAEtAJQBQQBHcwRAIAEgAjoAlAEgASABKAIgQSByNgIgCyAAQQA2AgAgA0EQaiQADwsQnQwACxCeDAALQaiswABBzABBrK3AABCiCQALbwEEfyMAQRBrIgIkAAJAIAAEQCAAKAIAIgFBf0YNASAAIAFBAWo2AgAgACgCBCIBKAIAIQMgAkEIaiIEIAEoAgQ2AgQgBCADNgIAIAIoAgggACAAKAIAQX9qNgIAIAJBEGokAA8LEJ0MAAsQngwAC20BA38jAEEQayICJAACQCAABEAgACgCACIBQX9GDQEgACABQQFqNgIAIAAoAgQhASACQQhqIgMgAEEIaigCADYCBCADIAE2AgAgAigCCCAAIAAoAgBBf2o2AgAgAkEQaiQADwsQnQwACxCeDAAL1AEAIABC////+////79/NwMwIABC////+/f//7//ADcDICAAQv////v3//+//wA3AxAgAEL////79///v/8ANwMIIABC////+/f//7//ADcDACAAQdgAakL////7////v383AwAgAEHQAGpC////+////79/NwMAIABByABqQv////v///+/fzcDACAAQUBrQv////v///+/fzcDACAAQThqQv////v///+/fzcDACAAQShqQv////v3//+//wA3AwAgAEEYakL////79///v/8ANwMAC2kBAn8jAEEgayICJAAgAiABNgIEQQEhAwJAIAAoAgAgAUYNAEECIQMgACgCBCABRg0AQQAhAyAAKAIIIAFGDQAgAkEANgIIIABBCGogAkEEaiACQQhqQcjawQAQ4AgACyACQSBqJAAgAwt3AQF/IwBBEGsiAyQAIAMgACABEOcHIAMoAgAiAARAAkACQAJAAkAgACgCGEEBaw4DAwECAAsgAEEcaiACOgB4DAILIABBHGogAjoAmQEMAQsgAEEcaiACOgC1AQsgA0EQaiQADwtBgKrAAEHJAEGAq8AAEKIJAAthAgJ/AX0CQCAABEAgACgCACICQX9GDQEgACACQQFqNgIAIAAoAgQiA0GoAWooAgAgAUsEQCADQaABaigCACABQThsakEMaioCACEECyAAIAI2AgAgBA8LEJ0MAAsQngwAC2wAIAEgAikCADcCUCABQfgAaiACQShqKAIANgIAIAFB8ABqIAJBIGopAgA3AgAgAUHoAGogAkEYaikCADcCACABQeAAaiACQRBqKQIANwIAIAFB2ABqIAJBCGopAgA3AgAgACABQYgBEOQGGgtoAgF/BH0jAEEQayIDJAAgAioCACIFIAWUIAIqAgQiBiAGlJIgAioCCCIHIAeUkkMAAAAAkhCzASEEIAMgByAElTgCCCADIAYgBJU4AgQgAyAFIASVOAIAIAAgASADEKIFIANBEGokAAtrAQF8QX8CfyAAQwAAAD+SIAGVjiIAIAJBf2qzIgEgACABXRtDAAAAACAAQwAAAABeG7siA0QAAAAAAAAAAGYiAiADRAAAAAAAAPBBY3EEQCADqwwBC0EAC0EAIAIbIANEAADg////70FkGwtpACAAQgA3AgAgAEIANwIwIABCADcCQCAAQShqQgA3AgAgAEEgakIANwIAIABBGGpCADcCACAAQRBqQgA3AgAgAEEIakIANwIAIABBOGpCADcCACAAQcgAakIANwIAIABB0ABqQgA3AgALcAEBfyMAQTBrIgIkACACIAE2AgQgAiAANgIAIAJBHGpBAjYCACACQSxqQQI2AgAgAkIDNwIMIAJBlN/CADYCCCACQQI2AiQgAiACQSBqNgIYIAIgAkEEajYCKCACIAI2AiAgAkEIakHI38IAEOAKAAtwAQF/IwBBMGsiAiQAIAIgATYCBCACIAA2AgAgAkEcakECNgIAIAJBLGpBAjYCACACQgM3AgwgAkHs38IANgIIIAJBAjYCJCACIAJBIGo2AhggAiACQQRqNgIoIAIgAjYCICACQQhqQdy3wAAQ4AoAC20BAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakECNgIAIANCAjcCDCADQbD5wgA2AgggA0ECNgIkIAMgA0EgajYCGCADIAM2AiggAyADQQRqNgIgIANBCGogAhDgCgALbQEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQQI2AgAgA0ICNwIMIANBiIDDADYCCCADQQI2AiQgAyADQSBqNgIYIAMgA0EEajYCKCADIAM2AiAgA0EIaiACEOAKAAttAQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EcakECNgIAIANBLGpBAjYCACADQgI3AgwgA0GogMMANgIIIANBAjYCJCADIANBIGo2AhggAyADQQRqNgIoIAMgAzYCICADQQhqIAIQ4AoAC20BAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakECNgIAIANCAjcCDCADQdyAwwA2AgggA0ECNgIkIAMgA0EgajYCGCADIANBBGo2AiggAyAD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/AoACyAAQQA2AgggAEIANwIAIAAgAiADkjgCDAtrAQF/IwBBIGsiAiQAIAJBuNPCADYCBCACIAA2AgAgAkEIaiIAQRBqIAFBEGopAgA3AwAgAEEIaiABQQhqKQIANwMAIAIgASkCADcDCEEAIAJB4NHCACACQQRqQeDRwgAgAEG028IAEMEEAAtoAQF/IwBBIGsiAyQAIANBvNPCADYCBCADIAA2AgAgA0EIaiIAQRBqIAFBEGopAgA3AwAgAEEIaiABQQhqKQIANwMAIAMgASkCADcDCEEAIANB0NHCACADQQRqQdDRwgAgACACEMEEAAtoAQF/IwBBIGsiAyQAIAMgATYCBCADIAA2AgAgA0EIaiIAQRBqIAJBEGopAgA3AwAgAEEIaiACQQhqKQIANwMAIAMgAikCADcDCEEAIANBwPnCACADQQRqQcD5wgAgAEHU4MIAEMEEAAtcAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQQhqIgBBEGogAUEQaikCADcDACAAQQhqIAFBCGopAgA3AwAgAiABKQIANwMIIAJBBGpB3JjAACAAEO8CIAJBIGokAAtpAQF/IwBBEGsiAiQAAkACQCAABEAgACgCAA0BIABBfzYCACACIABBBGogARDyBiACKAIAIgFFDQIgARCnCiAAQQA2AgAgAkEQaiQADwsQnQwACxCeDAALQZCrwABBzQBBmKzAABCiCQALXwECfyMAQdABayIBJAACQCAABEAgACgCAA0BIABBADYCACABQegAaiICIABB6AAQ5AYaIAEgAkEEckHkABDkBiEBIAAQ4QEgARCgAyABQdABaiQADwsQnQwACxCeDAALcQECfyMAQbAIayIAJAAgAEEIaiIBEM8CIABBoARqIAFBkAQQ5AYaQZgEQQgQxQsiAUUEQEGYBEEIQaCdwwAoAgAiAEGvBiAAGxEAAAALIAFBADYCACABQQRqIABBnARqQZQEEOQGGiAAQbAIaiQAIAELawEBfSAAQawBaiABKQIANwIAIABBtAFqIAFBCGooAgA2AgACQCAALQCUAg0AIAJFDQAgAEGMAmotAAAEQCAAIAAoApACQQRyNgKQAgsgAEEAOgCMAiAAQYgCaiAAKgKEAosiAyADkjgCAAsLSQEBfyAAKAIAIgEEQCAAKAIEIAFBAnRBBGprEOEBCwJAIABB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AgRAIAEoAgQhA0EIQQQQxQsiAUUNASABIAM2AgQgASACNgIAIABBoNbCADYCBCAAIAE2AgAPCwALQQhBBEGgncMAKAIAIgBBrwYgABsRAAAAC0gBAX8CQCAABEAgACgCACIDQX9GDQEgACADQQFqNgIAIABBBGogASACEK8FIAAgACgCAEF/ajYCAEH9AXEPCxCdDAALEJ4MAAtEAQF/IwBBMGsiAyQAIANBCGogACAAQQxqIABBGGogARCvAgJ/IAMoAhhBBEcEQCADKgIIIAJfDAELQQALIANBMGokAAtTAQJ/IAAgACgCIEEQcjYCICAAKAIQIgQoAgAhAyAEIANBf2o2AgAgA0EBRgRAIABBEGooAgAgAEEUaigCABCGCAsgACABNgIQIABBFGogAjYCAAt+AQF/IwBBEGsiBSQAIAEoAgAgAigCACADKAIAIAQoAgAQCiEBQeiWwwAoAgAhAkHslsMAKAIAIQNB6JbDAEIANwIAIAVBCGoiBCADNgIEIAQgAkEBRjYCACAAIAUoAggiAkEARzYCACAAIAUoAgwgASACGzYCBCAFQRBqJAALTQEBfyAAKAIIIgQgAUsEQCAAKAIAIAFBJGxqQQAgBCABSxsiAEEgaigCACEBIAIgACAAKAIcIAEoAghBB2pBeHFqIAEgAygCEBECAAsLSwECfyAAQQRqKAIAIABBCGoiBCgCACIDayACSQRAIAAgAyACEOkGIAQoAgAhAwsgACgCACADaiABIAIQ5AYaIAQgAiADajYCAEEAC18BAn8jAEHQAGsiACQAIABBCGoQjQpByABBBBDFCyIBRQRAQcgAQQRBoJ3DACgCACIAQa8GIAAbEQAAAAsgAUEANgIAIAFBBGogAEEIakHEABDkBhogAEHQAGokACABC18BAn8jAEHwAGsiACQAIABBCGoQjgdB6ABBBBDFCyIBRQRAQegAQQRBoJ3DACgCACIAQa8GIAAbEQAAAAsgAUEANgIAIAFBBGogAEEIakHkABDkBhogAEHwAGokACABC0YBAX8CQCAABEAgACgCACICQX9GDQEgACACQQFqNgIAIABBBGogARCZBiAAIAAoAgBBf2o2AgBB/wFxDwsQnQwACxCeDAALXwECfyMAQdAAayIAJAAgAEEIahCnBkHIAEEEEMULIgFFBEBByABBBEGgncMAKAIA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AAAACyADIAI4AgwgAyABOAIIIAMgADgCBCADQQA2AgAgAws2ACAAQgA3A6ABIABBjAJqQQE6AAAgAEGIAmpBADYCACAAQagBakIANwMAIABBsAFqQgA3AwALKgECfxAbIgIQDSIDIAAgARATIAJBJE8EQCACEAALIANBJE8EQCADEAALCywBAX8jAEEgayIDJAAgA0EIaiAAIAEgAkEBEJYBIAMoAhggA0EgaiQAQQRHCywBAX8jAEEgayIDJAAgA0EIaiAAIAEgAkEBENMBIAMoAhggA0EgaiQAQQRHCysBAX8jAEEQayIDJAAgA0EIaiAAIAEgAkEBEGMgAygCCCADQRBqJABBAUYLLAEBfyMAQSBrIgMkACADQQhqIAAgASACQQEQiQIgAygCGCADQSBqJABBBEcLKwEBfyMAQRBrIgMkACADQQhqIAAgASACQQEQWCADKAIIIANBEGokAEEBRgssAQF/IwBBIGsiAyQAIANBCGogACABIAJBARDmASADKAIYIANBIGokAEEERwssAQF/IwBBIGsiAyQAIANBCGogACABIAJBARCKAiADKAIYIANBIGokAEEERwssAQF/IwBBIGsiAyQAIANBCGogACABIAJBARDbASADKAIYIANBIGokAEEERwssAQF/IwBBIGsiAyQAIANBCGogACABIAJBARD5ASADKAIYIANBIGokAEEERwssAQF/IwBBIGsiAyQAIANBCGogACABIAJBARDFASADKAIYIANBIGokAEEERwsrAQF/IwBBEGsiAyQAIANBCGogACABIAJBARBuIAMoAgggA0EQaiQAQQFGCywBAX8jAEEgayIDJAAgA0EIaiAAIAEgAkEBENIBIAMoAhggA0EgaiQAQQRHCywBAX8jAEEgayIDJAAgA0EIaiAAIAEgAkEBEJUCIAMoAhggA0EgaiQAQQRHCywBAX8jAEEgayIDJAAgA0EIaiAAIAEgAkEBEPABIAMoAhggA0EgaiQAQQRHC0cBAX9BFEEEEMULIgBFBEBBFEEEQaCdwwAoAgAiAEGvBiAAGxEAAAALIABCADcCACAAQYCAgPwDNgIQIABBCGpCADcCACAACz4AIAAoAgAhACABLQAAQRBxQQR2RQRAIAEtAABBIHFBBXZFBEAgACABEJMMDwsgACABELEHDwsgACABELAHCz4AIAAoAgAhACABLQAAQRBxQQR2RQRAIAEtAABBIHFBBXZFBEAgACABEKUKDwsgACABEKwHDwsgACABEKkHC0MAIAAoAgAhACABLQAAQRBxQQR2RQRAIAEtAABBIHFBBXZFBEAgADEAAEEBIAEQ9wQPCyAAIAEQqwcPCyAAIAEQqgcLKQEBfyMAQTBrIgIkACACQQhqIAAgAUEBEEggAi0AFCACQTBqJABBAEcLKQEBfyMAQTBrIgIkACACQQhqIAAgAUEBEE4gAi0AFCACQTBqJABBAEcLSAEBfSABKgIAIQJBBEEEEMULIgFFBEBBBEEEQaCdwwAoAgAiAEGvBiAAGxEAAAALIAEgAjgCACAAQdTmwQA2AgQgACABNgIACy0BAn0gACoCACIBIABBBGoqAgAiAiABIAJfGyIBIABBCGoqAgAiAiABIAJfGwsyAQF9IAAgASoCACICIAKUIAFBBGoqAgAiAiAClJIQswE4AgwgAEEANgIIIABCADcCAAtMAQF/QQxBBBDFCyICRQRAQQxBBEGgncMAKAIAIgBBrwYgABsRAAAACyACIAE4AgggAkKBgICAEDcCACAAQdTmwQA2AgQgACACNgIAC0wBAn0gACoCBCAAKgIAEKsMIgFDAAAAAGBFBEBBjJHCAEEoQZSSwgAQ2wkAC0PbD8k/IAGTIgIgAiABIAGSIgEgAiABXRsgASABXBsLKwACQCAAIAEQtgQiAUUNACABQXhqLQAEQQNxRQ0AIAFBACAAEOgGGgsgAQs0ACAAIAEoAhggAiADIAFBHGooAgAoAgwRBQA6AAggACABNgIAIAAgA0U6AAkgAEEANgIECysAAkAgAARAIAAoAgANASAAQQA2AgAgAEEMaiABOAIADwsQnQwACxCeDAALKwACQCAABEAgACgCAA0BIABBADYCACAAQRBqIAE4AgAPCxCdDAALEJ4MAAsrAAJAIAAEQCAAKAIADQEgAEEANgIAIABBFGogATgCAA8LEJ0MAAsQngwACysAAkAgAARAIAAoAgANASAAQQA2AgAgAEEkaiABOAIADwsQnQwACxCeDAALKwACQCAABEAgACgCAA0BIABBADYCACAAQShqIAE4AgAPCxCdDAALEJ4MAAsrAAJAIAAEQCAAKAIADQEgAEEANgIAIABBLGogATgCAA8LEJ0MAAsQngwACysAAkAgAARAIAAoAgANASAAQQA2AgAgAEEwaiABOAIADwsQnQwACxCeDAALKwACQCAABEAgACgCAA0BIABBADYCACAAQTRqIAE4AgAPCxCdDAALEJ4MAAsrAAJAIAAEQCAAKAIADQEgAEEANgIAIABBOGogATYCAA8LEJ0MAAsQngwACysAAkAgAARAIAAoAgANASAAQQA2AgAgAEE8aiABNgIADwsQnQwACxCeDAALKwACQCAABEAgACgCAA0BIABBADYCACAAQUBrIAE2AgAPCxCdDAALEJ4MAAssAAJAIAAEQCAAKAIADQEgAEEANgIAIABBxABqIAE2AgAPCxCdDAALEJ4MAAsrAAJAIAAEQCAAKAIADQEgAEEANgIAIABBCGogATgCAA8LEJ0MAAsQngwAC18BAX8gACgCACEBAkAgAC0ABA0AQbCdwwAoAgBB/////wdxRQ0AAn9BoKHDACgCAEEBRgRAQaShwwAoAgBFDAELQaChwwBCATcDAEEBCw0AIAFBAToAAQsgAUEAOgAAC0YAIwBBEGsiACQAIAAgAa1CgICAgBBCACABKAIYQfjRwgBBCyABQRxqKAIAKAIMEQUAG4Q3AwggAEEIahCgCCAAQRBqJAALNQEBfyMAQRBrIgIkACACIAE2AgwgAiAANgIIIAJBqNDCADYCBCACQYDQwgA2AgAgAhCZCgALRgAjAEEQayIAJAAgACABrUKAgICAEEIAIAEoAhhBwNPCAEELIAFBHGooAgAoAgwRBQAbhDcDCCAAQQhqEP0GIABBEGokAAsqACAAIAAoAgRBAXEgAXJBAnI2AgQgACABakEEaiIAIAAoAgBBAXI2AgALKQEBfwJAIABBf0YNACAAIAAoAgQiAUF/ajYCBCABQQFHDQAgABDhAQsLJgACQCAABEAgACgCAA0BIABBADYCACAAEOEBDwsQnQwACxCeDAALLgAgAEHcAGogASkCADcCACAAIAAoAiBBBHI2AiAgAEHkAGogAUEIaigCADYCAAssAQF/IwBBEGsiBCQAIAQgACkCADcDCCAEQQhqIAEgAiADEJ8DIARBEGokAAssAQF/IwBBEGsiBCQAIAQgACkCADcDCCAEQQhqIAEgAiADEIcDIARBEGokAAssAQF/IwBBEGsiBCQAIAQgACkCADcDCCAEQQhqIAEgAiADEJsBIARBEGokAAswAQF9IAAgAioCCCABKgIAIgOUOAIIIAAgAyACKgIElDgCBCAAIAMgAioCAJQ4AgALLgAgACABKQJYNwIAIABBEGogAUHoAGopAgA3AgAgAEEIaiABQeAAaikCADcCAAssACAAIAEpAgA3AgAgAEEQaiABQRBqKQIANwIAIABBCGogAUEIaikCADcCAAssACAAIAEpAiA3AgAgAEEQaiABQTBqKQIANwIAIABBCGogAUEoaikCADcCAAs1AQF/IwBBEGsiAiQAIAIgATYCDCACIAA2AgggAkHs+MIANgIEIAJB2PfCADYCACACEJkKAAs3ACAAQQM6ACAgAEKAgICAgAQ3AgAgACABNgIYIABBADYCECAAQQA2AgggAEEcakGwl8AANgIACy0BAX8jAEEQayIDJAAgAyABNgIMIAMgADYCCCADQQhqQZyXwABBACACEMQGAAslAAJAIAAEQCAAKAIAQX9GDQEgAEEMaioCAA8LEJ0MAAsQngwACyUAAkAgAARAIAAoAgBBf0YNASAAQRBqKgIADwsQnQwACxCeDAALJQACQCAABEAgACgCAEF/Rg0BIABBFGoqAgAPCxCdDAALEJ4MAAslAAJAIAAEQCAAKAIAQX9GDQEgAEEkaioCAA8LEJ0MAAsQngwACyUAAkAgAARAIAAoAgBBf0YNASAAQShqKgIADwsQnQwACxCeDAALJQACQCAABEAgACgCAEF/Rg0BIABBLGoqAgAPCxCdDAALEJ4MAAslAAJAIAAEQCAAKAIAQX9GDQEgAEEwaioCAA8LEJ0MAAsQngwACyUAAkAgAARAIAAoAgBBf0YNASAAQTRqKgIADwsQnQwACxCeDAALJQACQCAABEAgACgCAEF/Rg0BIABBOGooAgAPCxCdDAALEJ4MAAslAAJAIAAEQCAAKAIAQX9GDQEgAEE8aigCAA8LEJ0MAAsQngwACyUAAkAgAARAIAAoAgBBf0YNASAAQUBrKAIADwsQnQwACxCeDAALJgACQCAABEAgACgCAEF/Rg0BIABBxABqKAIADwsQnQwACxCeDAALKAACQCAABEAgACgCAA0BIABBADYCACAAIAE4AgQPCxCdDAALEJ4MAAslAAJAIAAEQCAAKAIAQX9GDQEgAEEYai0AAA8LEJ0MAAsQngwACyUAAkAgAARAIAAoAgBBf0YNASAAQQhqKgIADwsQnQwACxCeDAALPAEBf0EQQQQQxQsiAEUEQEEQQQRBoJ3DACgCACIAQa8GIAAbEQAAAAsgAEIANwIAIABBCGpCADcCACAACy0BAX8jAEEQayIDJAAgAyABNgIMIAMgADYCCCADQQhqQdi9wABBACACEMQGAAs4AAJAIAEtAABBEHFBBHZFBEAgAS0AAEEgcUEFdg0BIAAgARCTDA8LIAAgARCwBw8LIAAgARCxBwtFAQF/QQhBBBDFCyIBRQRAQQhBBEGgncMAKAIAIgBBrwYgABsRAAAACyABQoGAgIAQNwIAIABB1LXAADYCBCAAIAE2AgALLQEBfyMAQRBrIgMkACADIAE2AgwgAyAANgIIIANBCGpBwLLBAEEAIAIQxAYACyUBAX8jAEEgayICJAAgAiAAIAEQ9QIgAi0ADCACQSBqJABBAEcLIgACQCAAQQhqKAIARQ0AIABBBGooAgAiAEUNACAAEOEBCwstAQF/IwBBEGsiAyQAIAMgATYCDCADIAA2AgggA0EIakGw1sIAQQAgAhDEBgALNQEBfyMAQRBrIgMkACADIAI2AgggAyABNgIEIAMgADYCACADKAIAIAMoAgQgAygCCBDiCgALNQEBfyMAQRBrIgMkACADIAI2AgggAyABNgIEIAMgADYCACADKAIAIAMoAgQgAygCCBDzCgALNQEBfyMAQRBrIgMkACADIAI2AgggAyABNgIEIAMgADYCACADKAIAIAMoAgQgAygCCBD2CgALKQEBfyAAKAIIIgIgAU0EQCABIAJBvLTCABDNCAALIAAoAgAgAUEMbGoLJAEBfyMAQRBrIgIkACACIAAgAUEBENACIAItAAwgAkEQaiQACyMBAX8jAEEQayICJAAgAiAAIAFBARAqIAItAAwgAkEQaiQACyMBAX8jAEEQayICJAAgAiAAIAFBARApIAItAAwgAkEQaiQACyMBAX8jAEEQayICJAAgAiAAIAFBARAnIAItAAwgAkEQaiQACyMBAX8jAEEQayICJAAgAiAAIAFBARAsIAItAAwgAkEQaiQACyMBAX8jAEEQayICJAAgAiAAIAFBARAtIAItAAwgAkEQaiQACyMBAX8jAEEQayICJAAgAiAAIAFBARArIAItAAwgAkEQaiQACzUBAX8jAEEQayIDJAAgAyACNgIIIAMgATYCBCADIAA2AgAgAygCACADKAIEIAMoAggQ+QoACx8AAkAgAEEEaigCAEUNACAAKAIAIgBFDQAgABDhAQsLIgACQCAABEAgACgCAEF/Rg0BIAAqAgQPCxCdDAALEJ4MAAs7AQF/QRBBBBDFCyIARQRAQRBBBEGgncMAKAIAIgBBrwYgABsRAAAACyAAQoHKADcCBCAAQQA6AAAgAAsnACABIAIpAgA3AiwgAUE0aiACQQhqKAIANgIAIAAgAUGIARDkBhoLJwAgASACKQIANwI4IAFBQGsgAkEIaigCADYCACAAIAFBiAEQ5AYaCyEBAX8CQCAAKAIEIgFFDQAgAEEIaigCAEUNACABEOEBCwsfAAJAIAFBfE0EQCAAIAFBBCACELQLIgANAQsACyAACyUAIABFBEBBqK/BAEEwEJwMAAsgACACIAMgBCAFIAEoAhARHAALIAECfiAAKQMAIgJCP4ciAyACIAN8hSACQn9VIAEQ9wQLMgEBf0EEQQQQxQsiAEUEQEEEQQRBoJ3DACgCACIAQa8GIAAbEQAAAAsgAEEANgIAIAALIwAgAEUEQEGor8EAQTAQnAwACyAAIAIgAyAEIAEoAhARFQALIwAgAEUEQEGor8EAQTAQnAwACyAAIAIgAyAEIAEoAhARAgALIwAgAEUEQEGor8EAQTAQnAwACyAAIAIgAyAEIAEoAhAROAALIwAgAEUEQEGor8EAQTAQnAwACyAAIAIgAyAEIAEoAhARXgALJwBB0J3DACgCAEEBRwRAQdCdwwBCATcCAEHYncMAQQA2AgALEOgFCyEAIABFBEBBqK/BAEEwEJwMAAsgACACIAMgASgCEBEBAAskACAALQAARQRAIAFB/P7CAEEFEL0BDwsgAUH4/sIAQQQQvQELHQAgASgCAEUEQAALIABBqKjAADYCBCAAIAE2AgALHQAgASgCAEUEQAALIABBrOHAADYCBCAAIAE2AgALHwAgAEUEQEGor8EAQTAQnAwACyAAIAIgASgCEBEDAAsYAEEBQQIgACgCABAYIgBBAUYbQQAgABsLHQAgASgCAEUEQAALIABB7L7BADYCBCAAIAE2AgALIAAgAEGg+8EANgIEIAAgATYCACAAQQhqIAEqAhg4AgALIAAgAEGs+MEANgIEIAAgATYCACAAQQhqIAEqAgw4AgALIAAgAEGU/sEANgIEIAAgATYCACAAQQhqIAEqAiQ4AgALIAAgAEG0jsIANgIEIAAgATYCACAAQQhqIAEqAgg4AgALIAAgAEHAksIANgIEIAAgATYCACAAQQhqIAEqAgg4AgALIAAgAEHAi8IANgIEIAAgATYCACAAQQhqIAEqAmA4AgALEgBB0MjCAEEcQczJwgAQ2wkACxIAQcTbwgBBHEGw3MIAENsJAAs0ACAAQv////f//////gA3AgggAEL////3/////343AgAgAEEQakL////39/////4ANwIACx0AIABBrPjBADYCBCAAIAE2AgAgAEEIakEANgIACx0AIABBlP7BADYCBCAAIAE2AgAgAEEIakEANgIACx0AIABBoPvBADYCBCAAIAE2AgAgAEEIakEANgIACx0AIABBwIvCADYCBCAAIAE2AgAgAEEIakEANgIACx0AIABBtI7CADYCBCAAIAE2AgAgAEEIakEANgIACx0AIABBwJLCADYCBCAAIAE2AgAgAEEIakEANgIACzQAIABC////9//////+ADcCCCAAQv////f/////fjcCACAAQRBqQv////f3/////gA3AgALNAAgAEL////3//////4ANwIIIABC////9/////9+NwIAIABBEGpC////9/f////+ADcCAAsdACABKAIARQRAAAsgAEGg1sIANgIEIAAgATYCAAsaACAAQQA2AgggAEIANwIAIAAgASoCADgCDAscACABKAIYQaD4wgBBCyABQRxqKAIAKAIMEQUACxwAIAEoAhhBq/jCAEEOIAFBHGooAgAoAgwRBQALHAAgASgCGEHqj8MAQQUgAUEcaigCACgCDBEFAAsTACAAKAIAIgBBJE8EQCAAEAALCxgAIAAoAgAgASgCACACKAIAIAMoAgAQDAsNACAAIAEgAiADEJsCCxQAIAAoAgAgAEEIaigCACABEKUMCwwAIAEEQCAAEOEBCwsUACAAIAEgAkEAEIsDIABCAjcCEAsTACAAIAEgAkEAEFAgAEEDNgIQCxQAIAAgASACQQAQ0AIgAEEDNgIQCxQAIAAgASACQQAQrQIgAEEDNgIQCxMAIAAgASACQQAQKyAAQQM2AhALEwAgACABIAJBABAnIABBAzYCEAsTACAAIAEgAkEAECwgAEEDNgIQCxMAIAAgASACQQAQLSAAQQM2AhALEwAgACABIAJBABAqIABBAzYCEAsUACAAIAEqAgAgAUEEaioCABCBBAsTACAAIAIgASgCACABKAIIEKYBCxQAIAAoAgAgASAAKAIEKAIMEQMACxAAIABBATYCBCAAQQE2AgALDwAgACgCACABENQEGkEACwkAIAAgARC2BAsTACAAQey9wAA2AgQgACABNgIACxYAQeyWwwAgADYCAEHolsMAQQE2AgALEwAgAEHUssEANgIEIAAgATYCAAsTACAAQeSywQA2AgQgACABNgIACxMAIABB9LLBADYCBCAAIAE2AgALEwAgAEGEs8EANgIEIAAgATYCAAsTACAAQZSzwQA2AgQgACABNgIACxMAIABBpLPBADYCBCAAIAE2AgALEwAgAEG0s8EANgIEIAAgATYCAAsTACAAQcSzwQA2AgQgACABNgIACxMAIABB1LPBADYCBCAAIAE2AgALEwAgAEHks8EANgIEIAAgATYCAAsTACAAQfSzwQA2AgQgACABNgIACxMAIABBhLTBADYCBCAAIAE2AgALEwAgAEGUtMEANgIEIAAgATYCAAsTACAAQaS0wQA2AgQgACABNgIACxMAIABBtLTBADYCBCAAIAE2AgALEwAgAEHEtMEANgIEIAAgATYCAAsTACAAQdS0wQA2AgQgACABNgIACxMAIABB5LTBADYCBCAAIAE2AgALEwAgAEH0tMEANgIEIAAgATYCAAsTACAAQYS1wQA2AgQgACABNgIACxMAIABBlLXBADYCBCAAIAE2AgALEwAgAEGktcEANgIEIAAgATYCAAsTACAAQbS1wQA2AgQgACABNgIACwsAIACtQiCGQgOECwsAIACtQiCGQgSECwsAIACtQiCGQgKECwsAIACtQiCGQgGECxMAIABBvPXBADYCBCAAIAE2AgALEwAgAEGQ+MEANgIEIAAgATYCAAsTACAAQYT7wQA2AgQgACABNgIACxMAIABB+P3BADYCBCAAIAE2AgALEwAgAEG0/sEANgIEIAAgATYCAAsLACAArUIghkIJhAsTACAAQYiBwgA2AgQgACABNgIACwsAIACtQiCGQgaECxMAIABB1IPCADYCBCAAIAE2AgALCwAgAK1CIIZCBYQLEwAgAEGghsIANgIEIAAgATYCAAsLACAArUIghkIIhAsLACAArUIghkIKhAsTACAAQaSLwgA2AgQgACABNgIACwsAIACtQiCGQguECxMAIABBmI7CADYCBCAAIAE2AgALCwAgAK1CIIZCDIQLEwAgAEGkksIANgIEIAAgATYCAAsZACAAQoCAgIDw//+//wA3AgggAEIANwIACwsAIACtQiCGQgeECwsAIACtQiCGQg2ECxMAIABBxMfCADYCBCAAIAE2AgALCwAgAK1CIIZCDoQLEwAgAEHgx8IANgIEIAAgATYCAAsLACAArUIghkIPhAsTACAAQfzHwgA2AgQgACABNgIACwsAIACtQiCGQhCECxMAIABBmMjCADYCBCAAIAE2AgALCwAgAK1CIIZCEYQLEwAgAEG0yMIANgIEIAAgATYCAAsRACAAKAIAIAAoAgQgARD0AQsfACABKAIYIAAoAgAgACgCBCABQRxqKAIAKAIMEQUACxMAIABBoNbCADYCBCAAIAE2AgALEQAgASAAKAIAIAAoAgQQvQELDAAgACABIAIgAxBmCw0AIAAgASACIAMQhQELDAAgACABIAIgAxBsCwwAIAAgASACIAMQagsNACAAIAEgAiADEMQBCw0AIAAgASACIAMQzQELDQAgACABIAIgAxDcAQsLACAAIAIgAxCzBAsNACAAIAEgAiADEL0DCw0AIAAgASACIAMQzgILDQAgACoCBCAAKgIIkgsOACAAKAIAIAEQ2gRBAAsSAEHA3sIAQRFB1N7CABDbCQALDgAgACgCABoDQAwACwALDgAgADUCAEEBIAEQ9wQLDgAgACgCACABIAIQkAMLDgAgACkDAEEBIAEQ9wQLCwAjACAAaiQAIwALHAAgASgCGEGAgMAAQQ4gAUEcaigCACgCDBEFAAscACABKAIYQdypwABBFCABQRxqKAIAKAIMEQUACxwAIAEoAhhB/IXAAEERIAFBHGooAgAoAgwRBQALHAAgASgCGEHIhsAAQREgAUEcaigCACgCDBEFAAsOACABQfy9wABBAhC9AQsJACAAIAEQGgALDQBBwLHBAEEbEJwMAAsOAEHbscEAQc8AEJwMAAsIACAArUIghgsLACAAIAEgAhDSAgsLACAAIAEgAhD3AgsLACAAIAEgAhDrAgsNACAAKgIkQwAAAACSCwwAIAAoAgAgARCWCwsLACACIAAgARC9AQscACABKAIYQdDPwgBBBSABQRxqKAIAKAIMEQUACwcAIAEQuQkLCQAgAEEANgIACwcAIABBDGoLCQAgAEEANgIACwkAIAAgARDpAQsHACAAELoECwcAIAAqAgALBwAgACoCGAsHACAAKgIECxIAQYzZwgBBJUHg2cIAEIULAAsEAEEBCw0AQvT5nubuo6r5/gALDQBCxKCh8f+YoK+RfwsEACAACw0AQsaK2cWlo/73qH8LDQBCr5rW26n524juAAsMAEKJubrk+4maiEYLDQBCs8n1qZ/OyZSGfwsMAEKDpJC66deRoi8LDABCsY77+cG1zoA6Cw0AQuHukeq6vvKkhn8LDQBCs5TU4Kncj4iyfwsNAEKWm5rMu87vw+cACwwAQpP/ttT9v56oYgsNAELjuoeA3Yn6uNcACwwAQsmu26uE387oYAsNAELJ3dDD4crx6eIACw0AQvXnssy+pvisjX8LDABChZC2i9WZvLonCw0AQoqUv/yumOeG9wALDABCqfWwsLat6OECCw0AQtOBj5aDntPzqX8LDABCx9a7spqk8L0rCw0AQtvClJn3kYX7l38LDABCkOzCn83Upqs0Cw0AQs2nxt3ntd/0wQALBABBAAsEAEEACwQAQQALBwBD2w9JQAsEAEEBCwcAQ9sPyT8LBABBAgsEAEEECwcAQwAAAAALBABBAwsEAEEJCwQAQQYLBABBBQsEAEEICwQAQQoLBwBD2w9JPwsEAEELCwQAQQwLBwBD//9/fwsEAEEHCwQAQQ0LBABBDgsEAEEPCwQAQRALBABBEQsMAEKx9I3g3ZOn9y0LDABC+KbehOD3rN1xCwMAAQsDAAELAwABCwvElgMIAEGAgMAAC8rhAmEgbWF0cml4IGFycmF5L2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL25hbGdlYnJhLTAuMjkuMC9zcmMvYmFzZS9hcnJheV9zdG9yYWdlLnJzAA4AEABpAAAABQEAADIAAAAEAAAAAAAAAAEAAAAFAAAABAAAAAAAAAABAAAABQAAAAQAAAAAAAAAAQAAAAUAAAAEAAAAAAAAAAEAAAAFAAAABAAAAAAAAAABAAAABQAAAAQAAAAAAAAAAQAAAAUAAAAEAAAAAAAAAAEAAAAFAAAABAAAAAAAAAABAAAABQAAAC9ydXN0Yy81ZDY4MDQ0NjlkODBhYWYyNmY5ODA5MGFlMDE2YWY0NWUyNjdmNThmL2xpYnJhcnkvYWxsb2Mvc3JjL2NvbGxlY3Rpb25zL3ZlY19kZXF1ZS9pdGVyLnJzAAgBEABfAAAASgAAABQAAAAIARAAXwAAAFMAAAAUAAAAY2FwYWNpdHkgb3ZlcmZsb3dObyBlbGVtZW50IGF0IGluZGV4Q2Fubm90IGRlc2VyaWFsaXplIGN1c3RvbSBzaGFwZS4EAAAAAAAAAAEAAAAGAAAABAAAAAAAAAABAAAABwAAAEFsbG9jYXRpb24gZnJvbSBpdGVyYXRvciBlcnJvcjogdGhlIGl0ZXJhdG9yIGRpZCBub3QgeWllbGQgdGhlIGNvcnJlY3QgbnVtYmVyIG9mIGVsZW1lbnRzLi9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9uYWxnZWJyYS0wLjI5LjAvc3JjL2Jhc2UvZGVmYXVsdF9hbGxvY2F0b3IucnMARgIQAG0AAAB+AAAACQAAAHN0cnVjdCBCaXRWZWMgd2l0aCAyIGVsZW1lbnRzAAAAxAIQAB0AAAAEAAAACAAAAAQAAAAIAAAAYSB0dXBsZSBvZiBzaXplIDIAAAAEAAAAAAAAAAEAAAAJAAAAc3RydWN0IFRyaU1lc2ggd2l0aCAzIGVsZW1lbnRzAAAgAxAAHgAAAGEgdHVwbGUgb2Ygc2l6ZSAzAAAABAAAAAAAAAABAAAACgAAAAQAAAAAAAAAAQAAAAoAAABzdHJ1Y3QgQ29tcG91bmQgd2l0aCA0IGVsZW1lbnRzAHwDEAAfAAAAc3RydWN0IFBvbHlsaW5lIHdpdGggMyBlbGVtZW50cwCkAxAAHwAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9jcm9zc2JlYW0tY2hhbm5lbC0wLjUuMS9zcmMvd2FrZXIucnPMAxAAZAAAAFYAAAAUAAAAzAMQAGQAAABdAAAAGQAAAMwDEABkAAAAXwAAABkAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvY3Jvc3NiZWFtLWNoYW5uZWwtMC41LjEvc3JjL2ZsYXZvcnMvemVyby5ycwBgBBAAawAAAKwAAAA2AAAAYAQQAGsAAACzAAAANgAAAHZhcmlhbnQgaW5kZXggMCA8PSBpIDwgMuwEEAAYAAAAc3RydWN0IEVkZ2Ugd2l0aCAzIGVsZW1lbnRzAAwFEAAbAAAAc3RydWN0IENvbGxpZGVyIHdpdGggMTAgZWxlbWVudHMwBRAAIAAAAHN0cnVjdCBBcmVuYSB3aXRoIDQgZWxlbWVudHNYBRAAHAAAAHN0cnVjdCBSaWdpZEJvZHkgd2l0aCAxMyBlbGVtZW50cwAAAHwFEAAhAAAAc3RydWN0IEVkZ2Ugd2l0aCA0IGVsZW1lbnRzAKgFEAAbAAAAdmFyaWFudCBpbmRleCAwIDw9IGkgPCAxOQAAAMwFEAAZAAAAc3RydWN0IENvYXJlbmEgd2l0aCAxIGVsZW1lbnQAAADwBRAAHQAAAHN0cnVjdCBHcmFwaCB3aXRoIDIgZWxlbWVudHMYBhAAHAAAAHN0cnVjdCBDb2xsaWRlclNldCB3aXRoIDMgZWxlbWVudHMAADwGEAAiAAAAc3RydWN0IENvbnRhY3REYXRhIHdpdGggMyBlbGVtZW50cwAAaAYQACIAAABzdHJ1Y3QgQ29udGFjdFBhaXIgd2l0aCA1IGVsZW1lbnRzAACUBhAAIgAAAHN0cnVjdCBRQlZIIHdpdGggNCBlbGVtZW50cwDABhAAGwAAAHN0cnVjdCBTb2x2ZXJDb250YWN0IHdpdGggOSBlbGVtZW50c+QGEAAkAAAAdmFyaWFudCBpbmRleCAwIDw9IGkgPCA0EAcQABgAAABzdHJ1Y3QgUmlnaWRCb2R5U2V0IHdpdGggMiBlbGVtZW50cwAwBxAAIwAAAHN0cnVjdCBJc2xhbmRNYW5hZ2VyIHdpdGggNCBlbGVtZW50c1wHEAAkAAAAc3RydWN0IENvbnZleFBvbHloZWRyb24gd2l0aCA4IGVsZW1lbnRzAIgHEAAnAAAAc3RydWN0IFJvdW5kU2hhcGUgd2l0aCAyIGVsZW1lbnRzAAAAuAcQACEAAABzdHJ1Y3QgQmFsbEpvaW50IHdpdGggMTUgZWxlbWVudHMAAADkBxAAIQAAAHN0cnVjdCBDb250YWN0TWFuaWZvbGREYXRhIHdpdGggOCBlbGVtZW50cwAAEAgQACoAAABzdHJ1Y3QgUmV2b2x1dGVKb2ludCB3aXRoIDIwIGVsZW1lbnRzAAAARAgQACUAAABzdHJ1Y3QgTWFzc1Byb3BlcnRpZXMgd2l0aCA0IGVsZW1lbnRzAAAAdAgQACUAAABzdHJ1Y3QgSXNvbWV0cnkgd2l0aCAyIGVsZW1lbnRzAKQIEAAfAAAAc3RydWN0IFByaXNtYXRpY0pvaW50IHdpdGggMTcgZWxlbWVudHMAAMwIEAAmAAAAc3RydWN0IFNBUEF4aXMgd2l0aCAzIGVsZW1lbnRzAAD8CBAAHgAAAHN0cnVjdCBTQVBMYXllciB3aXRoIDYgZWxlbWVudHMAJAkQAB8AAABzdHJ1Y3QgU0FQUHJveGllcyB3aXRoIDIgZWxlbWVudHMAAABMCRAAIQAAAHN0cnVjdCBTQVBSZWdpb24gd2l0aCA3IGVsZW1lbnRzeAkQACAAAABzdHJ1Y3QgQnJvYWRQaGFzZSB3aXRoIDcgZWxlbWVudHMAAACgCRAAIQAAAHZhcmlhbnQgaW5kZXggMCA8PSBpIDwgNswJEAAYAAAAc3RydWN0IFRyaU1lc2hTaGFwZUNvbnRhY3RNYW5pZm9sZHNXb3Jrc3BhY2Ugd2l0aCAzIGVsZW1lbnRz7AkQADwAAABzdHJ1Y3QgSGVpZ2h0RmllbGRTaGFwZUNvbnRhY3RNYW5pZm9sZHNXb3Jrc3BhY2Ugd2l0aCAyIGVsZW1lbnRzMAoQAEAAAABzdHJ1Y3QgQ29udGFjdE1hbmlmb2xkIHdpdGggOCBlbGVtZW50cwAAeAoQACYAAABzdHJ1Y3QgQ29tcG9zaXRlU2hhcGVTaGFwZUNvbnRhY3RNYW5pZm9sZHNXb3Jrc3BhY2Ugd2l0aCAyIGVsZW1lbnRzAKgKEABDAAAAc3RydWN0IEhlaWdodEZpZWxkQ29tcG9zaXRlU2hhcGVDb250YWN0TWFuaWZvbGRzV29ya3NwYWNlIHdpdGggMiBlbGVtZW50cwAAAPQKEABJAAAAc3RydWN0IENvbXBvc2l0ZVNoYXBlQ29tcG9zaXRlU2hhcGVDb250YWN0TWFuaWZvbGRzV29ya3NwYWNlIHdpdGggMiBlbGVtZW50c0gLEABMAAAABAAAAAgAAAAEAAAACwAAAAwAAAANAAAADAAAAAQAAAAOAAAADwAAABAAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5L3J1c3RjLzVkNjgwNDQ2OWQ4MGFhZjI2Zjk4MDkwYWUwMTZhZjQ1ZTI2N2Y1OGYvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzAAD/CxAASwAAAE8JAAAOAAAABAAAAAQAAAAEAAAAEQAAABIAAAATAAAAYXNzZXJ0aW9uIGZhaWxlZDogbWlkIDw9IHNlbGYubGVuKCkvcnVzdGMvNWQ2ODA0NDY5ZDgwYWFmMjZmOTgwOTBhZTAxNmFmNDVlMjY3ZjU4Zi9saWJyYXJ5L2NvcmUvc3JjL3NsaWNlL21vZC5yc5cMEABNAAAA/wUAAAkAAACXDBAATQAAAOEFAAAJAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZQAEAAAAAAAAAAEAAAAUAAAAL3J1c3RjLzVkNjgwNDQ2OWQ4MGFhZjI2Zjk4MDkwYWUwMTZhZjQ1ZTI2N2Y1OGYvbGlicmFyeS9hbGxvYy9zcmMvY29sbGVjdGlvbnMvdmVjX2RlcXVlL21vZC5ycwAAQA0QAF4AAAAOAgAACQAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuY2FwKCkgPT0gb2xkX2NhcCAqIDIAQA0QAF4AAAB4CAAADQAAAAQAAAAAAAAAAQAAAAAAAABpbnZhbGlkIHZhbHVlOiAsIGV4cGVjdGVkIAAA/A0QAA8AAAALDhAACwAAAGludmFsaWQgbGVuZ3RoIAAoDhAADwAAAAsOEAALAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC43LjEvc3JjL3BhcnRpdGlvbmluZy9xYnZoLnJzAABIDhAAZgAAAOkBAAAYAAAASA4QAGYAAACvAQAAGAAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9pbmRleG1hcC0xLjcuMC9zcmMvbWFwL2NvcmUucnMAANAOEABeAAAAKgAAACMAAADQDhAAXgAAACIAAAAPAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL25hbGdlYnJhLTAuMjkuMC9zcmMvYmFzZS9jb25zdHJ1Y3Rpb24ucnNNYXRyaXggaW5pdC4gZXJyb3I6IHRoZSBzbGljZSBkaWQgbm90IGNvbnRhaW4gdGhlIHJpZ2h0IG51bWJlciBvZiBlbGVtZW50cy4AUA8QAGgAAABgAAAACQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjExLjEvc3JjL2RhdGEvY29tcG9uZW50X3NldC5ycwAAABQQEABpAAAAGwAAABoAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4xL3NyYy9kYXRhL2FyZW5hLnJzAAAAkBAQAGEAAAAHAQAAHgAAAGNvcnJ1cHQgZnJlZSBsaXN0AAAAkBAQAGEAAAAIAQAAKwAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjExLjEvc3JjL2RhdGEvZ3JhcGgucnMAAAAoERAAYQAAAJIAAAAYAAAAYXNzZXJ0aW9uIGZhaWxlZDogc2VsZi5lZGdlcy5sZW4oKSAhPSBjcmF0ZTo6SU5WQUxJRF9VU0laRQAAKBEQAGEAAADcAAAACQAAAEdyYXBoOjphZGRfZWRnZTogbm9kZSBpbmRpY2VzIG91dCBvZiBib3VuZHMAKBEQAGEAAADkAAAAGwAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYubm9kZXMubGVuKCkgIT0gY3JhdGU6OklOVkFMSURfVVNJWkUAACgREABhAAAAswAAAAkAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4xL3NyYy9kYXRhL2NvYXJlbmEucnMAcBIQAGMAAABQAAAAGQAAAHASEABjAAAAQQAAAAkAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4xL3NyYy9keW5hbWljcy9qb2ludC9qb2ludF9zZXQucnMA9BIQAG8AAADWAAAACQAAAPQSEABvAAAAKAEAAA0AAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4xL3NyYy9nZW9tZXRyeS9pbnRlcmFjdGlvbl9ncmFwaC5ycwAAAIQTEABxAAAAfAAAAD8AAACEExAAcQAAAH0AAAAOAAAAhBMQAHEAAAB9AAAAJwAAAAQAAAAIAAAABAAAABUAAAAvcnVzdGMvNWQ2ODA0NDY5ZDgwYWFmMjZmOTgwOTBhZTAxNmFmNDVlMjY3ZjU4Zi9saWJyYXJ5L2FsbG9jL3NyYy9jb2xsZWN0aW9ucy92ZWNfZGVxdWUvcmluZ19zbGljZXMucnMAADgUEABmAAAAIAAAAA4AAABFeHBlY3RlZCAgY29tcG9uZW50cywgZm91bmQgsBQQAAkAAAC5FBAAEwAAAGFuIGFycmF5IG9mIGxlbmd0aCAzBAAAAAAAAAABAAAAFgAAAEludmFsaWQgSm9pbnQgcmVmZXJlbmNlLiBJdCBtYXkgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGh5c2ljcyBXb3JsZC5yYXBpZXIzZC8uLi9zcmMvZHluYW1pY3Mvam9pbnRfc2V0LnJzAABJFRAAJQAAAA0AAAAOAAAASRUQACUAAAAVAAAADgAAAEludmFsaWQgUmlnaWRCb2R5IHJlZmVyZW5jZS4gSXQgbWF5IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBoeXNpY3MgV29ybGQucmFwaWVyM2QvLi4vc3JjL2R5bmFtaWNzL3JpZ2lkX2JvZHlfc2V0LnJzAN0VEAAqAAAAKgAAADgAAADdFRAAKgAAADEAAAA8AAAASW52YWxpZCBDb2xsaWRlciByZWZlcmVuY2UuIEl0IG1heSBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwaHlzaWNzIFdvcmxkLnJhcGllcjNkLy4uL3NyYy9nZW9tZXRyeS9jb2xsaWRlcl9zZXQucnN0FhAAKAAAAA8AAAAOAAAAdBYQACgAAAAXAAAADgAAADAuNy42aW52YWxpZCBlbnVtIHZhbHVlIHBhc3NlZAAASRUQACUAAAApAAAAOQAAAEkVEAAlAAAAKgAAADkAAAByYXBpZXIzZC8uLi9zcmMvZHluYW1pY3MvcmlnaWRfYm9keS5ycwAA/BYQACYAAAAkAQAAHwAAAE5vdCB5ZXQgaW1wbGVtZW50ZWQucmFwaWVyM2QvLi4vc3JjL2dlb21ldHJ5L2NvbGxpZGVyLnJzSBcQACQAAACLAAAAOQAAAHJhcGllcjNkLy4uL3NyYy9nZW9tZXRyeS9uYXJyb3dfcGhhc2UucnN8FxAAKAAAAM8AAAASAAAAfBcQACgAAADTAAAAEgAAAHwXEAAoAAAA1wAAABIAAAByYXBpZXIzZC8uLi9zcmMvZ2VvbWV0cnkvc2hhcGUucnMAAADUFxAAIQAAAG8AAAA6AAAA1BcQACEAAABvAAAAQAAAANQXEAAhAAAAeQAAADgAAADUFxAAIQAAAHkAAAA+AAAA1BcQACEAAAC4AAAAQAAAANQXEAAhAAAAuAAAAEYAAADUFxAAIQAAAMMAAABAAAAA1BcQACEAAADDAAAARgAAAAQAAAAAAAAAAQAAABcAAAAYAAAAGQAAAAQAAAAAAAAAAQAAAAQAAAAAAAAAAQAAAJAYEAAaAAAAGwAAABwAAAAMAAAABAAAAB0AAAAeAAAAHwAAACAAAAAQAAAABAAAACAAAAAQAAAABAAAAMwYEAAhAAAAIgAAAHN0cnVjdCBEZXNlcmlhbGl6YWJsZVdvcmxkIHdpdGggOCBlbGVtZW50cwAA8BgQACoAAAACAAAAAwAAAAAAAAABAAAAAAAAAMEAAAAAAAAAfAAAAAAAAADpAAAAAAAAABUBAAAAAAAA/////0ludmFsaWQgc2l6ZSA6IHNpemVzIG11c3QgZml0IGluIGEgdXNpemUgKDAgdG8gKVwZEAANAAAAaRkQACIAAACLGRAAAQAAAFRoZSBsb29zZW5pbmcgbWFyZ2luIG11c3QgYmUgcG9zaXRpdmUuL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC43LjEvc3JjL2JvdW5kaW5nX3ZvbHVtZS9hYWJiLnJzAMoZEABpAAAAugEAAAkAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjcuMS9zcmMvcXVlcnkvZGVmYXVsdF9xdWVyeV9kaXNwYXRjaGVyLnJzAEQaEABzAAAA4AEAAB4AAAAlAAAAAAAAAAEAAAAlAAAAAAAAAAEAAADIGhAAJgAAACcAAAAoAAAAKQAAACoAAAAAAAAAKwAAACwAAAAtAAAARBoQAHMAAAC5AQAAMQAAAEQaEABzAAAApgEAADEAAABEGhAAcwAAABACAAAvAAAARBoQAHMAAAAfAgAALwAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9jcm9zc2JlYW0tY2hhbm5lbC0wLjUuMS9zcmMvd2FrZXIucnNIGxAAZAAAAFYAAAAUAAAASBsQAGQAAABdAAAAGQAAAEgbEABkAAAAXwAAABkAAABIGxAAZAAAAEUAAAAoAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZS9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9jcm9zc2JlYW0tY2hhbm5lbC0wLjUuMS9zcmMvY2hhbm5lbC5ycwAAFBwQAGYAAACwAQAALQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9jcm9zc2JlYW0tY2hhbm5lbC0wLjUuMS9zcmMvY29udGV4dC5ycwAAjBwQAGYAAAAxAAAAHgAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9jcm9zc2JlYW0tY2hhbm5lbC0wLjUuMS9zcmMvZmxhdm9ycy9saXN0LnJzAAQdEABrAAAAAwEAAEMAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvY3Jvc3NiZWFtLWNoYW5uZWwtMC41LjEvc3JjL2ZsYXZvcnMvemVyby5ycwCAHRAAawAAANsAAAAtAAAAgB0QAGsAAAD5AAAAQAAAAIAdEABrAAAA+gAAAEcAAACAHRAAawAAAPQAAABAAAAAgB0QAGsAAAD1AAAARwAAAIAdEABrAAAA8gAAACYAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvY3Jvc3NiZWFtLWNoYW5uZWwtMC41LjEvc3JjL2ZsYXZvcnMvYXJyYXkucnNMHhAAbAAAAIABAAA3AAAATB4QAGwAAAB+AQAAKgAAACUAAAAIAAAABAAAAC4AAAAvAAAAJQAAACQAAAAEAAAAMAAAACgpAAAlAAAABAAAAAQAAAAxAAAAYXNzZXJ0aW9uIGZhaWxlZDogbWlkIDw9IHNlbGYubGVuKCkvcnVzdGMvNWQ2ODA0NDY5ZDgwYWFmMjZmOTgwOTBhZTAxNmFmNDVlMjY3ZjU4Zi9saWJyYXJ5L2NvcmUvc3JjL3NsaWNlL21vZC5yczMfEABNAAAA/wUAAAkAAAAzHxAATQAAADUCAAAkAAAAAAAAAGNhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWUAJQAAAAAAAAABAAAAMgAAACUAAAAEAAAABAAAADMAAAAlAAAABAAAAAQAAAA0AAAAJQAAAAQAAAAEAAAANQAAAGNhcGFjaXR5IG92ZXJmbG93L3J1c3RjLzVkNjgwNDQ2OWQ4MGFhZjI2Zjk4MDkwYWUwMTZhZjQ1ZTI2N2Y1OGYvbGlicmFyeS9hbGxvYy9zcmMvY29sbGVjdGlvbnMvdmVjX2RlcXVlL21vZC5yc2Fzc2VydGlvbiBmYWlsZWQ6IHNlbGYuY2FwKCkgPT0gb2xkX2NhcCAqIDIAACEgEABe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YXAtMS43LjAvc3JjL21hcC5yc3suEABZAAAAhgEAABoAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvaW5kZXhtYXAtMS43LjAvc3JjL21hcC9jb3JlLnJzAADkLhAAXgAAACoAAAAjAAAAaW5kZXggbm90IGZvdW5kAOQuEABeAAAANgAAAAoAAADkLhAAXgAAAHcCAAAOAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2luZGV4bWFwLTEuNy4wL3NyYy9tYXAvY29yZS9yYXcucnMAAIQvEABiAAAAdgAAAAoAAADkLhAAXgAAACIAAAAPAAAATWF0cml4IGluZGV4IG91dCBvZiBib3VuZHMuSW5kZXggb3V0IG9mIGJvdW5kcy4vaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvbmFsZ2VicmEtMC4yOS4wL3NyYy9iYXNlL2luZGV4aW5nLnJzADcwEABkAAAAVwEAABoAAAAlAAAACAAAAAQAAABgAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMS9zcmMvZGF0YS9hcmVuYS5ycwAAALwwEABhAAAABwEAAB4AAABjb3JydXB0IGZyZWUgbGlzdAAAALwwEABhAAAACAEAACsAAABpbnNlcnRpbmcgd2lsbCBhbHdheXMgc3VjY2VlZCBhZnRlciByZXNlcnZpbmcgYWRkaXRpb25hbCBzcGFjZQAAvDAQAGEAAABJAQAADgAAAE5vIGVsZW1lbnQgYXQgaW5kZXgvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4xL3NyYy9kYXRhL2NvYXJlbmEucnMAALcxEABjAAAAQQAAAAkAAABDYW5ub3QgaW5kZXggdGhlIHNhbWUgb2JqZWN0IHR3aWNlLgAsMhAAIwAAALcxEABjAAAAYwAAAAkAAAC3MRAAYwAAAGwAAAATAAAAtzEQAGMAAABsAAAAIgAAALcxEABjAAAAdQAAABMAAAC3MRAAYwAAAHUAAAArAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMS9zcmMvZGF0YS9jb21wb25lbnRfc2V0LnJzAAAAqDIQAGkAAAAbAAAAGgAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjExLjEvc3JjL2RhdGEvZ3JhcGgucnMAAAAkMxAAYQAAAJIAAAAYAAAAYXNzZXJ0aW9uIGZhaWxlZDogc2VsZi5ub2Rlcy5sZW4oKSAhPSBjcmF0ZTo6SU5WQUxJRF9VU0laRQAAJDMQAGEAAACzAAAACQAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuZWRnZXMubGVuKCkgIT0gY3JhdGU6OklOVkFMSURfVVNJWkUAACQzEABhAAAA3AAAAAkAAABHcmFwaDo6YWRkX2VkZ2U6IG5vZGUgaW5kaWNlcyBvdXQgb2YgYm91bmRzACQzEABhAAAA5AAAABsAAAAkMxAAYQAAAA8BAAAcAAAAQ291bGQgbm90IGZpbmQgdGhlIENvbGxpZGVyUGFyZW50IGNvbXBvbmVudC4vaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4xL3NyYy9keW5hbWljcy9jY2QvY2NkX3NvbHZlci5ycwAAqDQQAG4AAACvAAAAGgAAAKg0EABuAAAAQwEAABoAAACoNBAAbgAAADACAABLAAAAqDQQAG4AAABCAgAASwAAAGFzc2VydGlvbiBmYWlsZWQ6IHRvaS50b2kgPD0gZHQAqDQQAG4AAACeAQAADQAAAKg0EABuAAAAqAEAADEAAACoNBAAbgAAAKsBAAAxAAAAqDQQAG4AAAC/AQAALgAAAKg0EABuAAAAwAEAADsAAACoNBAAbgAAAMQBAAAuAAAAqDQQAG4AAADFAQAAOwAAAKg0EABuAAAAzQEAAEgAAABhc3NlcnRpb24gZmFpbGVkOiBzdGFydF90aW1lIDw9IGVuZF90aW1lL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMS9zcmMvZHluYW1pY3MvY2NkL3RvaV9lbnRyeS5ycwAAACA2EABtAAAAUAAAAAkAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4xL3NyYy9keW5hbWljcy9pc2xhbmRfbWFuYWdlci5ycwAAoDYQAG4AAAB+AAAAHAAAAKA2EABuAAAAfgAAADwAAACgNhAAbgAAAH8AAAAKAAAAVGhlIG1pbmltdW0gaXNsYW5kIHNpemUgbXVzdCBiZSBhdCBsZWFzdCAxLgCgNhAAbgAAALwAAAAJAAAAoDYQAG4AAAAjAQAAUAAAAKA2EABuAAAAPQEAACkAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4xL3NyYy9keW5hbWljcy9qb2ludC9qb2ludF9zZXQucnMAnDcQAG8AAADmAAAAIAAAAJw3EABvAAAAAwEAABEAAACcNxAAbwAAAFABAABXAAAAnDcQAG8AAABVAQAAGQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjExLjEvc3JjL2R5bmFtaWNzL3JpZ2lkX2JvZHlfY29tcG9uZW50cy5ycwAAAEw4EAB1AAAA1AIAABIAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4xL3NyYy9keW5hbWljcy9zb2x2ZXIvY2F0ZWdvcml6YXRpb24ucnMAAADUOBAAdQAAAA0AAAAZAAAA1DgQAHUAAAAfAAAAFgAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjExLjEvc3JjL2R5bmFtaWNzL3NvbHZlci9qb2ludF9jb25zdHJhaW50L2JhbGxfcG9zaXRpb25fY29uc3RyYWludC5yc2w5EACQAAAAQgAAAB0AAABsORAAkAAAAEMAAAAdAAAAbDkQAJAAAACTAAAACQAAAGw5EACQAAAAlAAAAAkAAABsORAAkAAAANIAAAAdAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMS9zcmMvZHluYW1pY3Mvc29sdmVyL2pvaW50X2NvbnN0cmFpbnQvYmFsbF92ZWxvY2l0eV9jb25zdHJhaW50LnJzTDoQAJAAAAD0AAAAHgAAAEw6EACQAAAA9QAAAB4AAABMOhAAkAAAAE4BAAAeAAAATDoQAJAAAABPAQAAHgAAAEw6EACQAAAAVQEAAAkAAABMOhAAkAAAAFYBAAAJAAAATDoQAJAAAABaAQAAGgAAAEw6EACQAAAAQQIAAB4AAABMOhAAkAAAAIICAAAeAAAATDoQAJAAAACIAgAACQAAAEw6EACQAAAAjQIAABoAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4xL3NyYy9keW5hbWljcy9zb2x2ZXIvam9pbnRfY29uc3RyYWludC9maXhlZF9wb3NpdGlvbl9jb25zdHJhaW50LnJzAAAAjDsQAJEAAAA5AAAAHQAAAIw7EACRAAAAOgAAAB0AAACMOxAAkQAAAFUAAAAJAAAAjDsQAJEAAABWAAAACQAAAIw7EACRAAAAhgAAAB0AAABTaW5ndWxhciBzeXN0ZW0uL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMS9zcmMvZHluYW1pY3Mvc29sdmVyL2pvaW50X2NvbnN0cmFpbnQvZml4ZWRfdmVsb2NpdHlfY29uc3RyYWludC5ycwAAAIA8EACRAAAAcgAAACYAAACAPBAAkQAAAKgAAAAeAAAAgDwQAJEAAACpAAAAHgAAAIA8EACRAAAAwAAAAB4AAACAPBAAkQAAAMEAAAAeAAAAgDwQAJEAAADpAAAAGgAAAIA8EACRAAAATgEAACYAAACAPBAAkQAAAH4BAAAeAAAAgDwQAJEAAACPAQAAHgAAAIA8EACRAAAArwEAABoAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4xL3NyYy9keW5hbWljcy9zb2x2ZXIvam9pbnRfY29uc3RyYWludC9qb2ludF9jb25zdHJhaW50LnJztD0QAIgAAABeAQAAMgAAALQ9EACIAAAAhgEAADIAAAC0PRAAiAAAAMIBAAAyAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMS9zcmMvZHluYW1pY3Mvc29sdmVyL2pvaW50X2NvbnN0cmFpbnQvam9pbnRfcG9zaXRpb25fY29uc3RyYWludC5ycwAAAGw+EACRAAAAFQEAADIAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4xL3NyYy9keW5hbWljcy9zb2x2ZXIvam9pbnRfY29uc3RyYWludC9wcmlzbWF0aWNfcG9zaXRpb25fY29uc3RyYWludC5ycwAAABA/EACVAAAAQQAAAB0AAAAQPxAAlQAAAEIAAAAdAAAAED8QAJUAAABnAAAACQAAABA/EACVAAAAaAAAAAkAAAAQPxAAlQAAAJwAAAAdAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMS9zcmMvZHluYW1pY3Mvc29sdmVyL2pvaW50X2NvbnN0cmFpbnQvcHJpc21hdGljX3ZlbG9jaXR5X2NvbnN0cmFpbnQucnMAAAD4PxAAlQAAADcBAAAeAAAA+D8QAJUAAAA4AQAAHgAAAPg/EACVAAAAwQEAAB4AAAD4PxAAlQAAAMIBAAAeAAAA+D8QAJUAAADNAQAAGgAAAPg/EACVAAAA+QIAAB4AAAD4PxAAlQAAAEkDAAAeAAAA+D8QAJUAAABUAwAAGgAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjExLjEvc3JjL2R5bmFtaWNzL3NvbHZlci9qb2ludF9jb25zdHJhaW50L3Jldm9sdXRlX3Bvc2l0aW9uX2NvbnN0cmFpbnQucnMQQRAAlAAAAEwAAAAdAAAAEEEQAJQAAABNAAAAHQAAABBBEACUAAAAYwAAAC0AAAAQQRAAlAAAAJsAAAAJAAAAEEEQAJQAAACcAAAACQAAABBBEACUAAAA7QAAAB0AAAAQQRAAlAAAAPwAAAAtAAAAEEEQAJQAAAAlAQAACQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjExLjEvc3JjL2R5bmFtaWNzL3NvbHZlci9qb2ludF9jb25zdHJhaW50L3Jldm9sdXRlX3ZlbG9jaXR5X2NvbnN0cmFpbnQucnMkQhAAlAAAAAsBAAAeAAAAJEIQAJQAAAAMAQAAHgAAACRCEACUAAAAgAEAAB4AAAAkQhAAlAAAAIEBAAAeAAAAJEIQAJQAAACMAQAAGgAAACRCEACUAAAAiAIAAB4AAAAkQhAAlAAAANsCAAAeAAAAJEIQAJQAAADmAgAAGgAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjExLjEvc3JjL2R5bmFtaWNzL3NvbHZlci9wb3NpdGlvbl9jb25zdHJhaW50LnJzAAA4QxAAegAAACAAAAAtAAAAOEMQAHoAAABCAAAAMQAAADhDEAB6AAAAQwAAADEAAAA4QxAAegAAAH4AAAAYAAAAOEMQAHoAAAB/AAAAGAAAADhDEAB6AAAAgwAAACAAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4xL3NyYy9keW5hbWljcy9zb2x2ZXIvcG9zaXRpb25fZ3JvdW5kX2NvbnN0cmFpbnQucnMAAAAURBAAgQAAACcAAAAoAAAAFEQQAIEAAAApAAAAKAAAABREEACBAAAAWgAAABgAAAAURBAAgQAAAF4AAAAgAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMS9zcmMvZHluYW1pY3Mvc29sdmVyL3Bvc2l0aW9uX3NvbHZlci5ycwAA2EQQAHYAAAA1AAAAHQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjExLjEvc3JjL2R5bmFtaWNzL3NvbHZlci9zb2x2ZXJfY29uc3RyYWludHMucnMAAABgRRAAeQAAALgAAAAdAAAAYEUQAHkAAAD8AAAAHQAAAGBFEAB5AAAAYAEAABoAAABgRRAAeQAAAJMBAAAaAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMS9zcmMvZHluYW1pY3Mvc29sdmVyL3ZlbG9jaXR5X2NvbnN0cmFpbnQucnMAABxGEAB6AAAANAAAAC0AAAAcRhAAegAAAEAAAAAtAAAAHEYQAHoAAABMAAAALQAAAAAAAAAcRhAAegAAAHYAAAAJAAAAHEYQAHoAAAB7AAAAMQAAABxGEAB6AAAAfAAAADEAAAAcRhAAegAAALwAAAAWAAAAHEYQAHoAAAA3AQAADgAAABxGEAB6AAAAQQEAAAkAAAAcRhAAegAAAEIBAAAJAAAAHEYQAHoAAABGAQAAHgAAABxGEAB6AAAARwEAAB4AAAAcRhAAegAAAEoBAAASAAAAHEYQAHoAAABVAQAACQAAABxGEAB6AAAAVgEAAAkAAAAcRhAAegAAAFoBAAAdAAAAHEYQAHoAAABdAQAAHgAAABxGEAB6AAAAXgEAACcAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4xL3NyYy9keW5hbWljcy9zb2x2ZXIvdmVsb2NpdHlfZ3JvdW5kX2NvbnN0cmFpbnQucnMAAAC8RxAAgQAAAEMAAAApAAAAvEcQAIEAAAB7AAAAFgAAALxHEACBAAAA4gAAAA4AAAC8RxAAgQAAAOoAAAAJAAAAvEcQAIEAAADvAAAAHgAAALxHEACBAAAA8gAAABIAAAC8RxAAgQAAAPsAAAAJAAAAvEcQAIEAAAAAAQAAHQAAALxHEACBAAAAAwEAAB4AAAC8RxAAgQAAAAQBAAAnAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMS9zcmMvZHluYW1pY3Mvc29sdmVyL3ZlbG9jaXR5X3NvbHZlci5ycwAA4EgQAHYAAAAwAAAAHQAAAOBIEAB2AAAAVAAAABgAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4xL3NyYy9keW5hbWljcy9yaWdpZF9ib2R5LnJzAAB4SRAAagAAAGgBAAA6AAAAJQAAAAAAAAABAAAAyBoQACYAAAAnAAAAKAAAACkAAAAqAAAAAAAAACsAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4xL3NyYy9nZW9tZXRyeS9icm9hZF9waGFzZV9tdWx0aV9zYXAvYnJvYWRfcGhhc2UucnMAAAAgShAAgQAAAKIAAAAaAAAAIEoQAIEAAACjAAAAGgAAACBKEACBAAAAvwAAACMAAAAgShAAgQAAAOsAAAAl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ZF9waGFzZV9tdWx0aV9zYXAvc2FwX3JlZ2lvbi5yc4hREACAAAAARgAAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBvbGQudG9faW5zZXJ0LmlzX2VtcHR5KCkAAIhREACAAAAARwAAAAkAAACIURAAgAAAAIEAAAANAAAAiFEQAIAAAACJAAAACQAAAIhREACAAAAAqQAAAA0AAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4xL3NyYy9nZW9tZXRyeS9icm9hZF9waGFzZV9tdWx0aV9zYXAvc2FwX3V0aWxzLnJzAIRSEAB/AAAADQAAAAUAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4xL3NyYy9nZW9tZXRyeS9pbnRlcmFjdGlvbl9ncmFwaC5ycwAAABRTEABxAAAAfAAAAD8AAAAUUxAAcQAAAH0AAAAOAAAAFFMQAHEAAAB9AAAAJwAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjExLjEvc3JjL2dlb21ldHJ5L25hcnJvd19waGFzZS5yc7hTEABsAAAAUwEAABEAAAC4UxAAbAAAAF8BAAARAAAAuFMQAGwAAADDAgAAGwAAALhTEABsAAAAxAIAABsAAABBIGNvbnRhY3QgbWFuaWZvbGQgY2Fubm90IGNvbnRhaW4gbW9yZSB0aGFuIDI1NSBjb250YWN0cyBjdXJyZW50bHkuALhTEABsAAAAvQMAABUAAAC4UxAAbAAAABMEAAAgAAAAuFMQAGwAAAA8BAAAGQAAAFBhcmVudCByaWdpZCBib2R5IG5vdCBmb3VuZC4vaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4xL3NyYy9nZW9tZXRyeS9jb2xsaWRlcl9zZXQucnP0VBAAbAAAAKYAAAAOAAAA9FQQAGwAAACqAAAANQAAAPRUEABsAAAArQAAACUAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4xL3NyYy9waXBlbGluZS9waHlzaWNzX3BpcGVsaW5lLnJzkFUQAHAAAACrAAAAEQAAAJBVEABwAAAAEAEAABIAAACQVRAAcAAAACIBAAARAAAAkFUQAHAAAAApAQAAFgAAAJBVEABwAAAAKwEAABYAAABVbmFibGUgdG8gaW5kZXggdGhlIHNhbWUgZWxlbWVudCB0d2ljZS4vaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4xL3NyYy91dGlscy5ycwB3VhAAXAAAAO4CAAAJAAAAd1YQAFwAAADvAgAACQAAAGEAAAAEAAAABAAAAGIAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvaW5zdGFudC0wLjEuMTAvc3JjL3dhc20ucnNwZXJmb3JtYW5jZWZhaWxlZCB0byBnZXQgcGVyZm9ybWFuY2UgZnJvbSBnbG9iYWwgb2JqZWN0AAAABFcQAFoAAAB2AAAADgAAAGNsb3N1cmUgaW52b2tlZCByZWN1cnNpdmVseSBvciBkZXN0cm95ZWQgYWxyZWFkeWNhbm5vdCBhY2Nlc3MgYSBUaHJlYWQgTG9jYWwgU3RvcmFnZSB2YWx1ZSBkdXJpbmcgb3IgYWZ0ZXIgZGVzdHJ1Y3Rpb24vcnVzdGMvNWQ2ODA0NDY5ZDgwYWFmMjZmOTgwOTBhZTAxNmFmNDVlMjY3ZjU4Zi9saWJyYXJ5L3N0ZC9zcmMvdGhyZWFkL2xvY2FsLnJzAAAAHlgQAE8AAAB3AQAAGgAAAG4AAAAAAAAAAQAAAG8AAAByZXR1cm4gdGhpcwAEAAAAAAAAAEpzVmFsdWUoKQAAAKRYEAAIAAAArFgQAAEAAABudWxsIHBvaW50ZXIgcGFzc2VkIHRvIHJ1c3RyZWN1cnNpdmUgdXNlIG9mIGFuIG9iamVjdCBkZXRlY3RlZCB3aGljaCB3b3VsZCBsZWFkIHRvIHVuc2FmZSBhbGlhc2luZyBpbiBydXN0AQBjYXBhY2l0eSBvdmVyZmxvdwAAAHQAAAAIAAAABAAAAHUAAAB2AAAAdwAAAGQAAAAEAAAAeAAAAHQAAAAQAAAABAAAAHkAAAB0AAAACAAAAAQAAAB6AAAAewAAAFgAAAAEAAAAfAAAAH0AAAAgAAAABAAAAH4AAAB0AAAABAAAAAQAAAB/AAAAgAAAACAAAAAEAAAAgQAAAHQAAAAMAAAABAAAAIIAAAB0AAAAHAAAAAQAAACDAAAAgAAAACAAAAAEAAAAhAAAAIUAAABYAAAABAAAAIYAAAB0AAAADAAAAAQAAACHAAAAdAAAAAgAAAAEAAAAiAAAAIkAAABgAAAABAAAAIoAAAB0AAAADAAAAAQAAACLAAAAjAAAADAAAAAEAAAAjQAAAHQAAAAYAAAABAAAAI4AAACPAAAAUAAAAAQAAACQAAAAfQAAACAAAAAEAAAAkQAAAHQAAAAoAAAABAAAAJIAAAB0AAAAJAAAAAQAAACTAAAAdAAAAAwAAAAEAAAAlAAAAJUAAABwAAAABAAAAJYAAAB0AAAABAAAAAQAAACXAAAAYXNzZXJ0aW9uIGZhaWxlZDogbWlkIDw9IHNlbGYubGVuKCkvcnVzdGMvNWQ2ODA0NDY5ZDgwYWFmMjZmOTgwOTBhZTAxNmFmNDVlMjY3ZjU4Zi9saWJyYXJ5L2NvcmUvc3JjL3NsaWNlL21vZC5yc/daEABNAAAA/wUAAAkAAAD3WhAATQAAADYCAAAkAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZQAvcnVzdGMvNWQ2ODA0NDY5ZDgwYWFmMjZmOTgwOTBhZTAxNmFmNDVlMjY3ZjU4Zi9saWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwAAkFsQAEoAAADPAAAAEQAAAC9ydXN0Yy81ZDY4MDQ0NjlkODBhYWYyNmY5ODA5MGFlMDE2YWY0NWUyNjdmNThmL2xpYnJhcnkvYWxsb2Mvc3JjL2NvbGxlY3Rpb25zL3ZlY19kZXF1ZS9tb2QucnMAAOxbEABeAAAADgIAAAkAAADsWxAAXgAAAKwCAAAOAAAABAAAAAAAAAAQAAAAAAAAAHsAAAB8XBAAAQAAAJBbEAAAAAAALCAAAJBcEAACAAAAfQAAAJxcEAABAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2luZGV4bWFwLTEuNy4wL3NyYy9tYXAvY29yZS5ycwAAqFwQAF4AAAAqAAAAIwAAAKhcEABeAAAAdwIAAA4AAACoXBAAXgAAACIAAAAPAAAATWF0cml4IGluZGV4IG91dCBvZiBib3VuZHMuL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL25hbGdlYnJhLTAuMjkuMC9zcmMvYmFzZS9ibGFzLnJzRG90IHByb2R1Y3QgZGltZW5zaW9ucyBtaXNtYXRjaCBmb3Igc2hhcGVzICBhbmQgOiBsZWZ0IHJvd3MgIT0gcmlnaHQgcm93cy4AAACzXRAAKwAAAN5dEAAFAAAA410QABoAAABTXRAAYAAAACAAAAAJAAAASW5kZXggb3V0IG9mIGJvdW5kcy4vaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvbmFsZ2VicmEtMC4yOS4wL3NyYy9saW5hbGcvc3ltbWV0cmljX2VpZ2VuLnJzAAAAPF4QAG0AAACOAAAAFQAAADxeEABtAAAAkAAAAB0AAAA8XhAAbQAAAJEAAAAdAAAAPF4QAG0AAACUAAAAFQAAADxeEABtAAAAoQAAACMAAAA8XhAAbQAAALAAAAAwAAAAPF4QAG0AAADEAAAAFQAAADxeEABtAAAAxQAAABUAAAA8XhAAbQAAAMkAAAAvAAAAPF4QAG0AAAD+AAAAEAAAADxeEABtAAAAQAAAAD4AAAA8XhAAbQAAAFQAAAAgAAAAdAAAAAgAAAAEAAAAmAAAAC9ydXN0Yy81ZDY4MDQ0NjlkODBhYWYyNmY5ODA5MGFlMDE2YWY0NWUyNjdmNThmL2xpYnJhcnkvYWxsb2Mvc3JjL2NvbGxlY3Rpb25zL3ZlY19kZXF1ZS9yaW5nX3NsaWNlcy5ycwAAfF8QAGYAAAAgAAAADgAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuNy4xL3NyYy9ib3VuZGluZ192b2x1bWUvYWFiYi5yc1RoZSBsb29zZW5pbmcgbWFyZ2luIG11c3QgYmUgcG9zaXRpdmUuAPRfEABpAAAAugEAAAkAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjcuMS9zcmMvYm91bmRpbmdfdm9sdW1lL2FhYmJfdXRpbHMucnNQb2ludCBjbG91ZCBBQUJCIGNvbnN0cnVjdGlvbjogdGhlIGlucHV0IGl0ZXJhdG9yIHNob3VsZCB5aWVsZCBhdCBsZWFzdCBvbmUgcG9pbnQuAAAAlGAQAG8AAABAAAAAGAAAAJRgEABvAAAAVwAAABgAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjcuMS9zcmMvYm91bmRpbmdfdm9sdW1lL2JvdW5kaW5nX3NwaGVyZS5yc3hhEAB0AAAAcwAAAAkAAAAYAAAAdHdvIGFycmF5cyBjb250YWluaW5nIGF0IGxlYXN0ICBmbG9hdHMAAABiEAAfAAAAH2IQAAcAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjcuMS9zcmMvbWFzc19wcm9wZXJ0aWVzL21hc3NfcHJvcGVydGllc19jb252ZXhfcG9seWhlZHJvbi5ycwAAOGIQAIYAAAAXAAAAFwAAADhiEACGAAAAGAAAABcAAAA4YhAAhgAAABkAAAAXAAAAOGIQAIYAAAClAAAAEgAAADhiEACGAAAApgAAABIAAAA4YhAAhgAAAKcAAAASAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC43LjEvc3JjL3BhcnRpdGlvbmluZy9xYnZoLnJzAAAgYxAAZgAAAMgAAAAJAAAAIGMQAGYAAAC2AAAADQAAACBjEABmAAAAtwAAAA0AAAAgYxAAZgAAABIBAAAgAAAAIGMQAGYAAAAVAQAAEQAAACBjEABmAAAAMQEAABoAAAAgYxAAZgAAAG0BAAAJAAAAIGMQAGYAAABuAQAACQAAACBjEABmAAAAbwEAAAkAAAAgYxAAZgAAAK8BAAAYAAAAIGMQAGYAAADpAQAAGAAAACBjEABmAAAA2gIAABEAAAAgYxAAZgAAANsCAAAWAAAAIGMQAGYAAADdAgAADAAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuNy4xL3NyYy9xdWVyeS9jbGlwL2NsaXBfYWFiYl9saW5lLnJzAABoZBAAbgAAAI0AAAANAAAAaGQQAG4AAACbAAAADQAAAFRoZSBwcm94aW1pdHkgbWFyZ2luIG11c3QgYmUgcG9zaXRpdmUgb3IgbnVsbC4vaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjcuMS9zcmMvcXVlcnkvY2xvc2VzdF9wb2ludHMvY2xvc2VzdF9wb2ludHNfYmFsbF9iYWxsLnJzJmUQAIIAAAAPAAAABQAAAFRoZSBjb21wb3NpdGUgc2hhcGUgbXVzdCBub3QgYmUgZW1wdHkuL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC43LjEvc3JjL3F1ZXJ5L2Nsb3Nlc3RfcG9pbnRzL2Nsb3Nlc3RfcG9pbnRzX2NvbXBvc2l0ZV9zaGFwZV9zaGFwZS5yc95lEACOAAAAGwAAAAoAAADeZRAAjgAAAIEAAAAhAAAA3mUQAI4AAACCAAAAIQAAAN5lEACOAAAAgwAAACEAAABpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC43LjEvc3JjL3F1ZXJ5L2Nsb3Nlc3RfcG9pbnRzL2Nsb3Nlc3RfcG9pbnRzX2N1Ym9pZF9jdWJvaWQucnMAANRmEACGAAAAUgAAAAUAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjcuMS9zcmMvcXVlcnkvY2xvc2VzdF9wb2ludHMvY2xvc2VzdF9wb2ludHNfY3Vib2lkX3RyaWFuZ2xlLnJzbGcQAIgAAABNAAAABQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuNy4xL3NyYy9xdWVyeS9jbG9zZXN0X3BvaW50cy9jbG9zZXN0X3BvaW50c19oYWxmc3BhY2Vfc3VwcG9ydF9tYXAucnMAAARoEACOAAAADQAAAAUAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjcuMS9zcmMvcXVlcnkvY2xvc2VzdF9wb2ludHMvY2xvc2VzdF9wb2ludHNfc3VwcG9ydF9tYXBfc3VwcG9ydF9tYXAucnOkaBAAkAAAACAAAAAkAAAAdAAAABQAAAAEAAAAmQAAAJoAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjcuMS9zcmMvcXVlcnkvY29udGFjdC9jb250YWN0X3N1cHBvcnRfbWFwX3N1cHBvcnRfbWFwLnJzAABYaRAAggAAAB4AAAAkAAAAgAAAACAAAAAEAAAAgAAAACAAAAAEAAAAhAAAAJsAAACcAAAAnQAAAJ4AAADsaRAA7GkQAJwAAACfAAAAoAAAAH0AAAAgAAAABAAAAH0AAAAgAAAABAAAAJEAAAChAAAAogAAAKMAAACkAAAALGoQACxqEACiAAAApQAAAKYAAACAAAAAIAAAAAQAAACAAAAAIAAAAAQAAACB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Y3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC43LjEvc3JjL3F1ZXJ5L2ludGVyc2VjdGlvbl90ZXN0L2ludGVyc2VjdGlvbl90ZXN0X3N1cHBvcnRfbWFwX3N1cHBvcnRfbWFwLnJzAACEcRAAlgAAADkAAAApAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC43LjEvc3JjL3F1ZXJ5L25vbmxpbmVhcl90aW1lX29mX2ltcGFjdC9ub25saW5lYXJfdGltZV9vZl9pbXBhY3RfY29tcG9zaXRlX3NoYXBlX3NoYXBlLnJzAAB0AAAABAAAAAQAAAC5AAAAugAAALsAAAC8AAAAvQAAAL4AAAC/AAAAwAAAAHQAAAAEAAAABAAAAH8AAADBAAAAwgAAAMMAAADEAAAAdAAAAAQAAAAEAAAAdAAAAAQAAAAEAAAAfwAAAMEAAADCAAAAwwAAAMQAAAAccxAAHHMQAMIAAAB0AAAABAAAAAQAAADFAAAAxgAAAMcAAADIAAAAyQAAAMoAAAC5AAAAugAAALsAAAC8AAAAvQAAAL4AAAC/AAAAwAAAANByEAB/AAAApFkQAMEAAADCAAAAwwAAAMQAAAD8chAAHHMQABxzEADCAAAAKHMQAMsAAADMAAAAzQAAAM4AAADPAAAA0AAAANEAAADSAAAA0wAAANQAAABSAAAA1QAAANYAAADXAAAA2AAAANkAAAAschAAogAAAMMAAAAVAAAALHIQAKIAAACbAAAAKgAAACxyEACiAAAAvAAAACEAAAAschAAogAAAL0AAAAhAAAALHIQAKIAAAC+AAAAIQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuNy4xL3NyYy9xdWVyeS9ub25saW5lYXJfdGltZV9vZl9pbXBhY3Qvbm9ubGluZWFyX3RpbWVfb2ZfaW1wYWN0X3N1cHBvcnRfbWFwX3N1cHBvcnRfbWFwLnJzWHQQAKQAAADHAAAAKAAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuNy4xL3NyYy9xdWVyeS9wb2ludC9wb2ludF9jb21wb3NpdGVfc2hhcGUucnMAAAx1EAB2AAAAHQAAAFMAAAAMdRAAdgAAADoAAABUAAAADHUQAHYAAABNAAAANwAAAAx1EAB2AAAAawAAADcAAAAMdRAAdgAAAHoAAAA3AAAAYXNzZXJ0aW9uIGZhaWxlZDogc3FuYWIgIT0gMC4wL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC43LjEvc3JjL3F1ZXJ5L3BvaW50L3BvaW50X3NlZ21lbnQucnPydRAAbgAAAEgAAAANAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC43LjEvc3JjL3F1ZXJ5L3BvaW50L3BvaW50X3RldHJhaGVkcm9uLnJzYXNzZXJ0aW9uIGZhaWxlZDogZGVub20gIT0gXzAAcHYQAHIAAAAfAQAAFQAAAHQAAAAEAAAABAAAANoAAADbAAAAdAAAABwAAAAEAAAA3AAAAN0AAAB0AAAAHAAAAAQAAADeAAAA3wAAAHQAAAAIAAAABAAAAOAAAADhAAAAdAAAAAgAAAAEAAAA4gAAAOMAAAB0AAAACAAAAAQAAADkAAAA5QAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuNy4xL3NyYy9zaGFwZS9jdWJvaWQucnMAAACIdxAAYQAAAJcAAAASAAAAiHcQAGEAAACtAAAAEgAAAIh3EABhAAAAqQAAABIAAACIdxAAYQAAAKUAAAASAAAAiHcQAGEAAAAKAQAAFQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuNy4xL3NyYy9zaGFwZS9w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Y2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuNy4xL3NyYy90cmFuc2Zvcm1hdGlvbi9jb252ZXhfaHVsbDMvdmFsaWRhdGlvbi5ycwAwnxAAewAAAAYAAAASAAAAMJ8QAHsAAAAJAAAAEQAAAGFzc2VydGlvbiBmYWlsZWQ6IGZhY2V0c1tmYWNldC5hZGpbaV1dLnZhbGlkMJ8QAHsAAAAJAAAACQAAADCfEAB7AAAADwAAABQAAAAwnxAAewAAAA8AAAAJAAAAMJ8QAHsAAAAQAAAACQAAADCfEAB7AAAAEQAAAAkAAAAwnxAAewAAABUAAAAJAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC43LjEvc3JjL3RyYW5zZm9ybWF0aW9uL2NvbnZleF9odWxsX3V0aWxzLnJzAAAAWKAQAHUAAAApAAAAIgAAAFigEAB1AAAAQgAAACIAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjcuMS9zcmMvdHJhbnNmb3JtYXRpb24vdG9fdHJpbWVzaC9jb252ZXhfcG9seWhlZHJvbl90b190cmltZXNoLnJzAPCgEACLAAAADQAAABwAAADwoBAAiwAAAA8AAAAYAAAAQ2Fubm90IGNvbXB1dGUgdGhlIGNlbnRlciBvZiBsZXNzIHRoYW4gMSBwb2ludC4vaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjcuMS9zcmMvdXRpbHMvY2VudGVyLnJzy6EQAGEAAAAHAAAABQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuNy4xL3NyYy91dGlscy9jbGVhbnVwLnJzAAA8ohAAYgAAAAwAAAAJAAAAPKIQAGIAAAANAAAACQAAADyiEABi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cHBsaWVkIGluc3RhbnQgaXMgbGF0ZXIgdGhhbiBzZWxmbGlicmFyeS9zdGQvc3JjL3RpbWUucnMAAADuqRAAFwAAABEBAAAwAAAAb3ZlcmZsb3cgd2hlbiBhZGRpbmcgZHVyYXRpb24gdG8gaW5zdGFudO6pEAAXAAAAbgEAACEAAABsaWJyYXJ5L3N0ZC9zcmMvc3lzX2NvbW1vbi90aHJlYWRfaW5mby5ycwAAAFCqEAApAAAAFQAAABYAAABQqhAAKQAAABYAAAAYAAAAUKoQACkAAAAZAAAAFQAAAGxpYnJhcnkvc3RkL3NyYy9wYW5pY2tpbmcucnOsqhAAHAAAAAMCAAAfAAAArKoQABwAAAAEAgAAHgAAAD4DAAAQAAAABAAAAD8DAABAAwAAMAMAAAgAAAAEAAAAQQMAAEIDAABDAwAADAAAAAQAAABEAwAAMAMAAAgAAAAEAAAARQMAADADAAAIAAAABAAAAEYDAABHAwAATnVsRXJyb3IwAwAABAAAAAQAAABIAwAAbGlicmFyeS9zdGQvc3JjL3N5c19jb21tb24vdGhyZWFkX3Bhcmtlci9nZW5lcmljLnJzAFyrEAAzAAAAIQAAACYAAABpbmNvbnNpc3RlbnQgcGFyayBzdGF0ZQBcqxAAMwAAAC8AAAAXAAAAcGFyayBzdGF0ZSBjaGFuZ2VkIHVuZXhwZWN0ZWRseQDIqxAAHwAAAFyrEAAzAAAALAAAABEAAABcqxAAMwAAAEMAAAAiAAAAaW5jb25zaXN0ZW50IHBhcmtfdGltZW91dCBzdGF0ZQBcqxAAMwAAAEwAAAAXAAAAXKsQADMAAABJAAAAEQAAAGluY29uc2lzdGVudCBzdGF0ZSBpbiB1bnBhcmtcqxAAMwAAAGYAAAASAAAAXKsQADMAAAB0AAAAHwAAAHRpbWUgbm90IGltcGxlbWVudGVkIG9uIHRoaXMgcGxhdGZvcm1saWJyYXJ5L3N0ZC9zcmMvc3lzL3dhc20vLi4vdW5zdXBwb3J0ZWQvdGltZS5yc7GsEAAvAAAADQAAAAkAAABjb25kdmFyIHdhaXQgbm90IHN1cHBvcnRlZGxpYnJhcnkvc3RkL3NyYy9zeXMvd2FzbS8uLi91bnN1cHBvcnRlZC9jb25kdmFyLnJzCq0QADIAAAAXAAAACQAAAAqtEAAyAAAAGwAAAAkAAABjYW5ub3QgcmVjdXJzaXZlbHkgYWNxdWlyZSBtdXRleFytEAAgAAAAbGlicmFyeS9zdGQvc3JjL3N5cy93YXNtLy4uL3Vuc3VwcG9ydGVkL211dGV4LnJzhK0QADAAAAAXAAAACQAAAEhhc2ggdGFibGUgY2FwYWNpdHkgb3ZlcmZsb3cvY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9oYXNoYnJvd24tMC4xMS4wL3NyYy9yYXcvbW9kLnJzAOCtEABPAAAAYwAAACgAAAD/////SQMAAAQAAAAEAAAASgMAAEsDAABMAwAAL3J1c3RjLzVkNjgwNDQ2OWQ4MGFhZjI2Zjk4MDkwYWUwMTZhZjQ1ZTI2N2Y1OGYvbGlicmFyeS9jb3JlL3NyYy9mbXQvbW9kLnJzAFyuEABLAAAAlQEAABMAAABJAwAAAAAAAAEAAAAUAAAAYSBmb3JtYXR0aW5nIHRyYWl0IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9ybGlicmFyeS9hbGxvYy9zcmMvZm10LnJzAPuuEAAYAAAARwIAABwAAABsaWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjLnJzY2FwYWNpdHkgb3ZlcmZsb3cAAAAkrxAAHAAAAC8CAAAFAAAAc3dhcF9yZW1vdmUgaW5kZXggKGlzICkgc2hvdWxkIGJlIDwgbGVuIChpcyApAAAAZK8QABYAAAB6rxAAFgAAAJCvEAABAAAAbGlicmFyeS9hbGxvYy9zcmMvdmVjL21vZC5yc6yvEAAcAAAADgUAAA0AAAByZW1vdmFsIGluZGV4IChpcyAAANivEAASAAAAeq8QABYAAACQrxAAAQAAAGFzc2VydGlvbiBmYWlsZWQ6IGVkZWx0YSA+PSAwbGlicmFyeS9jb3JlL3NyYy9udW0vZGl5X2Zsb2F0LnJzAAAhsBAAIQAAAEwAAAAJAAAAIbAQACEAAABOAAAACQAAAAEAAAAKAAAAZAAAAOgDAAAQJwAAoIYBAEBCDwCAlpgAAOH1BQDKmjsCAAAAFAAAAMgAAADQBwAAIE4AAEANAwCAhB4AAC0xAQDC6wsAlDV3AADBb/KGIwAAAAAAge+shVtBbS3uBABB1OHCAAsTAR9q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").buffer)];
        case 1:
          return A2.sent(), [2];
      }
    });
  });
}
function aI() {
  return function() {
    try {
      const C2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.version(C2);
      var I2 = U()[C2 / 4 + 0], g2 = U()[C2 / 4 + 1];
      return D(I2, g2);
    } finally {
      A.__wbindgen_add_to_stack_pointer(16), A.__wbindgen_free(I2, g2);
    }
  }();
}
SI["-".charCodeAt(0)] = 62, SI["_".charCodeAt(0)] = 63;
Object.freeze({ __proto__: null, version: aI, Vector3: AA, VectorOps: IA, Quaternion: gA, RotationOps: CA, get RigidBodyType() {
  return $;
}, RigidBody: EA, RigidBodyDesc: iA, RigidBodySet: oA, IntegrationParameters: DA, get JointType() {
  return BA;
}, get SpringModel() {
  return QA;
}, Joint: JA, UnitJoint: KA, FixedJoint: FA, PrismaticJoint: aA, BallJoint: hA, RevoluteJoint: MA, JointParams: yA, JointSet: qA, get CoefficientCombineRule() {
  return wA;
}, CCDSolver: RA, IslandManager: sA, BroadPhase: cA, NarrowPhase: YA, TempContactManifold: lA, get ShapeType() {
  return NA;
}, Ball: HA, Cuboid: pA, RoundCuboid: tA, Capsule: TA, Segment: OA, Triangle: eA, RoundTriangle: nA, Polyline: dA, TriMesh: ZA, ConvexPolyhedron: rA, RoundConvexPolyhedron: fA, Heightfield: WA, Cylinder: bA, RoundCylinder: jA, Cone: xA, RoundCone: XA, get ActiveCollisionTypes() {
  return LA;
}, Collider: mA, ColliderDesc: uA, ColliderSet: PA, Ray: zA, RayColliderIntersection: vA, RayColliderToi: _A, PointColliderProjection: $A, ShapeColliderTOI: AI, World: BI, PhysicsPipeline: II, SerializationPipeline: CI, get ActiveEvents() {
  return VA;
}, EventQueue: iI, get ActiveHooks() {
  return QI;
}, get SolverFlags() {
  return EI;
}, init: FI });
class GLTFLoader extends Loader {
  constructor(manager) {
    super(manager);
    this.dracoLoader = null;
    this.ktx2Loader = null;
    this.meshoptDecoder = null;
    this.pluginCallbacks = [];
    this.register(function(parser) {
      return new GLTFMaterialsClearcoatExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureBasisUExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureWebPExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSheenExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsTransmissionExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsVolumeExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIorExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSpecularExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFLightsExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshoptCompression(parser);
    });
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    let resourcePath;
    if (this.resourcePath !== "") {
      resourcePath = this.resourcePath;
    } else if (this.path !== "") {
      resourcePath = this.path;
    } else {
      resourcePath = LoaderUtils.extractUrlBase(url);
    }
    this.manager.itemStart(url);
    const _onError = function(e2) {
      if (onError) {
        onError(e2);
      } else {
        console.error(e2);
      }
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    };
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(data) {
      try {
        scope.parse(data, resourcePath, function(gltf) {
          onLoad(gltf);
          scope.manager.itemEnd(url);
        }, _onError);
      } catch (e2) {
        _onError(e2);
      }
    }, onProgress, _onError);
  }
  setDRACOLoader(dracoLoader) {
    this.dracoLoader = dracoLoader;
    return this;
  }
  setDDSLoader() {
    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
  }
  setKTX2Loader(ktx2Loader) {
    this.ktx2Loader = ktx2Loader;
    return this;
  }
  setMeshoptDecoder(meshoptDecoder) {
    this.meshoptDecoder = meshoptDecoder;
    return this;
  }
  register(callback) {
    if (this.pluginCallbacks.indexOf(callback) === -1) {
      this.pluginCallbacks.push(callback);
    }
    return this;
  }
  unregister(callback) {
    if (this.pluginCallbacks.indexOf(callback) !== -1) {
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
    }
    return this;
  }
  parse(data, path, onLoad, onError) {
    let content;
    const extensions = {};
    const plugins = {};
    if (typeof data === "string") {
      content = data;
    } else {
      const magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));
      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
        try {
          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
        } catch (error) {
          if (onError)
            onError(error);
          return;
        }
        content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;
      } else {
        content = LoaderUtils.decodeText(new Uint8Array(data));
      }
    }
    const json = JSON.parse(content);
    if (json.asset === void 0 || json.asset.version[0] < 2) {
      if (onError)
        onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const parser = new GLTFParser(json, {
      path: path || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    parser.fileLoader.setRequestHeader(this.requestHeader);
    for (let i2 = 0; i2 < this.pluginCallbacks.length; i2++) {
      const plugin = this.pluginCallbacks[i2](parser);
      plugins[plugin.name] = plugin;
      extensions[plugin.name] = true;
    }
    if (json.extensionsUsed) {
      for (let i2 = 0; i2 < json.extensionsUsed.length; ++i2) {
        const extensionName = json.extensionsUsed[i2];
        const extensionsRequired = json.extensionsRequired || [];
        switch (extensionName) {
          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            extensions[extensionName] = new GLTFMaterialsUnlitExtension();
            break;
          case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();
            break;
          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
            break;
          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            extensions[extensionName] = new GLTFTextureTransformExtension();
            break;
          case EXTENSIONS.KHR_MESH_QUANTIZATION:
            extensions[extensionName] = new GLTFMeshQuantizationExtension();
            break;
          default:
            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
              console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
            }
        }
      }
    }
    parser.setExtensions(extensions);
    parser.setPlugins(plugins);
    parser.parse(onLoad, onError);
  }
  parseAsync(data, path) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.parse(data, path, resolve, reject);
    });
  }
}
function GLTFRegistry() {
  let objects = {};
  return {
    get: function(key) {
      return objects[key];
    },
    add: function(key, object) {
      objects[key] = object;
    },
    remove: function(key) {
      delete objects[key];
    },
    removeAll: function() {
      objects = {};
    }
  };
}
const EXTENSIONS = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
};
class GLTFLightsExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
    this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const parser = this.parser;
    const nodeDefs = this.parser.json.nodes || [];
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
      }
    }
  }
  _loadLight(lightIndex) {
    const parser = this.parser;
    const cacheKey = "light:" + lightIndex;
    let dependency = parser.cache.get(cacheKey);
    if (dependency)
      return dependency;
    const json = parser.json;
    const extensions = json.extensions && json.extensions[this.name] || {};
    const lightDefs = extensions.lights || [];
    const lightDef = lightDefs[lightIndex];
    let lightNode;
    const color = new Color(16777215);
    if (lightDef.color !== void 0)
      color.fromArray(lightDef.color);
    const range = lightDef.range !== void 0 ? lightDef.range : 0;
    switch (lightDef.type) {
      case "directional":
        lightNode = new DirectionalLight(color);
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      case "point":
        lightNode = new PointLight(color);
        lightNode.distance = range;
        break;
      case "spot":
        lightNode = new SpotLight(color);
        lightNode.distance = range;
        lightDef.spot = lightDef.spot || {};
        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
        lightNode.angle = lightDef.spot.outerConeAngle;
        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
    }
    lightNode.position.set(0, 0, 0);
    lightNode.decay = 2;
    if (lightDef.intensity !== void 0)
      lightNode.intensity = lightDef.intensity;
    lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
    dependency = Promise.resolve(lightNode);
    parser.cache.add(cacheKey, dependency);
    return dependency;
  }
  createNodeAttachment(nodeIndex) {
    const self2 = this;
    const parser = this.parser;
    const json = parser.json;
    const nodeDef = json.nodes[nodeIndex];
    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
    const lightIndex = lightDef.light;
    if (lightIndex === void 0)
      return null;
    return this._loadLight(lightIndex).then(function(light) {
      return parser._getNodeRef(self2.cache, lightIndex, light);
    });
  }
}
class GLTFMaterialsUnlitExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(materialParams, materialDef, parser) {
    const pending = [];
    materialParams.color = new Color(1, 1, 1);
    materialParams.opacity = 1;
    const metallicRoughness = materialDef.pbrMetallicRoughness;
    if (metallicRoughness) {
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture));
      }
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsClearcoatExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.clearcoatFactor !== void 0) {
      materialParams.clearcoat = extension.clearcoatFactor;
    }
    if (extension.clearcoatTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
    }
    if (extension.clearcoatRoughnessFactor !== void 0) {
      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
    }
    if (extension.clearcoatRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
    }
    if (extension.clearcoatNormalTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
      if (extension.clearcoatNormalTexture.scale !== void 0) {
        const scale = extension.clearcoatNormalTexture.scale;
        materialParams.clearcoatNormalScale = new Vector2(scale, scale);
      }
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsSheenExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    materialParams.sheenColor = new Color(0, 0, 0);
    materialParams.sheenRoughness = 0;
    materialParams.sheen = 1;
    const extension = materialDef.extensions[this.name];
    if (extension.sheenColorFactor !== void 0) {
      materialParams.sheenColor.fromArray(extension.sheenColorFactor);
    }
    if (extension.sheenRoughnessFactor !== void 0) {
      materialParams.sheenRoughness = extension.sheenRoughnessFactor;
    }
    if (extension.sheenColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenColorMap", extension.sheenColorTexture));
    }
    if (extension.sheenRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenRoughnessMap", extension.sheenRoughnessTexture));
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsTransmissionExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.transmissionFactor !== void 0) {
      materialParams.transmission = extension.transmissionFactor;
    }
    if (extension.transmissionTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsVolumeExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;
    if (extension.thicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "thicknessMap", extension.thicknessTexture));
    }
    materialParams.attenuationDistance = extension.attenuationDistance || 0;
    const colorArray = extension.attenuationColor || [1, 1, 1];
    materialParams.attenuationColor = new Color(colorArray[0], colorArray[1], colorArray[2]);
    return Promise.all(pending);
  }
}
class GLTFMaterialsIorExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IOR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const extension = materialDef.extensions[this.name];
    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;
    return Promise.resolve();
  }
}
class GLTFMaterialsSpecularExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;
    if (extension.specularTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularIntensityMap", extension.specularTexture));
    }
    const colorArray = extension.specularColorFactor || [1, 1, 1];
    materialParams.specularColor = new Color(colorArray[0], colorArray[1], colorArray[2]);
    if (extension.specularColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularColorMap", extension.specularColorTexture).then(function(texture) {
        texture.encoding = sRGBEncoding;
      }));
    }
    return Promise.all(pending);
  }
}
class GLTFTextureBasisUExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
  }
  loadTexture(textureIndex) {
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[this.name]) {
      return null;
    }
    const extension = textureDef.extensions[this.name];
    const loader = parser.options.ktx2Loader;
    if (!loader) {
      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      } else {
        return null;
      }
    }
    return parser.loadTextureImage(textureIndex, extension.source, loader);
  }
}
class GLTFTextureWebPExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const source = json.images[extension.source];
    let loader = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null)
        loader = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported)
        return parser.loadTextureImage(textureIndex, source, loader);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve) {
        const image = new Image();
        image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
        image.onload = image.onerror = function() {
          resolve(image.height === 1);
        };
      });
    }
    return this.isSupported;
  }
}
class GLTFMeshoptCompression {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
    this.parser = parser;
  }
  loadBufferView(index) {
    const json = this.parser.json;
    const bufferView = json.bufferViews[index];
    if (bufferView.extensions && bufferView.extensions[this.name]) {
      const extensionDef = bufferView.extensions[this.name];
      const buffer = this.parser.getDependency("buffer", extensionDef.buffer);
      const decoder = this.parser.options.meshoptDecoder;
      if (!decoder || !decoder.supported) {
        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        } else {
          return null;
        }
      }
      return Promise.all([buffer, decoder.ready]).then(function(res) {
        const byteOffset = extensionDef.byteOffset || 0;
        const byteLength = extensionDef.byteLength || 0;
        const count = extensionDef.count;
        const stride = extensionDef.byteStride;
        const result = new ArrayBuffer(count * stride);
        const source = new Uint8Array(res[0], byteOffset, byteLength);
        decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
        return result;
      });
    } else {
      return null;
    }
  }
}
const BINARY_EXTENSION_HEADER_MAGIC = "glTF";
const BINARY_EXTENSION_HEADER_LENGTH = 12;
const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
class GLTFBinaryExtension {
  constructor(data) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF;
    this.content = null;
    this.body = null;
    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
    this.header = {
      magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
      version: headerView.getUint32(4, true),
      length: headerView.getUint32(8, true)
    };
    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    } else if (this.header.version < 2) {
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    }
    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
    let chunkIndex = 0;
    while (chunkIndex < chunkContentsLength) {
      const chunkLength = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      const chunkType = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
        this.content = LoaderUtils.decodeText(contentArray);
      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
        this.body = data.slice(byteOffset, byteOffset + chunkLength);
      }
      chunkIndex += chunkLength;
    }
    if (this.content === null) {
      throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
}
class GLTFDracoMeshCompressionExtension {
  constructor(json, dracoLoader) {
    if (!dracoLoader) {
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    }
    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
    this.json = json;
    this.dracoLoader = dracoLoader;
    this.dracoLoader.preload();
  }
  decodePrimitive(primitive, parser) {
    const json = this.json;
    const dracoLoader = this.dracoLoader;
    const bufferViewIndex = primitive.extensions[this.name].bufferView;
    const gltfAttributeMap = primitive.extensions[this.name].attributes;
    const threeAttributeMap = {};
    const attributeNormalizedMap = {};
    const attributeTypeMap = {};
    for (const attributeName in gltfAttributeMap) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
    }
    for (const attributeName in primitive.attributes) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      if (gltfAttributeMap[attributeName] !== void 0) {
        const accessorDef = json.accessors[primitive.attributes[attributeName]];
        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        attributeTypeMap[threeAttributeName] = componentType;
        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
      }
    }
    return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
      return new Promise(function(resolve) {
        dracoLoader.decodeDracoFile(bufferView, function(geometry) {
          for (const attributeName in geometry.attributes) {
            const attribute = geometry.attributes[attributeName];
            const normalized = attributeNormalizedMap[attributeName];
            if (normalized !== void 0)
              attribute.normalized = normalized;
          }
          resolve(geometry);
        }, threeAttributeMap, attributeTypeMap);
      });
    });
  }
}
class GLTFTextureTransformExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(texture, transform) {
    if (transform.texCoord !== void 0) {
      console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.');
    }
    if (transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {
      return texture;
    }
    texture = texture.clone();
    if (transform.offset !== void 0) {
      texture.offset.fromArray(transform.offset);
    }
    if (transform.rotation !== void 0) {
      texture.rotation = transform.rotation;
    }
    if (transform.scale !== void 0) {
      texture.repeat.fromArray(transform.scale);
    }
    texture.needsUpdate = true;
    return texture;
  }
}
class GLTFMeshStandardSGMaterial extends MeshStandardMaterial {
  constructor(params) {
    super();
    this.isGLTFSpecularGlossinessMaterial = true;
    const specularMapParsFragmentChunk = [
      "#ifdef USE_SPECULARMAP",
      "	uniform sampler2D specularMap;",
      "#endif"
    ].join("\n");
    const glossinessMapParsFragmentChunk = [
      "#ifdef USE_GLOSSINESSMAP",
      "	uniform sampler2D glossinessMap;",
      "#endif"
    ].join("\n");
    const specularMapFragmentChunk = [
      "vec3 specularFactor = specular;",
      "#ifdef USE_SPECULARMAP",
      "	vec4 texelSpecular = texture2D( specularMap, vUv );",
      "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
      "	specularFactor *= texelSpecular.rgb;",
      "#endif"
    ].join("\n");
    const glossinessMapFragmentChunk = [
      "float glossinessFactor = glossiness;",
      "#ifdef USE_GLOSSINESSMAP",
      "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );",
      "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
      "	glossinessFactor *= texelGlossiness.a;",
      "#endif"
    ].join("\n");
    const lightPhysicalFragmentChunk = [
      "PhysicalMaterial material;",
      "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
      "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
      "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
      "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
      "material.roughness += geometryRoughness;",
      "material.roughness = min( material.roughness, 1.0 );",
      "material.specularColor = specularFactor;"
    ].join("\n");
    const uniforms = {
      specular: { value: new Color().setHex(16777215) },
      glossiness: { value: 1 },
      specularMap: { value: null },
      glossinessMap: { value: null }
    };
    this._extraUniforms = uniforms;
    this.onBeforeCompile = function(shader) {
      for (const uniformName in uniforms) {
        shader.uniforms[uniformName] = uniforms[uniformName];
      }
      shader.fragmentShader = shader.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", specularMapParsFragmentChunk).replace("#include <metalnessmap_pars_fragment>", glossinessMapParsFragmentChunk).replace("#include <roughnessmap_fragment>", specularMapFragmentChunk).replace("#include <metalnessmap_fragment>", glossinessMapFragmentChunk).replace("#include <lights_physical_fragment>", lightPhysicalFragmentChunk);
    };
    Object.defineProperties(this, {
      specular: {
        get: function() {
          return uniforms.specular.value;
        },
        set: function(v2) {
          uniforms.specular.value = v2;
        }
      },
      specularMap: {
        get: function() {
          return uniforms.specularMap.value;
        },
        set: function(v2) {
          uniforms.specularMap.value = v2;
          if (v2) {
            this.defines.USE_SPECULARMAP = "";
          } else {
            delete this.defines.USE_SPECULARMAP;
          }
        }
      },
      glossiness: {
        get: function() {
          return uniforms.glossiness.value;
        },
        set: function(v2) {
          uniforms.glossiness.value = v2;
        }
      },
      glossinessMap: {
        get: function() {
          return uniforms.glossinessMap.value;
        },
        set: function(v2) {
          uniforms.glossinessMap.value = v2;
          if (v2) {
            this.defines.USE_GLOSSINESSMAP = "";
            this.defines.USE_UV = "";
          } else {
            delete this.defines.USE_GLOSSINESSMAP;
            delete this.defines.USE_UV;
          }
        }
      }
    });
    delete this.metalness;
    delete this.roughness;
    delete this.metalnessMap;
    delete this.roughnessMap;
    this.setValues(params);
  }
  copy(source) {
    super.copy(source);
    this.specularMap = source.specularMap;
    this.specular.copy(source.specular);
    this.glossinessMap = source.glossinessMap;
    this.glossiness = source.glossiness;
    delete this.metalness;
    delete this.roughness;
    delete this.metalnessMap;
    delete this.roughnessMap;
    return this;
  }
}
class GLTFMaterialsPbrSpecularGlossinessExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;
    this.specularGlossinessParams = [
      "color",
      "map",
      "lightMap",
      "lightMapIntensity",
      "aoMap",
      "aoMapIntensity",
      "emissive",
      "emissiveIntensity",
      "emissiveMap",
      "bumpMap",
      "bumpScale",
      "normalMap",
      "normalMapType",
      "displacementMap",
      "displacementScale",
      "displacementBias",
      "specularMap",
      "specular",
      "glossinessMap",
      "glossiness",
      "alphaMap",
      "envMap",
      "envMapIntensity",
      "refractionRatio"
    ];
  }
  getMaterialType() {
    return GLTFMeshStandardSGMaterial;
  }
  extendParams(materialParams, materialDef, parser) {
    const pbrSpecularGlossiness = materialDef.extensions[this.name];
    materialParams.color = new Color(1, 1, 1);
    materialParams.opacity = 1;
    const pending = [];
    if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {
      const array = pbrSpecularGlossiness.diffuseFactor;
      materialParams.color.fromArray(array);
      materialParams.opacity = array[3];
    }
    if (pbrSpecularGlossiness.diffuseTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "map", pbrSpecularGlossiness.diffuseTexture));
    }
    materialParams.emissive = new Color(0, 0, 0);
    materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== void 0 ? pbrSpecularGlossiness.glossinessFactor : 1;
    materialParams.specular = new Color(1, 1, 1);
    if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {
      materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);
    }
    if (pbrSpecularGlossiness.specularGlossinessTexture !== void 0) {
      const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
      pending.push(parser.assignTexture(materialParams, "glossinessMap", specGlossMapDef));
      pending.push(parser.assignTexture(materialParams, "specularMap", specGlossMapDef));
    }
    return Promise.all(pending);
  }
  createMaterial(materialParams) {
    const material = new GLTFMeshStandardSGMaterial(materialParams);
    material.fog = true;
    material.color = materialParams.color;
    material.map = materialParams.map === void 0 ? null : materialParams.map;
    material.lightMap = null;
    material.lightMapIntensity = 1;
    material.aoMap = materialParams.aoMap === void 0 ? null : materialParams.aoMap;
    material.aoMapIntensity = 1;
    material.emissive = materialParams.emissive;
    material.emissiveIntensity = 1;
    material.emissiveMap = materialParams.emissiveMap === void 0 ? null : materialParams.emissiveMap;
    material.bumpMap = materialParams.bumpMap === void 0 ? null : materialParams.bumpMap;
    material.bumpScale = 1;
    material.normalMap = materialParams.normalMap === void 0 ? null : materialParams.normalMap;
    material.normalMapType = TangentSpaceNormalMap;
    if (materialParams.normalScale)
      material.normalScale = materialParams.normalScale;
    material.displacementMap = null;
    material.displacementScale = 1;
    material.displacementBias = 0;
    material.specularMap = materialParams.specularMap === void 0 ? null : materialParams.specularMap;
    material.specular = materialParams.specular;
    material.glossinessMap = materialParams.glossinessMap === void 0 ? null : materialParams.glossinessMap;
    material.glossiness = materialParams.glossiness;
    material.alphaMap = null;
    material.envMap = materialParams.envMap === void 0 ? null : materialParams.envMap;
    material.envMapIntensity = 1;
    material.refractionRatio = 0.98;
    return material;
  }
}
class GLTFMeshQuantizationExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
}
class GLTFCubicSplineInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
    for (let i2 = 0; i2 !== valueSize; i2++) {
      result[i2] = values[offset + i2];
    }
    return result;
  }
}
GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
GLTFCubicSplineInterpolant.prototype.interpolate_ = function(i1, t0, t2, t1) {
  const result = this.resultBuffer;
  const values = this.sampleValues;
  const stride = this.valueSize;
  const stride2 = stride * 2;
  const stride3 = stride * 3;
  const td = t1 - t0;
  const p2 = (t2 - t0) / td;
  const pp = p2 * p2;
  const ppp = pp * p2;
  const offset1 = i1 * stride3;
  const offset0 = offset1 - stride3;
  const s2 = -2 * ppp + 3 * pp;
  const s3 = ppp - pp;
  const s0 = 1 - s2;
  const s1 = s3 - pp + p2;
  for (let i2 = 0; i2 !== stride; i2++) {
    const p0 = values[offset0 + i2 + stride];
    const m0 = values[offset0 + i2 + stride2] * td;
    const p1 = values[offset1 + i2 + stride];
    const m1 = values[offset1 + i2] * td;
    result[i2] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
  }
  return result;
};
const _q = new Quaternion();
class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {
  interpolate_(i1, t0, t2, t1) {
    const result = super.interpolate_(i1, t0, t2, t1);
    _q.fromArray(result).normalize().toArray(result);
    return result;
  }
}
const WEBGL_CONSTANTS = {
  FLOAT: 5126,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
};
const WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
const WEBGL_FILTERS = {
  9728: NearestFilter,
  9729: LinearFilter,
  9984: NearestMipmapNearestFilter,
  9985: LinearMipmapNearestFilter,
  9986: NearestMipmapLinearFilter,
  9987: LinearMipmapLinearFilter
};
const WEBGL_WRAPPINGS = {
  33071: ClampToEdgeWrapping,
  33648: MirroredRepeatWrapping,
  10497: RepeatWrapping
};
const WEBGL_TYPE_SIZES = {
  "SCALAR": 1,
  "VEC2": 2,
  "VEC3": 3,
  "VEC4": 4,
  "MAT2": 4,
  "MAT3": 9,
  "MAT4": 16
};
const ATTRIBUTES = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv2",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
};
const PATH_PROPERTIES = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
};
const INTERPOLATION = {
  CUBICSPLINE: void 0,
  LINEAR: InterpolateLinear,
  STEP: InterpolateDiscrete
};
const ALPHA_MODES = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function createDefaultMaterial(cache) {
  if (cache["DefaultMaterial"] === void 0) {
    cache["DefaultMaterial"] = new MeshStandardMaterial({
      color: 16777215,
      emissive: 0,
      metalness: 1,
      roughness: 1,
      transparent: false,
      depthTest: true,
      side: FrontSide
    });
  }
  return cache["DefaultMaterial"];
}
function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
  for (const name in objectDef.extensions) {
    if (knownExtensions[name] === void 0) {
      object.userData.gltfExtensions = object.userData.gltfExtensions || {};
      object.userData.gltfExtensions[name] = objectDef.extensions[name];
    }
  }
}
function assignExtrasToUserData(object, gltfDef) {
  if (gltfDef.extras !== void 0) {
    if (typeof gltfDef.extras === "object") {
      Object.assign(object.userData, gltfDef.extras);
    } else {
      console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
    }
  }
}
function addMorphTargets(geometry, targets, parser) {
  let hasMorphPosition = false;
  let hasMorphNormal = false;
  let hasMorphColor = false;
  for (let i2 = 0, il = targets.length; i2 < il; i2++) {
    const target = targets[i2];
    if (target.POSITION !== void 0)
      hasMorphPosition = true;
    if (target.NORMAL !== void 0)
      hasMorphNormal = true;
    if (target.COLOR_0 !== void 0)
      hasMorphColor = true;
    if (hasMorphPosition && hasMorphNormal && hasMorphColor)
      break;
  }
  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor)
    return Promise.resolve(geometry);
  const pendingPositionAccessors = [];
  const pendingNormalAccessors = [];
  const pendingColorAccessors = [];
  for (let i2 = 0, il = targets.length; i2 < il; i2++) {
    const target = targets[i2];
    if (hasMorphPosition) {
      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
      pendingPositionAccessors.push(pendingAccessor);
    }
    if (hasMorphNormal) {
      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
      pendingNormalAccessors.push(pendingAccessor);
    }
    if (hasMorphColor) {
      const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency("accessor", target.COLOR_0) : geometry.attributes.color;
      pendingColorAccessors.push(pendingAccessor);
    }
  }
  return Promise.all([
    Promise.all(pendingPositionAccessors),
    Promise.all(pendingNormalAccessors),
    Promise.all(pendingColorAccessors)
  ]).then(function(accessors) {
    const morphPositions = accessors[0];
    const morphNormals = accessors[1];
    const morphColors = accessors[2];
    if (hasMorphPosition)
      geometry.morphAttributes.position = morphPositions;
    if (hasMorphNormal)
      geometry.morphAttributes.normal = morphNormals;
    if (hasMorphColor)
      geometry.morphAttributes.color = morphColors;
    geometry.morphTargetsRelative = true;
    return geometry;
  });
}
function updateMorphTargets(mesh, meshDef) {
  mesh.updateMorphTargets();
  if (meshDef.weights !== void 0) {
    for (let i2 = 0, il = meshDef.weights.length; i2 < il; i2++) {
      mesh.morphTargetInfluences[i2] = meshDef.weights[i2];
    }
  }
  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
    const targetNames = meshDef.extras.targetNames;
    if (mesh.morphTargetInfluences.length === targetNames.length) {
      mesh.morphTargetDictionary = {};
      for (let i2 = 0, il = targetNames.length; i2 < il; i2++) {
        mesh.morphTargetDictionary[targetNames[i2]] = i2;
      }
    } else {
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
}
function createPrimitiveKey(primitiveDef) {
  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
  let geometryKey;
  if (dracoExtension) {
    geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
  } else {
    geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
  }
  return geometryKey;
}
function createAttributesKey(attributes) {
  let attributesKey = "";
  const keys = Object.keys(attributes).sort();
  for (let i2 = 0, il = keys.length; i2 < il; i2++) {
    attributesKey += keys[i2] + ":" + attributes[keys[i2]] + ";";
  }
  return attributesKey;
}
function getNormalizedComponentScale(constructor) {
  switch (constructor) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
class GLTFParser {
  constructor(json = {}, options = {}) {
    this.json = json;
    this.extensions = {};
    this.plugins = {};
    this.options = options;
    this.cache = new GLTFRegistry();
    this.associations = /* @__PURE__ */ new Map();
    this.primitiveCache = {};
    this.meshCache = { refs: {}, uses: {} };
    this.cameraCache = { refs: {}, uses: {} };
    this.lightCache = { refs: {}, uses: {} };
    this.sourceCache = {};
    this.textureCache = {};
    this.nodeNamesUsed = {};
    if (typeof createImageBitmap !== "undefined" && /Firefox|^((?!chrome|android).)*safari/i.test(navigator.userAgent) === false) {
      this.textureLoader = new ImageBitmapLoader(this.options.manager);
    } else {
      this.textureLoader = new TextureLoader(this.options.manager);
    }
    this.textureLoader.setCrossOrigin(this.options.crossOrigin);
    this.textureLoader.setRequestHeader(this.options.requestHeader);
    this.fileLoader = new FileLoader(this.options.manager);
    this.fileLoader.setResponseType("arraybuffer");
    if (this.options.crossOrigin === "use-credentials") {
      this.fileLoader.setWithCredentials(true);
    }
  }
  setExtensions(extensions) {
    this.extensions = extensions;
  }
  setPlugins(plugins) {
    this.plugins = plugins;
  }
  parse(onLoad, onError) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    this.cache.removeAll();
    this._invokeAll(function(ext) {
      return ext._markDefs && ext._markDefs();
    });
    Promise.all(this._invokeAll(function(ext) {
      return ext.beforeRoot && ext.beforeRoot();
    })).then(function() {
      return Promise.all([
        parser.getDependencies("scene"),
        parser.getDependencies("animation"),
        parser.getDependencies("camera")
      ]);
    }).then(function(dependencies) {
      const result = {
        scene: dependencies[0][json.scene || 0],
        scenes: dependencies[0],
        animations: dependencies[1],
        cameras: dependencies[2],
        asset: json.asset,
        parser,
        userData: {}
      };
      addUnknownExtensionsToUserData(extensions, result, json);
      assignExtrasToUserData(result, json);
      Promise.all(parser._invokeAll(function(ext) {
        return ext.afterRoot && ext.afterRoot(result);
      })).then(function() {
        onLoad(result);
      });
    }).catch(onError);
  }
  _markDefs() {
    const nodeDefs = this.json.nodes || [];
    const skinDefs = this.json.skins || [];
    const meshDefs = this.json.meshes || [];
    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
      const joints = skinDefs[skinIndex].joints;
      for (let i2 = 0, il = joints.length; i2 < il; i2++) {
        nodeDefs[joints[i2]].isBone = true;
      }
    }
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.mesh !== void 0) {
        this._addNodeRef(this.meshCache, nodeDef.mesh);
        if (nodeDef.skin !== void 0) {
          meshDefs[nodeDef.mesh].isSkinnedMesh = true;
        }
      }
      if (nodeDef.camera !== void 0) {
        this._addNodeRef(this.cameraCache, nodeDef.camera);
      }
    }
  }
  _addNodeRef(cache, index) {
    if (index === void 0)
      return;
    if (cache.refs[index] === void 0) {
      cache.refs[index] = cache.uses[index] = 0;
    }
    cache.refs[index]++;
  }
  _getNodeRef(cache, index, object) {
    if (cache.refs[index] <= 1)
      return object;
    const ref = object.clone();
    const updateMappings = (original, clone) => {
      const mappings = this.associations.get(original);
      if (mappings != null) {
        this.associations.set(clone, mappings);
      }
      for (const [i2, child] of original.children.entries()) {
        updateMappings(child, clone.children[i2]);
      }
    };
    updateMappings(object, ref);
    ref.name += "_instance_" + cache.uses[index]++;
    return ref;
  }
  _invokeOne(func) {
    const extensions = Object.values(this.plugins);
    extensions.push(this);
    for (let i2 = 0; i2 < extensions.length; i2++) {
      const result = func(extensions[i2]);
      if (result)
        return result;
    }
    return null;
  }
  _invokeAll(func) {
    const extensions = Object.values(this.plugins);
    extensions.unshift(this);
    const pending = [];
    for (let i2 = 0; i2 < extensions.length; i2++) {
      const result = func(extensions[i2]);
      if (result)
        pending.push(result);
    }
    return pending;
  }
  getDependency(type, index) {
    const cacheKey = type + ":" + index;
    let dependency = this.cache.get(cacheKey);
    if (!dependency) {
      switch (type) {
        case "scene":
          dependency = this.loadScene(index);
          break;
        case "node":
          dependency = this.loadNode(index);
          break;
        case "mesh":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMesh && ext.loadMesh(index);
          });
          break;
        case "accessor":
          dependency = this.loadAccessor(index);
          break;
        case "bufferView":
          dependency = this._invokeOne(function(ext) {
            return ext.loadBufferView && ext.loadBufferView(index);
          });
          break;
        case "buffer":
          dependency = this.loadBuffer(index);
          break;
        case "material":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMaterial && ext.loadMaterial(index);
          });
          break;
        case "texture":
          dependency = this._invokeOne(function(ext) {
            return ext.loadTexture && ext.loadTexture(index);
          });
          break;
        case "skin":
          dependency = this.loadSkin(index);
          break;
        case "animation":
          dependency = this.loadAnimation(index);
          break;
        case "camera":
          dependency = this.loadCamera(index);
          break;
        default:
          throw new Error("Unknown type: " + type);
      }
      this.cache.add(cacheKey, dependency);
    }
    return dependency;
  }
  getDependencies(type) {
    let dependencies = this.cache.get(type);
    if (!dependencies) {
      const parser = this;
      const defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
      dependencies = Promise.all(defs.map(function(def, index) {
        return parser.getDependency(type, index);
      }));
      this.cache.add(type, dependencies);
    }
    return dependencies;
  }
  loadBuffer(bufferIndex) {
    const bufferDef = this.json.buffers[bufferIndex];
    const loader = this.fileLoader;
    if (bufferDef.type && bufferDef.type !== "arraybuffer") {
      throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
    }
    if (bufferDef.uri === void 0 && bufferIndex === 0) {
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    }
    const options = this.options;
    return new Promise(function(resolve, reject) {
      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {
        reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
      });
    });
  }
  loadBufferView(bufferViewIndex) {
    const bufferViewDef = this.json.bufferViews[bufferViewIndex];
    return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer) {
      const byteLength = bufferViewDef.byteLength || 0;
      const byteOffset = bufferViewDef.byteOffset || 0;
      return buffer.slice(byteOffset, byteOffset + byteLength);
    });
  }
  loadAccessor(accessorIndex) {
    const parser = this;
    const json = this.json;
    const accessorDef = this.json.accessors[accessorIndex];
    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
      return Promise.resolve(null);
    }
    const pendingBufferViews = [];
    if (accessorDef.bufferView !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
    } else {
      pendingBufferViews.push(null);
    }
    if (accessorDef.sparse !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
    }
    return Promise.all(pendingBufferViews).then(function(bufferViews) {
      const bufferView = bufferViews[0];
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const elementBytes = TypedArray.BYTES_PER_ELEMENT;
      const itemBytes = elementBytes * itemSize;
      const byteOffset = accessorDef.byteOffset || 0;
      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
      const normalized = accessorDef.normalized === true;
      let array, bufferAttribute;
      if (byteStride && byteStride !== itemBytes) {
        const ibSlice = Math.floor(byteOffset / byteStride);
        const ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
        let ib = parser.cache.get(ibCacheKey);
        if (!ib) {
          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
          ib = new InterleavedBuffer(array, byteStride / elementBytes);
          parser.cache.add(ibCacheKey, ib);
        }
        bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
      } else {
        if (bufferView === null) {
          array = new TypedArray(accessorDef.count * itemSize);
        } else {
          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
        }
        bufferAttribute = new BufferAttribute(array, itemSize, normalized);
      }
      if (accessorDef.sparse !== void 0) {
        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
        const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
        if (bufferView !== null) {
          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
        }
        for (let i2 = 0, il = sparseIndices.length; i2 < il; i2++) {
          const index = sparseIndices[i2];
          bufferAttribute.setX(index, sparseValues[i2 * itemSize]);
          if (itemSize >= 2)
            bufferAttribute.setY(index, sparseValues[i2 * itemSize + 1]);
          if (itemSize >= 3)
            bufferAttribute.setZ(index, sparseValues[i2 * itemSize + 2]);
          if (itemSize >= 4)
            bufferAttribute.setW(index, sparseValues[i2 * itemSize + 3]);
          if (itemSize >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return bufferAttribute;
    });
  }
  loadTexture(textureIndex) {
    const json = this.json;
    const options = this.options;
    const textureDef = json.textures[textureIndex];
    const sourceIndex = textureDef.source;
    const sourceDef = json.images[sourceIndex];
    let loader = this.textureLoader;
    if (sourceDef.uri) {
      const handler = options.manager.getHandler(sourceDef.uri);
      if (handler !== null)
        loader = handler;
    }
    return this.loadTextureImage(textureIndex, sourceIndex, loader);
  }
  loadTextureImage(textureIndex, sourceIndex, loader) {
    const parser = this;
    const json = this.json;
    const textureDef = json.textures[textureIndex];
    const sourceDef = json.images[sourceIndex];
    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ":" + textureDef.sampler;
    if (this.textureCache[cacheKey]) {
      return this.textureCache[cacheKey];
    }
    const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {
      texture.flipY = false;
      if (textureDef.name)
        texture.name = textureDef.name;
      const samplers = json.samplers || {};
      const sampler = samplers[textureDef.sampler] || {};
      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
      parser.associations.set(texture, { textures: textureIndex });
      return texture;
    }).catch(function() {
      return null;
    });
    this.textureCache[cacheKey] = promise;
    return promise;
  }
  loadImageSource(sourceIndex, loader) {
    const parser = this;
    const json = this.json;
    const options = this.options;
    if (this.sourceCache[sourceIndex] !== void 0) {
      return this.sourceCache[sourceIndex].then(function(texture) {
        return texture.clone();
      }).catch(function(error) {
        throw error;
      });
    }
    const sourceDef = json.images[sourceIndex];
    const URL2 = self.URL || self.webkitURL;
    let sourceURI = sourceDef.uri || "";
    let isObjectURL = false;
    if (sourceDef.bufferView !== void 0) {
      sourceURI = parser.getDependency("bufferView", sourceDef.bufferView).then(function(bufferView) {
        isObjectURL = true;
        const blob = new Blob([bufferView], { type: sourceDef.mimeType });
        sourceURI = URL2.createObjectURL(blob);
        return sourceURI;
      });
    } else if (sourceDef.uri === void 0) {
      throw new Error("THREE.GLTFLoader: Image " + sourceIndex + " is missing URI and bufferView");
    }
    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {
      return new Promise(function(resolve, reject) {
        let onLoad = resolve;
        if (loader.isImageBitmapLoader === true) {
          onLoad = function(imageBitmap) {
            const texture = new Texture(imageBitmap);
            texture.needsUpdate = true;
            resolve(texture);
          };
        }
        loader.load(LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);
      });
    }).then(function(texture) {
      if (isObjectURL === true) {
        URL2.revokeObjectURL(sourceURI);
      }
      return texture;
    }).catch(function(error) {
      console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI);
      throw error;
    });
    this.sourceCache[sourceIndex] = promise;
    return promise;
  }
  assignTexture(materialParams, mapName, mapDef) {
    const parser = this;
    return this.getDependency("texture", mapDef.index).then(function(texture) {
      if (mapDef.texCoord !== void 0 && mapDef.texCoord != 0 && !(mapName === "aoMap" && mapDef.texCoord == 1)) {
        console.warn("THREE.GLTFLoader: Custom UV set " + mapDef.texCoord + " for texture " + mapName + " not yet supported.");
      }
      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
        const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
        if (transform) {
          const gltfReference = parser.associations.get(texture);
          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
          parser.associations.set(texture, gltfReference);
        }
      }
      materialParams[mapName] = texture;
      return texture;
    });
  }
  assignFinalMaterial(mesh) {
    const geometry = mesh.geometry;
    let material = mesh.material;
    const useDerivativeTangents = geometry.attributes.tangent === void 0;
    const useVertexColors = geometry.attributes.color !== void 0;
    const useFlatShading = geometry.attributes.normal === void 0;
    if (mesh.isPoints) {
      const cacheKey = "PointsMaterial:" + material.uuid;
      let pointsMaterial = this.cache.get(cacheKey);
      if (!pointsMaterial) {
        pointsMaterial = new PointsMaterial();
        Material.prototype.copy.call(pointsMaterial, material);
        pointsMaterial.color.copy(material.color);
        pointsMaterial.map = material.map;
        pointsMaterial.sizeAttenuation = false;
        this.cache.add(cacheKey, pointsMaterial);
      }
      material = pointsMaterial;
    } else if (mesh.isLine) {
      const cacheKey = "LineBasicMaterial:" + material.uuid;
      let lineMaterial = this.cache.get(cacheKey);
      if (!lineMaterial) {
        lineMaterial = new LineBasicMaterial();
        Material.prototype.copy.call(lineMaterial, material);
        lineMaterial.color.copy(material.color);
        this.cache.add(cacheKey, lineMaterial);
      }
      material = lineMaterial;
    }
    if (useDerivativeTangents || useVertexColors || useFlatShading) {
      let cacheKey = "ClonedMaterial:" + material.uuid + ":";
      if (material.isGLTFSpecularGlossinessMaterial)
        cacheKey += "specular-glossiness:";
      if (useDerivativeTangents)
        cacheKey += "derivative-tangents:";
      if (useVertexColors)
        cacheKey += "vertex-colors:";
      if (useFlatShading)
        cacheKey += "flat-shading:";
      let cachedMaterial = this.cache.get(cacheKey);
      if (!cachedMaterial) {
        cachedMaterial = material.clone();
        if (useVertexColors)
          cachedMaterial.vertexColors = true;
        if (useFlatShading)
          cachedMaterial.flatShading = true;
        if (useDerivativeTangents) {
          if (cachedMaterial.normalScale)
            cachedMaterial.normalScale.y *= -1;
          if (cachedMaterial.clearcoatNormalScale)
            cachedMaterial.clearcoatNormalScale.y *= -1;
        }
        this.cache.add(cacheKey, cachedMaterial);
        this.associations.set(cachedMaterial, this.associations.get(material));
      }
      material = cachedMaterial;
    }
    if (material.aoMap && geometry.attributes.uv2 === void 0 && geometry.attributes.uv !== void 0) {
      geometry.setAttribute("uv2", geometry.attributes.uv);
    }
    mesh.material = material;
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  loadMaterial(materialIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const materialDef = json.materials[materialIndex];
    let materialType;
    const materialParams = {};
    const materialExtensions = materialDef.extensions || {};
    const pending = [];
    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
      const sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
      materialType = sgExtension.getMaterialType();
      pending.push(sgExtension.extendParams(materialParams, materialDef, parser));
    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
      materialType = kmuExtension.getMaterialType();
      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
    } else {
      const metallicRoughness = materialDef.pbrMetallicRoughness || {};
      materialParams.color = new Color(1, 1, 1);
      materialParams.opacity = 1;
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture));
      }
      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
      if (metallicRoughness.metallicRoughnessTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
        pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
      }
      materialType = this._invokeOne(function(ext) {
        return ext.getMaterialType && ext.getMaterialType(materialIndex);
      });
      pending.push(Promise.all(this._invokeAll(function(ext) {
        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
      })));
    }
    if (materialDef.doubleSided === true) {
      materialParams.side = DoubleSide;
    }
    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
    if (alphaMode === ALPHA_MODES.BLEND) {
      materialParams.transparent = true;
      materialParams.depthWrite = false;
    } else {
      materialParams.transparent = false;
      if (alphaMode === ALPHA_MODES.MASK) {
        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
      }
    }
    if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
      materialParams.normalScale = new Vector2(1, 1);
      if (materialDef.normalTexture.scale !== void 0) {
        const scale = materialDef.normalTexture.scale;
        materialParams.normalScale.set(scale, scale);
      }
    }
    if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
      if (materialDef.occlusionTexture.strength !== void 0) {
        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
      }
    }
    if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {
      materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);
    }
    if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture));
    }
    return Promise.all(pending).then(function() {
      let material;
      if (materialType === GLTFMeshStandardSGMaterial) {
        material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);
      } else {
        material = new materialType(materialParams);
      }
      if (materialDef.name)
        material.name = materialDef.name;
      if (material.map)
        material.map.encoding = sRGBEncoding;
      if (material.emissiveMap)
        material.emissiveMap.encoding = sRGBEncoding;
      assignExtrasToUserData(material, materialDef);
      parser.associations.set(material, { materials: materialIndex });
      if (materialDef.extensions)
        addUnknownExtensionsToUserData(extensions, material, materialDef);
      return material;
    });
  }
  createUniqueName(originalName) {
    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || "");
    let name = sanitizedName;
    for (let i2 = 1; this.nodeNamesUsed[name]; ++i2) {
      name = sanitizedName + "_" + i2;
    }
    this.nodeNamesUsed[name] = true;
    return name;
  }
  loadGeometries(primitives) {
    const parser = this;
    const extensions = this.extensions;
    const cache = this.primitiveCache;
    function createDracoPrimitive(primitive) {
      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
        return addPrimitiveAttributes(geometry, primitive, parser);
      });
    }
    const pending = [];
    for (let i2 = 0, il = primitives.length; i2 < il; i2++) {
      const primitive = primitives[i2];
      const cacheKey = createPrimitiveKey(primitive);
      const cached = cache[cacheKey];
      if (cached) {
        pending.push(cached.promise);
      } else {
        let geometryPromise;
        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
          geometryPromise = createDracoPrimitive(primitive);
        } else {
          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
        }
        cache[cacheKey] = { primitive, promise: geometryPromise };
        pending.push(geometryPromise);
      }
    }
    return Promise.all(pending);
  }
  loadMesh(meshIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const meshDef = json.meshes[meshIndex];
    const primitives = meshDef.primitives;
    const pending = [];
    for (let i2 = 0, il = primitives.length; i2 < il; i2++) {
      const material = primitives[i2].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i2].material);
      pending.push(material);
    }
    pending.push(parser.loadGeometries(primitives));
    return Promise.all(pending).then(function(results) {
      const materials = results.slice(0, results.length - 1);
      const geometries = results[results.length - 1];
      const meshes = [];
      for (let i2 = 0, il = geometries.length; i2 < il; i2++) {
        const geometry = geometries[i2];
        const primitive = primitives[i2];
        let mesh;
        const material = materials[i2];
        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {
          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);
          if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {
            mesh.normalizeSkinWeights();
          }
          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
          }
        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
          mesh = new LineSegments(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
          mesh = new Line(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
          mesh = new LineLoop(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
          mesh = new Points(geometry, material);
        } else {
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
        }
        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
          updateMorphTargets(mesh, meshDef);
        }
        mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
        assignExtrasToUserData(mesh, meshDef);
        if (primitive.extensions)
          addUnknownExtensionsToUserData(extensions, mesh, primitive);
        parser.assignFinalMaterial(mesh);
        meshes.push(mesh);
      }
      for (let i2 = 0, il = meshes.length; i2 < il; i2++) {
        parser.associations.set(meshes[i2], {
          meshes: meshIndex,
          primitives: i2
        });
      }
      if (meshes.length === 1) {
        return meshes[0];
      }
      const group = new Group();
      parser.associations.set(group, { meshes: meshIndex });
      for (let i2 = 0, il = meshes.length; i2 < il; i2++) {
        group.add(meshes[i2]);
      }
      return group;
    });
  }
  loadCamera(cameraIndex) {
    let camera;
    const cameraDef = this.json.cameras[cameraIndex];
    const params = cameraDef[cameraDef.type];
    if (!params) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    if (cameraDef.type === "perspective") {
      camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
    } else if (cameraDef.type === "orthographic") {
      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
    }
    if (cameraDef.name)
      camera.name = this.createUniqueName(cameraDef.name);
    assignExtrasToUserData(camera, cameraDef);
    return Promise.resolve(camera);
  }
  loadSkin(skinIndex) {
    const skinDef = this.json.skins[skinIndex];
    const skinEntry = { joints: skinDef.joints };
    if (skinDef.inverseBindMatrices === void 0) {
      return Promise.resolve(skinEntry);
    }
    return this.getDependency("accessor", skinDef.inverseBindMatrices).then(function(accessor) {
      skinEntry.inverseBindMatrices = accessor;
      return skinEntry;
    });
  }
  loadAnimation(animationIndex) {
    const json = this.json;
    const animationDef = json.animations[animationIndex];
    const pendingNodes = [];
    const pendingInputAccessors = [];
    const pendingOutputAccessors = [];
    const pendingSamplers = [];
    const pendingTargets = [];
    for (let i2 = 0, il = animationDef.channels.length; i2 < il; i2++) {
      const channel = animationDef.channels[i2];
      const sampler = animationDef.samplers[channel.sampler];
      const target = channel.target;
      const name = target.node !== void 0 ? target.node : target.id;
      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
      pendingNodes.push(this.getDependency("node", name));
      pendingInputAccessors.push(this.getDependency("accessor", input));
      pendingOutputAccessors.push(this.getDependency("accessor", output));
      pendingSamplers.push(sampler);
      pendingTargets.push(target);
    }
    return Promise.all([
      Promise.all(pendingNodes),
      Promise.all(pendingInputAccessors),
      Promise.all(pendingOutputAccessors),
      Promise.all(pendingSamplers),
      Promise.all(pendingTargets)
    ]).then(function(dependencies) {
      const nodes = dependencies[0];
      const inputAccessors = dependencies[1];
      const outputAccessors = dependencies[2];
      const samplers = dependencies[3];
      const targets = dependencies[4];
      const tracks = [];
      for (let i2 = 0, il = nodes.length; i2 < il; i2++) {
        const node = nodes[i2];
        const inputAccessor = inputAccessors[i2];
        const outputAccessor = outputAccessors[i2];
        const sampler = samplers[i2];
        const target = targets[i2];
        if (node === void 0)
          continue;
        node.updateMatrix();
        node.matrixAutoUpdate = true;
        let TypedKeyframeTrack;
        switch (PATH_PROPERTIES[target.path]) {
          case PATH_PROPERTIES.weights:
            TypedKeyframeTrack = NumberKeyframeTrack;
            break;
          case PATH_PROPERTIES.rotation:
            TypedKeyframeTrack = QuaternionKeyframeTrack;
            break;
          case PATH_PROPERTIES.position:
          case PATH_PROPERTIES.scale:
          default:
            TypedKeyframeTrack = VectorKeyframeTrack;
            break;
        }
        const targetName = node.name ? node.name : node.uuid;
        const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;
        const targetNames = [];
        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
          node.traverse(function(object) {
            if (object.morphTargetInfluences) {
              targetNames.push(object.name ? object.name : object.uuid);
            }
          });
        } else {
          targetNames.push(targetName);
        }
        let outputArray = outputAccessor.array;
        if (outputAccessor.normalized) {
          const scale = getNormalizedComponentScale(outputArray.constructor);
          const scaled = new Float32Array(outputArray.length);
          for (let j2 = 0, jl = outputArray.length; j2 < jl; j2++) {
            scaled[j2] = outputArray[j2] * scale;
          }
          outputArray = scaled;
        }
        for (let j2 = 0, jl = targetNames.length; j2 < jl; j2++) {
          const track = new TypedKeyframeTrack(targetNames[j2] + "." + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);
          if (sampler.interpolation === "CUBICSPLINE") {
            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
              const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
              return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
            };
            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
          }
          tracks.push(track);
        }
      }
      const name = animationDef.name ? animationDef.name : "animation_" + animationIndex;
      return new AnimationClip(name, void 0, tracks);
    });
  }
  createNodeMesh(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    if (nodeDef.mesh === void 0)
      return null;
    return parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
      if (nodeDef.weights !== void 0) {
        node.traverse(function(o2) {
          if (!o2.isMesh)
            return;
          for (let i2 = 0, il = nodeDef.weights.length; i2 < il; i2++) {
            o2.morphTargetInfluences[i2] = nodeDef.weights[i2];
          }
        });
      }
      return node;
    });
  }
  loadNode(nodeIndex) {
    const json = this.json;
    const extensions = this.extensions;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
    return function() {
      const pending = [];
      const meshPromise = parser._invokeOne(function(ext) {
        return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
      });
      if (meshPromise) {
        pending.push(meshPromise);
      }
      if (nodeDef.camera !== void 0) {
        pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera) {
          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
        }));
      }
      parser._invokeAll(function(ext) {
        return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
      }).forEach(function(promise) {
        pending.push(promise);
      });
      return Promise.all(pending);
    }().then(function(objects) {
      let node;
      if (nodeDef.isBone === true) {
        node = new Bone();
      } else if (objects.length > 1) {
        node = new Group();
      } else if (objects.length === 1) {
        node = objects[0];
      } else {
        node = new Object3D();
      }
      if (node !== objects[0]) {
        for (let i2 = 0, il = objects.length; i2 < il; i2++) {
          node.add(objects[i2]);
        }
      }
      if (nodeDef.name) {
        node.userData.name = nodeDef.name;
        node.name = nodeName;
      }
      assignExtrasToUserData(node, nodeDef);
      if (nodeDef.extensions)
        addUnknownExtensionsToUserData(extensions, node, nodeDef);
      if (nodeDef.matrix !== void 0) {
        const matrix = new Matrix4();
        matrix.fromArray(nodeDef.matrix);
        node.applyMatrix4(matrix);
      } else {
        if (nodeDef.translation !== void 0) {
          node.position.fromArray(nodeDef.translation);
        }
        if (nodeDef.rotation !== void 0) {
          node.quaternion.fromArray(nodeDef.rotation);
        }
        if (nodeDef.scale !== void 0) {
          node.scale.fromArray(nodeDef.scale);
        }
      }
      if (!parser.associations.has(node)) {
        parser.associations.set(node, {});
      }
      parser.associations.get(node).nodes = nodeIndex;
      return node;
    });
  }
  loadScene(sceneIndex) {
    const json = this.json;
    const extensions = this.extensions;
    const sceneDef = this.json.scenes[sceneIndex];
    const parser = this;
    const scene = new Group();
    if (sceneDef.name)
      scene.name = parser.createUniqueName(sceneDef.name);
    assignExtrasToUserData(scene, sceneDef);
    if (sceneDef.extensions)
      addUnknownExtensionsToUserData(extensions, scene, sceneDef);
    const nodeIds = sceneDef.nodes || [];
    const pending = [];
    for (let i2 = 0, il = nodeIds.length; i2 < il; i2++) {
      pending.push(buildNodeHierarchy(nodeIds[i2], scene, json, parser));
    }
    return Promise.all(pending).then(function() {
      const reduceAssociations = (node) => {
        const reducedAssociations = /* @__PURE__ */ new Map();
        for (const [key, value] of parser.associations) {
          if (key instanceof Material || key instanceof Texture) {
            reducedAssociations.set(key, value);
          }
        }
        node.traverse((node2) => {
          const mappings = parser.associations.get(node2);
          if (mappings != null) {
            reducedAssociations.set(node2, mappings);
          }
        });
        return reducedAssociations;
      };
      parser.associations = reduceAssociations(scene);
      return scene;
    });
  }
}
function buildNodeHierarchy(nodeId, parentObject, json, parser) {
  const nodeDef = json.nodes[nodeId];
  return parser.getDependency("node", nodeId).then(function(node) {
    if (nodeDef.skin === void 0)
      return node;
    let skinEntry;
    return parser.getDependency("skin", nodeDef.skin).then(function(skin) {
      skinEntry = skin;
      const pendingJoints = [];
      for (let i2 = 0, il = skinEntry.joints.length; i2 < il; i2++) {
        pendingJoints.push(parser.getDependency("node", skinEntry.joints[i2]));
      }
      return Promise.all(pendingJoints);
    }).then(function(jointNodes) {
      node.traverse(function(mesh) {
        if (!mesh.isMesh)
          return;
        const bones = [];
        const boneInverses = [];
        for (let j2 = 0, jl = jointNodes.length; j2 < jl; j2++) {
          const jointNode = jointNodes[j2];
          if (jointNode) {
            bones.push(jointNode);
            const mat = new Matrix4();
            if (skinEntry.inverseBindMatrices !== void 0) {
              mat.fromArray(skinEntry.inverseBindMatrices.array, j2 * 16);
            }
            boneInverses.push(mat);
          } else {
            console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[j2]);
          }
        }
        mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld);
      });
      return node;
    });
  }).then(function(node) {
    parentObject.add(node);
    const pending = [];
    if (nodeDef.children) {
      const children = nodeDef.children;
      for (let i2 = 0, il = children.length; i2 < il; i2++) {
        const child = children[i2];
        pending.push(buildNodeHierarchy(child, node, json, parser));
      }
    }
    return Promise.all(pending);
  });
}
function computeBounds(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const box = new Box3();
  if (attributes.POSITION !== void 0) {
    const accessor = parser.json.accessors[attributes.POSITION];
    const min = accessor.min;
    const max = accessor.max;
    if (min !== void 0 && max !== void 0) {
      box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]));
      if (accessor.normalized) {
        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
        box.min.multiplyScalar(boxScale);
        box.max.multiplyScalar(boxScale);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else {
    return;
  }
  const targets = primitiveDef.targets;
  if (targets !== void 0) {
    const maxDisplacement = new Vector3();
    const vector = new Vector3();
    for (let i2 = 0, il = targets.length; i2 < il; i2++) {
      const target = targets[i2];
      if (target.POSITION !== void 0) {
        const accessor = parser.json.accessors[target.POSITION];
        const min = accessor.min;
        const max = accessor.max;
        if (min !== void 0 && max !== void 0) {
          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));
          if (accessor.normalized) {
            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
            vector.multiplyScalar(boxScale);
          }
          maxDisplacement.max(vector);
        } else {
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }
    }
    box.expandByVector(maxDisplacement);
  }
  geometry.boundingBox = box;
  const sphere = new Sphere();
  box.getCenter(sphere.center);
  sphere.radius = box.min.distanceTo(box.max) / 2;
  geometry.boundingSphere = sphere;
}
function addPrimitiveAttributes(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const pending = [];
  function assignAttributeAccessor(accessorIndex, attributeName) {
    return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
      geometry.setAttribute(attributeName, accessor);
    });
  }
  for (const gltfAttributeName in attributes) {
    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
    if (threeAttributeName in geometry.attributes)
      continue;
    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
  }
  if (primitiveDef.indices !== void 0 && !geometry.index) {
    const accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
      geometry.setIndex(accessor2);
    });
    pending.push(accessor);
  }
  assignExtrasToUserData(geometry, primitiveDef);
  computeBounds(geometry, primitiveDef, parser);
  return Promise.all(pending).then(function() {
    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
  });
}
function toTrianglesDrawMode(geometry, drawMode) {
  let index = geometry.getIndex();
  if (index === null) {
    const indices = [];
    const position = geometry.getAttribute("position");
    if (position !== void 0) {
      for (let i2 = 0; i2 < position.count; i2++) {
        indices.push(i2);
      }
      geometry.setIndex(indices);
      index = geometry.getIndex();
    } else {
      console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
      return geometry;
    }
  }
  const numberOfTriangles = index.count - 2;
  const newIndices = [];
  if (drawMode === TriangleFanDrawMode) {
    for (let i2 = 1; i2 <= numberOfTriangles; i2++) {
      newIndices.push(index.getX(0));
      newIndices.push(index.getX(i2));
      newIndices.push(index.getX(i2 + 1));
    }
  } else {
    for (let i2 = 0; i2 < numberOfTriangles; i2++) {
      if (i2 % 2 === 0) {
        newIndices.push(index.getX(i2));
        newIndices.push(index.getX(i2 + 1));
        newIndices.push(index.getX(i2 + 2));
      } else {
        newIndices.push(index.getX(i2 + 2));
        newIndices.push(index.getX(i2 + 1));
        newIndices.push(index.getX(i2));
      }
    }
  }
  if (newIndices.length / 3 !== numberOfTriangles) {
    console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
  }
  const newGeometry = geometry.clone();
  newGeometry.setIndex(newIndices);
  return newGeometry;
}
export { MeshToonMaterial as $, TorusKnotGeometry as A, BoxGeometry as B, CanvasTexture as C, DataTexture as D, Euler as E, TubeGeometry as F, LineBasicMaterial as G, LineDashedMaterial as H, IcosahedronGeometry as I, MeshDepthMaterial as J, MeshDistanceMaterial as K, LatheGeometry as L, MeshBasicMaterial as M, MeshLambertMaterial as N, Object3D as O, PlaneGeometry as P, Quaternion as Q, RingGeometry as R, ShapeGeometry as S, TextureLoader as T, MeshMatcapMaterial as U, Vector3 as V, WireframeGeometry as W, MeshNormalMaterial as X, MeshPhongMaterial as Y, MeshPhysicalMaterial as Z, MeshStandardMaterial as _, defineQuery as a, PointsMaterial as a0, RawShaderMaterial as a1, ShaderMaterial as a2, ShadowMaterial as a3, SpriteMaterial as a4, Scene as a5, Mesh as a6, SkinnedMesh as a7, InstancedMesh as a8, DynamicDrawUsage as a9, zA as aA, ArrowHelper as aB, enterQuery as aC, HA as aD, TA as aE, AnimationMixer as aF, ACESFilmicToneMapping as aG, sRGBEncoding as aH, GLTFLoader as aI, RepeatWrapping as aJ, Bone as aa, OrthographicCamera as ab, PerspectiveCamera as ac, Group as ad, Line as ae, LineLoop as af, LineSegments as ag, PointLight as ah, Points as ai, SpotLight as aj, Audio as ak, PositionalAudio as al, AudioListener as am, Vector2 as an, createWorld as ao, WebGLRenderer as ap, Clock as aq, pipe as ar, MathUtils as as, $ as at, FI as au, BI as av, iA as aw, pA as ax, ZA as ay, uA as az, addComponent as b, Types as c, defineComponent as d, defineSystem as e, exitQuery as f, addEntity as g, removeComponent as h, hasComponent as i, Texture as j, CompressedTexture as k, CubeTexture as l, DepthTexture as m, VideoTexture as n, CircleGeometry as o, ConeGeometry as p, CylinderGeometry as q, removeEntity as r, DodecahedronGeometry as s, EdgesGeometry as t, ExtrudeGeometry as u, OctahedronGeometry as v, PolyhedronGeometry as w, SphereGeometry as x, TetrahedronGeometry as y, TorusGeometry as z };
