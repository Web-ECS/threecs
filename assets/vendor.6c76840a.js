var __defProp = Object.defineProperty;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __assign = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = "127";
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const FlatShading = 1;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;
const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const CubeUVRefractionMapping = 307;
const RepeatWrapping = 1e3;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedShort565Type = 1019;
const UnsignedInt248Type = 1020;
const AlphaFormat = 1021;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBIntegerFormat = 1032;
const RGBAIntegerFormat = 1033;
const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
const LoopOnce = 2200;
const LoopRepeat = 2201;
const LoopPingPong = 2202;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const TrianglesDrawMode = 0;
const TriangleStripDrawMode = 1;
const TriangleFanDrawMode = 2;
const LinearEncoding = 3e3;
const sRGBEncoding = 3001;
const GammaEncoding = 3007;
const RGBEEncoding = 3002;
const LogLuvEncoding = 3003;
const RGBM7Encoding = 3004;
const RGBM16Encoding = 3005;
const RGBDEncoding = 3006;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;
const KeepStencilOp = 7680;
const AlwaysStencilFunc = 519;
const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;
const GLSL3 = "300 es";
function EventDispatcher() {
}
Object.assign(EventDispatcher.prototype, {
  addEventListener: function(type, listener) {
    if (this._listeners === void 0)
      this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  },
  hasEventListener: function(type, listener) {
    if (this._listeners === void 0)
      return false;
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  },
  removeEventListener: function(type, listener) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  },
  dispatchEvent: function(event) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i2 = 0, l2 = array.length; i2 < l2; i2++) {
        array[i2].call(this, event);
      }
      event.target = null;
    }
  }
});
const _lut = [];
for (let i2 = 0; i2 < 256; i2++) {
  _lut[i2] = (i2 < 16 ? "0" : "") + i2.toString(16);
}
let _seed = 1234567;
const MathUtils = {
  DEG2RAD: Math.PI / 180,
  RAD2DEG: 180 / Math.PI,
  generateUUID: function() {
    const d0 = Math.random() * 4294967295 | 0;
    const d1 = Math.random() * 4294967295 | 0;
    const d2 = Math.random() * 4294967295 | 0;
    const d3 = Math.random() * 4294967295 | 0;
    const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
    return uuid.toUpperCase();
  },
  clamp: function(value, min, max) {
    return Math.max(min, Math.min(max, value));
  },
  euclideanModulo: function(n2, m2) {
    return (n2 % m2 + m2) % m2;
  },
  mapLinear: function(x2, a1, a2, b1, b2) {
    return b1 + (x2 - a1) * (b2 - b1) / (a2 - a1);
  },
  inverseLerp: function(x2, y2, value) {
    if (x2 !== y2) {
      return (value - x2) / (y2 - x2);
    } else {
      return 0;
    }
  },
  lerp: function(x2, y2, t2) {
    return (1 - t2) * x2 + t2 * y2;
  },
  damp: function(x2, y2, lambda, dt) {
    return MathUtils.lerp(x2, y2, 1 - Math.exp(-lambda * dt));
  },
  pingpong: function(x2, length = 1) {
    return length - Math.abs(MathUtils.euclideanModulo(x2, length * 2) - length);
  },
  smoothstep: function(x2, min, max) {
    if (x2 <= min)
      return 0;
    if (x2 >= max)
      return 1;
    x2 = (x2 - min) / (max - min);
    return x2 * x2 * (3 - 2 * x2);
  },
  smootherstep: function(x2, min, max) {
    if (x2 <= min)
      return 0;
    if (x2 >= max)
      return 1;
    x2 = (x2 - min) / (max - min);
    return x2 * x2 * x2 * (x2 * (x2 * 6 - 15) + 10);
  },
  randInt: function(low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
  },
  randFloat: function(low, high) {
    return low + Math.random() * (high - low);
  },
  randFloatSpread: function(range) {
    return range * (0.5 - Math.random());
  },
  seededRandom: function(s2) {
    if (s2 !== void 0)
      _seed = s2 % 2147483647;
    _seed = _seed * 16807 % 2147483647;
    return (_seed - 1) / 2147483646;
  },
  degToRad: function(degrees) {
    return degrees * MathUtils.DEG2RAD;
  },
  radToDeg: function(radians) {
    return radians * MathUtils.RAD2DEG;
  },
  isPowerOfTwo: function(value) {
    return (value & value - 1) === 0 && value !== 0;
  },
  ceilPowerOfTwo: function(value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
  },
  floorPowerOfTwo: function(value) {
    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
  },
  setQuaternionFromProperEuler: function(q2, a2, b2, c2, order) {
    const cos = Math.cos;
    const sin = Math.sin;
    const c22 = cos(b2 / 2);
    const s2 = sin(b2 / 2);
    const c13 = cos((a2 + c2) / 2);
    const s13 = sin((a2 + c2) / 2);
    const c1_3 = cos((a2 - c2) / 2);
    const s1_3 = sin((a2 - c2) / 2);
    const c3_1 = cos((c2 - a2) / 2);
    const s3_1 = sin((c2 - a2) / 2);
    switch (order) {
      case "XYX":
        q2.set(c22 * s13, s2 * c1_3, s2 * s1_3, c22 * c13);
        break;
      case "YZY":
        q2.set(s2 * s1_3, c22 * s13, s2 * c1_3, c22 * c13);
        break;
      case "ZXZ":
        q2.set(s2 * c1_3, s2 * s1_3, c22 * s13, c22 * c13);
        break;
      case "XZX":
        q2.set(c22 * s13, s2 * s3_1, s2 * c3_1, c22 * c13);
        break;
      case "YXY":
        q2.set(s2 * c3_1, c22 * s13, s2 * s3_1, c22 * c13);
        break;
      case "ZYZ":
        q2.set(s2 * s3_1, s2 * c3_1, c22 * s13, c22 * c13);
        break;
      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
    }
  }
};
class Vector2 {
  constructor(x2 = 0, y2 = 0) {
    this.x = x2;
    this.y = y2;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x2, y2) {
    this.x = x2;
    this.y = y2;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x2) {
    this.x = x2;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    return this;
  }
  add(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v2, w2);
    }
    this.x += v2.x;
    this.y += v2.y;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    return this;
  }
  addVectors(a2, b2) {
    this.x = a2.x + b2.x;
    this.y = a2.y + b2.y;
    return this;
  }
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    return this;
  }
  sub(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v2, w2);
    }
    this.x -= v2.x;
    this.y -= v2.y;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    return this;
  }
  subVectors(a2, b2) {
    this.x = a2.x - b2.x;
    this.y = a2.y - b2.y;
    return this;
  }
  multiply(v2) {
    this.x *= v2.x;
    this.y *= v2.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v2) {
    this.x /= v2.x;
    this.y /= v2.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m2) {
    const x2 = this.x, y2 = this.y;
    const e2 = m2.elements;
    this.x = e2[0] * x2 + e2[3] * y2 + e2[6];
    this.y = e2[1] * x2 + e2[4] * y2 + e2[7];
    return this;
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y;
  }
  cross(v2) {
    return this.x * v2.y - this.y * v2.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  distanceTo(v2) {
    return Math.sqrt(this.distanceToSquared(v2));
  }
  distanceToSquared(v2) {
    const dx = this.x - v2.x, dy = this.y - v2.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v2) {
    return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  }
  rotateAround(center, angle) {
    const c2 = Math.cos(angle), s2 = Math.sin(angle);
    const x2 = this.x - center.x;
    const y2 = this.y - center.y;
    this.x = x2 * c2 - y2 * s2 + center.x;
    this.y = x2 * s2 + y2 * c2 + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
}
Vector2.prototype.isVector2 = true;
class Matrix3 {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  }
  copy(m2) {
    const te = this.elements;
    const me = m2.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m2) {
    const me = m2.elements;
    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
    return this;
  }
  multiply(m2) {
    return this.multiplyMatrices(this, m2);
  }
  premultiply(m2) {
    return this.multiplyMatrices(m2, this);
  }
  multiplyMatrices(a2, b2) {
    const ae = a2.elements;
    const be = b2.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[3], a13 = ae[6];
    const a21 = ae[1], a22 = ae[4], a23 = ae[7];
    const a31 = ae[2], a32 = ae[5], a33 = ae[8];
    const b11 = be[0], b12 = be[3], b13 = be[6];
    const b21 = be[1], b22 = be[4], b23 = be[7];
    const b31 = be[2], b32 = be[5], b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s2) {
    const te = this.elements;
    te[0] *= s2;
    te[3] *= s2;
    te[6] *= s2;
    te[1] *= s2;
    te[4] *= s2;
    te[7] *= s2;
    te[2] *= s2;
    te[5] *= s2;
    te[8] *= s2;
    return this;
  }
  determinant() {
    const te = this.elements;
    const a2 = te[0], b2 = te[1], c2 = te[2], d2 = te[3], e2 = te[4], f2 = te[5], g2 = te[6], h2 = te[7], i2 = te[8];
    return a2 * e2 * i2 - a2 * f2 * h2 - b2 * d2 * i2 + b2 * f2 * g2 + c2 * d2 * h2 - c2 * e2 * g2;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp;
    const m2 = this.elements;
    tmp = m2[1];
    m2[1] = m2[3];
    m2[3] = tmp;
    tmp = m2[2];
    m2[2] = m2[6];
    m2[6] = tmp;
    tmp = m2[5];
    m2[5] = m2[7];
    m2[7] = tmp;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  transposeIntoArray(r2) {
    const m2 = this.elements;
    r2[0] = m2[0];
    r2[1] = m2[3];
    r2[2] = m2[6];
    r2[3] = m2[1];
    r2[4] = m2[4];
    r2[5] = m2[7];
    r2[6] = m2[2];
    r2[7] = m2[5];
    r2[8] = m2[8];
    return this;
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c2 = Math.cos(rotation);
    const s2 = Math.sin(rotation);
    this.set(sx * c2, sx * s2, -sx * (c2 * cx + s2 * cy) + cx + tx, -sy * s2, sy * c2, -sy * (-s2 * cx + c2 * cy) + cy + ty, 0, 0, 1);
    return this;
  }
  scale(sx, sy) {
    const te = this.elements;
    te[0] *= sx;
    te[3] *= sx;
    te[6] *= sx;
    te[1] *= sy;
    te[4] *= sy;
    te[7] *= sy;
    return this;
  }
  rotate(theta) {
    const c2 = Math.cos(theta);
    const s2 = Math.sin(theta);
    const te = this.elements;
    const a11 = te[0], a12 = te[3], a13 = te[6];
    const a21 = te[1], a22 = te[4], a23 = te[7];
    te[0] = c2 * a11 + s2 * a21;
    te[3] = c2 * a12 + s2 * a22;
    te[6] = c2 * a13 + s2 * a23;
    te[1] = -s2 * a11 + c2 * a21;
    te[4] = -s2 * a12 + c2 * a22;
    te[7] = -s2 * a13 + c2 * a23;
    return this;
  }
  translate(tx, ty) {
    const te = this.elements;
    te[0] += tx * te[2];
    te[3] += tx * te[5];
    te[6] += tx * te[8];
    te[1] += ty * te[2];
    te[4] += ty * te[5];
    te[7] += ty * te[8];
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i2 = 0; i2 < 9; i2++) {
      if (te[i2] !== me[i2])
        return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.elements[i2] = array[i2 + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
Matrix3.prototype.isMatrix3 = true;
let _canvas;
const ImageUtils = {
  getDataURL: function(image) {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }
    if (typeof HTMLCanvasElement == "undefined") {
      return image.src;
    }
    let canvas;
    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === void 0)
        _canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      _canvas.width = image.width;
      _canvas.height = image.height;
      const context = _canvas.getContext("2d");
      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas = _canvas;
    }
    if (canvas.width > 2048 || canvas.height > 2048) {
      console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
      return canvas.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas.toDataURL("image/png");
    }
  }
};
let textureId = 0;
class Texture extends EventDispatcher {
  constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
    super();
    Object.defineProperty(this, "id", {value: textureId++});
    this.uuid = MathUtils.generateUUID();
    this.name = "";
    this.image = image;
    this.mipmaps = [];
    this.mapping = mapping;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.encoding = encoding;
    this.version = 0;
    this.onUpdate = null;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.image = source.image;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.encoding = source.encoding;
    return this;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (this.image !== void 0) {
      const image = this.image;
      if (image.uuid === void 0) {
        image.uuid = MathUtils.generateUUID();
      }
      if (!isRootObject && meta.images[image.uuid] === void 0) {
        let url;
        if (Array.isArray(image)) {
          url = [];
          for (let i2 = 0, l2 = image.length; i2 < l2; i2++) {
            if (image[i2].isDataTexture) {
              url.push(serializeImage(image[i2].image));
            } else {
              url.push(serializeImage(image[i2]));
            }
          }
        } else {
          url = serializeImage(image);
        }
        meta.images[image.uuid] = {
          uuid: image.uuid,
          url
        };
      }
      output.image = image.uuid;
    }
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  }
  dispose() {
    this.dispatchEvent({type: "dispose"});
  }
  transformUv(uv) {
    if (this.mapping !== UVMapping)
      return uv;
    uv.applyMatrix3(this.matrix);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }
          break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
    return uv;
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
}
Texture.DEFAULT_IMAGE = void 0;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype.isTexture = true;
function serializeImage(image) {
  if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.prototype.slice.call(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
class Vector4 {
  constructor(x2 = 0, y2 = 0, z2 = 0, w2 = 1) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
    this.w = w2;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x2, y2, z2, w2) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
    this.w = w2;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  setX(x2) {
    this.x = x2;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setZ(z2) {
    this.z = z2;
    return this;
  }
  setW(w2) {
    this.w = w2;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    this.z = v2.z;
    this.w = v2.w !== void 0 ? v2.w : 1;
    return this;
  }
  add(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v2, w2);
    }
    this.x += v2.x;
    this.y += v2.y;
    this.z += v2.z;
    this.w += v2.w;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    this.z += s2;
    this.w += s2;
    return this;
  }
  addVectors(a2, b2) {
    this.x = a2.x + b2.x;
    this.y = a2.y + b2.y;
    this.z = a2.z + b2.z;
    this.w = a2.w + b2.w;
    return this;
  }
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    this.z += v2.z * s2;
    this.w += v2.w * s2;
    return this;
  }
  sub(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v2, w2);
    }
    this.x -= v2.x;
    this.y -= v2.y;
    this.z -= v2.z;
    this.w -= v2.w;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    this.z -= s2;
    this.w -= s2;
    return this;
  }
  subVectors(a2, b2) {
    this.x = a2.x - b2.x;
    this.y = a2.y - b2.y;
    this.z = a2.z - b2.z;
    this.w = a2.w - b2.w;
    return this;
  }
  multiply(v2) {
    this.x *= v2.x;
    this.y *= v2.y;
    this.z *= v2.z;
    this.w *= v2.w;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  applyMatrix4(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z, w2 = this.w;
    const e2 = m2.elements;
    this.x = e2[0] * x2 + e2[4] * y2 + e2[8] * z2 + e2[12] * w2;
    this.y = e2[1] * x2 + e2[5] * y2 + e2[9] * z2 + e2[13] * w2;
    this.z = e2[2] * x2 + e2[6] * y2 + e2[10] * z2 + e2[14] * w2;
    this.w = e2[3] * x2 + e2[7] * y2 + e2[11] * z2 + e2[15] * w2;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  setAxisAngleFromQuaternion(q2) {
    this.w = 2 * Math.acos(q2.w);
    const s2 = Math.sqrt(1 - q2.w * q2.w);
    if (s2 < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q2.x / s2;
      this.y = q2.y / s2;
      this.z = q2.z / s2;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m2) {
    let angle, x2, y2, z2;
    const epsilon = 0.01, epsilon2 = 0.1, te = m2.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x2 = 0;
          y2 = 0.707106781;
          z2 = 0.707106781;
        } else {
          x2 = Math.sqrt(xx);
          y2 = xy / x2;
          z2 = xz / x2;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x2 = 0.707106781;
          y2 = 0;
          z2 = 0.707106781;
        } else {
          y2 = Math.sqrt(yy);
          x2 = xy / y2;
          z2 = yz / y2;
        }
      } else {
        if (zz < epsilon) {
          x2 = 0.707106781;
          y2 = 0.707106781;
          z2 = 0;
        } else {
          z2 = Math.sqrt(zz);
          x2 = xz / z2;
          y2 = yz / z2;
        }
      }
      this.set(x2, y2, z2, angle);
      return this;
    }
    let s2 = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s2) < 1e-3)
      s2 = 1;
    this.x = (m32 - m23) / s2;
    this.y = (m13 - m31) / s2;
    this.z = (m21 - m12) / s2;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    this.z = Math.min(this.z, v2.z);
    this.w = Math.min(this.w, v2.w);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    this.z = Math.max(this.z, v2.z);
    this.w = Math.max(this.w, v2.w);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y + this.z * v2.z + this.w * v2.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    this.z += (v2.z - this.z) * alpha;
    this.w += (v2.w - this.w) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    this.w = v1.w + (v2.w - v1.w) * alpha;
    return this;
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y && v2.z === this.z && v2.w === this.w;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
}
Vector4.prototype.isVector4 = true;
class WebGLRenderTarget extends EventDispatcher {
  constructor(width, height, options) {
    super();
    this.width = width;
    this.height = height;
    this.depth = 1;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    options = options || {};
    this.texture = new Texture(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.image = {};
    this.texture.image.width = width;
    this.texture.image.height = height;
    this.texture.image.depth = 1;
    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
    this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : false;
    this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;
  }
  setTexture(texture) {
    texture.image = {
      width: this.width,
      height: this.height,
      depth: this.depth
    };
    this.texture = texture;
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.texture.image.width = width;
      this.texture.image.height = height;
      this.texture.image.depth = depth;
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    return this;
  }
  dispose() {
    this.dispatchEvent({type: "dispose"});
  }
}
WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
class Quaternion {
  constructor(x2 = 0, y2 = 0, z2 = 0, w2 = 1) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._w = w2;
  }
  static slerp(qa, qb, qm, t2) {
    console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.");
    return qm.slerpQuaternions(qa, qb, t2);
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t2) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (t2 === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }
    if (t2 === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s2 = 1 - t2;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
        s2 = Math.sin(s2 * len) / sin;
        t2 = Math.sin(t2 * len) / sin;
      }
      const tDir = t2 * dir;
      x0 = x0 * s2 + x1 * tDir;
      y0 = y0 * s2 + y1 * tDir;
      z0 = z0 * s2 + z1 * tDir;
      w0 = w0 * s2 + w1 * tDir;
      if (s2 === 1 - t2) {
        const f2 = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f2;
        y0 *= f2;
        z0 *= f2;
        w0 *= f2;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x2, y2, z2, w2) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._w = w2;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update) {
    if (!(euler && euler.isEuler)) {
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    const x2 = euler._x, y2 = euler._y, z2 = euler._z, order = euler._order;
    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x2 / 2);
    const c2 = cos(y2 / 2);
    const c3 = cos(z2 / 2);
    const s1 = sin(x2 / 2);
    const s2 = sin(y2 / 2);
    const s3 = sin(z2 / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update !== false)
      this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2, s2 = Math.sin(halfAngle);
    this._x = axis.x * s2;
    this._y = axis.y * s2;
    this._z = axis.z * s2;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m2) {
    const te = m2.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s2 = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s2;
      this._x = (m32 - m23) * s2;
      this._y = (m13 - m31) * s2;
      this._z = (m21 - m12) * s2;
    } else if (m11 > m22 && m11 > m33) {
      const s2 = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s2;
      this._x = 0.25 * s2;
      this._y = (m12 + m21) / s2;
      this._z = (m13 + m31) / s2;
    } else if (m22 > m33) {
      const s2 = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s2;
      this._x = (m12 + m21) / s2;
      this._y = 0.25 * s2;
      this._z = (m23 + m32) / s2;
    } else {
      const s2 = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s2;
      this._x = (m13 + m31) / s2;
      this._y = (m23 + m32) / s2;
      this._z = 0.25 * s2;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    let r2 = vFrom.dot(vTo) + 1;
    if (r2 < Number.EPSILON) {
      r2 = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r2;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r2;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r2;
    }
    return this.normalize();
  }
  angleTo(q2) {
    return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q2), -1, 1)));
  }
  rotateTowards(q2, step) {
    const angle = this.angleTo(q2);
    if (angle === 0)
      return this;
    const t2 = Math.min(1, step / angle);
    this.slerp(q2, t2);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v2) {
    return this._x * v2._x + this._y * v2._y + this._z * v2._z + this._w * v2._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l2 = this.length();
    if (l2 === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l2 = 1 / l2;
      this._x = this._x * l2;
      this._y = this._y * l2;
      this._z = this._z * l2;
      this._w = this._w * l2;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q2, p2) {
    if (p2 !== void 0) {
      console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
      return this.multiplyQuaternions(q2, p2);
    }
    return this.multiplyQuaternions(this, q2);
  }
  premultiply(q2) {
    return this.multiplyQuaternions(q2, this);
  }
  multiplyQuaternions(a2, b2) {
    const qax = a2._x, qay = a2._y, qaz = a2._z, qaw = a2._w;
    const qbx = b2._x, qby = b2._y, qbz = b2._z, qbw = b2._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb, t2) {
    if (t2 === 0)
      return this;
    if (t2 === 1)
      return this.copy(qb);
    const x2 = this._x, y2 = this._y, z2 = this._z, w2 = this._w;
    let cosHalfTheta = w2 * qb._w + x2 * qb._x + y2 * qb._y + z2 * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w2;
      this._x = x2;
      this._y = y2;
      this._z = z2;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s2 = 1 - t2;
      this._w = s2 * w2 + t2 * this._w;
      this._x = s2 * x2 + t2 * this._x;
      this._y = s2 * y2 + t2 * this._y;
      this._z = s2 * z2 + t2 * this._z;
      this.normalize();
      this._onChangeCallback();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t2) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t2 * halfTheta) / sinHalfTheta;
    this._w = w2 * ratioA + this._w * ratioB;
    this._x = x2 * ratioA + this._x * ratioB;
    this._y = y2 * ratioA + this._y * ratioB;
    this._z = z2 * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  slerpQuaternions(qa, qb, t2) {
    this.copy(qa).slerp(qb, t2);
  }
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    return this;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
}
Quaternion.prototype.isQuaternion = true;
class Vector3 {
  constructor(x2 = 0, y2 = 0, z2 = 0) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
  }
  set(x2, y2, z2) {
    if (z2 === void 0)
      z2 = this.z;
    this.x = x2;
    this.y = y2;
    this.z = z2;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x2) {
    this.x = x2;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setZ(z2) {
    this.z = z2;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    this.z = v2.z;
    return this;
  }
  add(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v2, w2);
    }
    this.x += v2.x;
    this.y += v2.y;
    this.z += v2.z;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    this.z += s2;
    return this;
  }
  addVectors(a2, b2) {
    this.x = a2.x + b2.x;
    this.y = a2.y + b2.y;
    this.z = a2.z + b2.z;
    return this;
  }
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    this.z += v2.z * s2;
    return this;
  }
  sub(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v2, w2);
    }
    this.x -= v2.x;
    this.y -= v2.y;
    this.z -= v2.z;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    this.z -= s2;
    return this;
  }
  subVectors(a2, b2) {
    this.x = a2.x - b2.x;
    this.y = a2.y - b2.y;
    this.z = a2.z - b2.z;
    return this;
  }
  multiply(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
      return this.multiplyVectors(v2, w2);
    }
    this.x *= v2.x;
    this.y *= v2.y;
    this.z *= v2.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a2, b2) {
    this.x = a2.x * b2.x;
    this.y = a2.y * b2.y;
    this.z = a2.z * b2.z;
    return this;
  }
  applyEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const e2 = m2.elements;
    this.x = e2[0] * x2 + e2[3] * y2 + e2[6] * z2;
    this.y = e2[1] * x2 + e2[4] * y2 + e2[7] * z2;
    this.z = e2[2] * x2 + e2[5] * y2 + e2[8] * z2;
    return this;
  }
  applyNormalMatrix(m2) {
    return this.applyMatrix3(m2).normalize();
  }
  applyMatrix4(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const e2 = m2.elements;
    const w2 = 1 / (e2[3] * x2 + e2[7] * y2 + e2[11] * z2 + e2[15]);
    this.x = (e2[0] * x2 + e2[4] * y2 + e2[8] * z2 + e2[12]) * w2;
    this.y = (e2[1] * x2 + e2[5] * y2 + e2[9] * z2 + e2[13]) * w2;
    this.z = (e2[2] * x2 + e2[6] * y2 + e2[10] * z2 + e2[14]) * w2;
    return this;
  }
  applyQuaternion(q2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const qx = q2.x, qy = q2.y, qz = q2.z, qw = q2.w;
    const ix = qw * x2 + qy * z2 - qz * y2;
    const iy = qw * y2 + qz * x2 - qx * z2;
    const iz = qw * z2 + qx * y2 - qy * x2;
    const iw = -qx * x2 - qy * y2 - qz * z2;
    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  }
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }
  transformDirection(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const e2 = m2.elements;
    this.x = e2[0] * x2 + e2[4] * y2 + e2[8] * z2;
    this.y = e2[1] * x2 + e2[5] * y2 + e2[9] * z2;
    this.z = e2[2] * x2 + e2[6] * y2 + e2[10] * z2;
    return this.normalize();
  }
  divide(v2) {
    this.x /= v2.x;
    this.y /= v2.y;
    this.z /= v2.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    this.z = Math.min(this.z, v2.z);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    this.z = Math.max(this.z, v2.z);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y + this.z * v2.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    this.z += (v2.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }
  cross(v2, w2) {
    if (w2 !== void 0) {
      console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
      return this.crossVectors(v2, w2);
    }
    return this.crossVectors(this, v2);
  }
  crossVectors(a2, b2) {
    const ax = a2.x, ay = a2.y, az = a2.z;
    const bx = b2.x, by = b2.y, bz = b2.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  projectOnVector(v2) {
    const denominator = v2.lengthSq();
    if (denominator === 0)
      return this.set(0, 0, 0);
    const scalar = v2.dot(this) / denominator;
    return this.copy(v2).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector$c.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector$c);
  }
  reflect(normal) {
    return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v2) {
    const denominator = Math.sqrt(this.lengthSq() * v2.lengthSq());
    if (denominator === 0)
      return Math.PI / 2;
    const theta = this.dot(v2) / denominator;
    return Math.acos(MathUtils.clamp(theta, -1, 1));
  }
  distanceTo(v2) {
    return Math.sqrt(this.distanceToSquared(v2));
  }
  distanceToSquared(v2) {
    const dx = this.x - v2.x, dy = this.y - v2.y, dz = this.z - v2.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v2) {
    return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y) + Math.abs(this.z - v2.z);
  }
  setFromSpherical(s2) {
    return this.setFromSphericalCoords(s2.radius, s2.phi, s2.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c2) {
    return this.setFromCylindricalCoords(c2.radius, c2.theta, c2.y);
  }
  setFromCylindricalCoords(radius, theta, y2) {
    this.x = radius * Math.sin(theta);
    this.y = y2;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m2) {
    const e2 = m2.elements;
    this.x = e2[12];
    this.y = e2[13];
    this.z = e2[14];
    return this;
  }
  setFromMatrixScale(m2) {
    const sx = this.setFromMatrixColumn(m2, 0).length();
    const sy = this.setFromMatrixColumn(m2, 1).length();
    const sz = this.setFromMatrixColumn(m2, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m2, index) {
    return this.fromArray(m2.elements, index * 4);
  }
  setFromMatrix3Column(m2, index) {
    return this.fromArray(m2.elements, index * 3);
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y && v2.z === this.z;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
}
Vector3.prototype.isVector3 = true;
const _vector$c = /* @__PURE__ */ new Vector3();
const _quaternion$4 = /* @__PURE__ */ new Quaternion();
class Box3 {
  constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromArray(array) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i2 = 0, l2 = array.length; i2 < l2; i2 += 3) {
      const x2 = array[i2];
      const y2 = array[i2 + 1];
      const z2 = array[i2 + 2];
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
      if (z2 < minZ)
        minZ = z2;
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
      if (z2 > maxZ)
        maxZ = z2;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromBufferAttribute(attribute) {
    let minX = Infinity;
    let minY = Infinity;
    let minZ = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;
    for (let i2 = 0, l2 = attribute.count; i2 < l2; i2++) {
      const x2 = attribute.getX(i2);
      const y2 = attribute.getY(i2);
      const z2 = attribute.getZ(i2);
      if (x2 < minX)
        minX = x2;
      if (y2 < minY)
        minY = y2;
      if (z2 < minZ)
        minZ = z2;
      if (x2 > maxX)
        maxX = x2;
      if (y2 > maxY)
        maxY = y2;
      if (z2 > maxZ)
        maxZ = z2;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i2 = 0, il = points.length; i2 < il; i2++) {
      this.expandByPoint(points[i2]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  setFromObject(object) {
    this.makeEmpty();
    return this.expandByObject(object);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .getCenter() target is now required");
      target = new Vector3();
    }
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .getSize() target is now required");
      target = new Vector3();
    }
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  expandByObject(object) {
    object.updateWorldMatrix(false, false);
    const geometry = object.geometry;
    if (geometry !== void 0) {
      if (geometry.boundingBox === null) {
        geometry.computeBoundingBox();
      }
      _box$3.copy(geometry.boundingBox);
      _box$3.applyMatrix4(object.matrixWorld);
      this.union(_box$3);
    }
    const children = object.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      this.expandByObject(children[i2]);
    }
    return this;
  }
  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }
  getParameter(point, target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .getParameter() target is now required");
      target = new Vector3();
    }
    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$b);
    return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  intersectsPlane(plane) {
    let min, max;
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }
    return min <= -plane.constant && max >= -plane.constant;
  }
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0$2.subVectors(triangle.a, _center);
    _v1$7.subVectors(triangle.b, _center);
    _v2$3.subVectors(triangle.c, _center);
    _f0.subVectors(_v1$7, _v0$2);
    _f1.subVectors(_v2$3, _v1$7);
    _f2.subVectors(_v0$2, _v2$3);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
  }
  clampPoint(point, target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .clampPoint() target is now required");
      target = new Vector3();
    }
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);
    return clampedPoint.sub(point).length();
  }
  getBoundingSphere(target) {
    if (target === void 0) {
      console.error("THREE.Box3: .getBoundingSphere() target is now required");
    }
    this.getCenter(target.center);
    target.radius = this.getSize(_vector$b).length() * 0.5;
    return target;
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty())
      this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty())
      return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
}
Box3.prototype.isBox3 = true;
const _points = [
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3()
];
const _vector$b = /* @__PURE__ */ new Vector3();
const _box$3 = /* @__PURE__ */ new Box3();
const _v0$2 = /* @__PURE__ */ new Vector3();
const _v1$7 = /* @__PURE__ */ new Vector3();
const _v2$3 = /* @__PURE__ */ new Vector3();
const _f0 = /* @__PURE__ */ new Vector3();
const _f1 = /* @__PURE__ */ new Vector3();
const _f2 = /* @__PURE__ */ new Vector3();
const _center = /* @__PURE__ */ new Vector3();
const _extents = /* @__PURE__ */ new Vector3();
const _triangleNormal = /* @__PURE__ */ new Vector3();
const _testAxis = /* @__PURE__ */ new Vector3();
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i2 = 0, j2 = axes.length - 3; i2 <= j2; i2 += 3) {
    _testAxis.fromArray(axes, i2);
    const r2 = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r2) {
      return false;
    }
  }
  return true;
}
const _box$2 = /* @__PURE__ */ new Box3();
const _v1$6 = /* @__PURE__ */ new Vector3();
const _toFarthestPoint = /* @__PURE__ */ new Vector3();
const _toPoint = /* @__PURE__ */ new Vector3();
class Sphere {
  constructor(center = new Vector3(), radius = -1) {
    this.center = center;
    this.radius = radius;
  }
  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }
  setFromPoints(points, optionalCenter) {
    const center = this.center;
    if (optionalCenter !== void 0) {
      center.copy(optionalCenter);
    } else {
      _box$2.setFromPoints(points).getCenter(center);
    }
    let maxRadiusSq = 0;
    for (let i2 = 0, il = points.length; i2 < il; i2++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    if (target === void 0) {
      console.warn("THREE.Sphere: .clampPoint() target is now required");
      target = new Vector3();
    }
    target.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  }
  getBoundingBox(target) {
    if (target === void 0) {
      console.warn("THREE.Sphere: .getBoundingBox() target is now required");
      target = new Box3();
    }
    if (this.isEmpty()) {
      target.makeEmpty();
      return target;
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  translate(offset) {
    this.center.add(offset);
    return this;
  }
  expandByPoint(point) {
    _toPoint.subVectors(point, this.center);
    const lengthSq = _toPoint.lengthSq();
    if (lengthSq > this.radius * this.radius) {
      const length = Math.sqrt(lengthSq);
      const missingRadiusHalf = (length - this.radius) * 0.5;
      this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
      this.radius += missingRadiusHalf;
    }
    return this;
  }
  union(sphere) {
    _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);
    this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
    this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
    return this;
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$a = /* @__PURE__ */ new Vector3();
const _segCenter = /* @__PURE__ */ new Vector3();
const _segDir = /* @__PURE__ */ new Vector3();
const _diff = /* @__PURE__ */ new Vector3();
const _edge1 = /* @__PURE__ */ new Vector3();
const _edge2 = /* @__PURE__ */ new Vector3();
const _normal$1 = /* @__PURE__ */ new Vector3();
class Ray {
  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction;
  }
  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  at(t2, target) {
    if (target === void 0) {
      console.warn("THREE.Ray: .at() target is now required");
      target = new Vector3();
    }
    return target.copy(this.direction).multiplyScalar(t2).add(this.origin);
  }
  lookAt(v2) {
    this.direction.copy(v2).sub(this.origin).normalize();
    return this;
  }
  recast(t2) {
    this.origin.copy(this.at(t2, _vector$a));
    return this;
  }
  closestPointToPoint(point, target) {
    if (target === void 0) {
      console.warn("THREE.Ray: .closestPointToPoint() target is now required");
      target = new Vector3();
    }
    target.subVectors(point, this.origin);
    const directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  }
  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }
  distanceSqToPoint(point) {
    const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }
    _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    return _vector$a.distanceToSquared(point);
  }
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
    _segDir.copy(v1).sub(v0).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b0 = _diff.dot(this.direction);
    const b1 = -_diff.dot(_segDir);
    const c2 = _diff.lengthSq();
    const det = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;
    if (det > 0) {
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            const invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c2;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c2;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
    }
    return sqrDist;
  }
  intersectSphere(sphere, target) {
    _vector$a.subVectors(sphere.center, this.origin);
    const tca = _vector$a.dot(this.direction);
    const d2 = _vector$a.dot(_vector$a) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2)
      return null;
    const thc = Math.sqrt(radius2 - d2);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t0 < 0 && t1 < 0)
      return null;
    if (t0 < 0)
      return this.at(t1, target);
    return this.at(t0, target);
  }
  intersectsSphere(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t2 = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t2 >= 0 ? t2 : null;
  }
  intersectPlane(plane, target) {
    const t2 = this.distanceToPlane(plane);
    if (t2 === null) {
      return null;
    }
    return this.at(t2, target);
  }
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax)
      return null;
    if (tymin > tmin || tmin !== tmin)
      tmin = tymin;
    if (tymax < tmax || tmax !== tmax)
      tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax)
      return null;
    if (tzmin > tmin || tmin !== tmin)
      tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax)
      tmax = tzmax;
    if (tmax < 0)
      return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }
  intersectsBox(box) {
    return this.intersectBox(box, _vector$a) !== null;
  }
  intersectTriangle(a2, b2, c2, backfaceCulling, target) {
    _edge1.subVectors(b2, a2);
    _edge2.subVectors(c2, a2);
    _normal$1.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal$1);
    let sign;
    if (DdN > 0) {
      if (backfaceCulling)
        return null;
      sign = 1;
    } else if (DdN < 0) {
      sign = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a2);
    const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign * _diff.dot(_normal$1);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target);
  }
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }
  equals(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Matrix4 {
  constructor() {
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(m2) {
    const te = this.elements;
    const me = m2.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }
  copyPosition(m2) {
    const te = this.elements, me = m2.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }
  setFromMatrix3(m2) {
    const me = m2.elements;
    this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  }
  extractRotation(m2) {
    const te = this.elements;
    const me = m2.elements;
    const scaleX = 1 / _v1$5.setFromMatrixColumn(m2, 0).length();
    const scaleY = 1 / _v1$5.setFromMatrixColumn(m2, 1).length();
    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m2, 2).length();
    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    }
    const te = this.elements;
    const x2 = euler.x, y2 = euler.y, z2 = euler.z;
    const a2 = Math.cos(x2), b2 = Math.sin(x2);
    const c2 = Math.cos(y2), d2 = Math.sin(y2);
    const e2 = Math.cos(z2), f2 = Math.sin(z2);
    if (euler.order === "XYZ") {
      const ae = a2 * e2, af = a2 * f2, be = b2 * e2, bf = b2 * f2;
      te[0] = c2 * e2;
      te[4] = -c2 * f2;
      te[8] = d2;
      te[1] = af + be * d2;
      te[5] = ae - bf * d2;
      te[9] = -b2 * c2;
      te[2] = bf - ae * d2;
      te[6] = be + af * d2;
      te[10] = a2 * c2;
    } else if (euler.order === "YXZ") {
      const ce = c2 * e2, cf = c2 * f2, de = d2 * e2, df = d2 * f2;
      te[0] = ce + df * b2;
      te[4] = de * b2 - cf;
      te[8] = a2 * d2;
      te[1] = a2 * f2;
      te[5] = a2 * e2;
      te[9] = -b2;
      te[2] = cf * b2 - de;
      te[6] = df + ce * b2;
      te[10] = a2 * c2;
    } else if (euler.order === "ZXY") {
      const ce = c2 * e2, cf = c2 * f2, de = d2 * e2, df = d2 * f2;
      te[0] = ce - df * b2;
      te[4] = -a2 * f2;
      te[8] = de + cf * b2;
      te[1] = cf + de * b2;
      te[5] = a2 * e2;
      te[9] = df - ce * b2;
      te[2] = -a2 * d2;
      te[6] = b2;
      te[10] = a2 * c2;
    } else if (euler.order === "ZYX") {
      const ae = a2 * e2, af = a2 * f2, be = b2 * e2, bf = b2 * f2;
      te[0] = c2 * e2;
      te[4] = be * d2 - af;
      te[8] = ae * d2 + bf;
      te[1] = c2 * f2;
      te[5] = bf * d2 + ae;
      te[9] = af * d2 - be;
      te[2] = -d2;
      te[6] = b2 * c2;
      te[10] = a2 * c2;
    } else if (euler.order === "YZX") {
      const ac = a2 * c2, ad = a2 * d2, bc = b2 * c2, bd = b2 * d2;
      te[0] = c2 * e2;
      te[4] = bd - ac * f2;
      te[8] = bc * f2 + ad;
      te[1] = f2;
      te[5] = a2 * e2;
      te[9] = -b2 * e2;
      te[2] = -d2 * e2;
      te[6] = ad * f2 + bc;
      te[10] = ac - bd * f2;
    } else if (euler.order === "XZY") {
      const ac = a2 * c2, ad = a2 * d2, bc = b2 * c2, bd = b2 * d2;
      te[0] = c2 * e2;
      te[4] = -f2;
      te[8] = d2 * e2;
      te[1] = ac * f2 + bd;
      te[5] = a2 * e2;
      te[9] = ad * f2 - bc;
      te[2] = bc * f2 - ad;
      te[6] = b2 * e2;
      te[10] = bd * f2 + ac;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q2) {
    return this.compose(_zero, q2, _one);
  }
  lookAt(eye, target, up) {
    const te = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }
  multiply(m2, n2) {
    if (n2 !== void 0) {
      console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
      return this.multiplyMatrices(m2, n2);
    }
    return this.multiplyMatrices(this, m2);
  }
  premultiply(m2) {
    return this.multiplyMatrices(m2, this);
  }
  multiplyMatrices(a2, b2) {
    const ae = a2.elements;
    const be = b2.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s2) {
    const te = this.elements;
    te[0] *= s2;
    te[4] *= s2;
    te[8] *= s2;
    te[12] *= s2;
    te[1] *= s2;
    te[5] *= s2;
    te[9] *= s2;
    te[13] *= s2;
    te[2] *= s2;
    te[6] *= s2;
    te[10] *= s2;
    te[14] *= s2;
    te[3] *= s2;
    te[7] *= s2;
    te[11] *= s2;
    te[15] *= s2;
    return this;
  }
  determinant() {
    const te = this.elements;
    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te = this.elements;
    let tmp;
    tmp = te[1];
    te[1] = te[4];
    te[4] = tmp;
    tmp = te[2];
    te[2] = te[8];
    te[8] = tmp;
    tmp = te[6];
    te[6] = te[9];
    te[9] = tmp;
    tmp = te[3];
    te[3] = te[12];
    te[12] = tmp;
    tmp = te[7];
    te[7] = te[13];
    te[13] = tmp;
    tmp = te[11];
    te[11] = te[14];
    te[14] = tmp;
    return this;
  }
  setPosition(x2, y2, z2) {
    const te = this.elements;
    if (x2.isVector3) {
      te[12] = x2.x;
      te[13] = x2.y;
      te[14] = x2.z;
    } else {
      te[12] = x2;
      te[13] = y2;
      te[14] = z2;
    }
    return this;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v2) {
    const te = this.elements;
    const x2 = v2.x, y2 = v2.y, z2 = v2.z;
    te[0] *= x2;
    te[4] *= y2;
    te[8] *= z2;
    te[1] *= x2;
    te[5] *= y2;
    te[9] *= z2;
    te[2] *= x2;
    te[6] *= y2;
    te[10] *= z2;
    te[3] *= x2;
    te[7] *= y2;
    te[11] *= z2;
    return this;
  }
  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x2, y2, z2) {
    this.set(1, 0, 0, x2, 0, 1, 0, y2, 0, 0, 1, z2, 0, 0, 0, 1);
    return this;
  }
  makeRotationX(theta) {
    const c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c2, -s2, 0, 0, s2, c2, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationY(theta) {
    const c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(c2, 0, s2, 0, 0, 1, 0, 0, -s2, 0, c2, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationZ(theta) {
    const c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(c2, -s2, 0, 0, s2, c2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationAxis(axis, angle) {
    const c2 = Math.cos(angle);
    const s2 = Math.sin(angle);
    const t2 = 1 - c2;
    const x2 = axis.x, y2 = axis.y, z2 = axis.z;
    const tx = t2 * x2, ty = t2 * y2;
    this.set(tx * x2 + c2, tx * y2 - s2 * z2, tx * z2 + s2 * y2, 0, tx * y2 + s2 * z2, ty * y2 + c2, ty * z2 - s2 * x2, 0, tx * z2 - s2 * y2, ty * z2 + s2 * x2, t2 * z2 * z2 + c2, 0, 0, 0, 0, 1);
    return this;
  }
  makeScale(x2, y2, z2) {
    this.set(x2, 0, 0, 0, 0, y2, 0, 0, 0, 0, z2, 0, 0, 0, 0, 1);
    return this;
  }
  makeShear(x2, y2, z2) {
    this.set(1, y2, z2, 0, x2, 1, z2, 0, x2, y2, 1, 0, 0, 0, 0, 1);
    return this;
  }
  compose(position, quaternion, scale) {
    const te = this.elements;
    const x2 = quaternion._x, y2 = quaternion._y, z2 = quaternion._z, w2 = quaternion._w;
    const x22 = x2 + x2, y22 = y2 + y2, z22 = z2 + z2;
    const xx = x2 * x22, xy = x2 * y22, xz = x2 * z22;
    const yy = y2 * y22, yz = y2 * z22, zz = z2 * z22;
    const wx = w2 * x22, wy = w2 * y22, wz = w2 * z22;
    const sx = scale.x, sy = scale.y, sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }
  decompose(position, quaternion, scale) {
    const te = this.elements;
    let sx = _v1$5.set(te[0], te[1], te[2]).length();
    const sy = _v1$5.set(te[4], te[5], te[6]).length();
    const sz = _v1$5.set(te[8], te[9], te[10]).length();
    const det = this.determinant();
    if (det < 0)
      sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14];
    _m1$2.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1$2.elements[0] *= invSX;
    _m1$2.elements[1] *= invSX;
    _m1$2.elements[2] *= invSX;
    _m1$2.elements[4] *= invSY;
    _m1$2.elements[5] *= invSY;
    _m1$2.elements[6] *= invSY;
    _m1$2.elements[8] *= invSZ;
    _m1$2.elements[9] *= invSZ;
    _m1$2.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1$2);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }
  makePerspective(left, right, top, bottom, near, far) {
    if (far === void 0) {
      console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    }
    const te = this.elements;
    const x2 = 2 * near / (right - left);
    const y2 = 2 * near / (top - bottom);
    const a2 = (right + left) / (right - left);
    const b2 = (top + bottom) / (top - bottom);
    const c2 = -(far + near) / (far - near);
    const d2 = -2 * far * near / (far - near);
    te[0] = x2;
    te[4] = 0;
    te[8] = a2;
    te[12] = 0;
    te[1] = 0;
    te[5] = y2;
    te[9] = b2;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c2;
    te[14] = d2;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far) {
    const te = this.elements;
    const w2 = 1 / (right - left);
    const h2 = 1 / (top - bottom);
    const p2 = 1 / (far - near);
    const x2 = (right + left) * w2;
    const y2 = (top + bottom) * h2;
    const z2 = (far + near) * p2;
    te[0] = 2 * w2;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x2;
    te[1] = 0;
    te[5] = 2 * h2;
    te[9] = 0;
    te[13] = -y2;
    te[2] = 0;
    te[6] = 0;
    te[10] = -2 * p2;
    te[14] = -z2;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i2 = 0; i2 < 16; i2++) {
      if (te[i2] !== me[i2])
        return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i2 = 0; i2 < 16; i2++) {
      this.elements[i2] = array[i2 + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }
}
Matrix4.prototype.isMatrix4 = true;
const _v1$5 = /* @__PURE__ */ new Vector3();
const _m1$2 = /* @__PURE__ */ new Matrix4();
const _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
const _one = /* @__PURE__ */ new Vector3(1, 1, 1);
const _x = /* @__PURE__ */ new Vector3();
const _y = /* @__PURE__ */ new Vector3();
const _z = /* @__PURE__ */ new Vector3();
const _matrix$1 = /* @__PURE__ */ new Matrix4();
const _quaternion$3 = /* @__PURE__ */ new Quaternion();
class Euler {
  constructor(x2 = 0, y2 = 0, z2 = 0, order = Euler.DefaultOrder) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._order = order;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x2, y2, z2, order) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._order = order || this._order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m2, order, update) {
    const clamp = MathUtils.clamp;
    const te = m2.elements;
    const m11 = te[0], m12 = te[4], m13 = te[8];
    const m21 = te[1], m22 = te[5], m23 = te[9];
    const m31 = te[2], m32 = te[6], m33 = te[10];
    order = order || this._order;
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
    }
    this._order = order;
    if (update !== false)
      this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q2, order, update) {
    _matrix$1.makeRotationFromQuaternion(q2);
    return this.setFromRotationMatrix(_matrix$1, order, update);
  }
  setFromVector3(v2, order) {
    return this.set(v2.x, v2.y, v2.z, order || this._order);
  }
  reorder(newOrder) {
    _quaternion$3.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$3, newOrder);
  }
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0)
      this._order = array[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }
  toVector3(optionalResult) {
    if (optionalResult) {
      return optionalResult.set(this._x, this._y, this._z);
    } else {
      return new Vector3(this._x, this._y, this._z);
    }
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
}
Euler.prototype.isEuler = true;
Euler.DefaultOrder = "XYZ";
Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class Layers {
  constructor() {
    this.mask = 1 | 0;
  }
  set(channel) {
    this.mask = 1 << channel | 0;
  }
  enable(channel) {
    this.mask |= 1 << channel | 0;
  }
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }
  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
}
let _object3DId = 0;
const _v1$4 = new Vector3();
const _q1 = new Quaternion();
const _m1$1 = new Matrix4();
const _target = new Vector3();
const _position$3 = new Vector3();
const _scale$2 = new Vector3();
const _quaternion$2 = new Quaternion();
const _xAxis = new Vector3(1, 0, 0);
const _yAxis = new Vector3(0, 1, 0);
const _zAxis = new Vector3(0, 0, 1);
const _addedEvent = {type: "added"};
const _removedEvent = {type: "removed"};
function Object3D() {
  Object.defineProperty(this, "id", {value: _object3DId++});
  this.uuid = MathUtils.generateUUID();
  this.name = "";
  this.type = "Object3D";
  this.parent = null;
  this.children = [];
  this.up = Object3D.DefaultUp.clone();
  const position = new Vector3();
  const rotation = new Euler();
  const quaternion = new Quaternion();
  const scale = new Vector3(1, 1, 1);
  function onRotationChange() {
    quaternion.setFromEuler(rotation, false);
  }
  function onQuaternionChange() {
    rotation.setFromQuaternion(quaternion, void 0, false);
  }
  rotation._onChange(onRotationChange);
  quaternion._onChange(onQuaternionChange);
  Object.defineProperties(this, {
    position: {
      configurable: true,
      enumerable: true,
      value: position
    },
    rotation: {
      configurable: true,
      enumerable: true,
      value: rotation
    },
    quaternion: {
      configurable: true,
      enumerable: true,
      value: quaternion
    },
    scale: {
      configurable: true,
      enumerable: true,
      value: scale
    },
    modelViewMatrix: {
      value: new Matrix4()
    },
    normalMatrix: {
      value: new Matrix3()
    }
  });
  this.matrix = new Matrix4();
  this.matrixWorld = new Matrix4();
  this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
  this.matrixWorldNeedsUpdate = false;
  this.layers = new Layers();
  this.visible = true;
  this.castShadow = false;
  this.receiveShadow = false;
  this.frustumCulled = true;
  this.renderOrder = 0;
  this.animations = [];
  this.userData = {};
}
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Object3D,
  isObject3D: true,
  onBeforeRender: function() {
  },
  onAfterRender: function() {
  },
  applyMatrix4: function(matrix) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  applyQuaternion: function(q2) {
    this.quaternion.premultiply(q2);
    return this;
  },
  setRotationFromAxisAngle: function(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  },
  setRotationFromEuler: function(euler) {
    this.quaternion.setFromEuler(euler, true);
  },
  setRotationFromMatrix: function(m2) {
    this.quaternion.setFromRotationMatrix(m2);
  },
  setRotationFromQuaternion: function(q2) {
    this.quaternion.copy(q2);
  },
  rotateOnAxis: function(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  },
  rotateOnWorldAxis: function(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  },
  rotateX: function(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  },
  rotateY: function(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  },
  rotateZ: function(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  },
  translateOnAxis: function(axis, distance) {
    _v1$4.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$4.multiplyScalar(distance));
    return this;
  },
  translateX: function(distance) {
    return this.translateOnAxis(_xAxis, distance);
  },
  translateY: function(distance) {
    return this.translateOnAxis(_yAxis, distance);
  },
  translateZ: function(distance) {
    return this.translateOnAxis(_zAxis, distance);
  },
  localToWorld: function(vector) {
    return vector.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function(vector) {
    return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
  },
  lookAt: function(x2, y2, z2) {
    if (x2.isVector3) {
      _target.copy(x2);
    } else {
      _target.set(x2, y2, z2);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position$3.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$1.lookAt(_position$3, _target, this.up);
    } else {
      _m1$1.lookAt(_target, _position$3, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$1);
    if (parent) {
      _m1$1.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$1);
      this.quaternion.premultiply(_q1.invert());
    }
  },
  add: function(object) {
    if (arguments.length > 1) {
      for (let i2 = 0; i2 < arguments.length; i2++) {
        this.add(arguments[i2]);
      }
      return this;
    }
    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  },
  remove: function(object) {
    if (arguments.length > 1) {
      for (let i2 = 0; i2 < arguments.length; i2++) {
        this.remove(arguments[i2]);
      }
      return this;
    }
    const index = this.children.indexOf(object);
    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
    }
    return this;
  },
  clear: function() {
    for (let i2 = 0; i2 < this.children.length; i2++) {
      const object = this.children[i2];
      object.parent = null;
      object.dispatchEvent(_removedEvent);
    }
    this.children.length = 0;
    return this;
  },
  attach: function(object) {
    this.updateWorldMatrix(true, false);
    _m1$1.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1$1.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1$1);
    this.add(object);
    object.updateWorldMatrix(false, true);
    return this;
  },
  getObjectById: function(id) {
    return this.getObjectByProperty("id", id);
  },
  getObjectByName: function(name) {
    return this.getObjectByProperty("name", name);
  },
  getObjectByProperty: function(name, value) {
    if (this[name] === value)
      return this;
    for (let i2 = 0, l2 = this.children.length; i2 < l2; i2++) {
      const child = this.children[i2];
      const object = child.getObjectByProperty(name, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  },
  getWorldPosition: function(target) {
    if (target === void 0) {
      console.warn("THREE.Object3D: .getWorldPosition() target is now required");
      target = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  },
  getWorldQuaternion: function(target) {
    if (target === void 0) {
      console.warn("THREE.Object3D: .getWorldQuaternion() target is now required");
      target = new Quaternion();
    }
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, target, _scale$2);
    return target;
  },
  getWorldScale: function(target) {
    if (target === void 0) {
      console.warn("THREE.Object3D: .getWorldScale() target is now required");
      target = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, _quaternion$2, target);
    return target;
  },
  getWorldDirection: function(target) {
    if (target === void 0) {
      console.warn("THREE.Object3D: .getWorldDirection() target is now required");
      target = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    const e2 = this.matrixWorld.elements;
    return target.set(e2[8], e2[9], e2[10]).normalize();
  },
  raycast: function() {
  },
  traverse: function(callback) {
    callback(this);
    const children = this.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      children[i2].traverse(callback);
    }
  },
  traverseVisible: function(callback) {
    if (this.visible === false)
      return;
    callback(this);
    const children = this.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      children[i2].traverseVisible(callback);
    }
  },
  traverseAncestors: function(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  },
  updateMatrix: function() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  },
  updateMatrixWorld: function(force) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      children[i2].updateMatrixWorld(force);
    }
  },
  updateWorldMatrix: function(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    }
    if (updateChildren === true) {
      const children = this.children;
      for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
        children[i2].updateWorldMatrix(false, true);
      }
    }
  },
  toJSON: function(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {}
      };
      output.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "")
      object.name = this.name;
    if (this.castShadow === true)
      object.castShadow = true;
    if (this.receiveShadow === true)
      object.receiveShadow = true;
    if (this.visible === false)
      object.visible = false;
    if (this.frustumCulled === false)
      object.frustumCulled = false;
    if (this.renderOrder !== 0)
      object.renderOrder = this.renderOrder;
    if (JSON.stringify(this.userData) !== "{}")
      object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    if (this.matrixAutoUpdate === false)
      object.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object.type = "InstancedMesh";
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null)
        object.instanceColor = this.instanceColor.toJSON();
    }
    function serialize(library, element) {
      if (library[element.uuid] === void 0) {
        library[element.uuid] = element.toJSON(meta);
      }
      return element.uuid;
    }
    if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
            const shape = shapes[i2];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i2 = 0, l2 = this.material.length; i2 < l2; i2++) {
          uuids.push(serialize(meta.materials, this.material[i2]));
        }
        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (let i2 = 0; i2 < this.children.length; i2++) {
        object.children.push(this.children[i2].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object.animations = [];
      for (let i2 = 0; i2 < this.animations.length; i2++) {
        const animation = this.animations[i2];
        object.animations.push(serialize(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      if (geometries.length > 0)
        output.geometries = geometries;
      if (materials.length > 0)
        output.materials = materials;
      if (textures.length > 0)
        output.textures = textures;
      if (images.length > 0)
        output.images = images;
      if (shapes.length > 0)
        output.shapes = shapes;
      if (skeletons.length > 0)
        output.skeletons = skeletons;
      if (animations.length > 0)
        output.animations = animations;
    }
    output.object = object;
    return output;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  },
  clone: function(recursive) {
    return new this.constructor().copy(this, recursive);
  },
  copy: function(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i2 = 0; i2 < source.children.length; i2++) {
        const child = source.children[i2];
        this.add(child.clone());
      }
    }
    return this;
  }
});
const _vector1 = /* @__PURE__ */ new Vector3();
const _vector2$1 = /* @__PURE__ */ new Vector3();
const _normalMatrix = /* @__PURE__ */ new Matrix3();
class Plane {
  constructor(normal = new Vector3(1, 0, 0), constant = 0) {
    this.normal = normal;
    this.constant = constant;
  }
  set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  }
  setComponents(x2, y2, z2, w2) {
    this.normal.set(x2, y2, z2);
    this.constant = w2;
    return this;
  }
  setFromNormalAndCoplanarPoint(normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  }
  setFromCoplanarPoints(a2, b2, c2) {
    const normal = _vector1.subVectors(c2, b2).cross(_vector2$1.subVectors(a2, b2)).normalize();
    this.setFromNormalAndCoplanarPoint(normal, a2);
    return this;
  }
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  projectPoint(point, target) {
    if (target === void 0) {
      console.warn("THREE.Plane: .projectPoint() target is now required");
      target = new Vector3();
    }
    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
  }
  intersectLine(line, target) {
    if (target === void 0) {
      console.warn("THREE.Plane: .intersectLine() target is now required");
      target = new Vector3();
    }
    const direction = line.delta(_vector1);
    const denominator = this.normal.dot(direction);
    if (denominator === 0) {
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      }
      return null;
    }
    const t2 = -(line.start.dot(this.normal) + this.constant) / denominator;
    if (t2 < 0 || t2 > 1) {
      return null;
    }
    return target.copy(direction).multiplyScalar(t2).add(line.start);
  }
  intersectsLine(line) {
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  coplanarPoint(target) {
    if (target === void 0) {
      console.warn("THREE.Plane: .coplanarPoint() target is now required");
      target = new Vector3();
    }
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }
  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
Plane.prototype.isPlane = true;
const _v0$1 = /* @__PURE__ */ new Vector3();
const _v1$3 = /* @__PURE__ */ new Vector3();
const _v2$2 = /* @__PURE__ */ new Vector3();
const _v3$1 = /* @__PURE__ */ new Vector3();
const _vab = /* @__PURE__ */ new Vector3();
const _vac = /* @__PURE__ */ new Vector3();
const _vbc = /* @__PURE__ */ new Vector3();
const _vap = /* @__PURE__ */ new Vector3();
const _vbp = /* @__PURE__ */ new Vector3();
const _vcp = /* @__PURE__ */ new Vector3();
class Triangle {
  constructor(a2 = new Vector3(), b2 = new Vector3(), c2 = new Vector3()) {
    this.a = a2;
    this.b = b2;
    this.c = c2;
  }
  static getNormal(a2, b2, c2, target) {
    if (target === void 0) {
      console.warn("THREE.Triangle: .getNormal() target is now required");
      target = new Vector3();
    }
    target.subVectors(c2, b2);
    _v0$1.subVectors(a2, b2);
    target.cross(_v0$1);
    const targetLengthSq = target.lengthSq();
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target.set(0, 0, 0);
  }
  static getBarycoord(point, a2, b2, c2, target) {
    _v0$1.subVectors(c2, a2);
    _v1$3.subVectors(b2, a2);
    _v2$2.subVectors(point, a2);
    const dot00 = _v0$1.dot(_v0$1);
    const dot01 = _v0$1.dot(_v1$3);
    const dot02 = _v0$1.dot(_v2$2);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$2);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (target === void 0) {
      console.warn("THREE.Triangle: .getBarycoord() target is now required");
      target = new Vector3();
    }
    if (denom === 0) {
      return target.set(-2, -1, -1);
    }
    const invDenom = 1 / denom;
    const u2 = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v2 = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target.set(1 - u2 - v2, v2, u2);
  }
  static containsPoint(point, a2, b2, c2) {
    this.getBarycoord(point, a2, b2, c2, _v3$1);
    return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
  }
  static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
    this.getBarycoord(point, p1, p2, p3, _v3$1);
    target.set(0, 0);
    target.addScaledVector(uv1, _v3$1.x);
    target.addScaledVector(uv2, _v3$1.y);
    target.addScaledVector(uv3, _v3$1.z);
    return target;
  }
  static isFrontFacing(a2, b2, c2, direction) {
    _v0$1.subVectors(c2, b2);
    _v1$3.subVectors(a2, b2);
    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
  }
  set(a2, b2, c2) {
    this.a.copy(a2);
    this.b.copy(b2);
    this.c.copy(c2);
    return this;
  }
  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }
  getArea() {
    _v0$1.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$1.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(target) {
    if (target === void 0) {
      console.warn("THREE.Triangle: .getMidpoint() target is now required");
      target = new Vector3();
    }
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }
  getPlane(target) {
    if (target === void 0) {
      console.warn("THREE.Triangle: .getPlane() target is now required");
      target = new Plane();
    }
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }
  getUV(point, uv1, uv2, uv3, target) {
    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
  }
  containsPoint(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  }
  isFrontFacing(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  closestPointToPoint(p2, target) {
    if (target === void 0) {
      console.warn("THREE.Triangle: .closestPointToPoint() target is now required");
      target = new Vector3();
    }
    const a2 = this.a, b2 = this.b, c2 = this.c;
    let v2, w2;
    _vab.subVectors(b2, a2);
    _vac.subVectors(c2, a2);
    _vap.subVectors(p2, a2);
    const d1 = _vab.dot(_vap);
    const d2 = _vac.dot(_vap);
    if (d1 <= 0 && d2 <= 0) {
      return target.copy(a2);
    }
    _vbp.subVectors(p2, b2);
    const d3 = _vab.dot(_vbp);
    const d4 = _vac.dot(_vbp);
    if (d3 >= 0 && d4 <= d3) {
      return target.copy(b2);
    }
    const vc = d1 * d4 - d3 * d2;
    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v2 = d1 / (d1 - d3);
      return target.copy(a2).addScaledVector(_vab, v2);
    }
    _vcp.subVectors(p2, c2);
    const d5 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d5 <= d6) {
      return target.copy(c2);
    }
    const vb = d5 * d2 - d1 * d6;
    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w2 = d2 / (d2 - d6);
      return target.copy(a2).addScaledVector(_vac, w2);
    }
    const va = d3 * d6 - d5 * d4;
    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c2, b2);
      w2 = (d4 - d3) / (d4 - d3 + (d5 - d6));
      return target.copy(b2).addScaledVector(_vbc, w2);
    }
    const denom = 1 / (va + vb + vc);
    v2 = vb * denom;
    w2 = vc * denom;
    return target.copy(a2).addScaledVector(_vab, v2).addScaledVector(_vac, w2);
  }
  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
}
let materialId = 0;
function Material() {
  Object.defineProperty(this, "id", {value: materialId++});
  this.uuid = MathUtils.generateUUID();
  this.name = "";
  this.type = "Material";
  this.fog = true;
  this.blending = NormalBlending;
  this.side = FrontSide;
  this.vertexColors = false;
  this.opacity = 1;
  this.transparent = false;
  this.blendSrc = SrcAlphaFactor;
  this.blendDst = OneMinusSrcAlphaFactor;
  this.blendEquation = AddEquation;
  this.blendSrcAlpha = null;
  this.blendDstAlpha = null;
  this.blendEquationAlpha = null;
  this.depthFunc = LessEqualDepth;
  this.depthTest = true;
  this.depthWrite = true;
  this.stencilWriteMask = 255;
  this.stencilFunc = AlwaysStencilFunc;
  this.stencilRef = 0;
  this.stencilFuncMask = 255;
  this.stencilFail = KeepStencilOp;
  this.stencilZFail = KeepStencilOp;
  this.stencilZPass = KeepStencilOp;
  this.stencilWrite = false;
  this.clippingPlanes = null;
  this.clipIntersection = false;
  this.clipShadows = false;
  this.shadowSide = null;
  this.colorWrite = true;
  this.precision = null;
  this.polygonOffset = false;
  this.polygonOffsetFactor = 0;
  this.polygonOffsetUnits = 0;
  this.dithering = false;
  this.alphaTest = 0;
  this.alphaToCoverage = false;
  this.premultipliedAlpha = false;
  this.visible = true;
  this.toneMapped = true;
  this.userData = {};
  this.version = 0;
}
Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Material,
  isMaterial: true,
  onBeforeCompile: function() {
  },
  customProgramCacheKey: function() {
    return this.onBeforeCompile.toString();
  },
  setValues: function(values) {
    if (values === void 0)
      return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        console.warn("THREE.Material: '" + key + "' parameter is undefined.");
        continue;
      }
      if (key === "shading") {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        this.flatShading = newValue === FlatShading ? true : false;
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  },
  toJSON: function(meta) {
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {}
      };
    }
    const data = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (this.color && this.color.isColor)
      data.color = this.color.getHex();
    if (this.roughness !== void 0)
      data.roughness = this.roughness;
    if (this.metalness !== void 0)
      data.metalness = this.metalness;
    if (this.sheen && this.sheen.isColor)
      data.sheen = this.sheen.getHex();
    if (this.emissive && this.emissive.isColor)
      data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity && this.emissiveIntensity !== 1)
      data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor)
      data.specular = this.specular.getHex();
    if (this.shininess !== void 0)
      data.shininess = this.shininess;
    if (this.clearcoat !== void 0)
      data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== void 0)
      data.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.map && this.map.isTexture)
      data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture)
      data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture)
      data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta).uuid;
      data.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture)
      data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture)
      data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture)
      data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture)
      data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      data.reflectivity = this.reflectivity;
      data.refractionRatio = this.refractionRatio;
      if (this.combine !== void 0)
        data.combine = this.combine;
      if (this.envMapIntensity !== void 0)
        data.envMapIntensity = this.envMapIntensity;
    }
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.size !== void 0)
      data.size = this.size;
    if (this.shadowSide !== null)
      data.shadowSide = this.shadowSide;
    if (this.sizeAttenuation !== void 0)
      data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending)
      data.blending = this.blending;
    if (this.side !== FrontSide)
      data.side = this.side;
    if (this.vertexColors)
      data.vertexColors = true;
    if (this.opacity < 1)
      data.opacity = this.opacity;
    if (this.transparent === true)
      data.transparent = this.transparent;
    data.depthFunc = this.depthFunc;
    data.depthTest = this.depthTest;
    data.depthWrite = this.depthWrite;
    data.colorWrite = this.colorWrite;
    data.stencilWrite = this.stencilWrite;
    data.stencilWriteMask = this.stencilWriteMask;
    data.stencilFunc = this.stencilFunc;
    data.stencilRef = this.stencilRef;
    data.stencilFuncMask = this.stencilFuncMask;
    data.stencilFail = this.stencilFail;
    data.stencilZFail = this.stencilZFail;
    data.stencilZPass = this.stencilZPass;
    if (this.rotation && this.rotation !== 0)
      data.rotation = this.rotation;
    if (this.polygonOffset === true)
      data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0)
      data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0)
      data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth && this.linewidth !== 1)
      data.linewidth = this.linewidth;
    if (this.dashSize !== void 0)
      data.dashSize = this.dashSize;
    if (this.gapSize !== void 0)
      data.gapSize = this.gapSize;
    if (this.scale !== void 0)
      data.scale = this.scale;
    if (this.dithering === true)
      data.dithering = true;
    if (this.alphaTest > 0)
      data.alphaTest = this.alphaTest;
    if (this.alphaToCoverage === true)
      data.alphaToCoverage = this.alphaToCoverage;
    if (this.premultipliedAlpha === true)
      data.premultipliedAlpha = this.premultipliedAlpha;
    if (this.wireframe === true)
      data.wireframe = this.wireframe;
    if (this.wireframeLinewidth > 1)
      data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round")
      data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round")
      data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.morphTargets === true)
      data.morphTargets = true;
    if (this.morphNormals === true)
      data.morphNormals = true;
    if (this.skinning === true)
      data.skinning = true;
    if (this.flatShading === true)
      data.flatShading = this.flatShading;
    if (this.visible === false)
      data.visible = false;
    if (this.toneMapped === false)
      data.toneMapped = false;
    if (JSON.stringify(this.userData) !== "{}")
      data.userData = this.userData;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
    }
    return data;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(source) {
    this.name = source.name;
    this.fog = source.fog;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n2 = srcPlanes.length;
      dstPlanes = new Array(n2);
      for (let i2 = 0; i2 !== n2; ++i2) {
        dstPlanes[i2] = srcPlanes[i2].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.alphaToCoverage = source.alphaToCoverage;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  },
  dispose: function() {
    this.dispatchEvent({type: "dispose"});
  }
});
Object.defineProperty(Material.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
const _colorKeywords = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
const _hslA = {h: 0, s: 0, l: 0};
const _hslB = {h: 0, s: 0, l: 0};
function hue2rgb(p2, q2, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p2 + (q2 - p2) * 6 * t2;
  if (t2 < 1 / 2)
    return q2;
  if (t2 < 2 / 3)
    return p2 + (q2 - p2) * 6 * (2 / 3 - t2);
  return p2;
}
function SRGBToLinear(c2) {
  return c2 < 0.04045 ? c2 * 0.0773993808 : Math.pow(c2 * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c2) {
  return c2 < 31308e-7 ? c2 * 12.92 : 1.055 * Math.pow(c2, 0.41666) - 0.055;
}
class Color {
  constructor(r2, g2, b2) {
    if (g2 === void 0 && b2 === void 0) {
      return this.set(r2);
    }
    return this.setRGB(r2, g2, b2);
  }
  set(value) {
    if (value && value.isColor) {
      this.copy(value);
    } else if (typeof value === "number") {
      this.setHex(value);
    } else if (typeof value === "string") {
      this.setStyle(value);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    return this;
  }
  setRGB(r2, g2, b2) {
    this.r = r2;
    this.g = g2;
    this.b = b2;
    return this;
  }
  setHSL(h2, s2, l2) {
    h2 = MathUtils.euclideanModulo(h2, 1);
    s2 = MathUtils.clamp(s2, 0, 1);
    l2 = MathUtils.clamp(l2, 0, 1);
    if (s2 === 0) {
      this.r = this.g = this.b = l2;
    } else {
      const p2 = l2 <= 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
      const q2 = 2 * l2 - p2;
      this.r = hue2rgb(q2, p2, h2 + 1 / 3);
      this.g = hue2rgb(q2, p2, h2);
      this.b = hue2rgb(q2, p2, h2 - 1 / 3);
    }
    return this;
  }
  setStyle(style) {
    function handleAlpha(string) {
      if (string === void 0)
        return;
      if (parseFloat(string) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    let m2;
    if (m2 = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
      let color;
      const name = m2[1];
      const components = m2[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
            handleAlpha(color[4]);
            return this;
          }
          if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
            handleAlpha(color[4]);
            return this;
          }
          break;
        case "hsl":
        case "hsla":
          if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            const h2 = parseFloat(color[1]) / 360;
            const s2 = parseInt(color[2], 10) / 100;
            const l2 = parseInt(color[3], 10) / 100;
            handleAlpha(color[4]);
            return this.setHSL(h2, s2, l2);
          }
          break;
      }
    } else if (m2 = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      const hex = m2[1];
      const size = hex.length;
      if (size === 3) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
        return this;
      } else if (size === 6) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
        return this;
      }
    }
    if (style && style.length > 0) {
      return this.setColorName(style);
    }
    return this;
  }
  setColorName(style) {
    const hex = _colorKeywords[style];
    if (hex !== void 0) {
      this.setHex(hex);
    } else {
      console.warn("THREE.Color: Unknown color " + style);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  }
  copyGammaToLinear(color, gammaFactor = 2) {
    this.r = Math.pow(color.r, gammaFactor);
    this.g = Math.pow(color.g, gammaFactor);
    this.b = Math.pow(color.b, gammaFactor);
    return this;
  }
  copyLinearToGamma(color, gammaFactor = 2) {
    const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
    this.r = Math.pow(color.r, safeInverse);
    this.g = Math.pow(color.g, safeInverse);
    this.b = Math.pow(color.b, safeInverse);
    return this;
  }
  convertGammaToLinear(gammaFactor) {
    this.copyGammaToLinear(this, gammaFactor);
    return this;
  }
  convertLinearToGamma(gammaFactor) {
    this.copyLinearToGamma(this, gammaFactor);
    return this;
  }
  copySRGBToLinear(color) {
    this.r = SRGBToLinear(color.r);
    this.g = SRGBToLinear(color.g);
    this.b = SRGBToLinear(color.b);
    return this;
  }
  copyLinearToSRGB(color) {
    this.r = LinearToSRGB(color.r);
    this.g = LinearToSRGB(color.g);
    this.b = LinearToSRGB(color.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex() {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  }
  getHexString() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }
  getHSL(target) {
    if (target === void 0) {
      console.warn("THREE.Color: .getHSL() target is now required");
      target = {h: 0, s: 0, l: 0};
    }
    const r2 = this.r, g2 = this.g, b2 = this.b;
    const max = Math.max(r2, g2, b2);
    const min = Math.min(r2, g2, b2);
    let hue, saturation;
    const lightness = (min + max) / 2;
    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
      switch (max) {
        case r2:
          hue = (g2 - b2) / delta + (g2 < b2 ? 6 : 0);
          break;
        case g2:
          hue = (b2 - r2) / delta + 2;
          break;
        case b2:
          hue = (r2 - g2) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }
  getStyle() {
    return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
  }
  offsetHSL(h2, s2, l2) {
    this.getHSL(_hslA);
    _hslA.h += h2;
    _hslA.s += s2;
    _hslA.l += l2;
    this.setHSL(_hslA.h, _hslA.s, _hslA.l);
    return this;
  }
  add(color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  addScalar(s2) {
    this.r += s2;
    this.g += s2;
    this.b += s2;
    return this;
  }
  sub(color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  }
  multiply(color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  }
  multiplyScalar(s2) {
    this.r *= s2;
    this.g *= s2;
    this.b *= s2;
    return this;
  }
  lerp(color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  }
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  lerpHSL(color, alpha) {
    this.getHSL(_hslA);
    color.getHSL(_hslB);
    const h2 = MathUtils.lerp(_hslA.h, _hslB.h, alpha);
    const s2 = MathUtils.lerp(_hslA.s, _hslB.s, alpha);
    const l2 = MathUtils.lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h2, s2, l2);
    return this;
  }
  equals(c2) {
    return c2.r === this.r && c2.g === this.g && c2.b === this.b;
  }
  fromArray(array, offset = 0) {
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.r = attribute.getX(index);
    this.g = attribute.getY(index);
    this.b = attribute.getZ(index);
    if (attribute.normalized === true) {
      this.r /= 255;
      this.g /= 255;
      this.b /= 255;
    }
    return this;
  }
  toJSON() {
    return this.getHex();
  }
}
Color.NAMES = _colorKeywords;
Color.prototype.isColor = true;
Color.prototype.r = 1;
Color.prototype.g = 1;
Color.prototype.b = 1;
class MeshBasicMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    return this;
  }
}
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
const _vector$9 = new Vector3();
const _vector2 = new Vector2();
function BufferAttribute(array, itemSize, normalized) {
  if (Array.isArray(array)) {
    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
  }
  this.name = "";
  this.array = array;
  this.itemSize = itemSize;
  this.count = array !== void 0 ? array.length / itemSize : 0;
  this.normalized = normalized === true;
  this.usage = StaticDrawUsage;
  this.updateRange = {offset: 0, count: -1};
  this.version = 0;
}
Object.defineProperty(BufferAttribute.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
Object.assign(BufferAttribute.prototype, {
  isBufferAttribute: true,
  onUploadCallback: function() {
  },
  setUsage: function(value) {
    this.usage = value;
    return this;
  },
  copy: function(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    return this;
  },
  copyAt: function(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (let i2 = 0, l2 = this.itemSize; i2 < l2; i2++) {
      this.array[index1 + i2] = attribute.array[index2 + i2];
    }
    return this;
  },
  copyArray: function(array) {
    this.array.set(array);
    return this;
  },
  copyColorsArray: function(colors) {
    const array = this.array;
    let offset = 0;
    for (let i2 = 0, l2 = colors.length; i2 < l2; i2++) {
      let color = colors[i2];
      if (color === void 0) {
        console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i2);
        color = new Color();
      }
      array[offset++] = color.r;
      array[offset++] = color.g;
      array[offset++] = color.b;
    }
    return this;
  },
  copyVector2sArray: function(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i2 = 0, l2 = vectors.length; i2 < l2; i2++) {
      let vector = vectors[i2];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i2);
        vector = new Vector2();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
    }
    return this;
  },
  copyVector3sArray: function(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i2 = 0, l2 = vectors.length; i2 < l2; i2++) {
      let vector = vectors[i2];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i2);
        vector = new Vector3();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
    }
    return this;
  },
  copyVector4sArray: function(vectors) {
    const array = this.array;
    let offset = 0;
    for (let i2 = 0, l2 = vectors.length; i2 < l2; i2++) {
      let vector = vectors[i2];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i2);
        vector = new Vector4();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
      array[offset++] = vector.w;
    }
    return this;
  },
  applyMatrix3: function(m2) {
    if (this.itemSize === 2) {
      for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
        _vector2.fromBufferAttribute(this, i2);
        _vector2.applyMatrix3(m2);
        this.setXY(i2, _vector2.x, _vector2.y);
      }
    } else if (this.itemSize === 3) {
      for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
        _vector$9.fromBufferAttribute(this, i2);
        _vector$9.applyMatrix3(m2);
        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
      }
    }
    return this;
  },
  applyMatrix4: function(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$9.x = this.getX(i2);
      _vector$9.y = this.getY(i2);
      _vector$9.z = this.getZ(i2);
      _vector$9.applyMatrix4(m2);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  },
  applyNormalMatrix: function(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$9.x = this.getX(i2);
      _vector$9.y = this.getY(i2);
      _vector$9.z = this.getZ(i2);
      _vector$9.applyNormalMatrix(m2);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  },
  transformDirection: function(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$9.x = this.getX(i2);
      _vector$9.y = this.getY(i2);
      _vector$9.z = this.getZ(i2);
      _vector$9.transformDirection(m2);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  },
  set: function(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  },
  getX: function(index) {
    return this.array[index * this.itemSize];
  },
  setX: function(index, x2) {
    this.array[index * this.itemSize] = x2;
    return this;
  },
  getY: function(index) {
    return this.array[index * this.itemSize + 1];
  },
  setY: function(index, y2) {
    this.array[index * this.itemSize + 1] = y2;
    return this;
  },
  getZ: function(index) {
    return this.array[index * this.itemSize + 2];
  },
  setZ: function(index, z2) {
    this.array[index * this.itemSize + 2] = z2;
    return this;
  },
  getW: function(index) {
    return this.array[index * this.itemSize + 3];
  },
  setW: function(index, w2) {
    this.array[index * this.itemSize + 3] = w2;
    return this;
  },
  setXY: function(index, x2, y2) {
    index *= this.itemSize;
    this.array[index + 0] = x2;
    this.array[index + 1] = y2;
    return this;
  },
  setXYZ: function(index, x2, y2, z2) {
    index *= this.itemSize;
    this.array[index + 0] = x2;
    this.array[index + 1] = y2;
    this.array[index + 2] = z2;
    return this;
  },
  setXYZW: function(index, x2, y2, z2, w2) {
    index *= this.itemSize;
    this.array[index + 0] = x2;
    this.array[index + 1] = y2;
    this.array[index + 2] = z2;
    this.array[index + 3] = w2;
    return this;
  },
  onUpload: function(callback) {
    this.onUploadCallback = callback;
    return this;
  },
  clone: function() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  },
  toJSON: function() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    };
    if (this.name !== "")
      data.name = this.name;
    if (this.usage !== StaticDrawUsage)
      data.usage = this.usage;
    if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
      data.updateRange = this.updateRange;
    return data;
  }
});
function Int8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
}
Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
function Uint8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
}
Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
}
Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
function Int16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
}
Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
function Uint16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}
Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
function Int32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
}
Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
function Uint32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
}
Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
function Float16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}
Float16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float16BufferAttribute.prototype.constructor = Float16BufferAttribute;
Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
function Float32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
}
Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
function Float64BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
}
Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
function arrayMax(array) {
  if (array.length === 0)
    return -Infinity;
  let max = array[0];
  for (let i2 = 1, l2 = array.length; i2 < l2; ++i2) {
    if (array[i2] > max)
      max = array[i2];
  }
  return max;
}
let _id = 0;
const _m1 = new Matrix4();
const _obj = new Object3D();
const _offset = new Vector3();
const _box$1 = new Box3();
const _boxMorphTargets = new Box3();
const _vector$8 = new Vector3();
function BufferGeometry() {
  Object.defineProperty(this, "id", {value: _id++});
  this.uuid = MathUtils.generateUUID();
  this.name = "";
  this.type = "BufferGeometry";
  this.index = null;
  this.attributes = {};
  this.morphAttributes = {};
  this.morphTargetsRelative = false;
  this.groups = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.drawRange = {start: 0, count: Infinity};
  this.userData = {};
}
BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: BufferGeometry,
  isBufferGeometry: true,
  getIndex: function() {
    return this.index;
  },
  setIndex: function(index) {
    if (Array.isArray(index)) {
      this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }
    return this;
  },
  getAttribute: function(name) {
    return this.attributes[name];
  },
  setAttribute: function(name, attribute) {
    this.attributes[name] = attribute;
    return this;
  },
  deleteAttribute: function(name) {
    delete this.attributes[name];
    return this;
  },
  hasAttribute: function(name) {
    return this.attributes[name] !== void 0;
  },
  addGroup: function(start, count, materialIndex = 0) {
    this.groups.push({
      start,
      count,
      materialIndex
    });
  },
  clearGroups: function() {
    this.groups = [];
  },
  setDrawRange: function(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  },
  applyMatrix4: function(matrix) {
    const position = this.attributes.position;
    if (position !== void 0) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }
    const normal = this.attributes.normal;
    if (normal !== void 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  },
  rotateX: function(angle) {
    _m1.makeRotationX(angle);
    this.applyMatrix4(_m1);
    return this;
  },
  rotateY: function(angle) {
    _m1.makeRotationY(angle);
    this.applyMatrix4(_m1);
    return this;
  },
  rotateZ: function(angle) {
    _m1.makeRotationZ(angle);
    this.applyMatrix4(_m1);
    return this;
  },
  translate: function(x2, y2, z2) {
    _m1.makeTranslation(x2, y2, z2);
    this.applyMatrix4(_m1);
    return this;
  },
  scale: function(x2, y2, z2) {
    _m1.makeScale(x2, y2, z2);
    this.applyMatrix4(_m1);
    return this;
  },
  lookAt: function(vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  },
  center: function() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  },
  setFromPoints: function(points) {
    const position = [];
    for (let i2 = 0, l2 = points.length; i2 < l2; i2++) {
      const point = points[i2];
      position.push(point.x, point.y, point.z || 0);
    }
    this.setAttribute("position", new Float32BufferAttribute(position, 3));
    return this;
  },
  computeBoundingBox: function() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(Infinity, Infinity, Infinity));
      return;
    }
    if (position !== void 0) {
      this.boundingBox.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          _box$1.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(this.boundingBox.min, _box$1.min);
            this.boundingBox.expandByPoint(_vector$8);
            _vector$8.addVectors(this.boundingBox.max, _box$1.max);
            this.boundingBox.expandByPoint(_vector$8);
          } else {
            this.boundingBox.expandByPoint(_box$1.min);
            this.boundingBox.expandByPoint(_box$1.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  },
  computeBoundingSphere: function() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingSphere.set(new Vector3(), Infinity);
      return;
    }
    if (position) {
      const center = this.boundingSphere.center;
      _box$1.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);
            _box$1.expandByPoint(_vector$8);
            _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);
            _box$1.expandByPoint(_vector$8);
          } else {
            _box$1.expandByPoint(_boxMorphTargets.min);
            _box$1.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$1.getCenter(center);
      let maxRadiusSq = 0;
      for (let i2 = 0, il = position.count; i2 < il; i2++) {
        _vector$8.fromBufferAttribute(position, i2);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
      }
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j2 = 0, jl = morphAttribute.count; j2 < jl; j2++) {
            _vector$8.fromBufferAttribute(morphAttribute, j2);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j2);
              _vector$8.add(_offset);
            }
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  },
  computeFaceNormals: function() {
  },
  computeTangents: function() {
    const index = this.index;
    const attributes = this.attributes;
    if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const indices = index.array;
    const positions = attributes.position.array;
    const normals = attributes.normal.array;
    const uvs = attributes.uv.array;
    const nVertices = positions.length / 3;
    if (attributes.tangent === void 0) {
      this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
    }
    const tangents = attributes.tangent.array;
    const tan1 = [], tan2 = [];
    for (let i2 = 0; i2 < nVertices; i2++) {
      tan1[i2] = new Vector3();
      tan2[i2] = new Vector3();
    }
    const vA2 = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
    function handleTriangle(a2, b2, c2) {
      vA2.fromArray(positions, a2 * 3);
      vB.fromArray(positions, b2 * 3);
      vC.fromArray(positions, c2 * 3);
      uvA.fromArray(uvs, a2 * 2);
      uvB.fromArray(uvs, b2 * 2);
      uvC.fromArray(uvs, c2 * 2);
      vB.sub(vA2);
      vC.sub(vA2);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r2 = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r2))
        return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r2);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r2);
      tan1[a2].add(sdir);
      tan1[b2].add(sdir);
      tan1[c2].add(sdir);
      tan2[a2].add(tdir);
      tan2[b2].add(tdir);
      tan2[c2].add(tdir);
    }
    let groups = this.groups;
    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: indices.length
      }];
    }
    for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
      const group = groups[i2];
      const start = group.start;
      const count = group.count;
      for (let j2 = start, jl = start + count; j2 < jl; j2 += 3) {
        handleTriangle(indices[j2 + 0], indices[j2 + 1], indices[j2 + 2]);
      }
    }
    const tmp = new Vector3(), tmp2 = new Vector3();
    const n2 = new Vector3(), n22 = new Vector3();
    function handleVertex(v2) {
      n2.fromArray(normals, v2 * 3);
      n22.copy(n2);
      const t2 = tan1[v2];
      tmp.copy(t2);
      tmp.sub(n2.multiplyScalar(n2.dot(t2))).normalize();
      tmp2.crossVectors(n22, t2);
      const test = tmp2.dot(tan2[v2]);
      const w2 = test < 0 ? -1 : 1;
      tangents[v2 * 4] = tmp.x;
      tangents[v2 * 4 + 1] = tmp.y;
      tangents[v2 * 4 + 2] = tmp.z;
      tangents[v2 * 4 + 3] = w2;
    }
    for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
      const group = groups[i2];
      const start = group.start;
      const count = group.count;
      for (let j2 = start, jl = start + count; j2 < jl; j2 += 3) {
        handleVertex(indices[j2 + 0]);
        handleVertex(indices[j2 + 1]);
        handleVertex(indices[j2 + 2]);
      }
    }
  },
  computeVertexNormals: function() {
    const index = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i2 = 0, il = normalAttribute.count; i2 < il; i2++) {
          normalAttribute.setXYZ(i2, 0, 0, 0);
        }
      }
      const pA2 = new Vector3(), pB = new Vector3(), pC = new Vector3();
      const nA2 = new Vector3(), nB = new Vector3(), nC = new Vector3();
      const cb = new Vector3(), ab = new Vector3();
      if (index) {
        for (let i2 = 0, il = index.count; i2 < il; i2 += 3) {
          const vA2 = index.getX(i2 + 0);
          const vB = index.getX(i2 + 1);
          const vC = index.getX(i2 + 2);
          pA2.fromBufferAttribute(positionAttribute, vA2);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA2, pB);
          cb.cross(ab);
          nA2.fromBufferAttribute(normalAttribute, vA2);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA2.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA2, nA2.x, nA2.y, nA2.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        for (let i2 = 0, il = positionAttribute.count; i2 < il; i2 += 3) {
          pA2.fromBufferAttribute(positionAttribute, i2 + 0);
          pB.fromBufferAttribute(positionAttribute, i2 + 1);
          pC.fromBufferAttribute(positionAttribute, i2 + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA2, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  },
  merge: function(geometry, offset) {
    if (!(geometry && geometry.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
      return;
    }
    if (offset === void 0) {
      offset = 0;
      console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      if (geometry.attributes[key] === void 0)
        continue;
      const attribute1 = attributes[key];
      const attributeArray1 = attribute1.array;
      const attribute2 = geometry.attributes[key];
      const attributeArray2 = attribute2.array;
      const attributeOffset = attribute2.itemSize * offset;
      const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
      for (let i2 = 0, j2 = attributeOffset; i2 < length; i2++, j2++) {
        attributeArray1[j2] = attributeArray2[i2];
      }
    }
    return this;
  },
  normalizeNormals: function() {
    const normals = this.attributes.normal;
    for (let i2 = 0, il = normals.count; i2 < il; i2++) {
      _vector$8.fromBufferAttribute(normals, i2);
      _vector$8.normalize();
      normals.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);
    }
  },
  toNonIndexed: function() {
    function convertBufferAttribute(attribute, indices2) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices2.length * itemSize);
      let index = 0, index2 = 0;
      for (let i2 = 0, l2 = indices2.length; i2 < l2; i2++) {
        index = indices2[i2] * itemSize;
        for (let j2 = 0; j2 < itemSize; j2++) {
          array2[index2++] = array[index++];
        }
      }
      return new BufferAttribute(array2, itemSize, normalized);
    }
    if (this.index === null) {
      console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
      return this;
    }
    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name];
      for (let i2 = 0, il = morphAttribute.length; i2 < il; i2++) {
        const attribute = morphAttribute[i2];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups = this.groups;
    for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
      const group = groups[i2];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  },
  toJSON: function() {
    const data = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (Object.keys(this.userData).length > 0)
      data.userData = this.userData;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== void 0)
          data[key] = parameters[key];
      }
      return data;
    }
    data.data = {attributes: {}};
    const index = this.index;
    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      data.data.attributes[key] = attribute.toJSON(data.data);
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];
      for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {
        const attribute = attributeArray[i2];
        array.push(attribute.toJSON(data.data));
      }
      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups = this.groups;
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data;
  },
  clone: function() {
    return new BufferGeometry().copy(this);
  },
  copy: function(source) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data = {};
    this.name = source.name;
    const index = source.index;
    if (index !== null) {
      this.setIndex(index.clone(data));
    }
    const attributes = source.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data));
    }
    const morphAttributes = source.morphAttributes;
    for (const name in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name];
      for (let i2 = 0, l2 = morphAttribute.length; i2 < l2; i2++) {
        array.push(morphAttribute[i2].clone(data));
      }
      this.morphAttributes[name] = array;
    }
    this.morphTargetsRelative = source.morphTargetsRelative;
    const groups = source.groups;
    for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
      const group = groups[i2];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    const boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    return this;
  },
  dispose: function() {
    this.dispatchEvent({type: "dispose"});
  }
});
const _inverseMatrix$2 = new Matrix4();
const _ray$2 = new Ray();
const _sphere$3 = new Sphere();
const _vA$1 = new Vector3();
const _vB$1 = new Vector3();
const _vC$1 = new Vector3();
const _tempA = new Vector3();
const _tempB = new Vector3();
const _tempC = new Vector3();
const _morphA = new Vector3();
const _morphB = new Vector3();
const _morphC = new Vector3();
const _uvA$1 = new Vector2();
const _uvB$1 = new Vector2();
const _uvC$1 = new Vector2();
const _intersectionPoint = new Vector3();
const _intersectionPointWorld = new Vector3();
function Mesh(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
  Object3D.call(this);
  this.type = "Mesh";
  this.geometry = geometry;
  this.material = material;
  this.updateMorphTargets();
}
Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Mesh,
  isMesh: true,
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  updateMorphTargets: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
            const name = morphAttribute[m2].name || String(m2);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m2;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  },
  raycast: function(raycaster, intersects) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0)
      return;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$3.copy(geometry.boundingSphere);
    _sphere$3.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere$3) === false)
      return;
    _inverseMatrix$2.copy(matrixWorld).invert();
    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
    if (geometry.boundingBox !== null) {
      if (_ray$2.intersectsBox(geometry.boundingBox) === false)
        return;
    }
    let intersection;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const position = geometry.attributes.position;
      const morphPosition = geometry.morphAttributes.position;
      const morphTargetsRelative = geometry.morphTargetsRelative;
      const uv = geometry.attributes.uv;
      const uv2 = geometry.attributes.uv2;
      const groups = geometry.groups;
      const drawRange = geometry.drawRange;
      if (index !== null) {
        if (Array.isArray(material)) {
          for (let i2 = 0, il = groups.length; i2 < il; i2++) {
            const group = groups[i2];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
            for (let j2 = start, jl = end; j2 < jl; j2 += 3) {
              const a2 = index.getX(j2);
              const b2 = index.getX(j2 + 1);
              const c2 = index.getX(j2 + 2);
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
              if (intersection) {
                intersection.faceIndex = Math.floor(j2 / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(index.count, drawRange.start + drawRange.count);
          for (let i2 = start, il = end; i2 < il; i2 += 3) {
            const a2 = index.getX(i2);
            const b2 = index.getX(i2 + 1);
            const c2 = index.getX(i2 + 2);
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
            if (intersection) {
              intersection.faceIndex = Math.floor(i2 / 3);
              intersects.push(intersection);
            }
          }
        }
      } else if (position !== void 0) {
        if (Array.isArray(material)) {
          for (let i2 = 0, il = groups.length; i2 < il; i2++) {
            const group = groups[i2];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
            for (let j2 = start, jl = end; j2 < jl; j2 += 3) {
              const a2 = j2;
              const b2 = j2 + 1;
              const c2 = j2 + 2;
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
              if (intersection) {
                intersection.faceIndex = Math.floor(j2 / 3);
                intersection.face.materialIndex = group.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(position.count, drawRange.start + drawRange.count);
          for (let i2 = start, il = end; i2 < il; i2 += 3) {
            const a2 = i2;
            const b2 = i2 + 1;
            const c2 = i2 + 2;
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
            if (intersection) {
              intersection.faceIndex = Math.floor(i2 / 3);
              intersects.push(intersection);
            }
          }
        }
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  }
});
function checkIntersection(object, material, raycaster, ray, pA2, pB, pC, point) {
  let intersect;
  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA2, true, point);
  } else {
    intersect = ray.intersectTriangle(pA2, pB, pC, material.side !== DoubleSide, point);
  }
  if (intersect === null)
    return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far)
    return null;
  return {
    distance,
    point: _intersectionPointWorld.clone(),
    object
  };
}
function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2) {
  _vA$1.fromBufferAttribute(position, a2);
  _vB$1.fromBufferAttribute(position, b2);
  _vC$1.fromBufferAttribute(position, c2);
  const morphInfluences = object.morphTargetInfluences;
  if (material.morphTargets && morphPosition && morphInfluences) {
    _morphA.set(0, 0, 0);
    _morphB.set(0, 0, 0);
    _morphC.set(0, 0, 0);
    for (let i2 = 0, il = morphPosition.length; i2 < il; i2++) {
      const influence = morphInfluences[i2];
      const morphAttribute = morphPosition[i2];
      if (influence === 0)
        continue;
      _tempA.fromBufferAttribute(morphAttribute, a2);
      _tempB.fromBufferAttribute(morphAttribute, b2);
      _tempC.fromBufferAttribute(morphAttribute, c2);
      if (morphTargetsRelative) {
        _morphA.addScaledVector(_tempA, influence);
        _morphB.addScaledVector(_tempB, influence);
        _morphC.addScaledVector(_tempC, influence);
      } else {
        _morphA.addScaledVector(_tempA.sub(_vA$1), influence);
        _morphB.addScaledVector(_tempB.sub(_vB$1), influence);
        _morphC.addScaledVector(_tempC.sub(_vC$1), influence);
      }
    }
    _vA$1.add(_morphA);
    _vB$1.add(_morphB);
    _vC$1.add(_morphC);
  }
  if (object.isSkinnedMesh && material.skinning) {
    object.boneTransform(a2, _vA$1);
    object.boneTransform(b2, _vB$1);
    object.boneTransform(c2, _vC$1);
  }
  const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (intersection) {
    if (uv) {
      _uvA$1.fromBufferAttribute(uv, a2);
      _uvB$1.fromBufferAttribute(uv, b2);
      _uvC$1.fromBufferAttribute(uv, c2);
      intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    if (uv2) {
      _uvA$1.fromBufferAttribute(uv2, a2);
      _uvB$1.fromBufferAttribute(uv2, b2);
      _uvC$1.fromBufferAttribute(uv2, c2);
      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    const face = {
      a: a2,
      b: b2,
      c: c2,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
    intersection.face = face;
  }
  return intersection;
}
class BoxGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      depthSegments
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
    buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
    buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
    buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
    buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
    buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(u2, v2, w2, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
      const segmentWidth = width2 / gridX;
      const segmentHeight = height2 / gridY;
      const widthHalf = width2 / 2;
      const heightHalf = height2 / 2;
      const depthHalf = depth2 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3();
      for (let iy = 0; iy < gridY1; iy++) {
        const y2 = iy * segmentHeight - heightHalf;
        for (let ix = 0; ix < gridX1; ix++) {
          const x2 = ix * segmentWidth - widthHalf;
          vector[u2] = x2 * udir;
          vector[v2] = y2 * vdir;
          vector[w2] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u2] = 0;
          vector[v2] = 0;
          vector[w2] = depth2 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a2 = numberOfVertices + ix + gridX1 * iy;
          const b2 = numberOfVertices + ix + gridX1 * (iy + 1);
          const c2 = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d2 = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices.push(a2, b2, d2);
          indices.push(b2, c2, d2);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
}
function cloneUniforms(src) {
  const dst = {};
  for (const u2 in src) {
    dst[u2] = {};
    for (const p2 in src[u2]) {
      const property = src[u2][p2];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        dst[u2][p2] = property.clone();
      } else if (Array.isArray(property)) {
        dst[u2][p2] = property.slice();
      } else {
        dst[u2][p2] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u2 = 0; u2 < uniforms.length; u2++) {
    const tmp = cloneUniforms(uniforms[u2]);
    for (const p2 in tmp) {
      merged[p2] = tmp[p2];
    }
  }
  return merged;
}
const UniformsUtils = {clone: cloneUniforms, merge: mergeUniforms};
var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
function ShaderMaterial(parameters) {
  Material.call(this);
  this.type = "ShaderMaterial";
  this.defines = {};
  this.uniforms = {};
  this.vertexShader = default_vertex;
  this.fragmentShader = default_fragment;
  this.linewidth = 1;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.lights = false;
  this.clipping = false;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.extensions = {
    derivatives: false,
    fragDepth: false,
    drawBuffers: false,
    shaderTextureLOD: false
  };
  this.defaultAttributeValues = {
    color: [1, 1, 1],
    uv: [0, 0],
    uv2: [0, 0]
  };
  this.index0AttributeName = void 0;
  this.uniformsNeedUpdate = false;
  this.glslVersion = null;
  if (parameters !== void 0) {
    if (parameters.attributes !== void 0) {
      console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
    }
    this.setValues(parameters);
  }
}
ShaderMaterial.prototype = Object.create(Material.prototype);
ShaderMaterial.prototype.constructor = ShaderMaterial;
ShaderMaterial.prototype.isShaderMaterial = true;
ShaderMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.fragmentShader = source.fragmentShader;
  this.vertexShader = source.vertexShader;
  this.uniforms = cloneUniforms(source.uniforms);
  this.defines = Object.assign({}, source.defines);
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.lights = source.lights;
  this.clipping = source.clipping;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  this.extensions = Object.assign({}, source.extensions);
  this.glslVersion = source.glslVersion;
  return this;
};
ShaderMaterial.prototype.toJSON = function(meta) {
  const data = Material.prototype.toJSON.call(this, meta);
  data.glslVersion = this.glslVersion;
  data.uniforms = {};
  for (const name in this.uniforms) {
    const uniform = this.uniforms[name];
    const value = uniform.value;
    if (value && value.isTexture) {
      data.uniforms[name] = {
        type: "t",
        value: value.toJSON(meta).uuid
      };
    } else if (value && value.isColor) {
      data.uniforms[name] = {
        type: "c",
        value: value.getHex()
      };
    } else if (value && value.isVector2) {
      data.uniforms[name] = {
        type: "v2",
        value: value.toArray()
      };
    } else if (value && value.isVector3) {
      data.uniforms[name] = {
        type: "v3",
        value: value.toArray()
      };
    } else if (value && value.isVector4) {
      data.uniforms[name] = {
        type: "v4",
        value: value.toArray()
      };
    } else if (value && value.isMatrix3) {
      data.uniforms[name] = {
        type: "m3",
        value: value.toArray()
      };
    } else if (value && value.isMatrix4) {
      data.uniforms[name] = {
        type: "m4",
        value: value.toArray()
      };
    } else {
      data.uniforms[name] = {
        value
      };
    }
  }
  if (Object.keys(this.defines).length > 0)
    data.defines = this.defines;
  data.vertexShader = this.vertexShader;
  data.fragmentShader = this.fragmentShader;
  const extensions = {};
  for (const key in this.extensions) {
    if (this.extensions[key] === true)
      extensions[key] = true;
  }
  if (Object.keys(extensions).length > 0)
    data.extensions = extensions;
  return data;
};
function Camera() {
  Object3D.call(this);
  this.type = "Camera";
  this.matrixWorldInverse = new Matrix4();
  this.projectionMatrix = new Matrix4();
  this.projectionMatrixInverse = new Matrix4();
}
Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Camera,
  isCamera: true,
  copy: function(source, recursive) {
    Object3D.prototype.copy.call(this, source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    return this;
  },
  getWorldDirection: function(target) {
    if (target === void 0) {
      console.warn("THREE.Camera: .getWorldDirection() target is now required");
      target = new Vector3();
    }
    this.updateWorldMatrix(true, false);
    const e2 = this.matrixWorld.elements;
    return target.set(-e2[8], -e2[9], -e2[10]).normalize();
  },
  updateMatrixWorld: function(force) {
    Object3D.prototype.updateMatrixWorld.call(this, force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  },
  updateWorldMatrix: function(updateParents, updateChildren) {
    Object3D.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  },
  clone: function() {
    return new this.constructor().copy(this);
  }
});
function PerspectiveCamera(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
  Camera.call(this);
  this.type = "PerspectiveCamera";
  this.fov = fov2;
  this.zoom = 1;
  this.near = near;
  this.far = far;
  this.focus = 10;
  this.aspect = aspect2;
  this.view = null;
  this.filmGauge = 35;
  this.filmOffset = 0;
  this.updateProjectionMatrix();
}
PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
  constructor: PerspectiveCamera,
  isPerspectiveCamera: true,
  copy: function(source, recursive) {
    Camera.prototype.copy.call(this, source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  },
  setFocalLength: function(focalLength) {
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  },
  getFocalLength: function() {
    const vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  },
  getEffectiveFOV: function() {
    return MathUtils.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);
  },
  getFilmWidth: function() {
    return this.filmGauge * Math.min(this.aspect, 1);
  },
  getFilmHeight: function() {
    return this.filmGauge / Math.max(this.aspect, 1);
  },
  setViewOffset: function(fullWidth, fullHeight, x2, y2, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x2;
    this.view.offsetY = y2;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  },
  clearViewOffset: function() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function() {
    const near = this.near;
    let top = near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0)
      left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  },
  toJSON: function(meta) {
    const data = Object3D.prototype.toJSON.call(this, meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
});
const fov = 90, aspect = 1;
class CubeCamera extends Object3D {
  constructor(near, far, renderTarget) {
    super();
    this.type = "CubeCamera";
    if (renderTarget.isWebGLCubeRenderTarget !== true) {
      console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
      return;
    }
    this.renderTarget = renderTarget;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector3(1, 0, 0));
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector3(-1, 0, 0));
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector3(0, 1, 0));
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector3(0, -1, 0));
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector3(0, 0, 1));
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector3(0, 0, -1));
    this.add(cameraNZ);
  }
  update(renderer, scene) {
    if (this.parent === null)
      this.updateMatrixWorld();
    const renderTarget = this.renderTarget;
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
    const currentXrEnabled = renderer.xr.enabled;
    const currentRenderTarget = renderer.getRenderTarget();
    renderer.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.xr.enabled = currentXrEnabled;
  }
}
class CubeTexture extends Texture {
  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    images = images !== void 0 ? images : [];
    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
    format = format !== void 0 ? format : RGBFormat;
    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this._needsFlipEnvMap = true;
    this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
}
CubeTexture.prototype.isCubeTexture = true;
class WebGLCubeRenderTarget extends WebGLRenderTarget {
  constructor(size, options, dummy) {
    if (Number.isInteger(options)) {
      console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )");
      options = dummy;
    }
    super(size, size, options);
    options = options || {};
    this.texture = new CubeTexture(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
    this.texture._needsFlipEnvMap = false;
  }
  fromEquirectangularTexture(renderer, texture) {
    this.texture.type = texture.type;
    this.texture.format = RGBAFormat;
    this.texture.encoding = texture.encoding;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
      uniforms: {
        tEquirect: {value: null}
      },
      vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
      fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
    };
    const geometry = new BoxGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh(geometry, material);
    const currentMinFilter = texture.minFilter;
    if (texture.minFilter === LinearMipmapLinearFilter)
      texture.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
  clear(renderer, color, depth, stencil) {
    const currentRenderTarget = renderer.getRenderTarget();
    for (let i2 = 0; i2 < 6; i2++) {
      renderer.setRenderTarget(this, i2);
      renderer.clear(color, depth, stencil);
    }
    renderer.setRenderTarget(currentRenderTarget);
  }
}
WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
class DataTexture extends Texture {
  constructor(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {data: data || null, width: width || 1, height: height || 1};
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }
}
DataTexture.prototype.isDataTexture = true;
const _sphere$2 = /* @__PURE__ */ new Sphere();
const _vector$7 = /* @__PURE__ */ new Vector3();
class Frustum {
  constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
    this.planes = [p0, p1, p2, p3, p4, p5];
  }
  set(p0, p1, p2, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  }
  copy(frustum) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      planes[i2].copy(frustum.planes[i2]);
    }
    return this;
  }
  setFromProjectionMatrix(m2) {
    const planes = this.planes;
    const me = m2.elements;
    const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
    const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
    const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
    const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  }
  intersectsObject(object) {
    const geometry = object.geometry;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
    return this.intersectsSphere(_sphere$2);
  }
  intersectsSprite(sprite) {
    _sphere$2.center.set(0, 0, 0);
    _sphere$2.radius = 0.7071067811865476;
    _sphere$2.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(_sphere$2);
  }
  intersectsSphere(sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;
    for (let i2 = 0; i2 < 6; i2++) {
      const distance = planes[i2].distanceToPoint(center);
      if (distance < negRadius) {
        return false;
      }
    }
    return true;
  }
  intersectsBox(box) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      const plane = planes[i2];
      _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
      if (plane.distanceToPoint(_vector$7) < 0) {
        return false;
      }
    }
    return true;
  }
  containsPoint(point) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      if (planes[i2].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating === true)
        return;
      if (animationLoop === null)
        return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context = value;
    }
  };
}
function WebGLAttributes(gl, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  const buffers = new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type = 5126;
    if (array instanceof Float32Array) {
      type = 5126;
    } else if (array instanceof Float64Array) {
      console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        if (isWebGL2) {
          type = 5131;
        } else {
          console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
        }
      } else {
        type = 5123;
      }
    } else if (array instanceof Int16Array) {
      type = 5122;
    } else if (array instanceof Uint32Array) {
      type = 5125;
    } else if (array instanceof Int32Array) {
      type = 5124;
    } else if (array instanceof Int8Array) {
      type = 5120;
    } else if (array instanceof Uint8Array) {
      type = 5121;
    }
    return {
      buffer,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }
  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer);
    if (updateRange.count === -1) {
      gl.bufferSubData(bufferType, 0, array);
    } else {
      if (isWebGL2) {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
      } else {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
      }
      updateRange.count = -1;
    }
  }
  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  function update(attribute, bufferType) {
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get,
    remove,
    update
  };
}
class PlaneGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = "PlaneGeometry";
    this.parameters = {
      width,
      height,
      widthSegments,
      heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy < gridY1; iy++) {
      const y2 = iy * segment_height - height_half;
      for (let ix = 0; ix < gridX1; ix++) {
        const x2 = ix * segment_width - width_half;
        vertices.push(x2, -y2, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a2 = ix + gridX1 * iy;
        const b2 = ix + gridX1 * (iy + 1);
        const c2 = ix + 1 + gridX1 * (iy + 1);
        const d2 = ix + 1 + gridX1 * iy;
        indices.push(a2, b2, d2);
        indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
}
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n#else\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n	return Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	return specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n	float invAlpha = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifndef ENVMAP_TYPE_CUBE_UV\n		envColor = envMapTexelToLinear( envColor );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n	fogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n	varying float fogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif";
var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float sigma = PI * roughness * roughness / ( 1.0 + roughness );\n		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n		#else\n			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheen;\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float specularRoughness;\n	vec3 specularColor;\n#ifdef CLEARCOAT\n	float clearcoat;\n	float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	vec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifdef CLEARCOAT\n		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = ccDotNL * directLight.color;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			ccIrradiance *= PI;\n		#endif\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n			material.specularRoughness,\n			directLight.direction,\n			geometry,\n			material.sheenColor\n		);\n	#else\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n	#endif\n	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef CLEARCOAT\n		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n		float ccDotNL = ccDotNV;\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	float clearcoatInv = 1.0 - clearcoatDHR;\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n	#ifdef CLEARCOAT\n		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n	#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifndef USE_MORPHNORMALS\n		uniform float morphTargetInfluences[ 8 ];\n	#else\n		uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n		transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n		transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n		transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n		transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n	#endif\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmissionmap_fragment = "#ifdef USE_TRANSMISSIONMAP\n	totalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif";
var transmissionmap_pars_fragment = "#ifdef USE_TRANSMISSIONMAP\n	uniform sampler2D transmissionMap;\n#endif";
var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
var uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
var uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
var depth_frag = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n	\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#ifndef FLAT_SHADED\n		vNormal = normalize( transformedNormal );\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n	#define REFLECTIVITY\n	#define CLEARCOAT\n	#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n	uniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n	uniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#ifdef TRANSMISSION\n		float totalTransmission = transmission;\n	#endif\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <transmissionmap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#ifdef TRANSMISSION\n		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n	#endif\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
const ShaderChunk = {
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  encodings_fragment,
  encodings_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_fragment,
  lightmap_pars_fragment,
  lights_lambert_vertex,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmissionmap_fragment,
  transmissionmap_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  uv2_pars_fragment,
  uv2_pars_vertex,
  uv2_vertex,
  worldpos_vertex,
  background_frag,
  background_vert,
  cube_frag,
  cube_vert,
  depth_frag,
  depth_vert,
  distanceRGBA_frag,
  distanceRGBA_vert,
  equirect_frag,
  equirect_vert,
  linedashed_frag,
  linedashed_vert,
  meshbasic_frag,
  meshbasic_vert,
  meshlambert_frag,
  meshlambert_vert,
  meshmatcap_frag,
  meshmatcap_vert,
  meshtoon_frag,
  meshtoon_vert,
  meshphong_frag,
  meshphong_vert,
  meshphysical_frag,
  meshphysical_vert,
  normal_frag,
  normal_vert,
  points_frag,
  points_vert,
  shadow_frag,
  shadow_vert,
  sprite_frag,
  sprite_vert
};
const UniformsLib = {
  common: {
    diffuse: {value: new Color(15658734)},
    opacity: {value: 1},
    map: {value: null},
    uvTransform: {value: new Matrix3()},
    uv2Transform: {value: new Matrix3()},
    alphaMap: {value: null}
  },
  specularmap: {
    specularMap: {value: null}
  },
  envmap: {
    envMap: {value: null},
    flipEnvMap: {value: -1},
    reflectivity: {value: 1},
    refractionRatio: {value: 0.98},
    maxMipLevel: {value: 0}
  },
  aomap: {
    aoMap: {value: null},
    aoMapIntensity: {value: 1}
  },
  lightmap: {
    lightMap: {value: null},
    lightMapIntensity: {value: 1}
  },
  emissivemap: {
    emissiveMap: {value: null}
  },
  bumpmap: {
    bumpMap: {value: null},
    bumpScale: {value: 1}
  },
  normalmap: {
    normalMap: {value: null},
    normalScale: {value: new Vector2(1, 1)}
  },
  displacementmap: {
    displacementMap: {value: null},
    displacementScale: {value: 1},
    displacementBias: {value: 0}
  },
  roughnessmap: {
    roughnessMap: {value: null}
  },
  metalnessmap: {
    metalnessMap: {value: null}
  },
  gradientmap: {
    gradientMap: {value: null}
  },
  fog: {
    fogDensity: {value: 25e-5},
    fogNear: {value: 1},
    fogFar: {value: 2e3},
    fogColor: {value: new Color(16777215)}
  },
  lights: {
    ambientLightColor: {value: []},
    lightProbe: {value: []},
    directionalLights: {value: [], properties: {
      direction: {},
      color: {}
    }},
    directionalLightShadows: {value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    }},
    directionalShadowMap: {value: []},
    directionalShadowMatrix: {value: []},
    spotLights: {value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    }},
    spotLightShadows: {value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    }},
    spotShadowMap: {value: []},
    spotShadowMatrix: {value: []},
    pointLights: {value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    }},
    pointLightShadows: {value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    }},
    pointShadowMap: {value: []},
    pointShadowMatrix: {value: []},
    hemisphereLights: {value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    }},
    rectAreaLights: {value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    }},
    ltc_1: {value: null},
    ltc_2: {value: null}
  },
  points: {
    diffuse: {value: new Color(15658734)},
    opacity: {value: 1},
    size: {value: 1},
    scale: {value: 1},
    map: {value: null},
    alphaMap: {value: null},
    uvTransform: {value: new Matrix3()}
  },
  sprite: {
    diffuse: {value: new Color(15658734)},
    opacity: {value: 1},
    center: {value: new Vector2(0.5, 0.5)},
    rotation: {value: 0},
    map: {value: null},
    alphaMap: {value: null},
    uvTransform: {value: new Matrix3()}
  }
};
const ShaderLib = {
  basic: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color(0)}
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color(0)},
        specular: {value: new Color(1118481)},
        shininess: {value: 30}
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color(0)},
        roughness: {value: 1},
        metalness: {value: 0},
        envMapIntensity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: {value: new Color(0)}
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: {value: null}
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: {value: 1},
        dashSize: {value: 1},
        totalSize: {value: 2}
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk.normal_vert,
    fragmentShader: ShaderChunk.normal_frag
  },
  sprite: {
    uniforms: mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: {value: new Matrix3()},
      t2D: {value: null}
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  cube: {
    uniforms: mergeUniforms([
      UniformsLib.envmap,
      {
        opacity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: {value: null}
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: {value: new Vector3()},
        nearDistance: {value: 1},
        farDistance: {value: 1e3}
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: {value: new Color(0)},
        opacity: {value: 1}
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: {value: 0},
      clearcoatMap: {value: null},
      clearcoatRoughness: {value: 0},
      clearcoatRoughnessMap: {value: null},
      clearcoatNormalScale: {value: new Vector2(1, 1)},
      clearcoatNormalMap: {value: null},
      sheen: {value: new Color(0)},
      transmission: {value: 0},
      transmissionMap: {value: null}
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
function WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {
  const clearColor = new Color(0);
  let clearAlpha = 0;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function render(renderList, scene, camera, forceClear) {
    let background = scene.isScene === true ? scene.background : null;
    if (background && background.isTexture) {
      background = cubemaps.get(background);
    }
    const xr = renderer.xr;
    const session = xr.getSession && xr.getSession();
    if (session && session.environmentBlendMode === "additive") {
      background = null;
    }
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
          name: "BackgroundCubeMaterial",
          uniforms: cloneUniforms(ShaderLib.cube.uniforms),
          vertexShader: ShaderLib.cube.vertexShader,
          fragmentShader: ShaderLib.cube.fragmentShader,
          side: BackSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function(renderer2, scene2, camera2) {
          this.matrixWorld.copyPosition(camera2.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background._needsFlipEnvMap ? -1 : 1;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
          name: "BackgroundMaterial",
          uniforms: cloneUniforms(ShaderLib.background.uniforms),
          vertexShader: ShaderLib.background.vertexShader,
          fragmentShader: ShaderLib.background.fragmentShader,
          side: FrontSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color, alpha) {
    state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color, alpha = 1) {
      clearColor.set(color);
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha) {
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    render
  };
}
function WebGLBindingStates(gl, extensions, attributes, capabilities) {
  const maxVertexAttributes = gl.getParameter(34921);
  const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
  const vaoAvailable = capabilities.isWebGL2 || extension !== null;
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  function setup(object, material, program, geometry, index) {
    let updateBuffers = false;
    if (vaoAvailable) {
      const state = getBindingState(geometry, program, material);
      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }
      updateBuffers = needsUpdate(geometry, index);
      if (updateBuffers)
        saveCache(geometry, index);
    } else {
      const wireframe = material.wireframe === true;
      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
        currentState.geometry = geometry.id;
        currentState.program = program.id;
        currentState.wireframe = wireframe;
        updateBuffers = true;
      }
    }
    if (object.isInstancedMesh === true) {
      updateBuffers = true;
    }
    if (index !== null) {
      attributes.update(index, 34963);
    }
    if (updateBuffers) {
      setupVertexAttributes(object, material, program, geometry);
      if (index !== null) {
        gl.bindBuffer(34963, attributes.get(index).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    if (capabilities.isWebGL2)
      return gl.createVertexArray();
    return extension.createVertexArrayOES();
  }
  function bindVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.bindVertexArray(vao);
    return extension.bindVertexArrayOES(vao);
  }
  function deleteVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.deleteVertexArray(vao);
    return extension.deleteVertexArrayOES(vao);
  }
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === void 0) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === void 0) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i2 = 0; i2 < maxVertexAttributes; i2++) {
      newAttributes[i2] = 0;
      enabledAttributes[i2] = 0;
      attributeDivisors[i2] = 0;
    }
    return {
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  function needsUpdate(geometry, index) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;
    for (const key in geometryAttributes) {
      const cachedAttribute = cachedAttributes[key];
      const geometryAttribute = geometryAttributes[key];
      if (cachedAttribute === void 0)
        return true;
      if (cachedAttribute.attribute !== geometryAttribute)
        return true;
      if (cachedAttribute.data !== geometryAttribute.data)
        return true;
      attributesNum++;
    }
    if (currentState.attributesNum !== attributesNum)
      return true;
    if (currentState.index !== index)
      return true;
    return false;
  }
  function saveCache(geometry, index) {
    const cache = {};
    const attributes2 = geometry.attributes;
    let attributesNum = 0;
    for (const key in attributes2) {
      const attribute = attributes2[key];
      const data = {};
      data.attribute = attribute;
      if (attribute.data) {
        data.data = attribute.data;
      }
      cache[key] = data;
      attributesNum++;
    }
    currentState.attributes = cache;
    currentState.attributesNum = attributesNum;
    currentState.index = index;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i2 = 0, il = newAttributes.length; i2 < il; i2++) {
      newAttributes[i2] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      const extension2 = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
      extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i2 = 0, il = enabledAttributes.length; i2 < il; i2++) {
      if (enabledAttributes[i2] !== newAttributes[i2]) {
        gl.disableVertexAttribArray(i2);
        enabledAttributes[i2] = 0;
      }
    }
  }
  function vertexAttribPointer(index, size, type, normalized, stride, offset) {
    if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
      gl.vertexAttribIPointer(index, size, type, stride, offset);
    } else {
      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
  }
  function setupVertexAttributes(object, material, program, geometry) {
    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
      if (extensions.get("ANGLE_instanced_arrays") === null)
        return;
    }
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute >= 0) {
        const geometryAttribute = geometryAttributes[name];
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset = geometryAttribute.offset;
            if (data && data.isInstancedInterleavedBuffer) {
              enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
              if (geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              enableAttribute(programAttribute);
            }
            gl.bindBuffer(34962, buffer);
            vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
              if (geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              enableAttribute(programAttribute);
            }
            gl.bindBuffer(34962, buffer);
            vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
          }
        } else if (name === "instanceMatrix") {
          const attribute = attributes.get(object.instanceMatrix);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          enableAttributeAndDivisor(programAttribute + 0, 1);
          enableAttributeAndDivisor(programAttribute + 1, 1);
          enableAttributeAndDivisor(programAttribute + 2, 1);
          enableAttributeAndDivisor(programAttribute + 3, 1);
          gl.bindBuffer(34962, buffer);
          gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);
          gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);
          gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);
          gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
        } else if (name === "instanceColor") {
          const attribute = attributes.get(object.instanceColor);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          enableAttributeAndDivisor(programAttribute, 1);
          gl.bindBuffer(34962, buffer);
          gl.vertexAttribPointer(programAttribute, 3, type, false, 12, 0);
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute, value);
                break;
              case 3:
                gl.vertexAttrib3fv(programAttribute, value);
                break;
              case 4:
                gl.vertexAttrib4fv(programAttribute, value);
                break;
              default:
                gl.vertexAttrib1fv(programAttribute, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose() {
    reset();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === void 0)
      return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === void 0)
        continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset() {
    resetDefaultState();
    if (currentState === defaultState)
      return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup,
    reset,
    resetDefaultState,
    dispose,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes
  };
}
function WebGLBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  function render(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawArraysInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawArraysInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, start, count, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLCapabilities(gl, extensions, parameters) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0)
      return maxAnisotropy;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
  let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const maxTextures = gl.getParameter(34930);
  const maxVertexTextures = gl.getParameter(35660);
  const maxTextureSize = gl.getParameter(3379);
  const maxCubemapSize = gl.getParameter(34076);
  const maxAttributes = gl.getParameter(34921);
  const maxVertexUniforms = gl.getParameter(36347);
  const maxVaryings = gl.getParameter(36348);
  const maxFragmentUniforms = gl.getParameter(36349);
  const vertexTextures = maxVertexTextures > 0;
  const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
  const floatVertexTextures = vertexTextures && floatFragmentTextures;
  const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
  return {
    isWebGL2,
    getMaxAnisotropy,
    getMaxPrecision,
    precision,
    logarithmicDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    floatFragmentTextures,
    floatVertexTextures,
    maxSamples
  };
}
function WebGLClipping(properties) {
  const scope = this;
  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
  const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = {value: null, needsUpdate: false};
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping, camera) {
    const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
    resetGlobalState();
  };
  this.setState = function(material, camera, useCache) {
    const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, useCache);
      for (let i2 = 0; i2 !== lGlobal; ++i2) {
        dstArray[i2] = globalState[i2];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i2 = 0, i4 = dstOffset; i2 !== nPlanes; ++i2, i4 += 4) {
          plane.copy(planes[i2]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLCubeMaps(renderer) {
  let cubemaps = new WeakMap();
  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }
    return texture;
  }
  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;
      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image = texture.image;
          if (image && image.height > 0) {
            const currentRenderTarget = renderer.getRenderTarget();
            const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            cubemaps.set(texture, renderTarget);
            renderer.setRenderTarget(currentRenderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemap = cubemaps.get(texture);
    if (cubemap !== void 0) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }
  function dispose() {
    cubemaps = new WeakMap();
  }
  return {
    get,
    dispose
  };
}
function WebGLExtensions(gl) {
  const extensions = {};
  function getExtension(name) {
    if (extensions[name] !== void 0) {
      return extensions[name];
    }
    let extension;
    switch (name) {
      case "WEBGL_depth_texture":
        extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        extension = gl.getExtension(name);
    }
    extensions[name] = extension;
    return extension;
  }
  return {
    has: function(name) {
      return getExtension(name) !== null;
    },
    init: function(capabilities) {
      if (capabilities.isWebGL2) {
        getExtension("EXT_color_buffer_float");
      } else {
        getExtension("WEBGL_depth_texture");
        getExtension("OES_texture_float");
        getExtension("OES_texture_half_float");
        getExtension("OES_texture_half_float_linear");
        getExtension("OES_standard_derivatives");
        getExtension("OES_element_index_uint");
        getExtension("OES_vertex_array_object");
        getExtension("ANGLE_instanced_arrays");
      }
      getExtension("OES_texture_float_linear");
      getExtension("EXT_color_buffer_half_float");
    },
    get: function(name) {
      const extension = getExtension(name);
      if (extension === null) {
        console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
      }
      return extension;
    }
  };
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries = {};
  const wireframeAttributes = new WeakMap();
  function onGeometryDispose(event) {
    const geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (const name in geometry.attributes) {
      attributes.remove(geometry.attributes[name]);
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    delete geometries[geometry.id];
    const attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  function get(object, geometry) {
    if (geometries[geometry.id] === true)
      return geometry;
    geometry.addEventListener("dispose", onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  function update(geometry) {
    const geometryAttributes = geometry.attributes;
    for (const name in geometryAttributes) {
      attributes.update(geometryAttributes[name], 34962);
    }
    const morphAttributes = geometry.morphAttributes;
    for (const name in morphAttributes) {
      const array = morphAttributes[name];
      for (let i2 = 0, l2 = array.length; i2 < l2; i2++) {
        attributes.update(array[i2], 34962);
      }
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version = 0;
    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version = geometryIndex.version;
      for (let i2 = 0, l2 = array.length; i2 < l2; i2 += 3) {
        const a2 = array[i2 + 0];
        const b2 = array[i2 + 1];
        const c2 = array[i2 + 2];
        indices.push(a2, b2, b2, c2, c2, a2);
      }
    } else {
      const array = geometryPosition.array;
      version = geometryPosition.version;
      for (let i2 = 0, l2 = array.length / 3 - 1; i2 < l2; i2 += 3) {
        const a2 = i2 + 0;
        const b2 = i2 + 1;
        const c2 = i2 + 2;
        indices.push(a2, b2, b2, c2, c2, a2);
      }
    }
    const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version;
    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute)
      attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get,
    update,
    getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawElementsInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawElementsInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLInfo(gl) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update(count, mode, instanceCount) {
    render.calls++;
    switch (mode) {
      case 4:
        render.triangles += instanceCount * (count / 3);
        break;
      case 1:
        render.lines += instanceCount * (count / 2);
        break;
      case 3:
        render.lines += instanceCount * (count - 1);
        break;
      case 2:
        render.lines += instanceCount * count;
        break;
      case 0:
        render.points += instanceCount * count;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  function reset() {
    render.frame++;
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }
  return {
    memory,
    render,
    programs: null,
    autoReset: true,
    reset,
    update
  };
}
function numericalSort(a2, b2) {
  return a2[0] - b2[0];
}
function absNumericalSort(a2, b2) {
  return Math.abs(b2[1]) - Math.abs(a2[1]);
}
function WebGLMorphtargets(gl) {
  const influencesList = {};
  const morphInfluences = new Float32Array(8);
  const workInfluences = [];
  for (let i2 = 0; i2 < 8; i2++) {
    workInfluences[i2] = [i2, 0];
  }
  function update(object, geometry, material, program) {
    const objectInfluences = object.morphTargetInfluences;
    const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
    let influences = influencesList[geometry.id];
    if (influences === void 0) {
      influences = [];
      for (let i2 = 0; i2 < length; i2++) {
        influences[i2] = [i2, 0];
      }
      influencesList[geometry.id] = influences;
    }
    for (let i2 = 0; i2 < length; i2++) {
      const influence = influences[i2];
      influence[0] = i2;
      influence[1] = objectInfluences[i2];
    }
    influences.sort(absNumericalSort);
    for (let i2 = 0; i2 < 8; i2++) {
      if (i2 < length && influences[i2][1]) {
        workInfluences[i2][0] = influences[i2][0];
        workInfluences[i2][1] = influences[i2][1];
      } else {
        workInfluences[i2][0] = Number.MAX_SAFE_INTEGER;
        workInfluences[i2][1] = 0;
      }
    }
    workInfluences.sort(numericalSort);
    const morphTargets = material.morphTargets && geometry.morphAttributes.position;
    const morphNormals = material.morphNormals && geometry.morphAttributes.normal;
    let morphInfluencesSum = 0;
    for (let i2 = 0; i2 < 8; i2++) {
      const influence = workInfluences[i2];
      const index = influence[0];
      const value = influence[1];
      if (index !== Number.MAX_SAFE_INTEGER && value) {
        if (morphTargets && geometry.getAttribute("morphTarget" + i2) !== morphTargets[index]) {
          geometry.setAttribute("morphTarget" + i2, morphTargets[index]);
        }
        if (morphNormals && geometry.getAttribute("morphNormal" + i2) !== morphNormals[index]) {
          geometry.setAttribute("morphNormal" + i2, morphNormals[index]);
        }
        morphInfluences[i2] = value;
        morphInfluencesSum += value;
      } else {
        if (morphTargets && geometry.hasAttribute("morphTarget" + i2) === true) {
          geometry.deleteAttribute("morphTarget" + i2);
        }
        if (morphNormals && geometry.hasAttribute("morphNormal" + i2) === true) {
          geometry.deleteAttribute("morphNormal" + i2);
        }
        morphInfluences[i2] = 0;
      }
    }
    const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
    program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
    program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
  }
  return {
    update
  };
}
function WebGLObjects(gl, geometries, attributes, info) {
  let updateMap = new WeakMap();
  function update(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries.get(object, geometry);
    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object.isInstancedMesh) {
      if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
        object.addEventListener("dispose", onInstancedMeshDispose);
      }
      attributes.update(object.instanceMatrix, 34962);
      if (object.instanceColor !== null) {
        attributes.update(object.instanceColor, 34962);
      }
    }
    return buffergeometry;
  }
  function dispose() {
    updateMap = new WeakMap();
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null)
      attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update,
    dispose
  };
}
class DataTexture2DArray extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.image = {data, width, height, depth};
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
  }
}
DataTexture2DArray.prototype.isDataTexture2DArray = true;
class DataTexture3D extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.image = {data, width, height, depth};
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
  }
}
DataTexture3D.prototype.isDataTexture3D = true;
const emptyTexture = new Texture();
const emptyTexture2dArray = new DataTexture2DArray();
const emptyTexture3d = new DataTexture3D();
const emptyCubeTexture = new CubeTexture();
const arrayCacheF32 = [];
const arrayCacheI32 = [];
const mat4array = new Float32Array(16);
const mat3array = new Float32Array(9);
const mat2array = new Float32Array(4);
function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0)
    return array;
  const n2 = nBlocks * blockSize;
  let r2 = arrayCacheF32[n2];
  if (r2 === void 0) {
    r2 = new Float32Array(n2);
    arrayCacheF32[n2] = r2;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r2, 0);
    for (let i2 = 1, offset = 0; i2 !== nBlocks; ++i2) {
      offset += blockSize;
      array[i2].toArray(r2, offset);
    }
  }
  return r2;
}
function arraysEqual(a2, b2) {
  if (a2.length !== b2.length)
    return false;
  for (let i2 = 0, l2 = a2.length; i2 < l2; i2++) {
    if (a2[i2] !== b2[i2])
      return false;
  }
  return true;
}
function copyArray(a2, b2) {
  for (let i2 = 0, l2 = b2.length; i2 < l2; i2++) {
    a2[i2] = b2[i2];
  }
}
function allocTexUnits(textures, n2) {
  let r2 = arrayCacheI32[n2];
  if (r2 === void 0) {
    r2 = new Int32Array(n2);
    arrayCacheI32[n2] = r2;
  }
  for (let i2 = 0; i2 !== n2; ++i2) {
    r2[i2] = textures.allocateTextureUnit();
  }
  return r2;
}
function setValueV1f(gl, v2) {
  const cache = this.cache;
  if (cache[0] === v2)
    return;
  gl.uniform1f(this.addr, v2);
  cache[0] = v2;
}
function setValueV2f(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y) {
      gl.uniform2f(this.addr, v2.x, v2.y);
      cache[0] = v2.x;
      cache[1] = v2.y;
    }
  } else {
    if (arraysEqual(cache, v2))
      return;
    gl.uniform2fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV3f(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z) {
      gl.uniform3f(this.addr, v2.x, v2.y, v2.z);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
    }
  } else if (v2.r !== void 0) {
    if (cache[0] !== v2.r || cache[1] !== v2.g || cache[2] !== v2.b) {
      gl.uniform3f(this.addr, v2.r, v2.g, v2.b);
      cache[0] = v2.r;
      cache[1] = v2.g;
      cache[2] = v2.b;
    }
  } else {
    if (arraysEqual(cache, v2))
      return;
    gl.uniform3fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV4f(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z || cache[3] !== v2.w) {
      gl.uniform4f(this.addr, v2.x, v2.y, v2.z, v2.w);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
      cache[3] = v2.w;
    }
  } else {
    if (arraysEqual(cache, v2))
      return;
    gl.uniform4fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueM2(gl, v2) {
  const cache = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2))
      return;
    gl.uniformMatrix2fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}
function setValueM3(gl, v2) {
  const cache = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2))
      return;
    gl.uniformMatrix3fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}
function setValueM4(gl, v2) {
  const cache = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2))
      return;
    gl.uniformMatrix4fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
}
function setValueV1i(gl, v2) {
  const cache = this.cache;
  if (cache[0] === v2)
    return;
  gl.uniform1i(this.addr, v2);
  cache[0] = v2;
}
function setValueV2i(gl, v2) {
  const cache = this.cache;
  if (arraysEqual(cache, v2))
    return;
  gl.uniform2iv(this.addr, v2);
  copyArray(cache, v2);
}
function setValueV3i(gl, v2) {
  const cache = this.cache;
  if (arraysEqual(cache, v2))
    return;
  gl.uniform3iv(this.addr, v2);
  copyArray(cache, v2);
}
function setValueV4i(gl, v2) {
  const cache = this.cache;
  if (arraysEqual(cache, v2))
    return;
  gl.uniform4iv(this.addr, v2);
  copyArray(cache, v2);
}
function setValueV1ui(gl, v2) {
  const cache = this.cache;
  if (cache[0] === v2)
    return;
  gl.uniform1ui(this.addr, v2);
  cache[0] = v2;
}
function setValueV2ui(gl, v2) {
  const cache = this.cache;
  if (arraysEqual(cache, v2))
    return;
  gl.uniform2uiv(this.addr, v2);
  copyArray(cache, v2);
}
function setValueV3ui(gl, v2) {
  const cache = this.cache;
  if (arraysEqual(cache, v2))
    return;
  gl.uniform3uiv(this.addr, v2);
  copyArray(cache, v2);
}
function setValueV4ui(gl, v2) {
  const cache = this.cache;
  if (arraysEqual(cache, v2))
    return;
  gl.uniform4uiv(this.addr, v2);
  copyArray(cache, v2);
}
function setValueT1(gl, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.safeSetTexture2D(v2 || emptyTexture, unit);
}
function setValueT3D1(gl, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture3D(v2 || emptyTexture3d, unit);
}
function setValueT6(gl, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.safeSetTextureCube(v2 || emptyCubeTexture, unit);
}
function setValueT2DArray1(gl, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2DArray(v2 || emptyTexture2dArray, unit);
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 36294:
      return setValueV2ui;
    case 36295:
      return setValueV3ui;
    case 36296:
      return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(gl, v2) {
  gl.uniform1fv(this.addr, v2);
}
function setValueV2fArray(gl, v2) {
  const data = flatten(v2, this.size, 2);
  gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v2) {
  const data = flatten(v2, this.size, 3);
  gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v2) {
  const data = flatten(v2, this.size, 4);
  gl.uniform4fv(this.addr, data);
}
function setValueM2Array(gl, v2) {
  const data = flatten(v2, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v2) {
  const data = flatten(v2, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v2) {
  const data = flatten(v2, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
}
function setValueV1iArray(gl, v2) {
  gl.uniform1iv(this.addr, v2);
}
function setValueV2iArray(gl, v2) {
  gl.uniform2iv(this.addr, v2);
}
function setValueV3iArray(gl, v2) {
  gl.uniform3iv(this.addr, v2);
}
function setValueV4iArray(gl, v2) {
  gl.uniform4iv(this.addr, v2);
}
function setValueV1uiArray(gl, v2) {
  gl.uniform1uiv(this.addr, v2);
}
function setValueV2uiArray(gl, v2) {
  gl.uniform2uiv(this.addr, v2);
}
function setValueV3uiArray(gl, v2) {
  gl.uniform3uiv(this.addr, v2);
}
function setValueV4uiArray(gl, v2) {
  gl.uniform4uiv(this.addr, v2);
}
function setValueT1Array(gl, v2, textures) {
  const n2 = v2.length;
  const units = allocTexUnits(textures, n2);
  gl.uniform1iv(this.addr, units);
  for (let i2 = 0; i2 !== n2; ++i2) {
    textures.safeSetTexture2D(v2[i2] || emptyTexture, units[i2]);
  }
}
function setValueT6Array(gl, v2, textures) {
  const n2 = v2.length;
  const units = allocTexUnits(textures, n2);
  gl.uniform1iv(this.addr, units);
  for (let i2 = 0; i2 !== n2; ++i2) {
    textures.safeSetTextureCube(v2[i2] || emptyCubeTexture, units[i2]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 5125:
      return setValueV1uiArray;
    case 36294:
      return setValueV2uiArray;
    case 36295:
      return setValueV3uiArray;
    case 36296:
      return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
  }
}
function SingleUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.setValue = getSingularSetter(activeInfo.type);
}
function PureArrayUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type);
}
PureArrayUniform.prototype.updateCache = function(data) {
  const cache = this.cache;
  if (data instanceof Float32Array && cache.length !== data.length) {
    this.cache = new Float32Array(data.length);
  }
  copyArray(cache, data);
};
function StructuredUniform(id) {
  this.id = id;
  this.seq = [];
  this.map = {};
}
StructuredUniform.prototype.setValue = function(gl, value, textures) {
  const seq = this.seq;
  for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
    const u2 = seq[i2];
    u2.setValue(gl, value[u2.id], textures);
  }
};
const RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
    let id = match[1];
    const idIsIndex = match[2] === "]", subscript = match[3];
    if (idIsIndex)
      id = id | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      const map = container.map;
      let next = map[id];
      if (next === void 0) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }
      container = next;
    }
  }
}
function WebGLUniforms(gl, program) {
  this.seq = [];
  this.map = {};
  const n2 = gl.getProgramParameter(program, 35718);
  for (let i2 = 0; i2 < n2; ++i2) {
    const info = gl.getActiveUniform(program, i2), addr = gl.getUniformLocation(program, info.name);
    parseUniform(info, addr, this);
  }
}
WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
  const u2 = this.map[name];
  if (u2 !== void 0)
    u2.setValue(gl, value, textures);
};
WebGLUniforms.prototype.setOptional = function(gl, object, name) {
  const v2 = object[name];
  if (v2 !== void 0)
    this.setValue(gl, name, v2);
};
WebGLUniforms.upload = function(gl, seq, values, textures) {
  for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
    const u2 = seq[i2], v2 = values[u2.id];
    if (v2.needsUpdate !== false) {
      u2.setValue(gl, v2.value, textures);
    }
  }
};
WebGLUniforms.seqWithValue = function(seq, values) {
  const r2 = [];
  for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
    const u2 = seq[i2];
    if (u2.id in values)
      r2.push(u2);
  }
  return r2;
};
function WebGLShader(gl, type, string) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}
let programIdCount = 0;
function addLineNumbers(string) {
  const lines = string.split("\n");
  for (let i2 = 0; i2 < lines.length; i2++) {
    lines[i2] = i2 + 1 + ": " + lines[i2];
  }
  return lines.join("\n");
}
function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ["Linear", "( value )"];
    case sRGBEncoding:
      return ["sRGB", "( value )"];
    case RGBEEncoding:
      return ["RGBE", "( value )"];
    case RGBM7Encoding:
      return ["RGBM", "( value, 7.0 )"];
    case RGBM16Encoding:
      return ["RGBM", "( value, 16.0 )"];
    case RGBDEncoding:
      return ["RGBD", "( value, 256.0 )"];
    case GammaEncoding:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    case LogLuvEncoding:
      return ["LogLuv", "( value )"];
    default:
      console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
      return ["Linear", "( value )"];
  }
}
function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, 35713);
  const log = gl.getShaderInfoLog(shader).trim();
  if (status && log === "")
    return "";
  const source = gl.getShaderSource(shader);
  return "THREE.WebGLShader: gl.getShaderInfoLog() " + type + "\n" + log + addLineNumbers(source);
}
function getTexelDecodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
}
function getTexelEncodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
}
function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case CineonToneMapping:
      toneMappingName = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    case CustomToneMapping:
      toneMappingName = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
      toneMappingName = "Linear";
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
function generateExtensions(parameters) {
  const chunks = [
    parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  const chunks = [];
  for (const name in defines) {
    const value = defines[name];
    if (value === false)
      continue;
    chunks.push("#define " + name + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl, program) {
  const attributes = {};
  const n2 = gl.getProgramParameter(program, 35721);
  for (let i2 = 0; i2 < n2; i2++) {
    const info = gl.getActiveAttrib(program, i2);
    const name = info.name;
    attributes[name] = gl.getAttribLocation(program, name);
  }
  return attributes;
}
function filterEmptyLine(string) {
  return string !== "";
}
function replaceLightNums(string, parameters) {
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}
function includeReplacer(match, include) {
  const string = ShaderChunk[include];
  if (string === void 0) {
    throw new Error("Can not resolve #include <" + include + ">");
  }
  return resolveIncludes(string);
}
const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}
function deprecatedLoopReplacer(match, start, end, snippet) {
  console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
  return loopReplacer(match, start, end, snippet);
}
function loopReplacer(match, start, end, snippet) {
  let string = "";
  for (let i2 = parseInt(start); i2 < parseInt(end); i2++) {
    string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i2 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i2);
  }
  return string;
}
function generatePrecision(parameters) {
  let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
  }
  return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
      case CubeUVRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  }
  return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
      case CubeUVRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return envMapBlendingDefine;
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  const gl = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
  const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      customExtensions,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      "#define MAX_BONES " + parameters.maxBones,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#ifdef USE_MORPHTARGETS",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      customExtensions,
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest + (parameters.alphaTest % 1 ? "" : ".0") : "",
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      ShaderChunk["encodings_pars_fragment"],
      parameters.map ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "",
      parameters.matcap ? getTexelDecodingFunction("matcapTexelToLinear", parameters.matcapEncoding) : "",
      parameters.envMap ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "",
      parameters.emissiveMap ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "",
      parameters.lightMap ? getTexelDecodingFunction("lightMapTexelToLinear", parameters.lightMapEncoding) : "",
      getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
      parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
    versionString = "#version 300 es\n";
    prefixVertex = [
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "#define varying in",
      parameters.glslVersion === GLSL3 ? "" : "out highp vec4 pc_fragColor;",
      parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader;
  const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== void 0) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, "position");
  }
  gl.linkProgram(program);
  if (renderer.debug.checkShaderErrors) {
    const programLog = gl.getProgramInfoLog(program).trim();
    const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
    const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
    let runnable = true;
    let haveDiagnostics = true;
    if (gl.getProgramParameter(program, 35714) === false) {
      runnable = false;
      const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
      const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
      console.error("THREE.WebGLProgram: shader error: ", gl.getError(), "35715", gl.getProgramParameter(program, 35715), "gl.getProgramInfoLog", programLog, vertexErrors, fragmentErrors);
    } else if (programLog !== "") {
      console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", programLog);
    } else if (vertexLog === "" || fragmentLog === "") {
      haveDiagnostics = false;
    }
    if (haveDiagnostics) {
      this.diagnostics = {
        runnable,
        programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
  }
  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader);
  let cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      cachedUniforms = new WebGLUniforms(gl, program);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }
    return cachedAttributes;
  };
  this.destroy = function() {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = void 0;
  };
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
function WebGLPrograms(renderer, cubemaps, extensions, capabilities, bindingStates, clipping) {
  const programs = [];
  const isWebGL2 = capabilities.isWebGL2;
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const floatVertexTextures = capabilities.floatVertexTextures;
  const maxVertexUniforms = capabilities.maxVertexUniforms;
  const vertexTextures = capabilities.vertexTextures;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  const parameterNames = [
    "precision",
    "isWebGL2",
    "supportsVertexTextures",
    "outputEncoding",
    "instancing",
    "instancingColor",
    "map",
    "mapEncoding",
    "matcap",
    "matcapEncoding",
    "envMap",
    "envMapMode",
    "envMapEncoding",
    "envMapCubeUV",
    "lightMap",
    "lightMapEncoding",
    "aoMap",
    "emissiveMap",
    "emissiveMapEncoding",
    "bumpMap",
    "normalMap",
    "objectSpaceNormalMap",
    "tangentSpaceNormalMap",
    "clearcoatMap",
    "clearcoatRoughnessMap",
    "clearcoatNormalMap",
    "displacementMap",
    "specularMap",
    "roughnessMap",
    "metalnessMap",
    "gradientMap",
    "alphaMap",
    "combine",
    "vertexColors",
    "vertexAlphas",
    "vertexTangents",
    "vertexUvs",
    "uvsVertexOnly",
    "fog",
    "useFog",
    "fogExp2",
    "flatShading",
    "sizeAttenuation",
    "logarithmicDepthBuffer",
    "skinning",
    "maxBones",
    "useVertexTexture",
    "morphTargets",
    "morphNormals",
    "premultipliedAlpha",
    "numDirLights",
    "numPointLights",
    "numSpotLights",
    "numHemiLights",
    "numRectAreaLights",
    "numDirLightShadows",
    "numPointLightShadows",
    "numSpotLightShadows",
    "shadowMapEnabled",
    "shadowMapType",
    "toneMapping",
    "physicallyCorrectLights",
    "alphaTest",
    "doubleSided",
    "flipSided",
    "numClippingPlanes",
    "numClipIntersection",
    "depthPacking",
    "dithering",
    "sheen",
    "transmissionMap"
  ];
  function getMaxBones(object) {
    const skeleton = object.skeleton;
    const bones = skeleton.bones;
    if (floatVertexTextures) {
      return 1024;
    } else {
      const nVertexUniforms = maxVertexUniforms;
      const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      const maxBones = Math.min(nVertexMatrices, bones.length);
      if (maxBones < bones.length) {
        console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
        return 0;
      }
      return maxBones;
    }
  }
  function getTextureEncodingFromMap(map) {
    let encoding;
    if (map && map.isTexture) {
      encoding = map.encoding;
    } else if (map && map.isWebGLRenderTarget) {
      console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
      encoding = map.texture.encoding;
    } else {
      encoding = LinearEncoding;
    }
    return encoding;
  }
  function getParameters(material, lights, shadows, scene, object) {
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const envMap = cubemaps.get(material.envMap || environment);
    const shaderID = shaderIDs[material.type];
    const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
      }
    }
    let vertexShader, fragmentShader;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
    }
    const currentRenderTarget = renderer.getRenderTarget();
    const parameters = {
      isWebGL2,
      shaderID,
      shaderName: material.type,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision,
      instancing: object.isInstancedMesh === true,
      instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
      supportsVertexTextures: vertexTextures,
      outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
      map: !!material.map,
      mapEncoding: getTextureEncodingFromMap(material.map),
      matcap: !!material.matcap,
      matcapEncoding: getTextureEncodingFromMap(material.matcap),
      envMap: !!envMap,
      envMapMode: envMap && envMap.mapping,
      envMapEncoding: getTextureEncodingFromMap(envMap),
      envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
      lightMap: !!material.lightMap,
      lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
      clearcoatMap: !!material.clearcoatMap,
      clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
      clearcoatNormalMap: !!material.clearcoatNormalMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      alphaMap: !!material.alphaMap,
      gradientMap: !!material.gradientMap,
      sheen: !!material.sheen,
      transmissionMap: !!material.transmissionMap,
      combine: material.combine,
      vertexTangents: material.normalMap && material.vertexTangents,
      vertexColors: material.vertexColors,
      vertexAlphas: material.vertexColors === true && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap,
      uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmissionMap) && !!material.displacementMap,
      fog: !!fog,
      useFog: material.fog,
      fogExp2: fog && fog.isFogExp2,
      flatShading: !!material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer,
      skinning: material.skinning && maxBones > 0,
      maxBones,
      useVertexTexture: floatVertexTextures,
      morphTargets: material.morphTargets,
      morphNormals: material.morphNormals,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
      physicallyCorrectLights: renderer.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      alphaTest: material.alphaTest,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives: material.extensions && material.extensions.derivatives,
      extensionFragDepth: material.extensions && material.extensions.fragDepth,
      extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
      extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.fragmentShader);
      array.push(parameters.vertexShader);
    }
    if (parameters.defines !== void 0) {
      for (const name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      for (let i2 = 0; i2 < parameterNames.length; i2++) {
        array.push(parameters[parameterNames[i2]]);
      }
      array.push(renderer.outputEncoding);
      array.push(renderer.gammaFactor);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    let program;
    for (let p2 = 0, pl = programs.length; p2 < pl; p2++) {
      const preexistingProgram = programs[p2];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i2 = programs.indexOf(program);
      programs[i2] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    programs
  };
}
function WebGLProperties() {
  let properties = new WeakMap();
  function get(object) {
    let map = properties.get(object);
    if (map === void 0) {
      map = {};
      properties.set(object, map);
    }
    return map;
  }
  function remove(object) {
    properties.delete(object);
  }
  function update(object, key, value) {
    properties.get(object)[key] = value;
  }
  function dispose() {
    properties = new WeakMap();
  }
  return {
    get,
    remove,
    update,
    dispose
  };
}
function painterSortStable(a2, b2) {
  if (a2.groupOrder !== b2.groupOrder) {
    return a2.groupOrder - b2.groupOrder;
  } else if (a2.renderOrder !== b2.renderOrder) {
    return a2.renderOrder - b2.renderOrder;
  } else if (a2.program !== b2.program) {
    return a2.program.id - b2.program.id;
  } else if (a2.material.id !== b2.material.id) {
    return a2.material.id - b2.material.id;
  } else if (a2.z !== b2.z) {
    return a2.z - b2.z;
  } else {
    return a2.id - b2.id;
  }
}
function reversePainterSortStable(a2, b2) {
  if (a2.groupOrder !== b2.groupOrder) {
    return a2.groupOrder - b2.groupOrder;
  } else if (a2.renderOrder !== b2.renderOrder) {
    return a2.renderOrder - b2.renderOrder;
  } else if (a2.z !== b2.z) {
    return b2.z - a2.z;
  } else {
    return a2.id - b2.id;
  }
}
function WebGLRenderList(properties) {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transparent = [];
  const defaultProgram = {id: -1};
  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry, material, groupOrder, z2, group) {
    let renderItem = renderItems[renderItemsIndex];
    const materialProperties = properties.get(material);
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        program: materialProperties.program || defaultProgram,
        groupOrder,
        renderOrder: object.renderOrder,
        z: z2,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.program = materialProperties.program || defaultProgram;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z2;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object, geometry, material, groupOrder, z2, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z2, group);
    (material.transparent === true ? transparent : opaque).push(renderItem);
  }
  function unshift(object, geometry, material, groupOrder, z2, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z2, group);
    (material.transparent === true ? transparent : opaque).unshift(renderItem);
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1)
      opaque.sort(customOpaqueSort || painterSortStable);
    if (transparent.length > 1)
      transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    for (let i2 = renderItemsIndex, il = renderItems.length; i2 < il; i2++) {
      const renderItem = renderItems[i2];
      if (renderItem.id === null)
        break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.program = null;
      renderItem.group = null;
    }
  }
  return {
    opaque,
    transparent,
    init,
    push,
    unshift,
    finish,
    sort
  };
}
function WebGLRenderLists(properties) {
  let lists = new WeakMap();
  function get(scene, renderCallDepth) {
    let list;
    if (lists.has(scene) === false) {
      list = new WebGLRenderList(properties);
      lists.set(scene, [list]);
    } else {
      if (renderCallDepth >= lists.get(scene).length) {
        list = new WebGLRenderList(properties);
        lists.get(scene).push(list);
      } else {
        list = lists.get(scene)[renderCallDepth];
      }
    }
    return list;
  }
  function dispose() {
    lists = new WeakMap();
  }
  return {
    get,
    dispose
  };
}
function UniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
let nextVersion = 0;
function shadowCastingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}
function WebGLLights(extensions, capabilities) {
  const cache = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  for (let i2 = 0; i2 < 9; i2++)
    state.probe.push(new Vector3());
  const vector3 = new Vector3();
  const matrix4 = new Matrix4();
  const matrix42 = new Matrix4();
  function setup(lights) {
    let r2 = 0, g2 = 0, b2 = 0;
    for (let i2 = 0; i2 < 9; i2++)
      state.probe[i2].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    lights.sort(shadowCastingLightsFirst);
    for (let i2 = 0, l2 = lights.length; i2 < l2; i2++) {
      const light = lights[i2];
      const color = light.color;
      const intensity = light.intensity;
      const distance = light.distance;
      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r2 += color.r * intensity;
        g2 += color.g * intensity;
        b2 += color.b * intensity;
      } else if (light.isLightProbe) {
        for (let j2 = 0; j2 < 9; j2++) {
          state.probe[j2].addScaledVector(light.sh.coefficients[j2], intensity);
        }
      } else if (light.isDirectionalLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.distance = distance;
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          state.spotShadowMatrix[spotLength] = light.shadow.matrix;
          numSpotShadows++;
        }
        state.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache.get(light);
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (capabilities.isWebGL2) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        if (extensions.has("OES_texture_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else if (extensions.has("OES_texture_half_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
        } else {
          console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
        }
      }
    }
    state.ambient[0] = r2;
    state.ambient[1] = g2;
    state.ambient[2] = b2;
    const hash = state.hash;
    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotShadowMatrix.length = numSpotShadows;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera.matrixWorldInverse;
    for (let i2 = 0, l2 = lights.length; i2 < l2; i2++) {
      const light = lights[i2];
      if (light.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.direction.normalize();
        hemiLength++;
      }
    }
  }
  return {
    setup,
    setupView,
    state
  };
}
function WebGLRenderState(extensions, capabilities) {
  const lights = new WebGLLights(extensions, capabilities);
  const lightsArray = [];
  const shadowsArray = [];
  function init() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights() {
    lights.setup(lightsArray);
  }
  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }
  const state = {
    lightsArray,
    shadowsArray,
    lights
  };
  return {
    init,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow
  };
}
function WebGLRenderStates(extensions, capabilities) {
  let renderStates = new WeakMap();
  function get(scene, renderCallDepth = 0) {
    let renderState;
    if (renderStates.has(scene) === false) {
      renderState = new WebGLRenderState(extensions, capabilities);
      renderStates.set(scene, [renderState]);
    } else {
      if (renderCallDepth >= renderStates.get(scene).length) {
        renderState = new WebGLRenderState(extensions, capabilities);
        renderStates.get(scene).push(renderState);
      } else {
        renderState = renderStates.get(scene)[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose() {
    renderStates = new WeakMap();
  }
  return {
    get,
    dispose
  };
}
class MeshDepthMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshDepthMaterial";
    this.depthPacking = BasicDepthPacking;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.depthPacking = source.depthPacking;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  }
}
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
class MeshDistanceMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "MeshDistanceMaterial";
    this.referencePosition = new Vector3();
    this.nearDistance = 1;
    this.farDistance = 1e3;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.fog = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.referencePosition.copy(source.referencePosition);
    this.nearDistance = source.nearDistance;
    this.farDistance = source.farDistance;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
  }
}
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean * HALF_SAMPLE_RATE;\n	squared_mean = squared_mean * HALF_SAMPLE_RATE;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
var vsm_vert = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
function WebGLShadowMap(_renderer, _objects, _capabilities) {
  let _frustum = new Frustum();
  const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterials = [], _distanceMaterials = [], _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
  const shadowSide = {0: BackSide, 1: FrontSide, 2: DoubleSide};
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      SAMPLE_RATE: 2 / 8,
      HALF_SAMPLE_RATE: 1 / 8
    },
    uniforms: {
      shadow_pass: {value: null},
      resolution: {value: new Vector2()},
      radius: {value: 4}
    },
    vertexShader: vsm_vert,
    fragmentShader: vsm_frag
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  this.render = function(lights, scene, camera) {
    if (scope.enabled === false)
      return;
    if (scope.autoUpdate === false && scope.needsUpdate === false)
      return;
    if (lights.length === 0)
      return;
    const currentRenderTarget = _renderer.getRenderTarget();
    const activeCubeFace = _renderer.getActiveCubeFace();
    const activeMipmapLevel = _renderer.getActiveMipmapLevel();
    const _state = _renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    for (let i2 = 0, il = lights.length; i2 < il; i2++) {
      const light = lights[i2];
      const shadow = light.shadow;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false)
        continue;
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
        if (_shadowMapSize.x > _maxTextureSize) {
          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > _maxTextureSize) {
          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
        const pars = {minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat};
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.camera.updateProjectionMatrix();
      }
      if (shadow.map === null) {
        const pars = {minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat};
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      const viewportCount = shadow.getViewportCount();
      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp);
        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
        _state.viewport(_viewport);
        shadow.updateMatrices(light, vp);
        _frustum = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      }
      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }
      shadow.needsUpdate = false;
    }
    scope.needsUpdate = false;
    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera) {
    const geometry = _objects.update(fullScreenMesh);
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.mapPass);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.map);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
    const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
    let material = _depthMaterials[index];
    if (material === void 0) {
      material = new MeshDepthMaterial({
        depthPacking: RGBADepthPacking,
        morphTargets: useMorphing,
        skinning: useSkinning
      });
      _depthMaterials[index] = material;
    }
    return material;
  }
  function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {
    const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
    let material = _distanceMaterials[index];
    if (material === void 0) {
      material = new MeshDistanceMaterial({
        morphTargets: useMorphing,
        skinning: useSkinning
      });
      _distanceMaterials[index] = material;
    }
    return material;
  }
  function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
    let result = null;
    let getMaterialVariant = getDepthMaterialVariant;
    let customMaterial = object.customDepthMaterial;
    if (light.isPointLight === true) {
      getMaterialVariant = getDistanceMaterialVariant;
      customMaterial = object.customDistanceMaterial;
    }
    if (customMaterial === void 0) {
      let useMorphing = false;
      if (material.morphTargets === true) {
        useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
      }
      let useSkinning = false;
      if (object.isSkinnedMesh === true) {
        if (material.skinning === true) {
          useSkinning = true;
        } else {
          console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", object);
        }
      }
      const useInstancing = object.isInstancedMesh === true;
      result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
    } else {
      result = customMaterial;
    }
    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
      const keyA = result.uuid, keyB = material.uuid;
      let materialsForVariant = _materialCache[keyA];
      if (materialsForVariant === void 0) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }
      let cachedMaterial = materialsForVariant[keyB];
      if (cachedMaterial === void 0) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }
      result = cachedMaterial;
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      result.referencePosition.setFromMatrixPosition(light.matrixWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        const geometry = _objects.update(object);
        const material = object.material;
        if (Array.isArray(material)) {
          const groups = geometry.groups;
          for (let k2 = 0, kl = groups.length; k2 < kl; k2++) {
            const group = groups[k2];
            const groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);
          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
        }
      }
    }
    const children = object.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      renderObject(children[i2], camera, shadowCamera, light, type);
    }
  }
}
function WebGLState(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function ColorBuffer() {
    let locked = false;
    const color = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r2, g2, b2, a2, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r2 *= a2;
          g2 *= a2;
          b2 *= a2;
        }
        color.set(r2, g2, b2, a2);
        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r2, g2, b2, a2);
          currentColorClear.copy(color);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    let locked = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setTest: function(depthTest) {
        if (depthTest) {
          enable(2929);
        } else {
          disable(2929);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(512);
                break;
              case AlwaysDepth:
                gl.depthFunc(519);
                break;
              case LessDepth:
                gl.depthFunc(513);
                break;
              case LessEqualDepth:
                gl.depthFunc(515);
                break;
              case EqualDepth:
                gl.depthFunc(514);
                break;
              case GreaterEqualDepth:
                gl.depthFunc(518);
                break;
              case GreaterDepth:
                gl.depthFunc(516);
                break;
              case NotEqualDepth:
                gl.depthFunc(517);
                break;
              default:
                gl.depthFunc(515);
            }
          } else {
            gl.depthFunc(515);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(2960);
          } else {
            disable(2960);
          }
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  let enabledCapabilities = {};
  let xrFramebuffer = null;
  let currentBoundFramebuffers = {};
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(35661);
  let lineWidthAvailable = false;
  let version = 0;
  const glVersion = gl.getParameter(7938);
  if (glVersion.indexOf("WebGL") !== -1) {
    version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const currentScissor = new Vector4(0, 0, gl.canvas.width, gl.canvas.height);
  const currentViewport = new Vector4(0, 0, gl.canvas.width, gl.canvas.height);
  function createTexture(type, target, count) {
    const data = new Uint8Array(4);
    const texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, 10241, 9728);
    gl.texParameteri(type, 10240, 9728);
    for (let i2 = 0; i2 < count; i2++) {
      gl.texImage2D(target + i2, 0, 6408, 1, 1, 0, 6408, 5121, data);
    }
    return texture;
  }
  const emptyTextures = {};
  emptyTextures[3553] = createTexture(3553, 3553, 1);
  emptyTextures[34067] = createTexture(34067, 34069, 6);
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(2929);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(2884);
  setBlending(NoBlending);
  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }
  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }
  function bindXRFramebuffer(framebuffer) {
    if (framebuffer !== xrFramebuffer) {
      gl.bindFramebuffer(36160, framebuffer);
      xrFramebuffer = framebuffer;
    }
  }
  function bindFramebuffer(target, framebuffer) {
    if (framebuffer === null && xrFramebuffer !== null)
      framebuffer = xrFramebuffer;
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;
    }
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: 32774,
    [SubtractEquation]: 32778,
    [ReverseSubtractEquation]: 32779
  };
  if (isWebGL2) {
    equationToGL[MinEquation] = 32775;
    equationToGL[MaxEquation] = 32776;
  } else {
    const extension = extensions.get("EXT_blend_minmax");
    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT;
      equationToGL[MaxEquation] = extension.MAX_EXT;
    }
  }
  const factorToGL = {
    [ZeroFactor]: 0,
    [OneFactor]: 1,
    [SrcColorFactor]: 768,
    [SrcAlphaFactor]: 770,
    [SrcAlphaSaturateFactor]: 776,
    [DstColorFactor]: 774,
    [DstAlphaFactor]: 772,
    [OneMinusSrcColorFactor]: 769,
    [OneMinusSrcAlphaFactor]: 771,
    [OneMinusDstColorFactor]: 775,
    [OneMinusDstAlphaFactor]: 773
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(3042);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(3042);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(32774);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(1, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(1, 1);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 0, 769, 771);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(770, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(770, 1);
              break;
            case SubtractiveBlending:
              gl.blendFunc(0, 769);
              break;
            case MultiplyBlending:
              gl.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = null;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(2884) : enable(2884);
    let flipSided = material.side === BackSide;
    if (frontFaceCW)
      flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true ? enable(32926) : disable(32926);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(2304);
      } else {
        gl.frontFace(2305);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(2884);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(1029);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(1028);
        } else {
          gl.cullFace(1032);
        }
      }
    } else {
      disable(2884);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable)
        gl.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(32823);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(32823);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(3089);
    } else {
      disable(3089);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0)
      webglSlot = 33984 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }
    let boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture === void 0) {
      boundTexture = {type: void 0, texture: void 0};
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function reset() {
    gl.disable(3042);
    gl.disable(2884);
    gl.disable(2929);
    gl.disable(32823);
    gl.disable(3089);
    gl.disable(2960);
    gl.disable(32926);
    gl.blendEquation(32774);
    gl.blendFunc(1, 0);
    gl.blendFuncSeparate(1, 0, 1, 0);
    gl.colorMask(true, true, true, true);
    gl.clearColor(0, 0, 0, 0);
    gl.depthMask(true);
    gl.depthFunc(513);
    gl.clearDepth(1);
    gl.stencilMask(4294967295);
    gl.stencilFunc(519, 0, 4294967295);
    gl.stencilOp(7680, 7680, 7680);
    gl.clearStencil(0);
    gl.cullFace(1029);
    gl.frontFace(2305);
    gl.polygonOffset(0, 0);
    gl.activeTexture(33984);
    gl.bindFramebuffer(36160, null);
    if (isWebGL2 === true) {
      gl.bindFramebuffer(36009, null);
      gl.bindFramebuffer(36008, null);
    }
    gl.useProgram(null);
    gl.lineWidth(1);
    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    xrFramebuffer = null;
    currentBoundFramebuffers = {};
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable,
    disable,
    bindFramebuffer,
    bindXRFramebuffer,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    texImage2D,
    texImage3D,
    scissor,
    viewport,
    reset
  };
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  const isWebGL2 = capabilities.isWebGL2;
  const maxTextures = capabilities.maxTextures;
  const maxCubemapSize = capabilities.maxCubemapSize;
  const maxTextureSize = capabilities.maxTextureSize;
  const maxSamples = capabilities.maxSamples;
  const _videoTextures = new WeakMap();
  let _canvas2;
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {
  }
  function createCanvas(width, height) {
    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  }
  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    let scale = 1;
    if (image.width > maxSize || image.height > maxSize) {
      scale = maxSize / Math.max(image.width, image.height);
    }
    if (scale < 1 || needsPowerOfTwo === true) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        const floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;
        const width = floor(scale * image.width);
        const height = floor(scale * image.height);
        if (_canvas2 === void 0)
          _canvas2 = createCanvas(width, height);
        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0, width, height);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
        return canvas;
      } else {
        if ("data" in image) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
        }
        return image;
      }
    }
    return image;
  }
  function isPowerOfTwo(image) {
    return MathUtils.isPowerOfTwo(image.width) && MathUtils.isPowerOfTwo(image.height);
  }
  function textureNeedsPowerOfTwo(texture) {
    if (isWebGL2)
      return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function generateMipmap(target, texture, width, height) {
    _gl.generateMipmap(target);
    const textureProperties = properties.get(texture);
    textureProperties.__maxMipLevel = Math.log2(Math.max(width, height));
  }
  function getInternalFormat(internalFormatName, glFormat, glType) {
    if (isWebGL2 === false)
      return glFormat;
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0)
        return _gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === 6403) {
      if (glType === 5126)
        internalFormat = 33326;
      if (glType === 5131)
        internalFormat = 33325;
      if (glType === 5121)
        internalFormat = 33321;
    }
    if (glFormat === 6407) {
      if (glType === 5126)
        internalFormat = 34837;
      if (glType === 5131)
        internalFormat = 34843;
      if (glType === 5121)
        internalFormat = 32849;
    }
    if (glFormat === 6408) {
      if (glType === 5126)
        internalFormat = 34836;
      if (glType === 5131)
        internalFormat = 34842;
      if (glType === 5121)
        internalFormat = 32856;
    }
    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  function filterFallback(f2) {
    if (f2 === NearestFilter || f2 === NearestMipmapNearestFilter || f2 === NearestMipmapLinearFilter) {
      return 9728;
    }
    return 9729;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
    info.memory.textures--;
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
    info.memory.textures--;
  }
  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === void 0)
      return;
    _gl.deleteTexture(textureProperties.__webglTexture);
    properties.remove(texture);
  }
  function deallocateRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    if (!renderTarget)
      return;
    if (textureProperties.__webglTexture !== void 0) {
      _gl.deleteTexture(textureProperties.__webglTexture);
    }
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i2 = 0; i2 < 6; i2++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i2]);
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i2]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      if (renderTargetProperties.__webglDepthbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer)
        _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
      if (renderTargetProperties.__webglDepthRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    properties.remove(texture);
    properties.remove(renderTarget);
  }
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= maxTextures) {
      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture)
      updateVideoTexture(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      const image = texture.image;
      if (image === void 0) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
      } else if (image.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(3553, textureProperties.__webglTexture);
  }
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(35866, textureProperties.__webglTexture);
  }
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(32879, textureProperties.__webglTexture);
  }
  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
  }
  const wrappingToGL = {
    [RepeatWrapping]: 10497,
    [ClampToEdgeWrapping]: 33071,
    [MirroredRepeatWrapping]: 33648
  };
  const filterToGL = {
    [NearestFilter]: 9728,
    [NearestMipmapNearestFilter]: 9984,
    [NearestMipmapLinearFilter]: 9986,
    [LinearFilter]: 9729,
    [LinearMipmapNearestFilter]: 9985,
    [LinearMipmapLinearFilter]: 9987
  };
  function setTextureParameters(textureType, texture, supportsMips) {
    if (supportsMips) {
      _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
      _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
      }
      _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
      _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
    } else {
      _gl.texParameteri(textureType, 10242, 33071);
      _gl.texParameteri(textureType, 10243, 33071);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, 33071);
      }
      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
      }
      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
      }
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false)
        return;
      if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false))
        return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      info.memory.textures++;
    }
  }
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = 3553;
    if (texture.isDataTexture2DArray)
      textureType = 35866;
    if (texture.isDataTexture3D)
      textureType = 32879;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(textureType, textureProperties.__webglTexture);
    _gl.pixelStorei(37440, texture.flipY);
    _gl.pixelStorei(37441, texture.premultiplyAlpha);
    _gl.pixelStorei(3317, texture.unpackAlignment);
    _gl.pixelStorei(37443, 0);
    const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
    const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
    const supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format);
    let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    setTextureParameters(textureType, texture, supportsMips);
    let mipmap;
    const mipmaps = texture.mipmaps;
    if (texture.isDepthTexture) {
      glInternalFormat = 6402;
      if (isWebGL2) {
        if (texture.type === FloatType) {
          glInternalFormat = 36012;
        } else if (texture.type === UnsignedIntType) {
          glInternalFormat = 33190;
        } else if (texture.type === UnsignedInt248Type) {
          glInternalFormat = 35056;
        } else {
          glInternalFormat = 33189;
        }
      } else {
        if (texture.type === FloatType) {
          console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
        }
      }
      if (texture.format === DepthFormat && glInternalFormat === 6402) {
        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
          console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
          texture.type = UnsignedShortType;
          glType = utils.convert(texture.type);
        }
      }
      if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
        glInternalFormat = 34041;
        if (texture.type !== UnsignedInt248Type) {
          console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
          texture.type = UnsignedInt248Type;
          glType = utils.convert(texture.type);
        }
      }
      state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
    } else if (texture.isDataTexture) {
      if (mipmaps.length > 0 && supportsMips) {
        for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
          mipmap = mipmaps[i2];
          state.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      }
    } else if (texture.isCompressedTexture) {
      for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
        mipmap = mipmaps[i2];
        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
          if (glFormat !== null) {
            state.compressedTexImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
          } else {
            console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
          }
        } else {
          state.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else if (texture.isDataTexture2DArray) {
      state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else if (texture.isDataTexture3D) {
      state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else {
      if (mipmaps.length > 0 && supportsMips) {
        for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
          mipmap = mipmaps[i2];
          state.texImage2D(3553, i2, glInternalFormat, glFormat, glType, mipmap);
        }
        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
        textureProperties.__maxMipLevel = 0;
      }
    }
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(textureType, texture, image.width, image.height);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate)
      texture.onUpdate(texture);
  }
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6)
      return;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
    _gl.pixelStorei(37440, texture.flipY);
    _gl.pixelStorei(37441, texture.premultiplyAlpha);
    _gl.pixelStorei(3317, texture.unpackAlignment);
    _gl.pixelStorei(37443, 0);
    const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
    const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
    const cubeImage = [];
    for (let i2 = 0; i2 < 6; i2++) {
      if (!isCompressed && !isDataTexture) {
        cubeImage[i2] = resizeImage(texture.image[i2], false, true, maxCubemapSize);
      } else {
        cubeImage[i2] = isDataTexture ? texture.image[i2].image : texture.image[i2];
      }
    }
    const image = cubeImage[0], supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    setTextureParameters(34067, texture, supportsMips);
    let mipmaps;
    if (isCompressed) {
      for (let i2 = 0; i2 < 6; i2++) {
        mipmaps = cubeImage[i2].mipmaps;
        for (let j2 = 0; j2 < mipmaps.length; j2++) {
          const mipmap = mipmaps[j2];
          if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
            if (glFormat !== null) {
              state.compressedTexImage2D(34069 + i2, j2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
            } else {
              console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
            }
          } else {
            state.texImage2D(34069 + i2, j2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else {
      mipmaps = texture.mipmaps;
      for (let i2 = 0; i2 < 6; i2++) {
        if (isDataTexture) {
          state.texImage2D(34069 + i2, 0, glInternalFormat, cubeImage[i2].width, cubeImage[i2].height, 0, glFormat, glType, cubeImage[i2].data);
          for (let j2 = 0; j2 < mipmaps.length; j2++) {
            const mipmap = mipmaps[j2];
            const mipmapImage = mipmap.image[i2].image;
            state.texImage2D(34069 + i2, j2 + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
          }
        } else {
          state.texImage2D(34069 + i2, 0, glInternalFormat, glFormat, glType, cubeImage[i2]);
          for (let j2 = 0; j2 < mipmaps.length; j2++) {
            const mipmap = mipmaps[j2];
            state.texImage2D(34069 + i2, j2 + 1, glInternalFormat, glFormat, glType, mipmap.image[i2]);
          }
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length;
    }
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(34067, texture, image.width, image.height);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate)
      texture.onUpdate(texture);
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
    const texture = renderTarget.texture;
    const glFormat = utils.convert(texture.format);
    const glType = utils.convert(texture.type);
    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    if (textureTarget === 32879 || textureTarget === 35866) {
      state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
    } else {
      state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
    }
    state.bindFramebuffer(36160, framebuffer);
    _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
    state.bindFramebuffer(36160, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(36161, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      let glInternalFormat = 33189;
      if (isMultisample) {
        const depthTexture = renderTarget.depthTexture;
        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          }
        }
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
    } else {
      const texture = renderTarget.texture;
      const glFormat = utils.convert(texture.format);
      const glType = utils.convert(texture.type);
      const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
    }
    _gl.bindRenderbuffer(36161, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube)
      throw new Error("Depth Texture with cube render targets is not supported");
    state.bindFramebuffer(36160, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    if (renderTarget.depthTexture.format === DepthFormat) {
      _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTarget.depthTexture) {
      if (isCube)
        throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i2 = 0; i2 < 6; i2++) {
          state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i2]);
          renderTargetProperties.__webglDepthbuffer[i2] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i2], renderTarget, false);
        }
      } else {
        state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
      }
    }
    state.bindFramebuffer(36160, null);
  }
  function setupRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    textureProperties.__webglTexture = _gl.createTexture();
    textureProperties.__version = texture.version;
    info.memory.textures++;
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
    const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
    const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
    if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {
      texture.format = RGBAFormat;
      console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.");
    }
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i2 = 0; i2 < 6; i2++) {
        renderTargetProperties.__webglFramebuffer[i2] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      if (isMultisample) {
        if (isWebGL2) {
          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
          renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
          const glFormat = utils.convert(texture.format);
          const glType = utils.convert(texture.type);
          const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
          _gl.bindRenderbuffer(36161, null);
          if (renderTarget.depthBuffer) {
            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
          }
          state.bindFramebuffer(36160, null);
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        }
      }
    }
    if (isCube) {
      state.bindTexture(34067, textureProperties.__webglTexture);
      setTextureParameters(34067, texture, supportsMips);
      for (let i2 = 0; i2 < 6; i2++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i2], renderTarget, 36064, 34069 + i2);
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(34067, texture, renderTarget.width, renderTarget.height);
      }
      state.bindTexture(34067, null);
    } else {
      let glTextureType = 3553;
      if (isRenderTarget3D) {
        if (isWebGL2) {
          const isTexture3D = texture.isDataTexture3D;
          glTextureType = isTexture3D ? 32879 : 35866;
        } else {
          console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
        }
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture, supportsMips);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, glTextureType);
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(3553, texture, renderTarget.width, renderTarget.height);
      }
      state.bindTexture(3553, null);
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const texture = renderTarget.texture;
    const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
      const webglTexture = properties.get(texture).__webglTexture;
      state.bindTexture(target, webglTexture);
      generateMipmap(target, texture, renderTarget.width, renderTarget.height);
      state.bindTexture(target, null);
    }
  }
  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.isWebGLMultisampleRenderTarget) {
      if (isWebGL2) {
        const renderTargetProperties = properties.get(renderTarget);
        state.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
        state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
        const width = renderTarget.width;
        const height = renderTarget.height;
        let mask = 16384;
        if (renderTarget.depthBuffer)
          mask |= 256;
        if (renderTarget.stencilBuffer)
          mask |= 1024;
        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
        state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
      } else {
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
      }
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
  }
  function updateVideoTexture(texture) {
    const frame = info.render.frame;
    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);
      texture.update();
    }
  }
  let warnedTexture2D = false;
  let warnedTextureCube = false;
  function safeSetTexture2D(texture, slot) {
    if (texture && texture.isWebGLRenderTarget) {
      if (warnedTexture2D === false) {
        console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
        warnedTexture2D = true;
      }
      texture = texture.texture;
    }
    setTexture2D(texture, slot);
  }
  function safeSetTextureCube(texture, slot) {
    if (texture && texture.isWebGLCubeRenderTarget) {
      if (warnedTextureCube === false) {
        console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
        warnedTextureCube = true;
      }
      texture = texture.texture;
    }
    setTextureCube(texture, slot);
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.safeSetTexture2D = safeSetTexture2D;
  this.safeSetTextureCube = safeSetTextureCube;
}
function WebGLUtils(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function convert(p2) {
    let extension;
    if (p2 === UnsignedByteType)
      return 5121;
    if (p2 === UnsignedShort4444Type)
      return 32819;
    if (p2 === UnsignedShort5551Type)
      return 32820;
    if (p2 === UnsignedShort565Type)
      return 33635;
    if (p2 === ByteType)
      return 5120;
    if (p2 === ShortType)
      return 5122;
    if (p2 === UnsignedShortType)
      return 5123;
    if (p2 === IntType)
      return 5124;
    if (p2 === UnsignedIntType)
      return 5125;
    if (p2 === FloatType)
      return 5126;
    if (p2 === HalfFloatType) {
      if (isWebGL2)
        return 5131;
      extension = extensions.get("OES_texture_half_float");
      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      } else {
        return null;
      }
    }
    if (p2 === AlphaFormat)
      return 6406;
    if (p2 === RGBFormat)
      return 6407;
    if (p2 === RGBAFormat)
      return 6408;
    if (p2 === LuminanceFormat)
      return 6409;
    if (p2 === LuminanceAlphaFormat)
      return 6410;
    if (p2 === DepthFormat)
      return 6402;
    if (p2 === DepthStencilFormat)
      return 34041;
    if (p2 === RedFormat)
      return 6403;
    if (p2 === RedIntegerFormat)
      return 36244;
    if (p2 === RGFormat)
      return 33319;
    if (p2 === RGIntegerFormat)
      return 33320;
    if (p2 === RGBIntegerFormat)
      return 36248;
    if (p2 === RGBAIntegerFormat)
      return 36249;
    if (p2 === RGB_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT3_Format || p2 === RGBA_S3TC_DXT5_Format) {
      extension = extensions.get("WEBGL_compressed_texture_s3tc");
      if (extension !== null) {
        if (p2 === RGB_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (p2 === RGBA_S3TC_DXT1_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (p2 === RGBA_S3TC_DXT3_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (p2 === RGBA_S3TC_DXT5_Format)
          return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else {
        return null;
      }
    }
    if (p2 === RGB_PVRTC_4BPPV1_Format || p2 === RGB_PVRTC_2BPPV1_Format || p2 === RGBA_PVRTC_4BPPV1_Format || p2 === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p2 === RGB_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p2 === RGB_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p2 === RGBA_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p2 === RGBA_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p2 === RGB_ETC1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc1");
      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    }
    if (p2 === RGB_ETC2_Format || p2 === RGBA_ETC2_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p2 === RGB_ETC2_Format)
          return extension.COMPRESSED_RGB8_ETC2;
        if (p2 === RGBA_ETC2_EAC_Format)
          return extension.COMPRESSED_RGBA8_ETC2_EAC;
      }
    }
    if (p2 === RGBA_ASTC_4x4_Format || p2 === RGBA_ASTC_5x4_Format || p2 === RGBA_ASTC_5x5_Format || p2 === RGBA_ASTC_6x5_Format || p2 === RGBA_ASTC_6x6_Format || p2 === RGBA_ASTC_8x5_Format || p2 === RGBA_ASTC_8x6_Format || p2 === RGBA_ASTC_8x8_Format || p2 === RGBA_ASTC_10x5_Format || p2 === RGBA_ASTC_10x6_Format || p2 === RGBA_ASTC_10x8_Format || p2 === RGBA_ASTC_10x10_Format || p2 === RGBA_ASTC_12x10_Format || p2 === RGBA_ASTC_12x12_Format || p2 === SRGB8_ALPHA8_ASTC_4x4_Format || p2 === SRGB8_ALPHA8_ASTC_5x4_Format || p2 === SRGB8_ALPHA8_ASTC_5x5_Format || p2 === SRGB8_ALPHA8_ASTC_6x5_Format || p2 === SRGB8_ALPHA8_ASTC_6x6_Format || p2 === SRGB8_ALPHA8_ASTC_8x5_Format || p2 === SRGB8_ALPHA8_ASTC_8x6_Format || p2 === SRGB8_ALPHA8_ASTC_8x8_Format || p2 === SRGB8_ALPHA8_ASTC_10x5_Format || p2 === SRGB8_ALPHA8_ASTC_10x6_Format || p2 === SRGB8_ALPHA8_ASTC_10x8_Format || p2 === SRGB8_ALPHA8_ASTC_10x10_Format || p2 === SRGB8_ALPHA8_ASTC_12x10_Format || p2 === SRGB8_ALPHA8_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        return p2;
      } else {
        return null;
      }
    }
    if (p2 === RGBA_BPTC_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        return p2;
      } else {
        return null;
      }
    }
    if (p2 === UnsignedInt248Type) {
      if (isWebGL2)
        return 34042;
      extension = extensions.get("WEBGL_depth_texture");
      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      } else {
        return null;
      }
    }
  }
  return {convert};
}
class ArrayCamera extends PerspectiveCamera {
  constructor(array = []) {
    super();
    this.cameras = array;
  }
}
ArrayCamera.prototype.isArrayCamera = true;
class Group extends Object3D {
  constructor() {
    super();
    this.type = "Group";
  }
}
Group.prototype.isGroup = true;
function WebXRController() {
  this._targetRay = null;
  this._grip = null;
  this._hand = null;
}
Object.assign(WebXRController.prototype, {
  constructor: WebXRController,
  getHandSpace: function() {
    if (this._hand === null) {
      this._hand = new Group();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = {pinching: false};
    }
    return this._hand;
  },
  getTargetRaySpace: function() {
    if (this._targetRay === null) {
      this._targetRay = new Group();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
    }
    return this._targetRay;
  },
  getGripSpace: function() {
    if (this._grip === null) {
      this._grip = new Group();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
    }
    return this._grip;
  },
  dispatchEvent: function(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }
    return this;
  },
  disconnect: function(inputSource) {
    this.dispatchEvent({type: "disconnected", data: inputSource});
    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }
    if (this._grip !== null) {
      this._grip.visible = false;
    }
    if (this._hand !== null) {
      this._hand.visible = false;
    }
    return this;
  },
  update: function(inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand = this._hand;
    if (inputSource && frame.session.visibilityState !== "visible-blurred") {
      if (targetRay !== null) {
        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
        if (inputPose !== null) {
          targetRay.matrix.fromArray(inputPose.transform.matrix);
          targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
        }
      }
      if (hand && inputSource.hand) {
        handPose = true;
        for (const inputjoint of inputSource.hand.values()) {
          const jointPose = frame.getJointPose(inputjoint, referenceSpace);
          if (hand.joints[inputjoint.jointName] === void 0) {
            const joint2 = new Group();
            joint2.matrixAutoUpdate = false;
            joint2.visible = false;
            hand.joints[inputjoint.jointName] = joint2;
            hand.add(joint2);
          }
          const joint = hand.joints[inputjoint.jointName];
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.jointRadius = jointPose.radius;
          }
          joint.visible = jointPose !== null;
        }
        const indexTip = hand.joints["index-finger-tip"];
        const thumbTip = hand.joints["thumb-tip"];
        const distance = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold = 5e-3;
        if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
          hand.inputState.pinching = false;
          this.dispatchEvent({
            type: "pinchend",
            handedness: inputSource.handedness,
            target: this
          });
        } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
          hand.inputState.pinching = true;
          this.dispatchEvent({
            type: "pinchstart",
            handedness: inputSource.handedness,
            target: this
          });
        }
      } else {
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
          }
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }
    if (grip !== null) {
      grip.visible = gripPose !== null;
    }
    if (hand !== null) {
      hand.visible = handPose !== null;
    }
    return this;
  }
});
function WebXRManager(renderer, gl) {
  const scope = this;
  const state = renderer.state;
  let session = null;
  let framebufferScaleFactor = 1;
  let referenceSpace = null;
  let referenceSpaceType = "local-floor";
  let pose = null;
  const controllers = [];
  const inputSourcesMap = new Map();
  const cameraL = new PerspectiveCamera();
  cameraL.layers.enable(1);
  cameraL.viewport = new Vector4();
  const cameraR = new PerspectiveCamera();
  cameraR.layers.enable(2);
  cameraR.viewport = new Vector4();
  const cameras = [cameraL, cameraR];
  const cameraVR = new ArrayCamera();
  cameraVR.layers.enable(1);
  cameraVR.layers.enable(2);
  let _currentDepthNear = null;
  let _currentDepthFar = null;
  this.enabled = false;
  this.isPresenting = false;
  this.getController = function(index) {
    let controller = controllers[index];
    if (controller === void 0) {
      controller = new WebXRController();
      controllers[index] = controller;
    }
    return controller.getTargetRaySpace();
  };
  this.getControllerGrip = function(index) {
    let controller = controllers[index];
    if (controller === void 0) {
      controller = new WebXRController();
      controllers[index] = controller;
    }
    return controller.getGripSpace();
  };
  this.getHand = function(index) {
    let controller = controllers[index];
    if (controller === void 0) {
      controller = new WebXRController();
      controllers[index] = controller;
    }
    return controller.getHandSpace();
  };
  function onSessionEvent(event) {
    const controller = inputSourcesMap.get(event.inputSource);
    if (controller) {
      controller.dispatchEvent({type: event.type, data: event.inputSource});
    }
  }
  function onSessionEnd() {
    inputSourcesMap.forEach(function(controller, inputSource) {
      controller.disconnect(inputSource);
    });
    inputSourcesMap.clear();
    _currentDepthNear = null;
    _currentDepthFar = null;
    state.bindXRFramebuffer(null);
    renderer.setRenderTarget(renderer.getRenderTarget());
    animation.stop();
    scope.isPresenting = false;
    scope.dispatchEvent({type: "sessionend"});
  }
  this.setFramebufferScaleFactor = function(value) {
    framebufferScaleFactor = value;
    if (scope.isPresenting === true) {
      console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }
  };
  this.setReferenceSpaceType = function(value) {
    referenceSpaceType = value;
    if (scope.isPresenting === true) {
      console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }
  };
  this.getReferenceSpace = function() {
    return referenceSpace;
  };
  this.getSession = function() {
    return session;
  };
  this.setSession = async function(value) {
    session = value;
    if (session !== null) {
      session.addEventListener("select", onSessionEvent);
      session.addEventListener("selectstart", onSessionEvent);
      session.addEventListener("selectend", onSessionEvent);
      session.addEventListener("squeeze", onSessionEvent);
      session.addEventListener("squeezestart", onSessionEvent);
      session.addEventListener("squeezeend", onSessionEvent);
      session.addEventListener("end", onSessionEnd);
      session.addEventListener("inputsourceschange", onInputSourcesChange);
      const attributes = gl.getContextAttributes();
      if (attributes.xrCompatible !== true) {
        await gl.makeXRCompatible();
      }
      const layerInit = {
        antialias: attributes.antialias,
        alpha: attributes.alpha,
        depth: attributes.depth,
        stencil: attributes.stencil,
        framebufferScaleFactor
      };
      const baseLayer = new XRWebGLLayer(session, gl, layerInit);
      session.updateRenderState({baseLayer});
      referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
      animation.setContext(session);
      animation.start();
      scope.isPresenting = true;
      scope.dispatchEvent({type: "sessionstart"});
    }
  };
  function onInputSourcesChange(event) {
    const inputSources = session.inputSources;
    for (let i2 = 0; i2 < controllers.length; i2++) {
      inputSourcesMap.set(inputSources[i2], controllers[i2]);
    }
    for (let i2 = 0; i2 < event.removed.length; i2++) {
      const inputSource = event.removed[i2];
      const controller = inputSourcesMap.get(inputSource);
      if (controller) {
        controller.dispatchEvent({type: "disconnected", data: inputSource});
        inputSourcesMap.delete(inputSource);
      }
    }
    for (let i2 = 0; i2 < event.added.length; i2++) {
      const inputSource = event.added[i2];
      const controller = inputSourcesMap.get(inputSource);
      if (controller) {
        controller.dispatchEvent({type: "connected", data: inputSource});
      }
    }
  }
  const cameraLPos = new Vector3();
  const cameraRPos = new Vector3();
  function setProjectionFromUnion(camera, cameraL2, cameraR2) {
    cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
    cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
    const ipd = cameraLPos.distanceTo(cameraRPos);
    const projL = cameraL2.projectionMatrix.elements;
    const projR = cameraR2.projectionMatrix.elements;
    const near = projL[14] / (projL[10] - 1);
    const far = projL[14] / (projL[10] + 1);
    const topFov = (projL[9] + 1) / projL[5];
    const bottomFov = (projL[9] - 1) / projL[5];
    const leftFov = (projL[8] - 1) / projL[0];
    const rightFov = (projR[8] + 1) / projR[0];
    const left = near * leftFov;
    const right = near * rightFov;
    const zOffset = ipd / (-leftFov + rightFov);
    const xOffset = zOffset * -leftFov;
    cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
    camera.translateX(xOffset);
    camera.translateZ(zOffset);
    camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
    camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    const near2 = near + zOffset;
    const far2 = far + zOffset;
    const left2 = left - xOffset;
    const right2 = right + (ipd - xOffset);
    const top2 = topFov * far / far2 * near2;
    const bottom2 = bottomFov * far / far2 * near2;
    camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
  }
  function updateCamera(camera, parent) {
    if (parent === null) {
      camera.matrixWorld.copy(camera.matrix);
    } else {
      camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
    }
    camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
  }
  this.getCamera = function(camera) {
    cameraVR.near = cameraR.near = cameraL.near = camera.near;
    cameraVR.far = cameraR.far = cameraL.far = camera.far;
    if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
      session.updateRenderState({
        depthNear: cameraVR.near,
        depthFar: cameraVR.far
      });
      _currentDepthNear = cameraVR.near;
      _currentDepthFar = cameraVR.far;
    }
    const parent = camera.parent;
    const cameras2 = cameraVR.cameras;
    updateCamera(cameraVR, parent);
    for (let i2 = 0; i2 < cameras2.length; i2++) {
      updateCamera(cameras2[i2], parent);
    }
    camera.matrixWorld.copy(cameraVR.matrixWorld);
    camera.matrix.copy(cameraVR.matrix);
    camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
    const children = camera.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      children[i2].updateMatrixWorld(true);
    }
    if (cameras2.length === 2) {
      setProjectionFromUnion(cameraVR, cameraL, cameraR);
    } else {
      cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
    }
    return cameraVR;
  };
  let onAnimationFrameCallback = null;
  function onAnimationFrame(time, frame) {
    pose = frame.getViewerPose(referenceSpace);
    if (pose !== null) {
      const views = pose.views;
      const baseLayer = session.renderState.baseLayer;
      state.bindXRFramebuffer(baseLayer.framebuffer);
      let cameraVRNeedsUpdate = false;
      if (views.length !== cameraVR.cameras.length) {
        cameraVR.cameras.length = 0;
        cameraVRNeedsUpdate = true;
      }
      for (let i2 = 0; i2 < views.length; i2++) {
        const view = views[i2];
        const viewport = baseLayer.getViewport(view);
        const camera = cameras[i2];
        camera.matrix.fromArray(view.transform.matrix);
        camera.projectionMatrix.fromArray(view.projectionMatrix);
        camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
        if (i2 === 0) {
          cameraVR.matrix.copy(camera.matrix);
        }
        if (cameraVRNeedsUpdate === true) {
          cameraVR.cameras.push(camera);
        }
      }
    }
    const inputSources = session.inputSources;
    for (let i2 = 0; i2 < controllers.length; i2++) {
      const controller = controllers[i2];
      const inputSource = inputSources[i2];
      controller.update(inputSource, frame, referenceSpace);
    }
    if (onAnimationFrameCallback)
      onAnimationFrameCallback(time, frame);
  }
  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
  };
  this.dispose = function() {
  };
}
Object.assign(WebXRManager.prototype, EventDispatcher.prototype);
function WebGLMaterials(properties) {
  function refreshFogUniforms(uniforms, fog) {
    uniforms.fogColor.value.copy(fog.color);
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material, pixelRatio, height) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsLambert(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material);
      } else {
        refreshUniformsStandard(uniforms, material);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDepth(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsNormal(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false;
    }
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMap.value = envMap;
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap._needsFlipEnvMap ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.refractionRatio.value = material.refractionRatio;
      const maxMipLevel = properties.get(envMap).__maxMipLevel;
      if (maxMipLevel !== void 0) {
        uniforms.maxMipLevel.value = maxMipLevel;
      }
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    } else if (material.clearcoatMap) {
      uvScaleMap = material.clearcoatMap;
    } else if (material.clearcoatNormalMap) {
      uvScaleMap = material.clearcoatNormalMap;
    } else if (material.clearcoatRoughnessMap) {
      uvScaleMap = material.clearcoatRoughnessMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
    let uv2ScaleMap;
    if (material.aoMap) {
      uv2ScaleMap = material.aoMap;
    } else if (material.lightMap) {
      uv2ScaleMap = material.lightMap;
    }
    if (uv2ScaleMap !== void 0) {
      if (uv2ScaleMap.isWebGLRenderTarget) {
        uv2ScaleMap = uv2ScaleMap.texture;
      }
      if (uv2ScaleMap.matrixAutoUpdate === true) {
        uv2ScaleMap.updateMatrix();
      }
      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsLambert(uniforms, material) {
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material) {
    refreshUniformsStandard(uniforms, material);
    uniforms.reflectivity.value = material.reflectivity;
    uniforms.clearcoat.value = material.clearcoat;
    uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
    if (material.sheen)
      uniforms.sheen.value.copy(material.sheen);
    if (material.clearcoatMap) {
      uniforms.clearcoatMap.value = material.clearcoatMap;
    }
    if (material.clearcoatRoughnessMap) {
      uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
    }
    if (material.clearcoatNormalMap) {
      uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
      uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
      if (material.side === BackSide) {
        uniforms.clearcoatNormalScale.value.negate();
      }
    }
    uniforms.transmission.value = material.transmission;
    if (material.transmissionMap) {
      uniforms.transmissionMap.value = material.transmissionMap;
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDepth(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    uniforms.referencePosition.value.copy(material.referencePosition);
    uniforms.nearDistance.value = material.nearDistance;
    uniforms.farDistance.value = material.farDistance;
  }
  function refreshUniformsNormal(uniforms, material) {
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms
  };
}
function createCanvasElement() {
  const canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  canvas.style.display = "block";
  return canvas;
}
function WebGLRenderer(parameters) {
  parameters = parameters || {};
  const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context2 = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
  let currentRenderList = null;
  let currentRenderState = null;
  const renderListStack = [];
  const renderStateStack = [];
  this.domElement = _canvas2;
  this.debug = {
    checkShaderErrors: true
  };
  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;
  this.sortObjects = true;
  this.clippingPlanes = [];
  this.localClippingEnabled = false;
  this.gammaFactor = 2;
  this.outputEncoding = LinearEncoding;
  this.physicallyCorrectLights = false;
  this.toneMapping = NoToneMapping;
  this.toneMappingExposure = 1;
  const _this = this;
  let _isContextLost = false;
  let _currentActiveCubeFace = 0;
  let _currentActiveMipmapLevel = 0;
  let _currentRenderTarget = null;
  let _currentMaterialId = -1;
  let _currentCamera = null;
  const _currentViewport = new Vector4();
  const _currentScissor = new Vector4();
  let _currentScissorTest = null;
  let _width = _canvas2.width;
  let _height = _canvas2.height;
  let _pixelRatio = 1;
  let _opaqueSort = null;
  let _transparentSort = null;
  const _viewport = new Vector4(0, 0, _width, _height);
  const _scissor = new Vector4(0, 0, _width, _height);
  let _scissorTest = false;
  const _frustum = new Frustum();
  let _clippingEnabled = false;
  let _localClippingEnabled = false;
  const _projScreenMatrix2 = new Matrix4();
  const _vector3 = new Vector3();
  const _emptyScene = {background: null, fog: null, environment: null, overrideMaterial: null, isScene: true};
  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  }
  let _gl = _context2;
  function getContext(contextNames, contextAttributes) {
    for (let i2 = 0; i2 < contextNames.length; i2++) {
      const contextName = contextNames[i2];
      const context = _canvas2.getContext(contextName, contextAttributes);
      if (context !== null)
        return context;
    }
    return null;
  }
  try {
    const contextAttributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference,
      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
    };
    _canvas2.addEventListener("webglcontextlost", onContextLost, false);
    _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
    if (_gl === null) {
      const contextNames = ["webgl2", "webgl", "experimental-webgl"];
      if (_this.isWebGL1Renderer === true) {
        contextNames.shift();
      }
      _gl = getContext(contextNames, contextAttributes);
      if (_gl === null) {
        if (getContext(contextNames)) {
          throw new Error("Error creating WebGL context with your selected attributes.");
        } else {
          throw new Error("Error creating WebGL context.");
        }
      }
    }
    if (_gl.getShaderPrecisionFormat === void 0) {
      _gl.getShaderPrecisionFormat = function() {
        return {rangeMin: 1, rangeMax: 1, precision: 1};
      };
    }
  } catch (error) {
    console.error("THREE.WebGLRenderer: " + error.message);
    throw error;
  }
  let extensions, capabilities, state, info;
  let properties, textures, cubemaps, attributes, geometries, objects;
  let programCache, materials, renderLists, renderStates, clipping, shadowMap;
  let background, morphtargets, bufferRenderer, indexedBufferRenderer;
  let utils, bindingStates;
  function initGLContext() {
    extensions = new WebGLExtensions(_gl);
    capabilities = new WebGLCapabilities(_gl, extensions, parameters);
    extensions.init(capabilities);
    utils = new WebGLUtils(_gl, extensions, capabilities);
    state = new WebGLState(_gl, extensions, capabilities);
    info = new WebGLInfo(_gl);
    properties = new WebGLProperties();
    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
    cubemaps = new WebGLCubeMaps(_this);
    attributes = new WebGLAttributes(_gl, capabilities);
    bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
    objects = new WebGLObjects(_gl, geometries, attributes, info);
    morphtargets = new WebGLMorphtargets(_gl);
    clipping = new WebGLClipping(properties);
    programCache = new WebGLPrograms(_this, cubemaps, extensions, capabilities, bindingStates, clipping);
    materials = new WebGLMaterials(properties);
    renderLists = new WebGLRenderLists(properties);
    renderStates = new WebGLRenderStates(extensions, capabilities);
    background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
    shadowMap = new WebGLShadowMap(_this, objects, capabilities);
    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
    info.programs = programCache.programs;
    _this.capabilities = capabilities;
    _this.extensions = extensions;
    _this.properties = properties;
    _this.renderLists = renderLists;
    _this.shadowMap = shadowMap;
    _this.state = state;
    _this.info = info;
  }
  initGLContext();
  const xr = new WebXRManager(_this, _gl);
  this.xr = xr;
  this.getContext = function() {
    return _gl;
  };
  this.getContextAttributes = function() {
    return _gl.getContextAttributes();
  };
  this.forceContextLoss = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.loseContext();
  };
  this.forceContextRestore = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.restoreContext();
  };
  this.getPixelRatio = function() {
    return _pixelRatio;
  };
  this.setPixelRatio = function(value) {
    if (value === void 0)
      return;
    _pixelRatio = value;
    this.setSize(_width, _height, false);
  };
  this.getSize = function(target) {
    if (target === void 0) {
      console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument");
      target = new Vector2();
    }
    return target.set(_width, _height);
  };
  this.setSize = function(width, height, updateStyle) {
    if (xr.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    _width = width;
    _height = height;
    _canvas2.width = Math.floor(width * _pixelRatio);
    _canvas2.height = Math.floor(height * _pixelRatio);
    if (updateStyle !== false) {
      _canvas2.style.width = width + "px";
      _canvas2.style.height = height + "px";
    }
    this.setViewport(0, 0, width, height);
  };
  this.getDrawingBufferSize = function(target) {
    if (target === void 0) {
      console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument");
      target = new Vector2();
    }
    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
  };
  this.setDrawingBufferSize = function(width, height, pixelRatio) {
    _width = width;
    _height = height;
    _pixelRatio = pixelRatio;
    _canvas2.width = Math.floor(width * pixelRatio);
    _canvas2.height = Math.floor(height * pixelRatio);
    this.setViewport(0, 0, width, height);
  };
  this.getCurrentViewport = function(target) {
    if (target === void 0) {
      console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument");
      target = new Vector4();
    }
    return target.copy(_currentViewport);
  };
  this.getViewport = function(target) {
    return target.copy(_viewport);
  };
  this.setViewport = function(x2, y2, width, height) {
    if (x2.isVector4) {
      _viewport.set(x2.x, x2.y, x2.z, x2.w);
    } else {
      _viewport.set(x2, y2, width, height);
    }
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissor = function(target) {
    return target.copy(_scissor);
  };
  this.setScissor = function(x2, y2, width, height) {
    if (x2.isVector4) {
      _scissor.set(x2.x, x2.y, x2.z, x2.w);
    } else {
      _scissor.set(x2, y2, width, height);
    }
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissorTest = function() {
    return _scissorTest;
  };
  this.setScissorTest = function(boolean) {
    state.setScissorTest(_scissorTest = boolean);
  };
  this.setOpaqueSort = function(method) {
    _opaqueSort = method;
  };
  this.setTransparentSort = function(method) {
    _transparentSort = method;
  };
  this.getClearColor = function(target) {
    if (target === void 0) {
      console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument");
      target = new Color();
    }
    return target.copy(background.getClearColor());
  };
  this.setClearColor = function() {
    background.setClearColor.apply(background, arguments);
  };
  this.getClearAlpha = function() {
    return background.getClearAlpha();
  };
  this.setClearAlpha = function() {
    background.setClearAlpha.apply(background, arguments);
  };
  this.clear = function(color, depth, stencil) {
    let bits = 0;
    if (color === void 0 || color)
      bits |= 16384;
    if (depth === void 0 || depth)
      bits |= 256;
    if (stencil === void 0 || stencil)
      bits |= 1024;
    _gl.clear(bits);
  };
  this.clearColor = function() {
    this.clear(true, false, false);
  };
  this.clearDepth = function() {
    this.clear(false, true, false);
  };
  this.clearStencil = function() {
    this.clear(false, false, true);
  };
  this.dispose = function() {
    _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
    _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
    renderLists.dispose();
    renderStates.dispose();
    properties.dispose();
    cubemaps.dispose();
    objects.dispose();
    bindingStates.dispose();
    xr.dispose();
    xr.removeEventListener("sessionstart", onXRSessionStart);
    xr.removeEventListener("sessionend", onXRSessionEnd);
    animation.stop();
  };
  function onContextLost(event) {
    event.preventDefault();
    console.log("THREE.WebGLRenderer: Context Lost.");
    _isContextLost = true;
  }
  function onContextRestore() {
    console.log("THREE.WebGLRenderer: Context Restored.");
    _isContextLost = false;
    const infoAutoReset = info.autoReset;
    const shadowMapEnabled = shadowMap.enabled;
    const shadowMapAutoUpdate = shadowMap.autoUpdate;
    const shadowMapNeedsUpdate = shadowMap.needsUpdate;
    const shadowMapType = shadowMap.type;
    initGLContext();
    info.autoReset = infoAutoReset;
    shadowMap.enabled = shadowMapEnabled;
    shadowMap.autoUpdate = shadowMapAutoUpdate;
    shadowMap.needsUpdate = shadowMapNeedsUpdate;
    shadowMap.type = shadowMapType;
  }
  function onMaterialDispose(event) {
    const material = event.target;
    material.removeEventListener("dispose", onMaterialDispose);
    deallocateMaterial(material);
  }
  function deallocateMaterial(material) {
    releaseMaterialProgramReferences(material);
    properties.remove(material);
  }
  function releaseMaterialProgramReferences(material) {
    const programs = properties.get(material).programs;
    if (programs !== void 0) {
      programs.forEach(function(program) {
        programCache.releaseProgram(program);
      });
    }
  }
  function renderObjectImmediate(object, program) {
    object.render(function(object2) {
      _this.renderBufferImmediate(object2, program);
    });
  }
  this.renderBufferImmediate = function(object, program) {
    bindingStates.initAttributes();
    const buffers = properties.get(object);
    if (object.hasPositions && !buffers.position)
      buffers.position = _gl.createBuffer();
    if (object.hasNormals && !buffers.normal)
      buffers.normal = _gl.createBuffer();
    if (object.hasUvs && !buffers.uv)
      buffers.uv = _gl.createBuffer();
    if (object.hasColors && !buffers.color)
      buffers.color = _gl.createBuffer();
    const programAttributes = program.getAttributes();
    if (object.hasPositions) {
      _gl.bindBuffer(34962, buffers.position);
      _gl.bufferData(34962, object.positionArray, 35048);
      bindingStates.enableAttribute(programAttributes.position);
      _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
    }
    if (object.hasNormals) {
      _gl.bindBuffer(34962, buffers.normal);
      _gl.bufferData(34962, object.normalArray, 35048);
      bindingStates.enableAttribute(programAttributes.normal);
      _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
    }
    if (object.hasUvs) {
      _gl.bindBuffer(34962, buffers.uv);
      _gl.bufferData(34962, object.uvArray, 35048);
      bindingStates.enableAttribute(programAttributes.uv);
      _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
    }
    if (object.hasColors) {
      _gl.bindBuffer(34962, buffers.color);
      _gl.bufferData(34962, object.colorArray, 35048);
      bindingStates.enableAttribute(programAttributes.color);
      _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
    }
    bindingStates.disableUnusedAttributes();
    _gl.drawArrays(4, 0, object.count);
    object.count = 0;
  };
  this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
    if (scene === null)
      scene = _emptyScene;
    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
    const program = setProgram(camera, scene, material, object);
    state.setMaterial(material, frontFaceCW);
    let index = geometry.index;
    const position = geometry.attributes.position;
    if (index === null) {
      if (position === void 0 || position.count === 0)
        return;
    } else if (index.count === 0) {
      return;
    }
    let rangeFactor = 1;
    if (material.wireframe === true) {
      index = geometries.getWireframeAttribute(geometry);
      rangeFactor = 2;
    }
    if (material.morphTargets || material.morphNormals) {
      morphtargets.update(object, geometry, material, program);
    }
    bindingStates.setup(object, material, program, geometry, index);
    let attribute;
    let renderer = bufferRenderer;
    if (index !== null) {
      attribute = attributes.get(index);
      renderer = indexedBufferRenderer;
      renderer.setIndex(attribute);
    }
    const dataCount = index !== null ? index.count : position.count;
    const rangeStart = geometry.drawRange.start * rangeFactor;
    const rangeCount = geometry.drawRange.count * rangeFactor;
    const groupStart = group !== null ? group.start * rangeFactor : 0;
    const groupCount = group !== null ? group.count * rangeFactor : Infinity;
    const drawStart = Math.max(rangeStart, groupStart);
    const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    const drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0)
      return;
    if (object.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer.setMode(1);
      } else {
        renderer.setMode(4);
      }
    } else if (object.isLine) {
      let lineWidth = material.linewidth;
      if (lineWidth === void 0)
        lineWidth = 1;
      state.setLineWidth(lineWidth * getTargetPixelRatio());
      if (object.isLineSegments) {
        renderer.setMode(1);
      } else if (object.isLineLoop) {
        renderer.setMode(2);
      } else {
        renderer.setMode(3);
      }
    } else if (object.isPoints) {
      renderer.setMode(0);
    } else if (object.isSprite) {
      renderer.setMode(4);
    }
    if (object.isInstancedMesh) {
      renderer.renderInstances(drawStart, drawCount, object.count);
    } else if (geometry.isInstancedBufferGeometry) {
      const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
      renderer.renderInstances(drawStart, drawCount, instanceCount);
    } else {
      renderer.render(drawStart, drawCount);
    }
  };
  this.compile = function(scene, camera) {
    currentRenderState = renderStates.get(scene);
    currentRenderState.init();
    scene.traverseVisible(function(object) {
      if (object.isLight && object.layers.test(camera.layers)) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      }
    });
    currentRenderState.setupLights();
    scene.traverse(function(object) {
      const material = object.material;
      if (material) {
        if (Array.isArray(material)) {
          for (let i2 = 0; i2 < material.length; i2++) {
            const material2 = material[i2];
            getProgram(material2, scene, object);
          }
        } else {
          getProgram(material, scene, object);
        }
      }
    });
  };
  let onAnimationFrameCallback = null;
  function onAnimationFrame(time) {
    if (onAnimationFrameCallback)
      onAnimationFrameCallback(time);
  }
  function onXRSessionStart() {
    animation.stop();
  }
  function onXRSessionEnd() {
    animation.start();
  }
  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  if (typeof window !== "undefined")
    animation.setContext(window);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
    xr.setAnimationLoop(callback);
    callback === null ? animation.stop() : animation.start();
  };
  xr.addEventListener("sessionstart", onXRSessionStart);
  xr.addEventListener("sessionend", onXRSessionEnd);
  this.render = function(scene, camera) {
    let renderTarget, forceClear;
    if (arguments[2] !== void 0) {
      console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
      renderTarget = arguments[2];
    }
    if (arguments[3] !== void 0) {
      console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
      forceClear = arguments[3];
    }
    if (camera !== void 0 && camera.isCamera !== true) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (_isContextLost === true)
      return;
    if (scene.autoUpdate === true)
      scene.updateMatrixWorld();
    if (camera.parent === null)
      camera.updateMatrixWorld();
    if (xr.enabled === true && xr.isPresenting === true) {
      camera = xr.getCamera(camera);
    }
    if (scene.isScene === true)
      scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);
    currentRenderState = renderStates.get(scene, renderStateStack.length);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);
    _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromProjectionMatrix(_projScreenMatrix2);
    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
    currentRenderList = renderLists.get(scene, renderListStack.length);
    currentRenderList.init();
    renderListStack.push(currentRenderList);
    projectObject(scene, camera, 0, _this.sortObjects);
    currentRenderList.finish();
    if (_this.sortObjects === true) {
      currentRenderList.sort(_opaqueSort, _transparentSort);
    }
    if (_clippingEnabled === true)
      clipping.beginShadows();
    const shadowsArray = currentRenderState.state.shadowsArray;
    shadowMap.render(shadowsArray, scene, camera);
    currentRenderState.setupLights();
    currentRenderState.setupLightsView(camera);
    if (_clippingEnabled === true)
      clipping.endShadows();
    if (this.info.autoReset === true)
      this.info.reset();
    if (renderTarget !== void 0) {
      this.setRenderTarget(renderTarget);
    }
    background.render(currentRenderList, scene, camera, forceClear);
    const opaqueObjects = currentRenderList.opaque;
    const transparentObjects = currentRenderList.transparent;
    if (opaqueObjects.length > 0)
      renderObjects(opaqueObjects, scene, camera);
    if (transparentObjects.length > 0)
      renderObjects(transparentObjects, scene, camera);
    if (_currentRenderTarget !== null) {
      textures.updateRenderTargetMipmap(_currentRenderTarget);
      textures.updateMultisampleRenderTarget(_currentRenderTarget);
    }
    if (scene.isScene === true)
      scene.onAfterRender(_this, scene, camera);
    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    state.setPolygonOffset(false);
    bindingStates.resetDefaultState();
    _currentMaterialId = -1;
    _currentCamera = null;
    renderStateStack.pop();
    if (renderStateStack.length > 0) {
      currentRenderState = renderStateStack[renderStateStack.length - 1];
    } else {
      currentRenderState = null;
    }
    renderListStack.pop();
    if (renderListStack.length > 0) {
      currentRenderList = renderListStack[renderListStack.length - 1];
    } else {
      currentRenderList = null;
    }
  };
  function projectObject(object, camera, groupOrder, sortObjects) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
      } else if (object.isLOD) {
        if (object.autoUpdate === true)
          object.update(camera);
      } else if (object.isLight) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry = objects.update(object);
          const material = object.material;
          if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      } else if (object.isImmediateRenderObject) {
        if (sortObjects) {
          _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
        }
        currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (object.isSkinnedMesh) {
          if (object.skeleton.frame !== info.render.frame) {
            object.skeleton.update();
            object.skeleton.frame = info.render.frame;
          }
        }
        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry = objects.update(object);
          const material = object.material;
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
              const group = groups[i2];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      }
    }
    const children = object.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      projectObject(children[i2], camera, groupOrder, sortObjects);
    }
  }
  function renderObjects(renderList, scene, camera) {
    const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
    for (let i2 = 0, l2 = renderList.length; i2 < l2; i2++) {
      const renderItem = renderList[i2];
      const object = renderItem.object;
      const geometry = renderItem.geometry;
      const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
      const group = renderItem.group;
      if (camera.isArrayCamera) {
        const cameras = camera.cameras;
        for (let j2 = 0, jl = cameras.length; j2 < jl; j2++) {
          const camera2 = cameras[j2];
          if (object.layers.test(camera2.layers)) {
            state.viewport(_currentViewport.copy(camera2.viewport));
            currentRenderState.setupLightsView(camera2);
            renderObject(object, scene, camera2, geometry, material, group);
          }
        }
      } else {
        renderObject(object, scene, camera, geometry, material, group);
      }
    }
  }
  function renderObject(object, scene, camera, geometry, material, group) {
    object.onBeforeRender(_this, scene, camera, geometry, material, group);
    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
    if (object.isImmediateRenderObject) {
      const program = setProgram(camera, scene, material, object);
      state.setMaterial(material);
      bindingStates.reset();
      renderObjectImmediate(object, program);
    } else {
      _this.renderBufferDirect(camera, scene, geometry, material, object, group);
    }
    object.onAfterRender(_this, scene, camera, geometry, material, group);
  }
  function getProgram(material, scene, object) {
    if (scene.isScene !== true)
      scene = _emptyScene;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    const shadowsArray = currentRenderState.state.shadowsArray;
    const lightsStateVersion = lights.state.version;
    const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
    const programCacheKey = programCache.getProgramCacheKey(parameters2);
    let programs = materialProperties.programs;
    materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
    materialProperties.fog = scene.fog;
    materialProperties.envMap = cubemaps.get(material.envMap || materialProperties.environment);
    if (programs === void 0) {
      material.addEventListener("dispose", onMaterialDispose);
      programs = new Map();
      materialProperties.programs = programs;
    }
    let program = programs.get(programCacheKey);
    if (program !== void 0) {
      if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
        updateCommonMaterialProperties(material, parameters2);
        return program;
      }
    } else {
      parameters2.uniforms = programCache.getUniforms(material);
      material.onBeforeCompile(parameters2, _this);
      program = programCache.acquireProgram(parameters2, programCacheKey);
      programs.set(programCacheKey, program);
      materialProperties.uniforms = parameters2.uniforms;
    }
    const uniforms = materialProperties.uniforms;
    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
      uniforms.clippingPlanes = clipping.uniform;
    }
    updateCommonMaterialProperties(material, parameters2);
    materialProperties.needsLights = materialNeedsLights(material);
    materialProperties.lightsStateVersion = lightsStateVersion;
    if (materialProperties.needsLights) {
      uniforms.ambientLightColor.value = lights.state.ambient;
      uniforms.lightProbe.value = lights.state.probe;
      uniforms.directionalLights.value = lights.state.directional;
      uniforms.directionalLightShadows.value = lights.state.directionalShadow;
      uniforms.spotLights.value = lights.state.spot;
      uniforms.spotLightShadows.value = lights.state.spotShadow;
      uniforms.rectAreaLights.value = lights.state.rectArea;
      uniforms.ltc_1.value = lights.state.rectAreaLTC1;
      uniforms.ltc_2.value = lights.state.rectAreaLTC2;
      uniforms.pointLights.value = lights.state.point;
      uniforms.pointLightShadows.value = lights.state.pointShadow;
      uniforms.hemisphereLights.value = lights.state.hemi;
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
    }
    const progUniforms = program.getUniforms();
    const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.currentProgram = program;
    materialProperties.uniformsList = uniformsList;
    return program;
  }
  function updateCommonMaterialProperties(material, parameters2) {
    const materialProperties = properties.get(material);
    materialProperties.outputEncoding = parameters2.outputEncoding;
    materialProperties.instancing = parameters2.instancing;
    materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
    materialProperties.numIntersection = parameters2.numClipIntersection;
    materialProperties.vertexAlphas = parameters2.vertexAlphas;
  }
  function setProgram(camera, scene, material, object) {
    if (scene.isScene !== true)
      scene = _emptyScene;
    textures.resetTextureUnits();
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
    const envMap = cubemaps.get(material.envMap || environment);
    const vertexAlphas = material.vertexColors === true && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    if (_clippingEnabled === true) {
      if (_localClippingEnabled === true || camera !== _currentCamera) {
        const useCache = camera === _currentCamera && material.id === _currentMaterialId;
        clipping.setState(material, camera, useCache);
      }
    }
    let needsProgramChange = false;
    if (material.version === materialProperties.__version) {
      if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
        needsProgramChange = true;
      } else if (materialProperties.outputEncoding !== encoding) {
        needsProgramChange = true;
      } else if (object.isInstancedMesh && materialProperties.instancing === false) {
        needsProgramChange = true;
      } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
        needsProgramChange = true;
      } else if (materialProperties.envMap !== envMap) {
        needsProgramChange = true;
      } else if (material.fog && materialProperties.fog !== fog) {
        needsProgramChange = true;
      } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
        needsProgramChange = true;
      } else if (materialProperties.vertexAlphas !== vertexAlphas) {
        needsProgramChange = true;
      }
    } else {
      needsProgramChange = true;
      materialProperties.__version = material.version;
    }
    let program = materialProperties.currentProgram;
    if (needsProgramChange === true) {
      program = getProgram(material, scene, object);
    }
    let refreshProgram = false;
    let refreshMaterial = false;
    let refreshLights = false;
    const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
    if (state.useProgram(program.program)) {
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }
    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }
    if (refreshProgram || _currentCamera !== camera) {
      p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2));
      }
      if (_currentCamera !== camera) {
        _currentCamera = camera;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
        const uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
        }
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
        p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || material.skinning) {
        p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
      }
    }
    if (material.skinning) {
      p_uniforms.setOptional(_gl, object, "bindMatrix");
      p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
      const skeleton = object.skeleton;
      if (skeleton) {
        const bones = skeleton.bones;
        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === null) {
            let size = Math.sqrt(bones.length * 4);
            size = MathUtils.ceilPowerOfTwo(size);
            size = Math.max(size, 4);
            const boneMatrices = new Float32Array(size * size * 4);
            boneMatrices.set(skeleton.boneMatrices);
            const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
            skeleton.boneMatrices = boneMatrices;
            skeleton.boneTexture = boneTexture;
            skeleton.boneTextureSize = size;
          }
          p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
          p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
        } else {
          p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
        }
      }
    }
    if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
      materialProperties.receiveShadow = object.receiveShadow;
      p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
    }
    if (refreshMaterial) {
      p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
      if (materialProperties.needsLights) {
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      }
      if (fog && material.fog) {
        materials.refreshFogUniforms(m_uniforms, fog);
      }
      materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height);
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
    }
    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      material.uniformsNeedUpdate = false;
    }
    if (material.isSpriteMaterial) {
      p_uniforms.setValue(_gl, "center", object.center);
    }
    p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
    p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
    p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
    return program;
  }
  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.lightProbe.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.directionalLightShadows.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.pointLightShadows.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.spotLightShadows.needsUpdate = value;
    uniforms.rectAreaLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
  }
  function materialNeedsLights(material) {
    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
  }
  this.getActiveCubeFace = function() {
    return _currentActiveCubeFace;
  };
  this.getActiveMipmapLevel = function() {
    return _currentActiveMipmapLevel;
  };
  this.getRenderTarget = function() {
    return _currentRenderTarget;
  };
  this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
    _currentRenderTarget = renderTarget;
    _currentActiveCubeFace = activeCubeFace;
    _currentActiveMipmapLevel = activeMipmapLevel;
    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === void 0) {
      textures.setupRenderTarget(renderTarget);
    }
    let framebuffer = null;
    let isCube = false;
    let isRenderTarget3D = false;
    if (renderTarget) {
      const texture = renderTarget.texture;
      if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
        isRenderTarget3D = true;
      }
      const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget) {
        framebuffer = __webglFramebuffer[activeCubeFace];
        isCube = true;
      } else if (renderTarget.isWebGLMultisampleRenderTarget) {
        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
      } else {
        framebuffer = __webglFramebuffer;
      }
      _currentViewport.copy(renderTarget.viewport);
      _currentScissor.copy(renderTarget.scissor);
      _currentScissorTest = renderTarget.scissorTest;
    } else {
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
      _currentScissorTest = _scissorTest;
    }
    state.bindFramebuffer(36160, framebuffer);
    state.viewport(_currentViewport);
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);
    if (isCube) {
      const textureProperties = properties.get(renderTarget.texture);
      _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
    } else if (isRenderTarget3D) {
      const textureProperties = properties.get(renderTarget.texture);
      const layer = activeCubeFace || 0;
      _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
    }
  };
  this.readRenderTargetPixels = function(renderTarget, x2, y2, width, height, buffer, activeCubeFaceIndex) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let framebuffer = properties.get(renderTarget).__webglFramebuffer;
    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
      framebuffer = framebuffer[activeCubeFaceIndex];
    }
    if (framebuffer) {
      state.bindFramebuffer(36160, framebuffer);
      try {
        const texture = renderTarget.texture;
        const textureFormat = texture.format;
        const textureType = texture.type;
        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        if (_gl.checkFramebufferStatus(36160) === 36053) {
          if (x2 >= 0 && x2 <= renderTarget.width - width && (y2 >= 0 && y2 <= renderTarget.height - height)) {
            _gl.readPixels(x2, y2, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } else {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
        }
      } finally {
        const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
        state.bindFramebuffer(36160, framebuffer2);
      }
    }
  };
  this.copyFramebufferToTexture = function(position, texture, level = 0) {
    const levelScale = Math.pow(2, -level);
    const width = Math.floor(texture.image.width * levelScale);
    const height = Math.floor(texture.image.height * levelScale);
    const glFormat = utils.convert(texture.format);
    textures.setTexture2D(texture, 0);
    _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);
    state.unbindTexture();
  };
  this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
    const width = srcTexture.image.width;
    const height = srcTexture.image.height;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    textures.setTexture2D(dstTexture, 0);
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
      } else {
        _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
      }
    }
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(3553);
    state.unbindTexture();
  };
  this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
    if (_this.isWebGL1Renderer) {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      return;
    }
    const {width, height, data} = srcTexture.image;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    let glTarget;
    if (dstTexture.isDataTexture3D) {
      textures.setTexture3D(dstTexture, 0);
      glTarget = 32879;
    } else if (dstTexture.isDataTexture2DArray) {
      textures.setTexture2DArray(dstTexture, 0);
      glTarget = 35866;
    } else {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      return;
    }
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    const unpackRowLen = _gl.getParameter(3314);
    const unpackImageHeight = _gl.getParameter(32878);
    const unpackSkipPixels = _gl.getParameter(3316);
    const unpackSkipRows = _gl.getParameter(3315);
    const unpackSkipImages = _gl.getParameter(32877);
    _gl.pixelStorei(3314, width);
    _gl.pixelStorei(32878, height);
    _gl.pixelStorei(3316, sourceBox.min.x);
    _gl.pixelStorei(3315, sourceBox.min.y);
    _gl.pixelStorei(32877, sourceBox.min.z);
    _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, sourceBox.max.x - sourceBox.min.x + 1, sourceBox.max.y - sourceBox.min.y + 1, sourceBox.max.z - sourceBox.min.z + 1, glFormat, glType, data);
    _gl.pixelStorei(3314, unpackRowLen);
    _gl.pixelStorei(32878, unpackImageHeight);
    _gl.pixelStorei(3316, unpackSkipPixels);
    _gl.pixelStorei(3315, unpackSkipRows);
    _gl.pixelStorei(32877, unpackSkipImages);
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(glTarget);
    state.unbindTexture();
  };
  this.initTexture = function(texture) {
    textures.setTexture2D(texture, 0);
    state.unbindTexture();
  };
  this.resetState = function() {
    _currentActiveCubeFace = 0;
    _currentActiveMipmapLevel = 0;
    _currentRenderTarget = null;
    state.reset();
    bindingStates.reset();
  };
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}));
  }
}
class Scene extends Object3D {
  constructor() {
    super();
    this.type = "Scene";
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.overrideMaterial = null;
    this.autoUpdate = true;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {detail: this}));
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null)
      this.background = source.background.clone();
    if (source.environment !== null)
      this.environment = source.environment.clone();
    if (source.fog !== null)
      this.fog = source.fog.clone();
    if (source.overrideMaterial !== null)
      this.overrideMaterial = source.overrideMaterial.clone();
    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.background !== null)
      data.object.background = this.background.toJSON(meta);
    if (this.environment !== null)
      data.object.environment = this.environment.toJSON(meta);
    if (this.fog !== null)
      data.object.fog = this.fog.toJSON();
    return data;
  }
}
Scene.prototype.isScene = true;
function InterleavedBuffer(array, stride) {
  this.array = array;
  this.stride = stride;
  this.count = array !== void 0 ? array.length / stride : 0;
  this.usage = StaticDrawUsage;
  this.updateRange = {offset: 0, count: -1};
  this.version = 0;
  this.uuid = MathUtils.generateUUID();
}
Object.defineProperty(InterleavedBuffer.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
Object.assign(InterleavedBuffer.prototype, {
  isInterleavedBuffer: true,
  onUploadCallback: function() {
  },
  setUsage: function(value) {
    this.usage = value;
    return this;
  },
  copy: function(source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.usage = source.usage;
    return this;
  },
  copyAt: function(index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;
    for (let i2 = 0, l2 = this.stride; i2 < l2; i2++) {
      this.array[index1 + i2] = attribute.array[index2 + i2];
    }
    return this;
  },
  set: function(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  },
  clone: function(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = MathUtils.generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }
    const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
    const ib = new InterleavedBuffer(array, this.stride);
    ib.setUsage(this.usage);
    return ib;
  },
  onUpload: function(callback) {
    this.onUploadCallback = callback;
    return this;
  },
  toJSON: function(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = MathUtils.generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
    }
    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
});
const _vector$6 = new Vector3();
function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
  this.name = "";
  this.data = interleavedBuffer;
  this.itemSize = itemSize;
  this.offset = offset;
  this.normalized = normalized === true;
}
Object.defineProperties(InterleavedBufferAttribute.prototype, {
  count: {
    get: function() {
      return this.data.count;
    }
  },
  array: {
    get: function() {
      return this.data.array;
    }
  },
  needsUpdate: {
    set: function(value) {
      this.data.needsUpdate = value;
    }
  }
});
Object.assign(InterleavedBufferAttribute.prototype, {
  isInterleavedBufferAttribute: true,
  applyMatrix4: function(m2) {
    for (let i2 = 0, l2 = this.data.count; i2 < l2; i2++) {
      _vector$6.x = this.getX(i2);
      _vector$6.y = this.getY(i2);
      _vector$6.z = this.getZ(i2);
      _vector$6.applyMatrix4(m2);
      this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  },
  applyNormalMatrix: function(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$6.x = this.getX(i2);
      _vector$6.y = this.getY(i2);
      _vector$6.z = this.getZ(i2);
      _vector$6.applyNormalMatrix(m2);
      this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  },
  transformDirection: function(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$6.x = this.getX(i2);
      _vector$6.y = this.getY(i2);
      _vector$6.z = this.getZ(i2);
      _vector$6.transformDirection(m2);
      this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  },
  setX: function(index, x2) {
    this.data.array[index * this.data.stride + this.offset] = x2;
    return this;
  },
  setY: function(index, y2) {
    this.data.array[index * this.data.stride + this.offset + 1] = y2;
    return this;
  },
  setZ: function(index, z2) {
    this.data.array[index * this.data.stride + this.offset + 2] = z2;
    return this;
  },
  setW: function(index, w2) {
    this.data.array[index * this.data.stride + this.offset + 3] = w2;
    return this;
  },
  getX: function(index) {
    return this.data.array[index * this.data.stride + this.offset];
  },
  getY: function(index) {
    return this.data.array[index * this.data.stride + this.offset + 1];
  },
  getZ: function(index) {
    return this.data.array[index * this.data.stride + this.offset + 2];
  },
  getW: function(index) {
    return this.data.array[index * this.data.stride + this.offset + 3];
  },
  setXY: function(index, x2, y2) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x2;
    this.data.array[index + 1] = y2;
    return this;
  },
  setXYZ: function(index, x2, y2, z2) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x2;
    this.data.array[index + 1] = y2;
    this.data.array[index + 2] = z2;
    return this;
  },
  setXYZW: function(index, x2, y2, z2, w2) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x2;
    this.data.array[index + 1] = y2;
    this.data.array[index + 2] = z2;
    this.data.array[index + 3] = w2;
    return this;
  },
  clone: function(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
      const array = [];
      for (let i2 = 0; i2 < this.count; i2++) {
        const index = i2 * this.data.stride + this.offset;
        for (let j2 = 0; j2 < this.itemSize; j2++) {
          array.push(this.data.array[index + j2]);
        }
      }
      return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
      }
      return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  },
  toJSON: function(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
      const array = [];
      for (let i2 = 0; i2 < this.count; i2++) {
        const index = i2 * this.data.stride + this.offset;
        for (let j2 = 0; j2 < this.itemSize; j2++) {
          array.push(this.data.array[index + j2]);
        }
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array,
        normalized: this.normalized
      };
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
      }
      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
});
const _basePosition = new Vector3();
const _skinIndex = new Vector4();
const _skinWeight = new Vector4();
const _vector$5 = new Vector3();
const _matrix = new Matrix4();
function SkinnedMesh(geometry, material) {
  Mesh.call(this, geometry, material);
  this.type = "SkinnedMesh";
  this.bindMode = "attached";
  this.bindMatrix = new Matrix4();
  this.bindMatrixInverse = new Matrix4();
}
SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: SkinnedMesh,
  isSkinnedMesh: true,
  copy: function(source) {
    Mesh.prototype.copy.call(this, source);
    this.bindMode = source.bindMode;
    this.bindMatrix.copy(source.bindMatrix);
    this.bindMatrixInverse.copy(source.bindMatrixInverse);
    this.skeleton = source.skeleton;
    return this;
  },
  bind: function(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === void 0) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.copy(bindMatrix).invert();
  },
  pose: function() {
    this.skeleton.pose();
  },
  normalizeSkinWeights: function() {
    const vector = new Vector4();
    const skinWeight = this.geometry.attributes.skinWeight;
    for (let i2 = 0, l2 = skinWeight.count; i2 < l2; i2++) {
      vector.x = skinWeight.getX(i2);
      vector.y = skinWeight.getY(i2);
      vector.z = skinWeight.getZ(i2);
      vector.w = skinWeight.getW(i2);
      const scale = 1 / vector.manhattanLength();
      if (scale !== Infinity) {
        vector.multiplyScalar(scale);
      } else {
        vector.set(1, 0, 0, 0);
      }
      skinWeight.setXYZW(i2, vector.x, vector.y, vector.z, vector.w);
    }
  },
  updateMatrixWorld: function(force) {
    Mesh.prototype.updateMatrixWorld.call(this, force);
    if (this.bindMode === "attached") {
      this.bindMatrixInverse.copy(this.matrixWorld).invert();
    } else if (this.bindMode === "detached") {
      this.bindMatrixInverse.copy(this.bindMatrix).invert();
    } else {
      console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
  },
  boneTransform: function(index, target) {
    const skeleton = this.skeleton;
    const geometry = this.geometry;
    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
    _basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);
    target.set(0, 0, 0);
    for (let i2 = 0; i2 < 4; i2++) {
      const weight = _skinWeight.getComponent(i2);
      if (weight !== 0) {
        const boneIndex = _skinIndex.getComponent(i2);
        _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
        target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
      }
    }
    return target.applyMatrix4(this.bindMatrixInverse);
  }
});
function Bone() {
  Object3D.call(this);
  this.type = "Bone";
}
Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Bone,
  isBone: true
});
const _offsetMatrix = /* @__PURE__ */ new Matrix4();
const _identityMatrix = /* @__PURE__ */ new Matrix4();
class Skeleton {
  constructor(bones = [], boneInverses = []) {
    this.uuid = MathUtils.generateUUID();
    this.bones = bones.slice(0);
    this.boneInverses = boneInverses;
    this.boneMatrices = null;
    this.boneTexture = null;
    this.boneTextureSize = 0;
    this.frame = -1;
    this.init();
  }
  init() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    this.boneMatrices = new Float32Array(bones.length * 16);
    if (boneInverses.length === 0) {
      this.calculateInverses();
    } else {
      if (bones.length !== boneInverses.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
        this.boneInverses = [];
        for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
          this.boneInverses.push(new Matrix4());
        }
      }
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const inverse = new Matrix4();
      if (this.bones[i2]) {
        inverse.copy(this.bones[i2].matrixWorld).invert();
      }
      this.boneInverses.push(inverse);
    }
  }
  pose() {
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const bone = this.bones[i2];
      if (bone) {
        bone.matrixWorld.copy(this.boneInverses[i2]).invert();
      }
    }
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const bone = this.bones[i2];
      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.copy(bone.parent.matrixWorld).invert();
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  }
  update() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    const boneMatrices = this.boneMatrices;
    const boneTexture = this.boneTexture;
    for (let i2 = 0, il = bones.length; i2 < il; i2++) {
      const matrix = bones[i2] ? bones[i2].matrixWorld : _identityMatrix;
      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i2]);
      _offsetMatrix.toArray(boneMatrices, i2 * 16);
    }
    if (boneTexture !== null) {
      boneTexture.needsUpdate = true;
    }
  }
  clone() {
    return new Skeleton(this.bones, this.boneInverses);
  }
  getBoneByName(name) {
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const bone = this.bones[i2];
      if (bone.name === name) {
        return bone;
      }
    }
    return void 0;
  }
  dispose() {
    if (this.boneTexture !== null) {
      this.boneTexture.dispose();
      this.boneTexture = null;
    }
  }
  fromJSON(json, bones) {
    this.uuid = json.uuid;
    for (let i2 = 0, l2 = json.bones.length; i2 < l2; i2++) {
      const uuid = json.bones[i2];
      let bone = bones[uuid];
      if (bone === void 0) {
        console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
        bone = new Bone();
      }
      this.bones.push(bone);
      this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i2]));
    }
    this.init();
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    data.uuid = this.uuid;
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    for (let i2 = 0, l2 = bones.length; i2 < l2; i2++) {
      const bone = bones[i2];
      data.bones.push(bone.uuid);
      const boneInverse = boneInverses[i2];
      data.boneInverses.push(boneInverse.toArray());
    }
    return data;
  }
}
const _instanceLocalMatrix = new Matrix4();
const _instanceWorldMatrix = new Matrix4();
const _instanceIntersects = [];
const _mesh = new Mesh();
function InstancedMesh(geometry, material, count) {
  Mesh.call(this, geometry, material);
  this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);
  this.instanceColor = null;
  this.count = count;
  this.frustumCulled = false;
}
InstancedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: InstancedMesh,
  isInstancedMesh: true,
  copy: function(source) {
    Mesh.prototype.copy.call(this, source);
    this.instanceMatrix.copy(source.instanceMatrix);
    if (source.instanceColor !== null)
      this.instanceColor = source.instanceColor.clone();
    this.count = source.count;
    return this;
  },
  getColorAt: function(index, color) {
    color.fromArray(this.instanceColor.array, index * 3);
  },
  getMatrixAt: function(index, matrix) {
    matrix.fromArray(this.instanceMatrix.array, index * 16);
  },
  raycast: function(raycaster, intersects) {
    const matrixWorld = this.matrixWorld;
    const raycastTimes = this.count;
    _mesh.geometry = this.geometry;
    _mesh.material = this.material;
    if (_mesh.material === void 0)
      return;
    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
      this.getMatrixAt(instanceId, _instanceLocalMatrix);
      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
      _mesh.matrixWorld = _instanceWorldMatrix;
      _mesh.raycast(raycaster, _instanceIntersects);
      for (let i2 = 0, l2 = _instanceIntersects.length; i2 < l2; i2++) {
        const intersect = _instanceIntersects[i2];
        intersect.instanceId = instanceId;
        intersect.object = this;
        intersects.push(intersect);
      }
      _instanceIntersects.length = 0;
    }
  },
  setColorAt: function(index, color) {
    if (this.instanceColor === null) {
      this.instanceColor = new BufferAttribute(new Float32Array(this.count * 3), 3);
    }
    color.toArray(this.instanceColor.array, index * 3);
  },
  setMatrixAt: function(index, matrix) {
    matrix.toArray(this.instanceMatrix.array, index * 16);
  },
  updateMorphTargets: function() {
  },
  dispose: function() {
    this.dispatchEvent({type: "dispose"});
  }
});
class LineBasicMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "LineBasicMaterial";
    this.color = new Color(16777215);
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.morphTargets = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    this.morphTargets = source.morphTargets;
    return this;
  }
}
LineBasicMaterial.prototype.isLineBasicMaterial = true;
const _start$1 = new Vector3();
const _end$1 = new Vector3();
const _inverseMatrix$1 = new Matrix4();
const _ray$1 = new Ray();
const _sphere$1 = new Sphere();
function Line(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
  Object3D.call(this);
  this.type = "Line";
  this.geometry = geometry;
  this.material = material;
  this.updateMorphTargets();
}
Line.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Line,
  isLine: true,
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  computeLineDistances: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [0];
        for (let i2 = 1, l2 = positionAttribute.count; i2 < l2; i2++) {
          _start$1.fromBufferAttribute(positionAttribute, i2 - 1);
          _end$1.fromBufferAttribute(positionAttribute, i2);
          lineDistances[i2] = lineDistances[i2 - 1];
          lineDistances[i2] += _start$1.distanceTo(_end$1);
        }
        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    return this;
  },
  raycast: function(raycaster, intersects) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Line.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$1.copy(geometry.boundingSphere);
    _sphere$1.applyMatrix4(matrixWorld);
    _sphere$1.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$1) === false)
      return;
    _inverseMatrix$1.copy(matrixWorld).invert();
    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const vStart = new Vector3();
    const vEnd = new Vector3();
    const interSegment = new Vector3();
    const interRay = new Vector3();
    const step = this.isLineSegments ? 2 : 1;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index !== null) {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);
        for (let i2 = start, l2 = end - 1; i2 < l2; i2 += step) {
          const a2 = index.getX(i2);
          const b2 = index.getX(i2 + 1);
          vStart.fromBufferAttribute(positionAttribute, a2);
          vEnd.fromBufferAttribute(positionAttribute, b2);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far)
            continue;
          intersects.push({
            distance,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i2,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
        for (let i2 = start, l2 = end - 1; i2 < l2; i2 += step) {
          vStart.fromBufferAttribute(positionAttribute, i2);
          vEnd.fromBufferAttribute(positionAttribute, i2 + 1);
          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
          if (distSq > localThresholdSq)
            continue;
          interRay.applyMatrix4(this.matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far)
            continue;
          intersects.push({
            distance,
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i2,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  },
  updateMorphTargets: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
            const name = morphAttribute[m2].name || String(m2);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m2;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
});
const _start = new Vector3();
const _end = new Vector3();
function LineSegments(geometry, material) {
  Line.call(this, geometry, material);
  this.type = "LineSegments";
}
LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
  constructor: LineSegments,
  isLineSegments: true,
  computeLineDistances: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [];
        for (let i2 = 0, l2 = positionAttribute.count; i2 < l2; i2 += 2) {
          _start.fromBufferAttribute(positionAttribute, i2);
          _end.fromBufferAttribute(positionAttribute, i2 + 1);
          lineDistances[i2] = i2 === 0 ? 0 : lineDistances[i2 - 1];
          lineDistances[i2 + 1] = lineDistances[i2] + _start.distanceTo(_end);
        }
        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      }
    } else if (geometry.isGeometry) {
      console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    return this;
  }
});
class LineLoop extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.type = "LineLoop";
  }
}
LineLoop.prototype.isLineLoop = true;
class PointsMaterial extends Material {
  constructor(parameters) {
    super();
    this.type = "PointsMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.morphTargets = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    this.morphTargets = source.morphTargets;
    return this;
  }
}
PointsMaterial.prototype.isPointsMaterial = true;
const _inverseMatrix = new Matrix4();
const _ray = new Ray();
const _sphere = new Sphere();
const _position$2 = new Vector3();
function Points(geometry = new BufferGeometry(), material = new PointsMaterial()) {
  Object3D.call(this);
  this.type = "Points";
  this.geometry = geometry;
  this.material = material;
  this.updateMorphTargets();
}
Points.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Points,
  isPoints: true,
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  raycast: function(raycaster, intersects) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Points.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere.copy(geometry.boundingSphere);
    _sphere.applyMatrix4(matrixWorld);
    _sphere.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere) === false)
      return;
    _inverseMatrix.copy(matrixWorld).invert();
    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const attributes = geometry.attributes;
      const positionAttribute = attributes.position;
      if (index !== null) {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);
        for (let i2 = start, il = end; i2 < il; i2++) {
          const a2 = index.getX(i2);
          _position$2.fromBufferAttribute(positionAttribute, a2);
          testPoint(_position$2, a2, localThresholdSq, matrixWorld, raycaster, intersects, this);
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
        for (let i2 = start, l2 = end; i2 < l2; i2++) {
          _position$2.fromBufferAttribute(positionAttribute, i2);
          testPoint(_position$2, i2, localThresholdSq, matrixWorld, raycaster, intersects, this);
        }
      }
    } else {
      console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  },
  updateMorphTargets: function() {
    const geometry = this.geometry;
    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
            const name = morphAttribute[m2].name || String(m2);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m2;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  }
});
function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
  const rayPointDistanceSq = _ray.distanceSqToPoint(point);
  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3();
    _ray.closestPointToPoint(point, intersectPoint);
    intersectPoint.applyMatrix4(matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far)
      return;
    intersects.push({
      distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index,
      face: null,
      object
    });
  }
}
class CompressedTexture extends Texture {
  constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {width, height};
    this.mipmaps = mipmaps;
    this.flipY = false;
    this.generateMipmaps = false;
  }
}
CompressedTexture.prototype.isCompressedTexture = true;
class CanvasTexture extends Texture {
  constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.needsUpdate = true;
  }
}
CanvasTexture.prototype.isCanvasTexture = true;
class CylinderGeometry extends BufferGeometry {
  constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CylinderGeometry";
    this.parameters = {
      radiusTop,
      radiusBottom,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
    const scope = this;
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let index = 0;
    const indexArray = [];
    const halfHeight = height / 2;
    let groupStart = 0;
    generateTorso();
    if (openEnded === false) {
      if (radiusTop > 0)
        generateCap(true);
      if (radiusBottom > 0)
        generateCap(false);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateTorso() {
      const normal = new Vector3();
      const vertex = new Vector3();
      let groupCount = 0;
      const slope = (radiusBottom - radiusTop) / height;
      for (let y2 = 0; y2 <= heightSegments; y2++) {
        const indexRow = [];
        const v2 = y2 / heightSegments;
        const radius = v2 * (radiusBottom - radiusTop) + radiusTop;
        for (let x2 = 0; x2 <= radialSegments; x2++) {
          const u2 = x2 / radialSegments;
          const theta = u2 * thetaLength + thetaStart;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta);
          vertex.x = radius * sinTheta;
          vertex.y = -v2 * height + halfHeight;
          vertex.z = radius * cosTheta;
          vertices.push(vertex.x, vertex.y, vertex.z);
          normal.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(u2, 1 - v2);
          indexRow.push(index++);
        }
        indexArray.push(indexRow);
      }
      for (let x2 = 0; x2 < radialSegments; x2++) {
        for (let y2 = 0; y2 < heightSegments; y2++) {
          const a2 = indexArray[y2][x2];
          const b2 = indexArray[y2 + 1][x2];
          const c2 = indexArray[y2 + 1][x2 + 1];
          const d2 = indexArray[y2][x2 + 1];
          indices.push(a2, b2, d2);
          indices.push(b2, c2, d2);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, 0);
      groupStart += groupCount;
    }
    function generateCap(top) {
      const centerIndexStart = index;
      const uv = new Vector2();
      const vertex = new Vector3();
      let groupCount = 0;
      const radius = top === true ? radiusTop : radiusBottom;
      const sign = top === true ? 1 : -1;
      for (let x2 = 1; x2 <= radialSegments; x2++) {
        vertices.push(0, halfHeight * sign, 0);
        normals.push(0, sign, 0);
        uvs.push(0.5, 0.5);
        index++;
      }
      const centerIndexEnd = index;
      for (let x2 = 0; x2 <= radialSegments; x2++) {
        const u2 = x2 / radialSegments;
        const theta = u2 * thetaLength + thetaStart;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);
        vertex.x = radius * sinTheta;
        vertex.y = halfHeight * sign;
        vertex.z = radius * cosTheta;
        vertices.push(vertex.x, vertex.y, vertex.z);
        normals.push(0, sign, 0);
        uv.x = cosTheta * 0.5 + 0.5;
        uv.y = sinTheta * 0.5 * sign + 0.5;
        uvs.push(uv.x, uv.y);
        index++;
      }
      for (let x2 = 0; x2 < radialSegments; x2++) {
        const c2 = centerIndexStart + x2;
        const i2 = centerIndexEnd + x2;
        if (top === true) {
          indices.push(i2, i2 + 1, c2);
        } else {
          indices.push(i2 + 1, i2, c2);
        }
        groupCount += 3;
      }
      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
      groupStart += groupCount;
    }
  }
}
function ParametricGeometry(func, slices, stacks) {
  BufferGeometry.call(this);
  this.type = "ParametricGeometry";
  this.parameters = {
    func,
    slices,
    stacks
  };
  const indices = [];
  const vertices = [];
  const normals = [];
  const uvs = [];
  const EPS = 1e-5;
  const normal = new Vector3();
  const p0 = new Vector3(), p1 = new Vector3();
  const pu = new Vector3(), pv = new Vector3();
  if (func.length < 3) {
    console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
  }
  const sliceCount = slices + 1;
  for (let i2 = 0; i2 <= stacks; i2++) {
    const v2 = i2 / stacks;
    for (let j2 = 0; j2 <= slices; j2++) {
      const u2 = j2 / slices;
      func(u2, v2, p0);
      vertices.push(p0.x, p0.y, p0.z);
      if (u2 - EPS >= 0) {
        func(u2 - EPS, v2, p1);
        pu.subVectors(p0, p1);
      } else {
        func(u2 + EPS, v2, p1);
        pu.subVectors(p1, p0);
      }
      if (v2 - EPS >= 0) {
        func(u2, v2 - EPS, p1);
        pv.subVectors(p0, p1);
      } else {
        func(u2, v2 + EPS, p1);
        pv.subVectors(p1, p0);
      }
      normal.crossVectors(pu, pv).normalize();
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(u2, v2);
    }
  }
  for (let i2 = 0; i2 < stacks; i2++) {
    for (let j2 = 0; j2 < slices; j2++) {
      const a2 = i2 * sliceCount + j2;
      const b2 = i2 * sliceCount + j2 + 1;
      const c2 = (i2 + 1) * sliceCount + j2 + 1;
      const d2 = (i2 + 1) * sliceCount + j2;
      indices.push(a2, b2, d2);
      indices.push(b2, c2, d2);
    }
  }
  this.setIndex(indices);
  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
ParametricGeometry.prototype = Object.create(BufferGeometry.prototype);
ParametricGeometry.prototype.constructor = ParametricGeometry;
class SphereGeometry extends BufferGeometry {
  constructor(radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    super();
    this.type = "SphereGeometry";
    this.parameters = {
      radius,
      widthSegments,
      heightSegments,
      phiStart,
      phiLength,
      thetaStart,
      thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index = 0;
    const grid = [];
    const vertex = new Vector3();
    const normal = new Vector3();
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v2 = iy / heightSegments;
      let uOffset = 0;
      if (iy == 0 && thetaStart == 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy == heightSegments && thetaEnd == Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix = 0; ix <= widthSegments; ix++) {
        const u2 = ix / widthSegments;
        vertex.x = -radius * Math.cos(phiStart + u2 * phiLength) * Math.sin(thetaStart + v2 * thetaLength);
        vertex.y = radius * Math.cos(thetaStart + v2 * thetaLength);
        vertex.z = radius * Math.sin(phiStart + u2 * phiLength) * Math.sin(thetaStart + v2 * thetaLength);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normal.copy(vertex).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u2 + uOffset, 1 - v2);
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a2 = grid[iy][ix + 1];
        const b2 = grid[iy][ix];
        const c2 = grid[iy + 1][ix];
        const d2 = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0)
          indices.push(a2, b2, d2);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
          indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
}
function MeshStandardMaterial(parameters) {
  Material.call(this);
  this.defines = {STANDARD: ""};
  this.type = "MeshStandardMaterial";
  this.color = new Color(16777215);
  this.roughness = 1;
  this.metalness = 0;
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.emissive = new Color(0);
  this.emissiveIntensity = 1;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.roughnessMap = null;
  this.metalnessMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.envMapIntensity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = "round";
  this.wireframeLinejoin = "round";
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.flatShading = false;
  this.vertexTangents = false;
  this.setValues(parameters);
}
MeshStandardMaterial.prototype = Object.create(Material.prototype);
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
MeshStandardMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.defines = {STANDARD: ""};
  this.color.copy(source.color);
  this.roughness = source.roughness;
  this.metalness = source.metalness;
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.roughnessMap = source.roughnessMap;
  this.metalnessMap = source.metalnessMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.envMapIntensity = source.envMapIntensity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  this.flatShading = source.flatShading;
  this.vertexTangents = source.vertexTangents;
  return this;
};
function MeshPhysicalMaterial(parameters) {
  MeshStandardMaterial.call(this);
  this.defines = {
    STANDARD: "",
    PHYSICAL: ""
  };
  this.type = "MeshPhysicalMaterial";
  this.clearcoat = 0;
  this.clearcoatMap = null;
  this.clearcoatRoughness = 0;
  this.clearcoatRoughnessMap = null;
  this.clearcoatNormalScale = new Vector2(1, 1);
  this.clearcoatNormalMap = null;
  this.reflectivity = 0.5;
  Object.defineProperty(this, "ior", {
    get: function() {
      return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
    },
    set: function(ior) {
      this.reflectivity = MathUtils.clamp(2.5 * (ior - 1) / (ior + 1), 0, 1);
    }
  });
  this.sheen = null;
  this.transmission = 0;
  this.transmissionMap = null;
  this.setValues(parameters);
}
MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
MeshPhysicalMaterial.prototype.copy = function(source) {
  MeshStandardMaterial.prototype.copy.call(this, source);
  this.defines = {
    STANDARD: "",
    PHYSICAL: ""
  };
  this.clearcoat = source.clearcoat;
  this.clearcoatMap = source.clearcoatMap;
  this.clearcoatRoughness = source.clearcoatRoughness;
  this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
  this.clearcoatNormalMap = source.clearcoatNormalMap;
  this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
  this.reflectivity = source.reflectivity;
  if (source.sheen) {
    this.sheen = (this.sheen || new Color()).copy(source.sheen);
  } else {
    this.sheen = null;
  }
  this.transmission = source.transmission;
  this.transmissionMap = source.transmissionMap;
  return this;
};
const AnimationUtils = {
  arraySlice: function(array, from, to) {
    if (AnimationUtils.isTypedArray(array)) {
      return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));
    }
    return array.slice(from, to);
  },
  convertArray: function(array, type, forceClone) {
    if (!array || !forceClone && array.constructor === type)
      return array;
    if (typeof type.BYTES_PER_ELEMENT === "number") {
      return new type(array);
    }
    return Array.prototype.slice.call(array);
  },
  isTypedArray: function(object) {
    return ArrayBuffer.isView(object) && !(object instanceof DataView);
  },
  getKeyframeOrder: function(times) {
    function compareTime(i2, j2) {
      return times[i2] - times[j2];
    }
    const n2 = times.length;
    const result = new Array(n2);
    for (let i2 = 0; i2 !== n2; ++i2)
      result[i2] = i2;
    result.sort(compareTime);
    return result;
  },
  sortedArray: function(values, stride, order) {
    const nValues = values.length;
    const result = new values.constructor(nValues);
    for (let i2 = 0, dstOffset = 0; dstOffset !== nValues; ++i2) {
      const srcOffset = order[i2] * stride;
      for (let j2 = 0; j2 !== stride; ++j2) {
        result[dstOffset++] = values[srcOffset + j2];
      }
    }
    return result;
  },
  flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
    let i2 = 1, key = jsonKeys[0];
    while (key !== void 0 && key[valuePropertyName] === void 0) {
      key = jsonKeys[i2++];
    }
    if (key === void 0)
      return;
    let value = key[valuePropertyName];
    if (value === void 0)
      return;
    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push.apply(values, value);
        }
        key = jsonKeys[i2++];
      } while (key !== void 0);
    } else if (value.toArray !== void 0) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          value.toArray(values, values.length);
        }
        key = jsonKeys[i2++];
      } while (key !== void 0);
    } else {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push(value);
        }
        key = jsonKeys[i2++];
      } while (key !== void 0);
    }
  },
  subclip: function(sourceClip, name, startFrame, endFrame, fps = 30) {
    const clip = sourceClip.clone();
    clip.name = name;
    const tracks = [];
    for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
      const track = clip.tracks[i2];
      const valueSize = track.getValueSize();
      const times = [];
      const values = [];
      for (let j2 = 0; j2 < track.times.length; ++j2) {
        const frame = track.times[j2] * fps;
        if (frame < startFrame || frame >= endFrame)
          continue;
        times.push(track.times[j2]);
        for (let k2 = 0; k2 < valueSize; ++k2) {
          values.push(track.values[j2 * valueSize + k2]);
        }
      }
      if (times.length === 0)
        continue;
      track.times = AnimationUtils.convertArray(times, track.times.constructor);
      track.values = AnimationUtils.convertArray(values, track.values.constructor);
      tracks.push(track);
    }
    clip.tracks = tracks;
    let minStartTime = Infinity;
    for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
      if (minStartTime > clip.tracks[i2].times[0]) {
        minStartTime = clip.tracks[i2].times[0];
      }
    }
    for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
      clip.tracks[i2].shift(-1 * minStartTime);
    }
    clip.resetDuration();
    return clip;
  },
  makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
    if (fps <= 0)
      fps = 30;
    const numTracks = referenceClip.tracks.length;
    const referenceTime = referenceFrame / fps;
    for (let i2 = 0; i2 < numTracks; ++i2) {
      const referenceTrack = referenceClip.tracks[i2];
      const referenceTrackType = referenceTrack.ValueTypeName;
      if (referenceTrackType === "bool" || referenceTrackType === "string")
        continue;
      const targetTrack = targetClip.tracks.find(function(track) {
        return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
      });
      if (targetTrack === void 0)
        continue;
      let referenceOffset = 0;
      const referenceValueSize = referenceTrack.getValueSize();
      if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        referenceOffset = referenceValueSize / 3;
      }
      let targetOffset = 0;
      const targetValueSize = targetTrack.getValueSize();
      if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
        targetOffset = targetValueSize / 3;
      }
      const lastIndex = referenceTrack.times.length - 1;
      let referenceValue;
      if (referenceTime <= referenceTrack.times[0]) {
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else if (referenceTime >= referenceTrack.times[lastIndex]) {
        const startIndex = lastIndex * referenceValueSize + referenceOffset;
        const endIndex = startIndex + referenceValueSize - referenceOffset;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
      } else {
        const interpolant = referenceTrack.createInterpolant();
        const startIndex = referenceOffset;
        const endIndex = referenceValueSize - referenceOffset;
        interpolant.evaluate(referenceTime);
        referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
      }
      if (referenceTrackType === "quaternion") {
        const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
        referenceQuat.toArray(referenceValue);
      }
      const numTimes = targetTrack.times.length;
      for (let j2 = 0; j2 < numTimes; ++j2) {
        const valueStart = j2 * targetValueSize + targetOffset;
        if (referenceTrackType === "quaternion") {
          Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
        } else {
          const valueEnd = targetValueSize - targetOffset * 2;
          for (let k2 = 0; k2 < valueEnd; ++k2) {
            targetTrack.values[valueStart + k2] -= referenceValue[k2];
          }
        }
      }
    }
    targetClip.blendMode = AdditiveAnimationBlendMode;
    return targetClip;
  }
};
function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  this.parameterPositions = parameterPositions;
  this._cachedIndex = 0;
  this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
  this.sampleValues = sampleValues;
  this.valueSize = sampleSize;
}
Object.assign(Interpolant.prototype, {
  evaluate: function(t2) {
    const pp = this.parameterPositions;
    let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
    validate_interval: {
      seek: {
        let right;
        linear_scan: {
          forward_scan:
            if (!(t2 < t1)) {
              for (let giveUpAt = i1 + 2; ; ) {
                if (t1 === void 0) {
                  if (t2 < t0)
                    break forward_scan;
                  i1 = pp.length;
                  this._cachedIndex = i1;
                  return this.afterEnd_(i1 - 1, t2, t0);
                }
                if (i1 === giveUpAt)
                  break;
                t0 = t1;
                t1 = pp[++i1];
                if (t2 < t1) {
                  break seek;
                }
              }
              right = pp.length;
              break linear_scan;
            }
          if (!(t2 >= t0)) {
            const t1global = pp[1];
            if (t2 < t1global) {
              i1 = 2;
              t0 = t1global;
            }
            for (let giveUpAt = i1 - 2; ; ) {
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.beforeStart_(0, t2, t1);
              }
              if (i1 === giveUpAt)
                break;
              t1 = t0;
              t0 = pp[--i1 - 1];
              if (t2 >= t0) {
                break seek;
              }
            }
            right = i1;
            i1 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i1 < right) {
          const mid = i1 + right >>> 1;
          if (t2 < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }
        t1 = pp[i1];
        t0 = pp[i1 - 1];
        if (t0 === void 0) {
          this._cachedIndex = 0;
          return this.beforeStart_(0, t2, t1);
        }
        if (t1 === void 0) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.afterEnd_(i1 - 1, t0, t2);
        }
      }
      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    }
    return this.interpolate_(i1, t0, t2, t1);
  },
  settings: null,
  DefaultSettings_: {},
  getSettings_: function() {
    return this.settings || this.DefaultSettings_;
  },
  copySampleValue_: function(index) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = values[offset + i2];
    }
    return result;
  },
  interpolate_: function() {
    throw new Error("call to abstract method");
  },
  intervalChanged_: function() {
  }
});
Object.assign(Interpolant.prototype, {
  beforeStart_: Interpolant.prototype.copySampleValue_,
  afterEnd_: Interpolant.prototype.copySampleValue_
});
function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  this._weightPrev = -0;
  this._offsetPrev = -0;
  this._weightNext = -0;
  this._offsetNext = -0;
}
CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: CubicInterpolant,
  DefaultSettings_: {
    endingStart: ZeroCurvatureEnding,
    endingEnd: ZeroCurvatureEnding
  },
  intervalChanged_: function(i1, t0, t1) {
    const pp = this.parameterPositions;
    let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;
        case WrapAroundEnding:
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;
        default:
          iPrev = i1;
          tPrev = t1;
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;
        default:
          iNext = i1 - 1;
          tNext = t0;
      }
    }
    const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  },
  interpolate_: function(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p2 = (t2 - t0) / (t1 - t0), pp = p2 * p2, ppp = pp * p2;
    const sP = -wP * ppp + 2 * wP * pp - wP * p2;
    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p2 + 1;
    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p2;
    const sN = wN * ppp - wN * pp;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = sP * values[oP + i2] + s0 * values[o0 + i2] + s1 * values[o1 + i2] + sN * values[oN + i2];
    }
    return result;
  }
});
function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: LinearInterpolant,
  interpolate_: function(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t2 - t0) / (t1 - t0), weight0 = 1 - weight1;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = values[offset0 + i2] * weight0 + values[offset1 + i2] * weight1;
    }
    return result;
  }
});
function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: DiscreteInterpolant,
  interpolate_: function(i1) {
    return this.copySampleValue_(i1 - 1);
  }
});
class KeyframeTrack {
  constructor(name, times, values, interpolation) {
    if (name === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times === void 0 || times.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
    this.name = name;
    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }
  static toJSON(track) {
    const trackType = track.constructor;
    let json;
    if (trackType.toJSON !== this.toJSON) {
      json = trackType.toJSON(track);
    } else {
      json = {
        name: track.name,
        times: AnimationUtils.convertArray(track.times, Array),
        values: AnimationUtils.convertArray(track.values, Array)
      };
      const interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }
    json.type = track.ValueTypeName;
    return json;
  }
  InterpolantFactoryMethodDiscrete(result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodLinear(result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodSmooth(result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  setInterpolation(interpolation) {
    let factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === void 0) {
      const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      console.warn("THREE.KeyframeTrack:", message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(timeOffset) {
    if (timeOffset !== 0) {
      const times = this.times;
      for (let i2 = 0, n2 = times.length; i2 !== n2; ++i2) {
        times[i2] += timeOffset;
      }
    }
    return this;
  }
  scale(timeScale) {
    if (timeScale !== 1) {
      const times = this.times;
      for (let i2 = 0, n2 = times.length; i2 !== n2; ++i2) {
        times[i2] *= timeScale;
      }
    }
    return this;
  }
  trim(startTime, endTime) {
    const times = this.times, nKeys = times.length;
    let from = 0, to = nKeys - 1;
    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }
    while (to !== -1 && times[to] > endTime) {
      --to;
    }
    ++to;
    if (from !== 0 || to !== nKeys) {
      if (from >= to) {
        to = Math.max(to, 1);
        from = to - 1;
      }
      const stride = this.getValueSize();
      this.times = AnimationUtils.arraySlice(times, from, to);
      this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
    }
    return this;
  }
  validate() {
    let valid = true;
    const valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
      valid = false;
    }
    const times = this.times, values = this.values, nKeys = times.length;
    if (nKeys === 0) {
      console.error("THREE.KeyframeTrack: Track is empty.", this);
      valid = false;
    }
    let prevTime = null;
    for (let i2 = 0; i2 !== nKeys; i2++) {
      const currTime = times[i2];
      if (typeof currTime === "number" && isNaN(currTime)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i2, currTime);
        valid = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, i2, currTime, prevTime);
        valid = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== void 0) {
      if (AnimationUtils.isTypedArray(values)) {
        for (let i2 = 0, n2 = values.length; i2 !== n2; ++i2) {
          const value = values[i2];
          if (isNaN(value)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i2, value);
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  }
  optimize() {
    const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
    let writeIndex = 1;
    for (let i2 = 1; i2 < lastIndex; ++i2) {
      let keep = false;
      const time = times[i2];
      const timeNext = times[i2 + 1];
      if (time !== timeNext && (i2 !== 1 || time !== times[0])) {
        if (!smoothInterpolation) {
          const offset = i2 * stride, offsetP = offset - stride, offsetN = offset + stride;
          for (let j2 = 0; j2 !== stride; ++j2) {
            const value = values[offset + j2];
            if (value !== values[offsetP + j2] || value !== values[offsetN + j2]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      }
      if (keep) {
        if (i2 !== writeIndex) {
          times[writeIndex] = times[i2];
          const readOffset = i2 * stride, writeOffset = writeIndex * stride;
          for (let j2 = 0; j2 !== stride; ++j2) {
            values[writeOffset + j2] = values[readOffset + j2];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j2 = 0; j2 !== stride; ++j2) {
        values[writeOffset + j2] = values[readOffset + j2];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }
    return this;
  }
  clone() {
    const times = AnimationUtils.arraySlice(this.times, 0);
    const values = AnimationUtils.arraySlice(this.values, 0);
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times, values);
    track.createInterpolant = this.createInterpolant;
    return track;
  }
}
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
class BooleanKeyframeTrack extends KeyframeTrack {
}
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class ColorKeyframeTrack extends KeyframeTrack {
}
ColorKeyframeTrack.prototype.ValueTypeName = "color";
class NumberKeyframeTrack extends KeyframeTrack {
}
NumberKeyframeTrack.prototype.ValueTypeName = "number";
function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: QuaternionLinearInterpolant,
  interpolate_: function(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t2 - t0) / (t1 - t0);
    let offset = i1 * stride;
    for (let end = offset + stride; offset !== end; offset += 4) {
      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
    }
    return result;
  }
});
class QuaternionKeyframeTrack extends KeyframeTrack {
  InterpolantFactoryMethodLinear(result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
}
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class StringKeyframeTrack extends KeyframeTrack {
}
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class VectorKeyframeTrack extends KeyframeTrack {
}
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
class AnimationClip {
  constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
    this.name = name;
    this.tracks = tracks;
    this.duration = duration;
    this.blendMode = blendMode;
    this.uuid = MathUtils.generateUUID();
    if (this.duration < 0) {
      this.resetDuration();
    }
  }
  static parse(json) {
    const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
    for (let i2 = 0, n2 = jsonTracks.length; i2 !== n2; ++i2) {
      tracks.push(parseKeyframeTrack(jsonTracks[i2]).scale(frameTime));
    }
    const clip = new this(json.name, json.duration, tracks, json.blendMode);
    clip.uuid = json.uuid;
    return clip;
  }
  static toJSON(clip) {
    const tracks = [], clipTracks = clip.tracks;
    const json = {
      name: clip.name,
      duration: clip.duration,
      tracks,
      uuid: clip.uuid,
      blendMode: clip.blendMode
    };
    for (let i2 = 0, n2 = clipTracks.length; i2 !== n2; ++i2) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i2]));
    }
    return json;
  }
  static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
    const numMorphTargets = morphTargetSequence.length;
    const tracks = [];
    for (let i2 = 0; i2 < numMorphTargets; i2++) {
      let times = [];
      let values = [];
      times.push((i2 + numMorphTargets - 1) % numMorphTargets, i2, (i2 + 1) % numMorphTargets);
      values.push(0, 1, 0);
      const order = AnimationUtils.getKeyframeOrder(times);
      times = AnimationUtils.sortedArray(times, 1, order);
      values = AnimationUtils.sortedArray(values, 1, order);
      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }
      tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i2].name + "]", times, values).scale(1 / fps));
    }
    return new this(name, -1, tracks);
  }
  static findByName(objectOrClipArray, name) {
    let clipArray = objectOrClipArray;
    if (!Array.isArray(objectOrClipArray)) {
      const o2 = objectOrClipArray;
      clipArray = o2.geometry && o2.geometry.animations || o2.animations;
    }
    for (let i2 = 0; i2 < clipArray.length; i2++) {
      if (clipArray[i2].name === name) {
        return clipArray[i2];
      }
    }
    return null;
  }
  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
    const animationToMorphTargets = {};
    const pattern = /^([\w-]*?)([\d]+)$/;
    for (let i2 = 0, il = morphTargets.length; i2 < il; i2++) {
      const morphTarget = morphTargets[i2];
      const parts = morphTarget.name.match(pattern);
      if (parts && parts.length > 1) {
        const name = parts[1];
        let animationMorphTargets = animationToMorphTargets[name];
        if (!animationMorphTargets) {
          animationToMorphTargets[name] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
      }
    }
    const clips = [];
    for (const name in animationToMorphTargets) {
      clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
    }
    return clips;
  }
  static parseAnimation(animation, bones) {
    if (!animation) {
      console.error("THREE.AnimationClip: No animation in JSONLoader data.");
      return null;
    }
    const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
      if (animationKeys.length !== 0) {
        const times = [];
        const values = [];
        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values));
        }
      }
    };
    const tracks = [];
    const clipName = animation.name || "default";
    const fps = animation.fps || 30;
    const blendMode = animation.blendMode;
    let duration = animation.length || -1;
    const hierarchyTracks = animation.hierarchy || [];
    for (let h2 = 0; h2 < hierarchyTracks.length; h2++) {
      const animationKeys = hierarchyTracks[h2].keys;
      if (!animationKeys || animationKeys.length === 0)
        continue;
      if (animationKeys[0].morphTargets) {
        const morphTargetNames = {};
        let k2;
        for (k2 = 0; k2 < animationKeys.length; k2++) {
          if (animationKeys[k2].morphTargets) {
            for (let m2 = 0; m2 < animationKeys[k2].morphTargets.length; m2++) {
              morphTargetNames[animationKeys[k2].morphTargets[m2]] = -1;
            }
          }
        }
        for (const morphTargetName in morphTargetNames) {
          const times = [];
          const values = [];
          for (let m2 = 0; m2 !== animationKeys[k2].morphTargets.length; ++m2) {
            const animationKey = animationKeys[k2];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
        }
        duration = morphTargetNames.length * (fps || 1);
      } else {
        const boneName = ".bones[" + bones[h2].name + "]";
        addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
        addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
        addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
      }
    }
    if (tracks.length === 0) {
      return null;
    }
    const clip = new this(clipName, duration, tracks, blendMode);
    return clip;
  }
  resetDuration() {
    const tracks = this.tracks;
    let duration = 0;
    for (let i2 = 0, n2 = tracks.length; i2 !== n2; ++i2) {
      const track = this.tracks[i2];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }
    this.duration = duration;
    return this;
  }
  trim() {
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      this.tracks[i2].trim(0, this.duration);
    }
    return this;
  }
  validate() {
    let valid = true;
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      valid = valid && this.tracks[i2].validate();
    }
    return valid;
  }
  optimize() {
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      this.tracks[i2].optimize();
    }
    return this;
  }
  clone() {
    const tracks = [];
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      tracks.push(this.tracks[i2].clone());
    }
    return new this.constructor(this.name, this.duration, tracks, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json) {
  if (json.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  const trackType = getTrackTypeForValueTypeName(json.type);
  if (json.times === void 0) {
    const times = [], values = [];
    AnimationUtils.flattenJSON(json.keys, times, values, "value");
    json.times = times;
    json.values = values;
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json);
  } else {
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}
const Cache = {
  enabled: false,
  files: {},
  add: function(key, file) {
    if (this.enabled === false)
      return;
    this.files[key] = file;
  },
  get: function(key) {
    if (this.enabled === false)
      return;
    return this.files[key];
  },
  remove: function(key) {
    delete this.files[key];
  },
  clear: function() {
    this.files = {};
  }
};
function LoadingManager(onLoad, onProgress, onError) {
  const scope = this;
  let isLoading = false;
  let itemsLoaded = 0;
  let itemsTotal = 0;
  let urlModifier = void 0;
  const handlers = [];
  this.onStart = void 0;
  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;
  this.itemStart = function(url) {
    itemsTotal++;
    if (isLoading === false) {
      if (scope.onStart !== void 0) {
        scope.onStart(url, itemsLoaded, itemsTotal);
      }
    }
    isLoading = true;
  };
  this.itemEnd = function(url) {
    itemsLoaded++;
    if (scope.onProgress !== void 0) {
      scope.onProgress(url, itemsLoaded, itemsTotal);
    }
    if (itemsLoaded === itemsTotal) {
      isLoading = false;
      if (scope.onLoad !== void 0) {
        scope.onLoad();
      }
    }
  };
  this.itemError = function(url) {
    if (scope.onError !== void 0) {
      scope.onError(url);
    }
  };
  this.resolveURL = function(url) {
    if (urlModifier) {
      return urlModifier(url);
    }
    return url;
  };
  this.setURLModifier = function(transform) {
    urlModifier = transform;
    return this;
  };
  this.addHandler = function(regex, loader) {
    handlers.push(regex, loader);
    return this;
  };
  this.removeHandler = function(regex) {
    const index = handlers.indexOf(regex);
    if (index !== -1) {
      handlers.splice(index, 2);
    }
    return this;
  };
  this.getHandler = function(file) {
    for (let i2 = 0, l2 = handlers.length; i2 < l2; i2 += 2) {
      const regex = handlers[i2];
      const loader = handlers[i2 + 1];
      if (regex.global)
        regex.lastIndex = 0;
      if (regex.test(file)) {
        return loader;
      }
    }
    return null;
  };
}
const DefaultLoadingManager = new LoadingManager();
function Loader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  this.crossOrigin = "anonymous";
  this.withCredentials = false;
  this.path = "";
  this.resourcePath = "";
  this.requestHeader = {};
}
Object.assign(Loader.prototype, {
  load: function() {
  },
  loadAsync: function(url, onProgress) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.load(url, resolve, onProgress, reject);
    });
  },
  parse: function() {
  },
  setCrossOrigin: function(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  },
  setWithCredentials: function(value) {
    this.withCredentials = value;
    return this;
  },
  setPath: function(path) {
    this.path = path;
    return this;
  },
  setResourcePath: function(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  },
  setRequestHeader: function(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
});
const loading = {};
function FileLoader(manager) {
  Loader.call(this, manager);
}
FileLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: FileLoader,
  load: function(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    if (loading[url] !== void 0) {
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      return;
    }
    const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
    const dataUriRegexResult = url.match(dataUriRegex);
    let request;
    if (dataUriRegexResult) {
      const mimeType = dataUriRegexResult[1];
      const isBase64 = !!dataUriRegexResult[2];
      let data = dataUriRegexResult[3];
      data = decodeURIComponent(data);
      if (isBase64)
        data = atob(data);
      try {
        let response;
        const responseType = (this.responseType || "").toLowerCase();
        switch (responseType) {
          case "arraybuffer":
          case "blob":
            const view = new Uint8Array(data.length);
            for (let i2 = 0; i2 < data.length; i2++) {
              view[i2] = data.charCodeAt(i2);
            }
            if (responseType === "blob") {
              response = new Blob([view.buffer], {type: mimeType});
            } else {
              response = view.buffer;
            }
            break;
          case "document":
            const parser = new DOMParser();
            response = parser.parseFromString(data, mimeType);
            break;
          case "json":
            response = JSON.parse(data);
            break;
          default:
            response = data;
            break;
        }
        setTimeout(function() {
          if (onLoad)
            onLoad(response);
          scope.manager.itemEnd(url);
        }, 0);
      } catch (error) {
        setTimeout(function() {
          if (onError)
            onError(error);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }, 0);
      }
    } else {
      loading[url] = [];
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      request = new XMLHttpRequest();
      request.open("GET", url, true);
      request.addEventListener("load", function(event) {
        const response = this.response;
        const callbacks = loading[url];
        delete loading[url];
        if (this.status === 200 || this.status === 0) {
          if (this.status === 0)
            console.warn("THREE.FileLoader: HTTP Status 0 received.");
          Cache.add(url, response);
          for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
            const callback = callbacks[i2];
            if (callback.onLoad)
              callback.onLoad(response);
          }
          scope.manager.itemEnd(url);
        } else {
          for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
            const callback = callbacks[i2];
            if (callback.onError)
              callback.onError(event);
          }
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }
      }, false);
      request.addEventListener("progress", function(event) {
        const callbacks = loading[url];
        for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
          const callback = callbacks[i2];
          if (callback.onProgress)
            callback.onProgress(event);
        }
      }, false);
      request.addEventListener("error", function(event) {
        const callbacks = loading[url];
        delete loading[url];
        for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
          const callback = callbacks[i2];
          if (callback.onError)
            callback.onError(event);
        }
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      request.addEventListener("abort", function(event) {
        const callbacks = loading[url];
        delete loading[url];
        for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
          const callback = callbacks[i2];
          if (callback.onError)
            callback.onError(event);
        }
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      if (this.responseType !== void 0)
        request.responseType = this.responseType;
      if (this.withCredentials !== void 0)
        request.withCredentials = this.withCredentials;
      if (request.overrideMimeType)
        request.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
      for (const header in this.requestHeader) {
        request.setRequestHeader(header, this.requestHeader[header]);
      }
      request.send(null);
    }
    scope.manager.itemStart(url);
    return request;
  },
  setResponseType: function(value) {
    this.responseType = value;
    return this;
  },
  setMimeType: function(value) {
    this.mimeType = value;
    return this;
  }
});
function CompressedTextureLoader(manager) {
  Loader.call(this, manager);
}
CompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: CompressedTextureLoader,
  load: function(url, onLoad, onProgress, onError) {
    const scope = this;
    const images = [];
    const texture = new CompressedTexture();
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    let loaded = 0;
    function loadTexture(i2) {
      loader.load(url[i2], function(buffer) {
        const texDatas = scope.parse(buffer, true);
        images[i2] = {
          width: texDatas.width,
          height: texDatas.height,
          format: texDatas.format,
          mipmaps: texDatas.mipmaps
        };
        loaded += 1;
        if (loaded === 6) {
          if (texDatas.mipmapCount === 1)
            texture.minFilter = LinearFilter;
          texture.image = images;
          texture.format = texDatas.format;
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }
      }, onProgress, onError);
    }
    if (Array.isArray(url)) {
      for (let i2 = 0, il = url.length; i2 < il; ++i2) {
        loadTexture(i2);
      }
    } else {
      loader.load(url, function(buffer) {
        const texDatas = scope.parse(buffer, true);
        if (texDatas.isCubemap) {
          const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
          for (let f2 = 0; f2 < faces; f2++) {
            images[f2] = {mipmaps: []};
            for (let i2 = 0; i2 < texDatas.mipmapCount; i2++) {
              images[f2].mipmaps.push(texDatas.mipmaps[f2 * texDatas.mipmapCount + i2]);
              images[f2].format = texDatas.format;
              images[f2].width = texDatas.width;
              images[f2].height = texDatas.height;
            }
          }
          texture.image = images;
        } else {
          texture.image.width = texDatas.width;
          texture.image.height = texDatas.height;
          texture.mipmaps = texDatas.mipmaps;
        }
        if (texDatas.mipmapCount === 1) {
          texture.minFilter = LinearFilter;
        }
        texture.format = texDatas.format;
        texture.needsUpdate = true;
        if (onLoad)
          onLoad(texture);
      }, onProgress, onError);
    }
    return texture;
  }
});
class ImageLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
    function onImageLoad() {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
      Cache.add(url, this);
      if (onLoad)
        onLoad(this);
      scope.manager.itemEnd(url);
    }
    function onImageError(event) {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
      if (onError)
        onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }
    image.addEventListener("load", onImageLoad, false);
    image.addEventListener("error", onImageError, false);
    if (url.substr(0, 5) !== "data:") {
      if (this.crossOrigin !== void 0)
        image.crossOrigin = this.crossOrigin;
    }
    scope.manager.itemStart(url);
    image.src = url;
    return image;
  }
}
class CubeTextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(urls, onLoad, onProgress, onError) {
    const texture = new CubeTexture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    let loaded = 0;
    function loadTexture(i2) {
      loader.load(urls[i2], function(image) {
        texture.images[i2] = image;
        loaded++;
        if (loaded === 6) {
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }
      }, void 0, onError);
    }
    for (let i2 = 0; i2 < urls.length; ++i2) {
      loadTexture(i2);
    }
    return texture;
  }
}
function DataTextureLoader(manager) {
  Loader.call(this, manager);
}
DataTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: DataTextureLoader,
  load: function(url, onLoad, onProgress, onError) {
    const scope = this;
    const texture = new DataTexture();
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setPath(this.path);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(buffer) {
      const texData = scope.parse(buffer);
      if (!texData)
        return;
      if (texData.image !== void 0) {
        texture.image = texData.image;
      } else if (texData.data !== void 0) {
        texture.image.width = texData.width;
        texture.image.height = texData.height;
        texture.image.data = texData.data;
      }
      texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping;
      texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping;
      texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter;
      texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearFilter;
      texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
      if (texData.encoding !== void 0) {
        texture.encoding = texData.encoding;
      }
      if (texData.flipY !== void 0) {
        texture.flipY = texData.flipY;
      }
      if (texData.format !== void 0) {
        texture.format = texData.format;
      }
      if (texData.type !== void 0) {
        texture.type = texData.type;
      }
      if (texData.mipmaps !== void 0) {
        texture.mipmaps = texData.mipmaps;
        texture.minFilter = LinearMipmapLinearFilter;
      }
      if (texData.mipmapCount === 1) {
        texture.minFilter = LinearFilter;
      }
      if (texData.generateMipmaps !== void 0) {
        texture.generateMipmaps = texData.generateMipmaps;
      }
      texture.needsUpdate = true;
      if (onLoad)
        onLoad(texture, texData);
    }, onProgress, onError);
    return texture;
  }
});
function TextureLoader(manager) {
  Loader.call(this, manager);
}
TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: TextureLoader,
  load: function(url, onLoad, onProgress, onError) {
    const texture = new Texture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function(image) {
      texture.image = image;
      const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
      texture.format = isJPEG ? RGBFormat : RGBAFormat;
      texture.needsUpdate = true;
      if (onLoad !== void 0) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  }
});
function Curve() {
  this.type = "Curve";
  this.arcLengthDivisions = 200;
}
Object.assign(Curve.prototype, {
  getPoint: function() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  },
  getPointAt: function(u2, optionalTarget) {
    const t2 = this.getUtoTmapping(u2);
    return this.getPoint(t2, optionalTarget);
  },
  getPoints: function(divisions = 5) {
    const points = [];
    for (let d2 = 0; d2 <= divisions; d2++) {
      points.push(this.getPoint(d2 / divisions));
    }
    return points;
  },
  getSpacedPoints: function(divisions = 5) {
    const points = [];
    for (let d2 = 0; d2 <= divisions; d2++) {
      points.push(this.getPointAt(d2 / divisions));
    }
    return points;
  },
  getLength: function() {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  },
  getLengths: function(divisions) {
    if (divisions === void 0)
      divisions = this.arcLengthDivisions;
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = false;
    const cache = [];
    let current, last = this.getPoint(0);
    let sum = 0;
    cache.push(0);
    for (let p2 = 1; p2 <= divisions; p2++) {
      current = this.getPoint(p2 / divisions);
      sum += current.distanceTo(last);
      cache.push(sum);
      last = current;
    }
    this.cacheArcLengths = cache;
    return cache;
  },
  updateArcLengths: function() {
    this.needsUpdate = true;
    this.getLengths();
  },
  getUtoTmapping: function(u2, distance) {
    const arcLengths = this.getLengths();
    let i2 = 0;
    const il = arcLengths.length;
    let targetArcLength;
    if (distance) {
      targetArcLength = distance;
    } else {
      targetArcLength = u2 * arcLengths[il - 1];
    }
    let low = 0, high = il - 1, comparison;
    while (low <= high) {
      i2 = Math.floor(low + (high - low) / 2);
      comparison = arcLengths[i2] - targetArcLength;
      if (comparison < 0) {
        low = i2 + 1;
      } else if (comparison > 0) {
        high = i2 - 1;
      } else {
        high = i2;
        break;
      }
    }
    i2 = high;
    if (arcLengths[i2] === targetArcLength) {
      return i2 / (il - 1);
    }
    const lengthBefore = arcLengths[i2];
    const lengthAfter = arcLengths[i2 + 1];
    const segmentLength = lengthAfter - lengthBefore;
    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
    const t2 = (i2 + segmentFraction) / (il - 1);
    return t2;
  },
  getTangent: function(t2, optionalTarget) {
    const delta = 1e-4;
    let t1 = t2 - delta;
    let t22 = t2 + delta;
    if (t1 < 0)
      t1 = 0;
    if (t22 > 1)
      t22 = 1;
    const pt1 = this.getPoint(t1);
    const pt2 = this.getPoint(t22);
    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  },
  getTangentAt: function(u2, optionalTarget) {
    const t2 = this.getUtoTmapping(u2);
    return this.getTangent(t2, optionalTarget);
  },
  computeFrenetFrames: function(segments, closed) {
    const normal = new Vector3();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new Vector3();
    const mat = new Matrix4();
    for (let i2 = 0; i2 <= segments; i2++) {
      const u2 = i2 / segments;
      tangents[i2] = this.getTangentAt(u2, new Vector3());
      tangents[i2].normalize();
    }
    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    let min = Number.MAX_VALUE;
    const tx = Math.abs(tangents[0].x);
    const ty = Math.abs(tangents[0].y);
    const tz = Math.abs(tangents[0].z);
    if (tx <= min) {
      min = tx;
      normal.set(1, 0, 0);
    }
    if (ty <= min) {
      min = ty;
      normal.set(0, 1, 0);
    }
    if (tz <= min) {
      normal.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
    for (let i2 = 1; i2 <= segments; i2++) {
      normals[i2] = normals[i2 - 1].clone();
      binormals[i2] = binormals[i2 - 1].clone();
      vec.crossVectors(tangents[i2 - 1], tangents[i2]);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(MathUtils.clamp(tangents[i2 - 1].dot(tangents[i2]), -1, 1));
        normals[i2].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }
      binormals[i2].crossVectors(tangents[i2], normals[i2]);
    }
    if (closed === true) {
      let theta = Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;
      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }
      for (let i2 = 1; i2 <= segments; i2++) {
        normals[i2].applyMatrix4(mat.makeRotationAxis(tangents[i2], theta * i2));
        binormals[i2].crossVectors(tangents[i2], normals[i2]);
      }
    }
    return {
      tangents,
      normals,
      binormals
    };
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  },
  toJSON: function() {
    const data = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  },
  fromJSON: function(json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }
});
class Light extends Object3D {
  constructor(color, intensity = 1) {
    super();
    this.type = "Light";
    this.color = new Color(color);
    this.intensity = intensity;
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== void 0)
      data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== void 0)
      data.object.distance = this.distance;
    if (this.angle !== void 0)
      data.object.angle = this.angle;
    if (this.decay !== void 0)
      data.object.decay = this.decay;
    if (this.penumbra !== void 0)
      data.object.penumbra = this.penumbra;
    if (this.shadow !== void 0)
      data.object.shadow = this.shadow.toJSON();
    return data;
  }
}
Light.prototype.isLight = true;
const _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
const _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
const _lookTarget$1 = /* @__PURE__ */ new Vector3();
class LightShadow {
  constructor(camera) {
    this.camera = camera;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [
      new Vector4(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(light) {
    const shadowCamera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
    shadowCamera.position.copy(_lightPositionWorld$1);
    _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
    shadowCamera.lookAt(_lookTarget$1);
    shadowCamera.updateMatrixWorld();
    _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
    shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
    shadowMatrix.multiply(shadowCamera.projectionMatrix);
    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
  }
  getViewport(viewportIndex) {
    return this._viewports[viewportIndex];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  copy(source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const object = {};
    if (this.bias !== 0)
      object.bias = this.bias;
    if (this.normalBias !== 0)
      object.normalBias = this.normalBias;
    if (this.radius !== 1)
      object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
      object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
}
class SpotLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500));
    this.focus = 1;
  }
  updateMatrices(light) {
    const camera = this.camera;
    const fov2 = MathUtils.RAD2DEG * 2 * light.angle * this.focus;
    const aspect2 = this.mapSize.width / this.mapSize.height;
    const far = light.distance || camera.far;
    if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
      camera.fov = fov2;
      camera.aspect = aspect2;
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    super.updateMatrices(light);
  }
  copy(source) {
    super.copy(source);
    this.focus = source.focus;
    return this;
  }
}
SpotLightShadow.prototype.isSpotLightShadow = true;
class SpotLight extends Light {
  constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
    super(color, intensity);
    this.type = "SpotLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.distance = distance;
    this.angle = angle;
    this.penumbra = penumbra;
    this.decay = decay;
    this.shadow = new SpotLightShadow();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(power) {
    this.intensity = power / Math.PI;
  }
  copy(source) {
    super.copy(source);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
}
SpotLight.prototype.isSpotLight = true;
const _projScreenMatrix = /* @__PURE__ */ new Matrix4();
const _lightPositionWorld = /* @__PURE__ */ new Vector3();
const _lookTarget = /* @__PURE__ */ new Vector3();
class PointLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500));
    this._frameExtents = new Vector2(4, 2);
    this._viewportCount = 6;
    this._viewports = [
      new Vector4(2, 1, 1, 1),
      new Vector4(0, 1, 1, 1),
      new Vector4(3, 1, 1, 1),
      new Vector4(1, 1, 1, 1),
      new Vector4(3, 0, 1, 1),
      new Vector4(1, 0, 1, 1)
    ];
    this._cubeDirections = [
      new Vector3(1, 0, 0),
      new Vector3(-1, 0, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1),
      new Vector3(0, 1, 0),
      new Vector3(0, -1, 0)
    ];
    this._cubeUps = [
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1)
    ];
  }
  updateMatrices(light, viewportIndex = 0) {
    const camera = this.camera;
    const shadowMatrix = this.matrix;
    const far = light.distance || camera.far;
    if (far !== camera.far) {
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    camera.position.copy(_lightPositionWorld);
    _lookTarget.copy(camera.position);
    _lookTarget.add(this._cubeDirections[viewportIndex]);
    camera.up.copy(this._cubeUps[viewportIndex]);
    camera.lookAt(_lookTarget);
    camera.updateMatrixWorld();
    shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix);
  }
}
PointLightShadow.prototype.isPointLightShadow = true;
class PointLight extends Light {
  constructor(color, intensity, distance = 0, decay = 1) {
    super(color, intensity);
    this.type = "PointLight";
    this.distance = distance;
    this.decay = decay;
    this.shadow = new PointLightShadow();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(power) {
    this.intensity = power / (4 * Math.PI);
  }
  copy(source) {
    super.copy(source);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
}
PointLight.prototype.isPointLight = true;
class OrthographicCamera extends Camera {
  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
    super();
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  }
  setViewOffset(fullWidth, fullHeight, x2, y2, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x2;
    this.view.offsetY = y2;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = Object3D.prototype.toJSON.call(this, meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    return data;
  }
}
OrthographicCamera.prototype.isOrthographicCamera = true;
class DirectionalLightShadow extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
  }
}
DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
class DirectionalLight extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
  }
  copy(source) {
    super.copy(source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
}
DirectionalLight.prototype.isDirectionalLight = true;
const LoaderUtils = {
  decodeText: function(array) {
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array);
    }
    let s2 = "";
    for (let i2 = 0, il = array.length; i2 < il; i2++) {
      s2 += String.fromCharCode(array[i2]);
    }
    try {
      return decodeURIComponent(escape(s2));
    } catch (e2) {
      return s2;
    }
  },
  extractUrlBase: function(url) {
    const index = url.lastIndexOf("/");
    if (index === -1)
      return "./";
    return url.substr(0, index + 1);
  }
};
function InstancedBufferGeometry() {
  BufferGeometry.call(this);
  this.type = "InstancedBufferGeometry";
  this.instanceCount = Infinity;
}
InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
  constructor: InstancedBufferGeometry,
  isInstancedBufferGeometry: true,
  copy: function(source) {
    BufferGeometry.prototype.copy.call(this, source);
    this.instanceCount = source.instanceCount;
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  toJSON: function() {
    const data = BufferGeometry.prototype.toJSON.call(this);
    data.instanceCount = this.instanceCount;
    data.isInstancedBufferGeometry = true;
    return data;
  }
});
function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
  if (typeof normalized === "number") {
    meshPerAttribute = normalized;
    normalized = false;
    console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
  }
  BufferAttribute.call(this, array, itemSize, normalized);
  this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
  constructor: InstancedBufferAttribute,
  isInstancedBufferAttribute: true,
  copy: function(source) {
    BufferAttribute.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  },
  toJSON: function() {
    const data = BufferAttribute.prototype.toJSON.call(this);
    data.meshPerAttribute = this.meshPerAttribute;
    data.isInstancedBufferAttribute = true;
    return data;
  }
});
function ImageBitmapLoader(manager) {
  if (typeof createImageBitmap === "undefined") {
    console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
  }
  if (typeof fetch === "undefined") {
    console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
  }
  Loader.call(this, manager);
  this.options = {premultiplyAlpha: "none"};
}
ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: ImageBitmapLoader,
  isImageBitmapLoader: true,
  setOptions: function setOptions(options) {
    this.options = options;
    return this;
  },
  load: function(url, onLoad, onProgress, onError) {
    if (url === void 0)
      url = "";
    if (this.path !== void 0)
      url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad)
          onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const fetchOptions = {};
    fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
    fetchOptions.headers = this.requestHeader;
    fetch(url, fetchOptions).then(function(res) {
      return res.blob();
    }).then(function(blob) {
      return createImageBitmap(blob, Object.assign(scope.options, {colorSpaceConversion: "none"}));
    }).then(function(imageBitmap) {
      Cache.add(url, imageBitmap);
      if (onLoad)
        onLoad(imageBitmap);
      scope.manager.itemEnd(url);
    }).catch(function(e2) {
      if (onError)
        onError(e2);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    });
    scope.manager.itemStart(url);
  }
});
let _context;
const AudioContext = {
  getContext: function() {
    if (_context === void 0) {
      _context = new (window.AudioContext || window.webkitAudioContext)();
    }
    return _context;
  },
  setContext: function(value) {
    _context = value;
  }
};
class AudioLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(buffer) {
      try {
        const bufferCopy = buffer.slice(0);
        const context = AudioContext.getContext();
        context.decodeAudioData(bufferCopy, function(audioBuffer) {
          onLoad(audioBuffer);
        });
      } catch (e2) {
        if (onError) {
          onError(e2);
        } else {
          console.error(e2);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
}
new Matrix4();
new Matrix4();
class Clock {
  constructor(autoStart) {
    this.autoStart = autoStart !== void 0 ? autoStart : true;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
  }
  start() {
    this.startTime = now();
    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
  }
  stop() {
    this.getElapsedTime();
    this.running = false;
    this.autoStart = false;
  }
  getElapsedTime() {
    this.getDelta();
    return this.elapsedTime;
  }
  getDelta() {
    let diff2 = 0;
    if (this.autoStart && !this.running) {
      this.start();
      return 0;
    }
    if (this.running) {
      const newTime = now();
      diff2 = (newTime - this.oldTime) / 1e3;
      this.oldTime = newTime;
      this.elapsedTime += diff2;
    }
    return diff2;
  }
}
function now() {
  return (typeof performance === "undefined" ? Date : performance).now();
}
const _position$1 = /* @__PURE__ */ new Vector3();
const _quaternion$1 = /* @__PURE__ */ new Quaternion();
const _scale$1 = /* @__PURE__ */ new Vector3();
const _orientation$1 = /* @__PURE__ */ new Vector3();
class AudioListener extends Object3D {
  constructor() {
    super();
    this.type = "AudioListener";
    this.context = AudioContext.getContext();
    this.gain = this.context.createGain();
    this.gain.connect(this.context.destination);
    this.filter = null;
    this.timeDelta = 0;
    this._clock = new Clock();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
      this.gain.connect(this.context.destination);
      this.filter = null;
    }
    return this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(value) {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
    } else {
      this.gain.disconnect(this.context.destination);
    }
    this.filter = value;
    this.gain.connect(this.filter);
    this.filter.connect(this.context.destination);
    return this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    const listener = this.context.listener;
    const up = this.up;
    this.timeDelta = this._clock.getDelta();
    this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);
    _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);
    if (listener.positionX) {
      const endTime = this.context.currentTime + this.timeDelta;
      listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
      listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
      listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
      listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
      listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
      listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
      listener.upX.linearRampToValueAtTime(up.x, endTime);
      listener.upY.linearRampToValueAtTime(up.y, endTime);
      listener.upZ.linearRampToValueAtTime(up.z, endTime);
    } else {
      listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
      listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);
    }
  }
}
class Audio extends Object3D {
  constructor(listener) {
    super();
    this.type = "Audio";
    this.listener = listener;
    this.context = listener.context;
    this.gain = this.context.createGain();
    this.gain.connect(listener.getInput());
    this.autoplay = false;
    this.buffer = null;
    this.detune = 0;
    this.loop = false;
    this.loopStart = 0;
    this.loopEnd = 0;
    this.offset = 0;
    this.duration = void 0;
    this.playbackRate = 1;
    this.isPlaying = false;
    this.hasPlaybackControl = true;
    this.source = null;
    this.sourceType = "empty";
    this._startedAt = 0;
    this._progress = 0;
    this._connected = false;
    this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(audioNode) {
    this.hasPlaybackControl = false;
    this.sourceType = "audioNode";
    this.source = audioNode;
    this.connect();
    return this;
  }
  setMediaElementSource(mediaElement) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaNode";
    this.source = this.context.createMediaElementSource(mediaElement);
    this.connect();
    return this;
  }
  setMediaStreamSource(mediaStream) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaStreamNode";
    this.source = this.context.createMediaStreamSource(mediaStream);
    this.connect();
    return this;
  }
  setBuffer(audioBuffer) {
    this.buffer = audioBuffer;
    this.sourceType = "buffer";
    if (this.autoplay)
      this.play();
    return this;
  }
  play(delay = 0) {
    if (this.isPlaying === true) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + delay;
    const source = this.context.createBufferSource();
    source.buffer = this.buffer;
    source.loop = this.loop;
    source.loopStart = this.loopStart;
    source.loopEnd = this.loopEnd;
    source.onended = this.onEnded.bind(this);
    source.start(this._startedAt, this._progress + this.offset, this.duration);
    this.isPlaying = true;
    this.source = source;
    this.setDetune(this.detune);
    this.setPlaybackRate(this.playbackRate);
    return this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    if (this.isPlaying === true) {
      this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
      if (this.loop === true) {
        this._progress = this._progress % (this.duration || this.buffer.duration);
      }
      this.source.stop();
      this.source.onended = null;
      this.isPlaying = false;
    }
    return this;
  }
  stop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._progress = 0;
    this.source.stop();
    this.source.onended = null;
    this.isPlaying = false;
    return this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let i2 = 1, l2 = this.filters.length; i2 < l2; i2++) {
        this.filters[i2 - 1].connect(this.filters[i2]);
      }
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }
    this._connected = true;
    return this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let i2 = 1, l2 = this.filters.length; i2 < l2; i2++) {
        this.filters[i2 - 1].disconnect(this.filters[i2]);
      }
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }
    this._connected = false;
    return this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(value) {
    if (!value)
      value = [];
    if (this._connected === true) {
      this.disconnect();
      this.filters = value.slice();
      this.connect();
    } else {
      this.filters = value.slice();
    }
    return this;
  }
  setDetune(value) {
    this.detune = value;
    if (this.source.detune === void 0)
      return;
    if (this.isPlaying === true) {
      this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
    }
    return this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(filter) {
    return this.setFilters(filter ? [filter] : []);
  }
  setPlaybackRate(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.playbackRate = value;
    if (this.isPlaying === true) {
      this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
    }
    return this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = false;
  }
  getLoop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return false;
    }
    return this.loop;
  }
  setLoop(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.loop = value;
    if (this.isPlaying === true) {
      this.source.loop = this.loop;
    }
    return this;
  }
  setLoopStart(value) {
    this.loopStart = value;
    return this;
  }
  setLoopEnd(value) {
    this.loopEnd = value;
    return this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
}
const _position = /* @__PURE__ */ new Vector3();
const _quaternion = /* @__PURE__ */ new Quaternion();
const _scale = /* @__PURE__ */ new Vector3();
const _orientation = /* @__PURE__ */ new Vector3();
class PositionalAudio extends Audio {
  constructor(listener) {
    super(listener);
    this.panner = this.context.createPanner();
    this.panner.panningModel = "HRTF";
    this.panner.connect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(value) {
    this.panner.refDistance = value;
    return this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(value) {
    this.panner.rolloffFactor = value;
    return this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(value) {
    this.panner.distanceModel = value;
    return this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(value) {
    this.panner.maxDistance = value;
    return this;
  }
  setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
    this.panner.coneInnerAngle = coneInnerAngle;
    this.panner.coneOuterAngle = coneOuterAngle;
    this.panner.coneOuterGain = coneOuterGain;
    return this;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.hasPlaybackControl === true && this.isPlaying === false)
      return;
    this.matrixWorld.decompose(_position, _quaternion, _scale);
    _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
    const panner = this.panner;
    if (panner.positionX) {
      const endTime = this.context.currentTime + this.listener.timeDelta;
      panner.positionX.linearRampToValueAtTime(_position.x, endTime);
      panner.positionY.linearRampToValueAtTime(_position.y, endTime);
      panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
      panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
      panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
      panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
    } else {
      panner.setPosition(_position.x, _position.y, _position.z);
      panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
    }
  }
}
class PropertyMixer {
  constructor(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    let mixFunction, mixFunctionAdditive, setIdentity;
    switch (typeName) {
      case "quaternion":
        mixFunction = this._slerp;
        mixFunctionAdditive = this._slerpAdditive;
        setIdentity = this._setAdditiveIdentityQuaternion;
        this.buffer = new Float64Array(valueSize * 6);
        this._workIndex = 5;
        break;
      case "string":
      case "bool":
        mixFunction = this._select;
        mixFunctionAdditive = this._select;
        setIdentity = this._setAdditiveIdentityOther;
        this.buffer = new Array(valueSize * 5);
        break;
      default:
        mixFunction = this._lerp;
        mixFunctionAdditive = this._lerpAdditive;
        setIdentity = this._setAdditiveIdentityNumeric;
        this.buffer = new Float64Array(valueSize * 5);
    }
    this._mixBufferRegion = mixFunction;
    this._mixBufferRegionAdditive = mixFunctionAdditive;
    this._setIdentity = setIdentity;
    this._origIndex = 3;
    this._addIndex = 4;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    this.useCount = 0;
    this.referenceCount = 0;
  }
  accumulate(accuIndex, weight) {
    const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
    let currentWeight = this.cumulativeWeight;
    if (currentWeight === 0) {
      for (let i2 = 0; i2 !== stride; ++i2) {
        buffer[offset + i2] = buffer[i2];
      }
      currentWeight = weight;
    } else {
      currentWeight += weight;
      const mix = weight / currentWeight;
      this._mixBufferRegion(buffer, offset, 0, mix, stride);
    }
    this.cumulativeWeight = currentWeight;
  }
  accumulateAdditive(weight) {
    const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
    if (this.cumulativeWeightAdditive === 0) {
      this._setIdentity();
    }
    this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
    this.cumulativeWeightAdditive += weight;
  }
  apply(accuIndex) {
    const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    if (weight < 1) {
      const originalValueOffset = stride * this._origIndex;
      this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
    }
    if (weightAdditive > 0) {
      this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
    }
    for (let i2 = stride, e2 = stride + stride; i2 !== e2; ++i2) {
      if (buffer[i2] !== buffer[i2 + stride]) {
        binding.setValue(buffer, offset);
        break;
      }
    }
  }
  saveOriginalState() {
    const binding = this.binding;
    const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
    binding.getValue(buffer, originalValueOffset);
    for (let i2 = stride, e2 = originalValueOffset; i2 !== e2; ++i2) {
      buffer[i2] = buffer[originalValueOffset + i2 % stride];
    }
    this._setIdentity();
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
  }
  restoreOriginalState() {
    const originalValueOffset = this.valueSize * 3;
    this.binding.setValue(this.buffer, originalValueOffset);
  }
  _setAdditiveIdentityNumeric() {
    const startIndex = this._addIndex * this.valueSize;
    const endIndex = startIndex + this.valueSize;
    for (let i2 = startIndex; i2 < endIndex; i2++) {
      this.buffer[i2] = 0;
    }
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric();
    this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const startIndex = this._origIndex * this.valueSize;
    const targetIndex = this._addIndex * this.valueSize;
    for (let i2 = 0; i2 < this.valueSize; i2++) {
      this.buffer[targetIndex + i2] = this.buffer[startIndex + i2];
    }
  }
  _select(buffer, dstOffset, srcOffset, t2, stride) {
    if (t2 >= 0.5) {
      for (let i2 = 0; i2 !== stride; ++i2) {
        buffer[dstOffset + i2] = buffer[srcOffset + i2];
      }
    }
  }
  _slerp(buffer, dstOffset, srcOffset, t2) {
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t2);
  }
  _slerpAdditive(buffer, dstOffset, srcOffset, t2, stride) {
    const workOffset = this._workIndex * stride;
    Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t2);
  }
  _lerp(buffer, dstOffset, srcOffset, t2, stride) {
    const s2 = 1 - t2;
    for (let i2 = 0; i2 !== stride; ++i2) {
      const j2 = dstOffset + i2;
      buffer[j2] = buffer[j2] * s2 + buffer[srcOffset + i2] * t2;
    }
  }
  _lerpAdditive(buffer, dstOffset, srcOffset, t2, stride) {
    for (let i2 = 0; i2 !== stride; ++i2) {
      const j2 = dstOffset + i2;
      buffer[j2] = buffer[j2] + buffer[srcOffset + i2] * t2;
    }
  }
}
const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
const _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
const _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
const _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
const _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
const _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
const _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
const _supportedObjectNames = ["material", "materials", "bones"];
function Composite(targetGroup, path, optionalParsedPath) {
  const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
  this._targetGroup = targetGroup;
  this._bindings = targetGroup.subscribe_(path, parsedPath);
}
Object.assign(Composite.prototype, {
  getValue: function(array, offset) {
    this.bind();
    const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
    if (binding !== void 0)
      binding.getValue(array, offset);
  },
  setValue: function(array, offset) {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].setValue(array, offset);
    }
  },
  bind: function() {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].bind();
    }
  },
  unbind: function() {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].unbind();
    }
  }
});
function PropertyBinding(rootNode, path, parsedPath) {
  this.path = path;
  this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
  this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
  this.rootNode = rootNode;
}
Object.assign(PropertyBinding, {
  Composite,
  create: function(root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path, parsedPath);
    } else {
      return new PropertyBinding.Composite(root, path, parsedPath);
    }
  },
  sanitizeNodeName: function(name) {
    return name.replace(/\s/g, "_").replace(_reservedRe, "");
  },
  parseTrackName: function(trackName) {
    const matches = _trackRe.exec(trackName);
    if (!matches) {
      throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
    }
    const results = {
      nodeName: matches[2],
      objectName: matches[3],
      objectIndex: matches[4],
      propertyName: matches[5],
      propertyIndex: matches[6]
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
    if (lastDot !== void 0 && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1);
      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }
    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
    }
    return results;
  },
  findNode: function(root, nodeName) {
    if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    }
    if (root.skeleton) {
      const bone = root.skeleton.getBoneByName(nodeName);
      if (bone !== void 0) {
        return bone;
      }
    }
    if (root.children) {
      const searchNodeSubtree = function(children) {
        for (let i2 = 0; i2 < children.length; i2++) {
          const childNode = children[i2];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          const result = searchNodeSubtree(childNode.children);
          if (result)
            return result;
        }
        return null;
      };
      const subTreeNode = searchNodeSubtree(root.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
});
Object.assign(PropertyBinding.prototype, {
  _getValue_unavailable: function() {
  },
  _setValue_unavailable: function() {
  },
  BindingType: {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  },
  Versioning: {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  },
  GetterByBindingType: [
    function getValue_direct(buffer, offset) {
      buffer[offset] = this.node[this.propertyName];
    },
    function getValue_array(buffer, offset) {
      const source = this.resolvedProperty;
      for (let i2 = 0, n2 = source.length; i2 !== n2; ++i2) {
        buffer[offset++] = source[i2];
      }
    },
    function getValue_arrayElement(buffer, offset) {
      buffer[offset] = this.resolvedProperty[this.propertyIndex];
    },
    function getValue_toArray(buffer, offset) {
      this.resolvedProperty.toArray(buffer, offset);
    }
  ],
  SetterByBindingTypeAndVersioning: [
    [
      function setValue_direct(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
      },
      function setValue_direct_setNeedsUpdate(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
        this.targetObject.needsUpdate = true;
      },
      function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ],
    [
      function setValue_array(buffer, offset) {
        const dest = this.resolvedProperty;
        for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
          dest[i2] = buffer[offset++];
        }
      },
      function setValue_array_setNeedsUpdate(buffer, offset) {
        const dest = this.resolvedProperty;
        for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
          dest[i2] = buffer[offset++];
        }
        this.targetObject.needsUpdate = true;
      },
      function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
        const dest = this.resolvedProperty;
        for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
          dest[i2] = buffer[offset++];
        }
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ],
    [
      function setValue_arrayElement(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
      },
      function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.needsUpdate = true;
      },
      function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ],
    [
      function setValue_fromArray(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
      },
      function setValue_fromArray_setNeedsUpdate(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.needsUpdate = true;
      },
      function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ]
  ],
  getValue: function getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset);
  },
  setValue: function getValue_unbound2(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  },
  bind: function() {
    let targetObject = this.node;
    const parsedPath = this.parsedPath;
    const objectName = parsedPath.objectName;
    const propertyName = parsedPath.propertyName;
    let propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
      this.node = targetObject;
    }
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (!targetObject) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (objectName) {
      let objectIndex = parsedPath.objectIndex;
      switch (objectName) {
        case "materials":
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case "bones":
          if (!targetObject.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (let i2 = 0; i2 < targetObject.length; i2++) {
            if (targetObject[i2].name === objectIndex) {
              objectIndex = i2;
              break;
            }
          }
          break;
        default:
          if (targetObject[objectName] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== void 0) {
        if (targetObject[objectIndex] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }
    const nodeProperty = targetObject[propertyName];
    if (nodeProperty === void 0) {
      const nodeName = parsedPath.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
      return;
    }
    let versioning = this.Versioning.None;
    this.targetObject = targetObject;
    if (targetObject.needsUpdate !== void 0) {
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    }
    let bindingType = this.BindingType.Direct;
    if (propertyIndex !== void 0) {
      if (propertyName === "morphTargetInfluences") {
        if (!targetObject.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (targetObject.geometry.isBufferGeometry) {
          if (!targetObject.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
          }
        } else {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
          return;
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  },
  unbind: function() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
});
Object.assign(PropertyBinding.prototype, {
  _getValue_unbound: PropertyBinding.prototype.getValue,
  _setValue_unbound: PropertyBinding.prototype.setValue
});
class AnimationAction {
  constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot;
    this.blendMode = blendMode;
    const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
    const interpolantSettings = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
    for (let i2 = 0; i2 !== nTracks; ++i2) {
      const interpolant = tracks[i2].createInterpolant(null);
      interpolants[i2] = interpolant;
      interpolant.settings = interpolantSettings;
    }
    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants;
    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null;
    this._byClipCacheIndex = null;
    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1;
    this._startTime = null;
    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity;
    this.paused = false;
    this.enabled = true;
    this.clampWhenFinished = false;
    this.zeroSlopeAtStart = true;
    this.zeroSlopeAtEnd = true;
  }
  play() {
    this._mixer._activateAction(this);
    return this;
  }
  stop() {
    this._mixer._deactivateAction(this);
    return this.reset();
  }
  reset() {
    this.paused = false;
    this.enabled = true;
    this.time = 0;
    this._loopCount = -1;
    this._startTime = null;
    return this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(time) {
    this._startTime = time;
    return this;
  }
  setLoop(mode, repetitions) {
    this.loop = mode;
    this.repetitions = repetitions;
    return this;
  }
  setEffectiveWeight(weight) {
    this.weight = weight;
    this._effectiveWeight = this.enabled ? weight : 0;
    return this.stopFading();
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(duration) {
    return this._scheduleFading(duration, 0, 1);
  }
  fadeOut(duration) {
    return this._scheduleFading(duration, 1, 0);
  }
  crossFadeFrom(fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration);
    this.fadeIn(duration);
    if (warp) {
      const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
      fadeOutAction.warp(1, startEndRatio, duration);
      this.warp(endStartRatio, 1, duration);
    }
    return this;
  }
  crossFadeTo(fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp);
  }
  stopFading() {
    const weightInterpolant = this._weightInterpolant;
    if (weightInterpolant !== null) {
      this._weightInterpolant = null;
      this._mixer._takeBackControlInterpolant(weightInterpolant);
    }
    return this;
  }
  setEffectiveTimeScale(timeScale) {
    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 : timeScale;
    return this.stopWarping();
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(duration) {
    this.timeScale = this._clip.duration / duration;
    return this.stopWarping();
  }
  syncWith(action) {
    this.time = action.time;
    this.timeScale = action.timeScale;
    return this.stopWarping();
  }
  halt(duration) {
    return this.warp(this._effectiveTimeScale, 0, duration);
  }
  warp(startTimeScale, endTimeScale, duration) {
    const mixer = this._mixer, now2 = mixer.time, timeScale = this.timeScale;
    let interpolant = this._timeScaleInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._timeScaleInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now2;
    times[1] = now2 + duration;
    values[0] = startTimeScale / timeScale;
    values[1] = endTimeScale / timeScale;
    return this;
  }
  stopWarping() {
    const timeScaleInterpolant = this._timeScaleInterpolant;
    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null;
      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
    }
    return this;
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(time, deltaTime, timeDirection, accuIndex) {
    if (!this.enabled) {
      this._updateWeight(time);
      return;
    }
    const startTime = this._startTime;
    if (startTime !== null) {
      const timeRunning = (time - startTime) * timeDirection;
      if (timeRunning < 0 || timeDirection === 0) {
        return;
      }
      this._startTime = null;
      deltaTime = timeDirection * timeRunning;
    }
    deltaTime *= this._updateTimeScale(time);
    const clipTime = this._updateTime(deltaTime);
    const weight = this._updateWeight(time);
    if (weight > 0) {
      const interpolants = this._interpolants;
      const propertyMixers = this._propertyBindings;
      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let j2 = 0, m2 = interpolants.length; j2 !== m2; ++j2) {
            interpolants[j2].evaluate(clipTime);
            propertyMixers[j2].accumulateAdditive(weight);
          }
          break;
        case NormalAnimationBlendMode:
        default:
          for (let j2 = 0, m2 = interpolants.length; j2 !== m2; ++j2) {
            interpolants[j2].evaluate(clipTime);
            propertyMixers[j2].accumulate(accuIndex, weight);
          }
      }
    }
  }
  _updateWeight(time) {
    let weight = 0;
    if (this.enabled) {
      weight = this.weight;
      const interpolant = this._weightInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        weight *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopFading();
          if (interpolantValue === 0) {
            this.enabled = false;
          }
        }
      }
    }
    this._effectiveWeight = weight;
    return weight;
  }
  _updateTimeScale(time) {
    let timeScale = 0;
    if (!this.paused) {
      timeScale = this.timeScale;
      const interpolant = this._timeScaleInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        timeScale *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopWarping();
          if (timeScale === 0) {
            this.paused = true;
          } else {
            this.timeScale = timeScale;
          }
        }
      }
    }
    this._effectiveTimeScale = timeScale;
    return timeScale;
  }
  _updateTime(deltaTime) {
    const duration = this._clip.duration;
    const loop = this.loop;
    let time = this.time + deltaTime;
    let loopCount = this._loopCount;
    const pingPong = loop === LoopPingPong;
    if (deltaTime === 0) {
      if (loopCount === -1)
        return time;
      return pingPong && (loopCount & 1) === 1 ? duration - time : time;
    }
    if (loop === LoopOnce) {
      if (loopCount === -1) {
        this._loopCount = 0;
        this._setEndings(true, true, false);
      }
      handle_stop: {
        if (time >= duration) {
          time = duration;
        } else if (time < 0) {
          time = 0;
        } else {
          this.time = time;
          break handle_stop;
        }
        if (this.clampWhenFinished)
          this.paused = true;
        else
          this.enabled = false;
        this.time = time;
        this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: deltaTime < 0 ? -1 : 1
        });
      }
    } else {
      if (loopCount === -1) {
        if (deltaTime >= 0) {
          loopCount = 0;
          this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
          this._setEndings(this.repetitions === 0, true, pingPong);
        }
      }
      if (time >= duration || time < 0) {
        const loopDelta = Math.floor(time / duration);
        time -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        const pending = this.repetitions - loopCount;
        if (pending <= 0) {
          if (this.clampWhenFinished)
            this.paused = true;
          else
            this.enabled = false;
          time = deltaTime > 0 ? duration : 0;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: deltaTime > 0 ? 1 : -1
          });
        } else {
          if (pending === 1) {
            const atStart = deltaTime < 0;
            this._setEndings(atStart, !atStart, pingPong);
          } else {
            this._setEndings(false, false, pingPong);
          }
          this._loopCount = loopCount;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta
          });
        }
      } else {
        this.time = time;
      }
      if (pingPong && (loopCount & 1) === 1) {
        return duration - time;
      }
    }
    return time;
  }
  _setEndings(atStart, atEnd, pingPong) {
    const settings = this._interpolantSettings;
    if (pingPong) {
      settings.endingStart = ZeroSlopeEnding;
      settings.endingEnd = ZeroSlopeEnding;
    } else {
      if (atStart) {
        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingStart = WrapAroundEnding;
      }
      if (atEnd) {
        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingEnd = WrapAroundEnding;
      }
    }
  }
  _scheduleFading(duration, weightNow, weightThen) {
    const mixer = this._mixer, now2 = mixer.time;
    let interpolant = this._weightInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._weightInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now2;
    values[0] = weightNow;
    times[1] = now2 + duration;
    values[1] = weightThen;
    return this;
  }
}
class AnimationMixer extends EventDispatcher {
  constructor(root) {
    super();
    this._root = root;
    this._initMemoryManager();
    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1;
  }
  _bindAction(action, prototypeAction) {
    const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
    let bindingsByName = bindingsByRoot[rootUuid];
    if (bindingsByName === void 0) {
      bindingsByName = {};
      bindingsByRoot[rootUuid] = bindingsByName;
    }
    for (let i2 = 0; i2 !== nTracks; ++i2) {
      const track = tracks[i2], trackName = track.name;
      let binding = bindingsByName[trackName];
      if (binding !== void 0) {
        bindings[i2] = binding;
      } else {
        binding = bindings[i2];
        if (binding !== void 0) {
          if (binding._cacheIndex === null) {
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
          }
          continue;
        }
        const path = prototypeAction && prototypeAction._propertyBindings[i2].binding.parsedPath;
        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
        ++binding.referenceCount;
        this._addInactiveBinding(binding, rootUuid, trackName);
        bindings[i2] = binding;
      }
      interpolants[i2].resultBuffer = binding.buffer;
    }
  }
  _activateAction(action) {
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
        this._addInactiveAction(action, clipUuid, rootUuid);
      }
      const bindings = action._propertyBindings;
      for (let i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
        const binding = bindings[i2];
        if (binding.useCount++ === 0) {
          this._lendBinding(binding);
          binding.saveOriginalState();
        }
      }
      this._lendAction(action);
    }
  }
  _deactivateAction(action) {
    if (this._isActiveAction(action)) {
      const bindings = action._propertyBindings;
      for (let i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
        const binding = bindings[i2];
        if (--binding.useCount === 0) {
          binding.restoreOriginalState();
          this._takeBackBinding(binding);
        }
      }
      this._takeBackAction(action);
    }
  }
  _initMemoryManager() {
    this._actions = [];
    this._nActiveActions = 0;
    this._actionsByClip = {};
    this._bindings = [];
    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {};
    this._controlInterpolants = [];
    this._nActiveControlInterpolants = 0;
    const scope = this;
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length;
        },
        get inUse() {
          return scope._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return scope._bindings.length;
        },
        get inUse() {
          return scope._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length;
        },
        get inUse() {
          return scope._nActiveControlInterpolants;
        }
      }
    };
  }
  _isActiveAction(action) {
    const index = action._cacheIndex;
    return index !== null && index < this._nActiveActions;
  }
  _addInactiveAction(action, clipUuid, rootUuid) {
    const actions = this._actions, actionsByClip = this._actionsByClip;
    let actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip === void 0) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {}
      };
      action._byClipCacheIndex = 0;
      actionsByClip[clipUuid] = actionsForClip;
    } else {
      const knownActions = actionsForClip.knownActions;
      action._byClipCacheIndex = knownActions.length;
      knownActions.push(action);
    }
    action._cacheIndex = actions.length;
    actions.push(action);
    actionsForClip.actionByRoot[rootUuid] = action;
  }
  _removeInactiveAction(action) {
    const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
    lastInactiveAction._cacheIndex = cacheIndex;
    actions[cacheIndex] = lastInactiveAction;
    actions.pop();
    action._cacheIndex = null;
    const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
    knownActionsForClip.pop();
    action._byClipCacheIndex = null;
    const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
    delete actionByRoot[rootUuid];
    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid];
    }
    this._removeInactiveBindingsForAction(action);
  }
  _removeInactiveBindingsForAction(action) {
    const bindings = action._propertyBindings;
    for (let i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
      const binding = bindings[i2];
      if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding);
      }
    }
  }
  _lendAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
    action._cacheIndex = lastActiveIndex;
    actions[lastActiveIndex] = action;
    firstInactiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = firstInactiveAction;
  }
  _takeBackAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
    action._cacheIndex = firstInactiveIndex;
    actions[firstInactiveIndex] = action;
    lastActiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = lastActiveAction;
  }
  _addInactiveBinding(binding, rootUuid, trackName) {
    const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
    let bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName === void 0) {
      bindingByName = {};
      bindingsByRoot[rootUuid] = bindingByName;
    }
    bindingByName[trackName] = binding;
    binding._cacheIndex = bindings.length;
    bindings.push(binding);
  }
  _removeInactiveBinding(binding) {
    const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[cacheIndex] = lastInactiveBinding;
    bindings.pop();
    delete bindingByName[trackName];
    if (Object.keys(bindingByName).length === 0) {
      delete bindingsByRoot[rootUuid];
    }
  }
  _lendBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
    binding._cacheIndex = lastActiveIndex;
    bindings[lastActiveIndex] = binding;
    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = firstInactiveBinding;
  }
  _takeBackBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
    binding._cacheIndex = firstInactiveIndex;
    bindings[firstInactiveIndex] = binding;
    lastActiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = lastActiveBinding;
  }
  _lendControlInterpolant() {
    const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
    let interpolant = interpolants[lastActiveIndex];
    if (interpolant === void 0) {
      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[lastActiveIndex] = interpolant;
    }
    return interpolant;
  }
  _takeBackControlInterpolant(interpolant) {
    const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[firstInactiveIndex] = interpolant;
    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[prevIndex] = lastActiveInterpolant;
  }
  clipAction(clip, optionalRoot, blendMode) {
    const root = optionalRoot || this._root, rootUuid = root.uuid;
    let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
    const clipUuid = clipObject !== null ? clipObject.uuid : clip;
    const actionsForClip = this._actionsByClip[clipUuid];
    let prototypeAction = null;
    if (blendMode === void 0) {
      if (clipObject !== null) {
        blendMode = clipObject.blendMode;
      } else {
        blendMode = NormalAnimationBlendMode;
      }
    }
    if (actionsForClip !== void 0) {
      const existingAction = actionsForClip.actionByRoot[rootUuid];
      if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
        return existingAction;
      }
      prototypeAction = actionsForClip.knownActions[0];
      if (clipObject === null)
        clipObject = prototypeAction._clip;
    }
    if (clipObject === null)
      return null;
    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
    this._bindAction(newAction, prototypeAction);
    this._addInactiveAction(newAction, clipUuid, rootUuid);
    return newAction;
  }
  existingAction(clip, optionalRoot) {
    const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      return actionsForClip.actionByRoot[rootUuid] || null;
    }
    return null;
  }
  stopAllAction() {
    const actions = this._actions, nActions = this._nActiveActions;
    for (let i2 = nActions - 1; i2 >= 0; --i2) {
      actions[i2].stop();
    }
    return this;
  }
  update(deltaTime) {
    deltaTime *= this.timeScale;
    const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
    for (let i2 = 0; i2 !== nActions; ++i2) {
      const action = actions[i2];
      action._update(time, deltaTime, timeDirection, accuIndex);
    }
    const bindings = this._bindings, nBindings = this._nActiveBindings;
    for (let i2 = 0; i2 !== nBindings; ++i2) {
      bindings[i2].apply(accuIndex);
    }
    return this;
  }
  setTime(timeInSeconds) {
    this.time = 0;
    for (let i2 = 0; i2 < this._actions.length; i2++) {
      this._actions[i2].time = 0;
    }
    return this.update(timeInSeconds);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(clip) {
    const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      const actionsToRemove = actionsForClip.knownActions;
      for (let i2 = 0, n2 = actionsToRemove.length; i2 !== n2; ++i2) {
        const action = actionsToRemove[i2];
        this._deactivateAction(action);
        const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        this._removeInactiveBindingsForAction(action);
      }
      delete actionsByClip[clipUuid];
    }
  }
  uncacheRoot(root) {
    const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
    for (const clipUuid in actionsByClip) {
      const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
      if (action !== void 0) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
    const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName !== void 0) {
      for (const trackName in bindingByName) {
        const binding = bindingByName[trackName];
        binding.restoreOriginalState();
        this._removeInactiveBinding(binding);
      }
    }
  }
  uncacheAction(clip, optionalRoot) {
    const action = this.existingAction(clip, optionalRoot);
    if (action !== null) {
      this._deactivateAction(action);
      this._removeInactiveAction(action);
    }
  }
}
AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
  InterleavedBuffer.call(this, array, stride);
  this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
  constructor: InstancedInterleavedBuffer,
  isInstancedInterleavedBuffer: true,
  copy: function(source) {
    InterleavedBuffer.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  },
  clone: function(data) {
    const ib = InterleavedBuffer.prototype.clone.call(this, data);
    ib.meshPerAttribute = this.meshPerAttribute;
    return ib;
  },
  toJSON: function(data) {
    const json = InterleavedBuffer.prototype.toJSON.call(this, data);
    json.isInstancedInterleavedBuffer = true;
    json.meshPerAttribute = this.meshPerAttribute;
    return json;
  }
});
function GLBufferAttribute(buffer, type, itemSize, elementSize, count) {
  this.buffer = buffer;
  this.type = type;
  this.itemSize = itemSize;
  this.elementSize = elementSize;
  this.count = count;
  this.version = 0;
}
Object.defineProperty(GLBufferAttribute.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true)
      this.version++;
  }
});
Object.assign(GLBufferAttribute.prototype, {
  isGLBufferAttribute: true,
  setBuffer: function(buffer) {
    this.buffer = buffer;
    return this;
  },
  setType: function(type, elementSize) {
    this.type = type;
    this.elementSize = elementSize;
    return this;
  },
  setItemSize: function(itemSize) {
    this.itemSize = itemSize;
    return this;
  },
  setCount: function(count) {
    this.count = count;
    return this;
  }
});
function Raycaster(origin, direction, near = 0, far = Infinity) {
  this.ray = new Ray(origin, direction);
  this.near = near;
  this.far = far;
  this.camera = null;
  this.layers = new Layers();
  this.params = {
    Mesh: {},
    Line: {threshold: 1},
    LOD: {},
    Points: {threshold: 1},
    Sprite: {}
  };
  Object.defineProperties(this.params, {
    PointCloud: {
      get: function() {
        console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
        return this.Points;
      }
    }
  });
}
function ascSort(a2, b2) {
  return a2.distance - b2.distance;
}
function intersectObject(object, raycaster, intersects, recursive) {
  if (object.layers.test(raycaster.layers)) {
    object.raycast(raycaster, intersects);
  }
  if (recursive === true) {
    const children = object.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      intersectObject(children[i2], raycaster, intersects, true);
    }
  }
}
Object.assign(Raycaster.prototype, {
  set: function(origin, direction) {
    this.ray.set(origin, direction);
  },
  setFromCamera: function(coords, camera) {
    if (camera && camera.isPerspectiveCamera) {
      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
      this.camera = camera;
    } else if (camera && camera.isOrthographicCamera) {
      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
      this.camera = camera;
    } else {
      console.error("THREE.Raycaster: Unsupported camera type: " + camera.type);
    }
  },
  intersectObject: function(object, recursive = false, intersects = []) {
    intersectObject(object, this, intersects, recursive);
    intersects.sort(ascSort);
    return intersects;
  },
  intersectObjects: function(objects, recursive = false, intersects = []) {
    for (let i2 = 0, l2 = objects.length; i2 < l2; i2++) {
      intersectObject(objects[i2], this, intersects, recursive);
    }
    intersects.sort(ascSort);
    return intersects;
  }
});
function ImmediateRenderObject(material) {
  Object3D.call(this);
  this.material = material;
  this.render = function() {
  };
  this.hasPositions = false;
  this.hasNormals = false;
  this.hasColors = false;
  this.hasUvs = false;
  this.positionArray = null;
  this.normalArray = null;
  this.colorArray = null;
  this.uvArray = null;
  this.count = 0;
}
ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
ImmediateRenderObject.prototype.isImmediateRenderObject = true;
const _axis = /* @__PURE__ */ new Vector3();
let _lineGeometry, _coneGeometry;
class ArrowHelper extends Object3D {
  constructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 16776960, headLength = length * 0.2, headWidth = headLength * 0.2) {
    super();
    this.type = "ArrowHelper";
    if (_lineGeometry === void 0) {
      _lineGeometry = new BufferGeometry();
      _lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
      _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
      _coneGeometry.translate(0, -0.5, 0);
    }
    this.position.copy(origin);
    this.line = new Line(_lineGeometry, new LineBasicMaterial({color, toneMapped: false}));
    this.line.matrixAutoUpdate = false;
    this.add(this.line);
    this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({color, toneMapped: false}));
    this.cone.matrixAutoUpdate = false;
    this.add(this.cone);
    this.setDirection(dir);
    this.setLength(length, headLength, headWidth);
  }
  setDirection(dir) {
    if (dir.y > 0.99999) {
      this.quaternion.set(0, 0, 0, 1);
    } else if (dir.y < -0.99999) {
      this.quaternion.set(1, 0, 0, 0);
    } else {
      _axis.set(dir.z, 0, -dir.x).normalize();
      const radians = Math.acos(dir.y);
      this.quaternion.setFromAxisAngle(_axis, radians);
    }
  }
  setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, length - headLength), 1);
    this.line.updateMatrix();
    this.cone.scale.set(headWidth, headLength, headWidth);
    this.cone.position.y = length;
    this.cone.updateMatrix();
  }
  setColor(color) {
    this.line.material.color.set(color);
    this.cone.material.color.set(color);
  }
  copy(source) {
    super.copy(source, false);
    this.line.copy(source.line);
    this.cone.copy(source.cone);
    return this;
  }
}
const backgroundMaterial = new MeshBasicMaterial({
  side: BackSide,
  depthWrite: false,
  depthTest: false
});
new Mesh(new BoxGeometry(), backgroundMaterial);
Curve.create = function(construct, getPoint) {
  console.log("THREE.Curve.create() has been deprecated");
  construct.prototype = Object.create(Curve.prototype);
  construct.prototype.constructor = construct;
  construct.prototype.getPoint = getPoint;
  return construct;
};
Loader.prototype.extractUrlBase = function(url) {
  console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
  return LoaderUtils.extractUrlBase(url);
};
Loader.Handlers = {
  add: function() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  },
  get: function() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  }
};
Box3.prototype.center = function(optionalTarget) {
  console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Box3.prototype.empty = function() {
  console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Box3.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Box3.prototype.isIntersectionSphere = function(sphere) {
  console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
  return this.intersectsSphere(sphere);
};
Box3.prototype.size = function(optionalTarget) {
  console.warn("THREE.Box3: .size() has been renamed to .getSize().");
  return this.getSize(optionalTarget);
};
Sphere.prototype.empty = function() {
  console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
  return this.isEmpty();
};
Frustum.prototype.setFromMatrix = function(m2) {
  console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
  return this.setFromProjectionMatrix(m2);
};
MathUtils.random16 = function() {
  console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");
  return Math.random();
};
MathUtils.nearestPowerOfTwo = function(value) {
  console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");
  return MathUtils.floorPowerOfTwo(value);
};
MathUtils.nextPowerOfTwo = function(value) {
  console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
  return MathUtils.ceilPowerOfTwo(value);
};
Matrix3.prototype.flattenToArrayOffset = function(array, offset) {
  console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
  return this.toArray(array, offset);
};
Matrix3.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
  return vector.applyMatrix3(this);
};
Matrix3.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
};
Matrix3.prototype.applyToBufferAttribute = function(attribute) {
  console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
  return attribute.applyMatrix3(this);
};
Matrix3.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
};
Matrix3.prototype.getInverse = function(matrix) {
  console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
  return this.copy(matrix).invert();
};
Matrix4.prototype.extractPosition = function(m2) {
  console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
  return this.copyPosition(m2);
};
Matrix4.prototype.flattenToArrayOffset = function(array, offset) {
  console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
  return this.toArray(array, offset);
};
Matrix4.prototype.getPosition = function() {
  console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
  return new Vector3().setFromMatrixColumn(this, 3);
};
Matrix4.prototype.setRotationFromQuaternion = function(q2) {
  console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
  return this.makeRotationFromQuaternion(q2);
};
Matrix4.prototype.multiplyToArray = function() {
  console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
};
Matrix4.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector4 = function(vector) {
  console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
};
Matrix4.prototype.rotateAxis = function(v2) {
  console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
  v2.transformDirection(this);
};
Matrix4.prototype.crossVector = function(vector) {
  console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
  return vector.applyMatrix4(this);
};
Matrix4.prototype.translate = function() {
  console.error("THREE.Matrix4: .translate() has been removed.");
};
Matrix4.prototype.rotateX = function() {
  console.error("THREE.Matrix4: .rotateX() has been removed.");
};
Matrix4.prototype.rotateY = function() {
  console.error("THREE.Matrix4: .rotateY() has been removed.");
};
Matrix4.prototype.rotateZ = function() {
  console.error("THREE.Matrix4: .rotateZ() has been removed.");
};
Matrix4.prototype.rotateByAxis = function() {
  console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
};
Matrix4.prototype.applyToBufferAttribute = function(attribute) {
  console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
  return attribute.applyMatrix4(this);
};
Matrix4.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
};
Matrix4.prototype.makeFrustum = function(left, right, bottom, top, near, far) {
  console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
  return this.makePerspective(left, right, top, bottom, near, far);
};
Matrix4.prototype.getInverse = function(matrix) {
  console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
  return this.copy(matrix).invert();
};
Plane.prototype.isIntersectionLine = function(line) {
  console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
  return this.intersectsLine(line);
};
Quaternion.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
  return vector.applyQuaternion(this);
};
Quaternion.prototype.inverse = function() {
  console.warn("THREE.Quaternion: .inverse() has been renamed to invert().");
  return this.invert();
};
Ray.prototype.isIntersectionBox = function(box) {
  console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
  return this.intersectsBox(box);
};
Ray.prototype.isIntersectionPlane = function(plane) {
  console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
  return this.intersectsPlane(plane);
};
Ray.prototype.isIntersectionSphere = function(sphere) {
  console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
  return this.intersectsSphere(sphere);
};
Triangle.prototype.area = function() {
  console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
  return this.getArea();
};
Triangle.prototype.barycoordFromPoint = function(point, target) {
  console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
  return this.getBarycoord(point, target);
};
Triangle.prototype.midpoint = function(target) {
  console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
  return this.getMidpoint(target);
};
Triangle.prototypenormal = function(target) {
  console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
  return this.getNormal(target);
};
Triangle.prototype.plane = function(target) {
  console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
  return this.getPlane(target);
};
Triangle.barycoordFromPoint = function(point, a2, b2, c2, target) {
  console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
  return Triangle.getBarycoord(point, a2, b2, c2, target);
};
Triangle.normal = function(a2, b2, c2, target) {
  console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
  return Triangle.getNormal(a2, b2, c2, target);
};
Vector2.prototype.fromAttribute = function(attribute, index, offset) {
  console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset);
};
Vector2.prototype.distanceToManhattan = function(v2) {
  console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
  return this.manhattanDistanceTo(v2);
};
Vector2.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Vector3.prototype.setEulerFromRotationMatrix = function() {
  console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
};
Vector3.prototype.setEulerFromQuaternion = function() {
  console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
};
Vector3.prototype.getPositionFromMatrix = function(m2) {
  console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
  return this.setFromMatrixPosition(m2);
};
Vector3.prototype.getScaleFromMatrix = function(m2) {
  console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
  return this.setFromMatrixScale(m2);
};
Vector3.prototype.getColumnFromMatrix = function(index, matrix) {
  console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
  return this.setFromMatrixColumn(matrix, index);
};
Vector3.prototype.applyProjection = function(m2) {
  console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
  return this.applyMatrix4(m2);
};
Vector3.prototype.fromAttribute = function(attribute, index, offset) {
  console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset);
};
Vector3.prototype.distanceToManhattan = function(v2) {
  console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
  return this.manhattanDistanceTo(v2);
};
Vector3.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Vector4.prototype.fromAttribute = function(attribute, index, offset) {
  console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
  return this.fromBufferAttribute(attribute, index, offset);
};
Vector4.prototype.lengthManhattan = function() {
  console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
  return this.manhattanLength();
};
Object3D.prototype.getChildByName = function(name) {
  console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
  return this.getObjectByName(name);
};
Object3D.prototype.renderDepth = function() {
  console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
};
Object3D.prototype.translate = function(distance, axis) {
  console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
  return this.translateOnAxis(axis, distance);
};
Object3D.prototype.getWorldRotation = function() {
  console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
};
Object3D.prototype.applyMatrix = function(matrix) {
  console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
  return this.applyMatrix4(matrix);
};
Object.defineProperties(Object3D.prototype, {
  eulerOrder: {
    get: function() {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      return this.rotation.order;
    },
    set: function(value) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      this.rotation.order = value;
    }
  },
  useQuaternion: {
    get: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }
  }
});
Mesh.prototype.setDrawMode = function() {
  console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
};
Object.defineProperties(Mesh.prototype, {
  drawMode: {
    get: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
      return TrianglesDrawMode;
    },
    set: function() {
      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    }
  }
});
SkinnedMesh.prototype.initBones = function() {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
Object.defineProperty(Curve.prototype, "__arcLengthDivisions", {
  get: function() {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
    return this.arcLengthDivisions;
  },
  set: function(value) {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
    this.arcLengthDivisions = value;
  }
});
PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
  if (filmGauge !== void 0)
    this.filmGauge = filmGauge;
  this.setFocalLength(focalLength);
};
Object.defineProperties(Light.prototype, {
  onlyShadow: {
    set: function() {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }
  },
  shadowCameraFov: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
      this.shadow.camera.fov = value;
    }
  },
  shadowCameraLeft: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
      this.shadow.camera.left = value;
    }
  },
  shadowCameraRight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
      this.shadow.camera.right = value;
    }
  },
  shadowCameraTop: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
      this.shadow.camera.top = value;
    }
  },
  shadowCameraBottom: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
      this.shadow.camera.bottom = value;
    }
  },
  shadowCameraNear: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
      this.shadow.camera.near = value;
    }
  },
  shadowCameraFar: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
      this.shadow.camera.far = value;
    }
  },
  shadowCameraVisible: {
    set: function() {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }
  },
  shadowBias: {
    set: function(value) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
      this.shadow.bias = value;
    }
  },
  shadowDarkness: {
    set: function() {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }
  },
  shadowMapWidth: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
      this.shadow.mapSize.width = value;
    }
  },
  shadowMapHeight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
      this.shadow.mapSize.height = value;
    }
  }
});
Object.defineProperties(BufferAttribute.prototype, {
  length: {
    get: function() {
      console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
      return this.array.length;
    }
  },
  dynamic: {
    get: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
      return this.usage === DynamicDrawUsage;
    },
    set: function() {
      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
      this.setUsage(DynamicDrawUsage);
    }
  }
});
BufferAttribute.prototype.setDynamic = function(value) {
  console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};
BufferAttribute.prototype.copyIndicesArray = function() {
  console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
}, BufferAttribute.prototype.setArray = function() {
  console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
BufferGeometry.prototype.addIndex = function(index) {
  console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
  this.setIndex(index);
};
BufferGeometry.prototype.addAttribute = function(name, attribute) {
  console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
  if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
    console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
    return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
  }
  if (name === "index") {
    console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
    this.setIndex(attribute);
    return this;
  }
  return this.setAttribute(name, attribute);
};
BufferGeometry.prototype.addDrawCall = function(start, count, indexOffset) {
  if (indexOffset !== void 0) {
    console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
  }
  console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
  this.addGroup(start, count);
};
BufferGeometry.prototype.clearDrawCalls = function() {
  console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
  this.clearGroups();
};
BufferGeometry.prototype.computeOffsets = function() {
  console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
};
BufferGeometry.prototype.removeAttribute = function(name) {
  console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
  return this.deleteAttribute(name);
};
BufferGeometry.prototype.applyMatrix = function(matrix) {
  console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
  return this.applyMatrix4(matrix);
};
Object.defineProperties(BufferGeometry.prototype, {
  drawcalls: {
    get: function() {
      console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
      return this.groups;
    }
  },
  offsets: {
    get: function() {
      console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
      return this.groups;
    }
  }
});
Object.defineProperties(InstancedBufferGeometry.prototype, {
  maxInstancedCount: {
    get: function() {
      console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.");
      return this.instanceCount;
    },
    set: function(value) {
      console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.");
      this.instanceCount = value;
    }
  }
});
Object.defineProperties(Raycaster.prototype, {
  linePrecision: {
    get: function() {
      console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.");
      return this.params.Line.threshold;
    },
    set: function(value) {
      console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.");
      this.params.Line.threshold = value;
    }
  }
});
Object.defineProperties(InterleavedBuffer.prototype, {
  dynamic: {
    get: function() {
      console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
      return this.usage === DynamicDrawUsage;
    },
    set: function(value) {
      console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
      this.setUsage(value);
    }
  }
});
InterleavedBuffer.prototype.setDynamic = function(value) {
  console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
  return this;
};
InterleavedBuffer.prototype.setArray = function() {
  console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
};
Scene.prototype.dispose = function() {
  console.error("THREE.Scene: .dispose() has been removed.");
};
Object.defineProperties(Material.prototype, {
  wrapAround: {
    get: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }
  },
  overdraw: {
    get: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    }
  },
  wrapRGB: {
    get: function() {
      console.warn("THREE.Material: .wrapRGB has been removed.");
      return new Color();
    }
  },
  shading: {
    get: function() {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
      this.flatShading = value === FlatShading;
    }
  },
  stencilMask: {
    get: function() {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
      return this.stencilFuncMask;
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
      this.stencilFuncMask = value;
    }
  }
});
Object.defineProperties(MeshPhysicalMaterial.prototype, {
  transparency: {
    get: function() {
      console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.");
      return this.transmission;
    },
    set: function(value) {
      console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.");
      this.transmission = value;
    }
  }
});
Object.defineProperties(ShaderMaterial.prototype, {
  derivatives: {
    get: function() {
      console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      return this.extensions.derivatives;
    },
    set: function(value) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      this.extensions.derivatives = value;
    }
  }
});
WebGLRenderer.prototype.clearTarget = function(renderTarget, color, depth, stencil) {
  console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
  this.setRenderTarget(renderTarget);
  this.clear(color, depth, stencil);
};
WebGLRenderer.prototype.animate = function(callback) {
  console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
  this.setAnimationLoop(callback);
};
WebGLRenderer.prototype.getCurrentRenderTarget = function() {
  console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
  return this.getRenderTarget();
};
WebGLRenderer.prototype.getMaxAnisotropy = function() {
  console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
  return this.capabilities.getMaxAnisotropy();
};
WebGLRenderer.prototype.getPrecision = function() {
  console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
  return this.capabilities.precision;
};
WebGLRenderer.prototype.resetGLState = function() {
  console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
  return this.state.reset();
};
WebGLRenderer.prototype.supportsFloatTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
  return this.extensions.get("OES_texture_float");
};
WebGLRenderer.prototype.supportsHalfFloatTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
  return this.extensions.get("OES_texture_half_float");
};
WebGLRenderer.prototype.supportsStandardDerivatives = function() {
  console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
  return this.extensions.get("OES_standard_derivatives");
};
WebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {
  console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
  return this.extensions.get("WEBGL_compressed_texture_s3tc");
};
WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {
  console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
  return this.extensions.get("WEBGL_compressed_texture_pvrtc");
};
WebGLRenderer.prototype.supportsBlendMinMax = function() {
  console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
  return this.extensions.get("EXT_blend_minmax");
};
WebGLRenderer.prototype.supportsVertexTextures = function() {
  console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
  return this.capabilities.vertexTextures;
};
WebGLRenderer.prototype.supportsInstancedArrays = function() {
  console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
  return this.extensions.get("ANGLE_instanced_arrays");
};
WebGLRenderer.prototype.enableScissorTest = function(boolean) {
  console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
  this.setScissorTest(boolean);
};
WebGLRenderer.prototype.initMaterial = function() {
  console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
};
WebGLRenderer.prototype.addPrePlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
};
WebGLRenderer.prototype.addPostPlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
};
WebGLRenderer.prototype.updateShadowMap = function() {
  console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
};
WebGLRenderer.prototype.setFaceCulling = function() {
  console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
};
WebGLRenderer.prototype.allocTextureUnit = function() {
  console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
};
WebGLRenderer.prototype.setTexture = function() {
  console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
};
WebGLRenderer.prototype.setTexture2D = function() {
  console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
};
WebGLRenderer.prototype.setTextureCube = function() {
  console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
};
WebGLRenderer.prototype.getActiveMipMapLevel = function() {
  console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
  return this.getActiveMipmapLevel();
};
Object.defineProperties(WebGLRenderer.prototype, {
  shadowMapEnabled: {
    get: function() {
      return this.shadowMap.enabled;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
      this.shadowMap.enabled = value;
    }
  },
  shadowMapType: {
    get: function() {
      return this.shadowMap.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
      this.shadowMap.type = value;
    }
  },
  shadowMapCullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  context: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
      return this.getContext();
    }
  },
  vr: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
      return this.xr;
    }
  },
  gammaInput: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
      return false;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
    }
  },
  gammaOutput: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      return false;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
    }
  },
  toneMappingWhitePoint: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
      return 1;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
    }
  }
});
Object.defineProperties(WebGLShadowMap.prototype, {
  cullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  renderReverseSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }
  },
  renderSingleSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }
  }
});
Object.defineProperties(WebGLRenderTarget.prototype, {
  wrapS: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      return this.texture.wrapS;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      this.texture.wrapS = value;
    }
  },
  wrapT: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      return this.texture.wrapT;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      this.texture.wrapT = value;
    }
  },
  magFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      return this.texture.magFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      this.texture.magFilter = value;
    }
  },
  minFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      return this.texture.minFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      this.texture.minFilter = value;
    }
  },
  anisotropy: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      return this.texture.anisotropy;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      this.texture.anisotropy = value;
    }
  },
  offset: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      return this.texture.offset;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      this.texture.offset = value;
    }
  },
  repeat: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      return this.texture.repeat;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      this.texture.repeat = value;
    }
  },
  format: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      return this.texture.format;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      this.texture.format = value;
    }
  },
  type: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      return this.texture.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      this.texture.type = value;
    }
  },
  generateMipmaps: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      return this.texture.generateMipmaps;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      this.texture.generateMipmaps = value;
    }
  }
});
Audio.prototype.load = function(file) {
  console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
  const scope = this;
  const audioLoader = new AudioLoader();
  audioLoader.load(file, function(buffer) {
    scope.setBuffer(buffer);
  });
  return this;
};
CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
  console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
  return this.update(renderer, scene);
};
CubeCamera.prototype.clear = function(renderer, color, depth, stencil) {
  console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear().");
  return this.renderTarget.clear(renderer, color, depth, stencil);
};
ImageUtils.crossOrigin = void 0;
ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
  const loader = new TextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(url, onLoad, void 0, onError);
  if (mapping)
    texture.mapping = mapping;
  return texture;
};
ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
  const loader = new CubeTextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(urls, onLoad, void 0, onError);
  if (mapping)
    texture.mapping = mapping;
  return texture;
};
ImageUtils.loadCompressedTexture = function() {
  console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
};
ImageUtils.loadCompressedTextureCube = function() {
  console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
};
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {detail: {
    revision: REVISION
  }}));
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    console.warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}
const TYPES_ENUM = {
  i8: "i8",
  ui8: "ui8",
  ui8c: "ui8c",
  i16: "i16",
  ui16: "ui16",
  i32: "i32",
  ui32: "ui32",
  f32: "f32",
  f64: "f64"
};
const TYPES_NAMES = {
  i8: "Int8",
  ui8: "Uint8",
  ui8c: "Uint8Clamped",
  i16: "Int16",
  ui16: "Uint16",
  i32: "Int32",
  ui32: "Uint32",
  f32: "Float32",
  f64: "Float64"
};
const TYPES = {
  i8: Int8Array,
  ui8: Uint8Array,
  ui8c: Uint8ClampedArray,
  i16: Int16Array,
  ui16: Uint16Array,
  i32: Int32Array,
  ui32: Uint32Array,
  f32: Float32Array,
  f64: Float64Array
};
const UNSIGNED_MAX = {
  uint8: 2 ** 8,
  uint16: 2 ** 16,
  uint32: 2 ** 32
};
const $storeRef = Symbol("storeRef");
const $storeSize = Symbol("storeSize");
const $storeMaps = Symbol("storeMaps");
const $storeFlattened = Symbol("storeFlattened");
const $storeBase = Symbol("storeBase");
const $storeType = Symbol("storeType");
const $storeArrayCounts = Symbol("storeArrayCount");
const $storeSubarrays = Symbol("storeSubarrays");
const $storeCursor = Symbol("storeCursor");
const $subarrayCursors = Symbol("subarrayCursors");
const $subarray = Symbol("subarray");
const $queryShadow = Symbol("queryShadow");
const $serializeShadow = Symbol("serializeShadow");
const $indexType = Symbol("indexType");
const $indexBytes = Symbol("indexBytes");
const stores = {};
const resize = (ta, size) => {
  const newBuffer = new ArrayBuffer(size * ta.BYTES_PER_ELEMENT);
  const newTa = new ta.constructor(newBuffer);
  newTa.set(ta, 0);
  return newTa;
};
const resizeRecursive = (store, size) => {
  Object.keys(store).forEach((key) => {
    const ta = store[key];
    if (ta[$subarray])
      return;
    else if (ArrayBuffer.isView(ta)) {
      store[key] = resize(ta, size);
      store[key][$queryShadow] = resize(ta[$queryShadow], size);
      store[key][$serializeShadow] = resize(ta[$serializeShadow], size);
    } else if (typeof ta === "object") {
      resizeRecursive(store[key], size);
    }
  });
};
const resizeSubarrays = (metadata, size) => {
  Object.keys(metadata[$subarrayCursors]).forEach((k2) => {
    metadata[$subarrayCursors][k2] = 0;
  });
  const cursors = metadata[$subarrayCursors];
  metadata[$storeFlattened].filter((store) => !ArrayBuffer.isView(store)).forEach((store) => {
    const type = store[$storeType];
    const length = store[0].length;
    const arrayCount = metadata[$storeArrayCounts][type];
    const summedLength = Array(arrayCount).fill(0).reduce((a2, p2) => a2 + length, 0);
    const array = new TYPES[type](summedLength * size);
    array.set(metadata[$storeSubarrays][type]);
    metadata[$storeSubarrays][type] = array;
    metadata[$storeSubarrays][type][$queryShadow] = array.slice(0);
    metadata[$storeSubarrays][type][$serializeShadow] = array.slice(0);
    for (let eid = 0; eid < size; eid++) {
      const from = cursors[type] + eid * length;
      const to = from + length;
      store[eid] = metadata[$storeSubarrays][type].subarray(from, to);
      store[eid].from = from;
      store[eid].to = to;
      store[eid][$queryShadow] = metadata[$storeSubarrays][type][$queryShadow].subarray(from, to);
      store[eid][$serializeShadow] = metadata[$storeSubarrays][type][$serializeShadow].subarray(from, to);
      store[eid][$subarray] = true;
      store[eid][$indexType] = array[$indexType];
      store[eid][$indexBytes] = array[$indexBytes];
    }
  });
};
const resizeStore = (store, size) => {
  store[$storeSize] = size;
  resizeRecursive(store, size);
  resizeSubarrays(store, size);
};
const resetStoreFor = (store, eid) => {
  store[$storeFlattened].forEach((ta) => {
    if (ArrayBuffer.isView(ta))
      ta[eid] = 0;
    else
      ta[eid].fill(0);
  });
};
const createTypeStore = (type, length) => {
  const totalBytes = length * TYPES[type].BYTES_PER_ELEMENT;
  const buffer = new ArrayBuffer(totalBytes);
  return new TYPES[type](buffer);
};
const createArrayStore = (metadata, type, length) => {
  const size = metadata[$storeSize];
  const store = Array(size).fill(0);
  store[$storeType] = type;
  const cursors = metadata[$subarrayCursors];
  const indexType = length < UNSIGNED_MAX.uint8 ? "ui8" : length < UNSIGNED_MAX.uint16 ? "ui16" : "ui32";
  if (!length)
    throw new Error("\u274C Must define a length for component array.");
  if (!TYPES[type])
    throw new Error(`\u274C Invalid component array property type ${type}.`);
  if (!metadata[$storeSubarrays][type]) {
    const arrayCount = metadata[$storeArrayCounts][type];
    const summedLength = Array(arrayCount).fill(0).reduce((a2, p2) => a2 + length, 0);
    const array = new TYPES[type](summedLength * size);
    metadata[$storeSubarrays][type] = array;
    metadata[$storeSubarrays][type][$queryShadow] = array.slice(0);
    metadata[$storeSubarrays][type][$serializeShadow] = array.slice(0);
    array[$indexType] = TYPES_NAMES[indexType];
    array[$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT;
  }
  let end = 0;
  for (let eid = 0; eid < size; eid++) {
    const from = cursors[type] + eid * length;
    const to = from + length;
    store[eid] = metadata[$storeSubarrays][type].subarray(from, to);
    store[eid].from = from;
    store[eid].to = to;
    store[eid][$queryShadow] = metadata[$storeSubarrays][type][$queryShadow].subarray(from, to);
    store[eid][$serializeShadow] = metadata[$storeSubarrays][type][$serializeShadow].subarray(from, to);
    store[eid][$subarray] = true;
    store[eid][$indexType] = TYPES_NAMES[indexType];
    store[eid][$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT;
    end = to;
  }
  cursors[type] = end;
  return store;
};
const createShadows = (store) => {
  store[$queryShadow] = store.slice(0);
  store[$serializeShadow] = store.slice(0);
};
const isArrayType = (x2) => Array.isArray(x2) && typeof x2[0] === "string" && typeof x2[1] === "number";
const createStore = (schema, size = 1e4) => {
  const $store = Symbol("store");
  if (!schema)
    return {};
  schema = JSON.parse(JSON.stringify(schema));
  const arrayCounts = {};
  const collectArrayCounts = (s2) => {
    const keys = Object.keys(s2);
    for (const k2 of keys) {
      if (isArrayType(s2[k2])) {
        if (!arrayCounts[s2[k2][0]])
          arrayCounts[s2[k2][0]] = 0;
        arrayCounts[s2[k2][0]]++;
      } else if (s2[k2] instanceof Object) {
        collectArrayCounts(s2[k2]);
      }
    }
  };
  collectArrayCounts(schema);
  const metadata = {
    [$storeSize]: size,
    [$storeMaps]: {},
    [$storeSubarrays]: {},
    [$storeRef]: $store,
    [$storeCursor]: 0,
    [$subarrayCursors]: Object.keys(TYPES).reduce((a2, type) => __assign(__assign({}, a2), {
      [type]: 0
    }), {}),
    [$storeArrayCounts]: arrayCounts,
    [$storeFlattened]: []
  };
  if (schema instanceof Object && Object.keys(schema).length) {
    const recursiveTransform = (a2, k2) => {
      if (typeof a2[k2] === "string") {
        a2[k2] = createTypeStore(a2[k2], size);
        a2[k2][$storeBase] = () => stores[$store];
        metadata[$storeFlattened].push(a2[k2]);
        createShadows(a2[k2]);
      } else if (isArrayType(a2[k2])) {
        const [type, length] = a2[k2];
        a2[k2] = createArrayStore(metadata, type, length);
        a2[k2][$storeBase] = () => stores[$store];
        metadata[$storeFlattened].push(a2[k2]);
      } else if (a2[k2] instanceof Object) {
        a2[k2] = Object.keys(a2[k2]).reduce(recursiveTransform, a2[k2]);
      }
      return a2;
    };
    stores[$store] = Object.assign(Object.keys(schema).reduce(recursiveTransform, schema), metadata);
    stores[$store][$storeBase] = () => stores[$store];
    return stores[$store];
  }
  stores[$store] = metadata;
  stores[$store][$storeBase] = () => stores[$store];
  return stores[$store];
};
const $entityMasks = Symbol("entityMasks");
const $entityEnabled = Symbol("entityEnabled");
const $entityArray = Symbol("entityArray");
const $entityIndices = Symbol("entityIndices");
const NONE$1 = 2 ** 32;
let globalEntityCursor = 0;
const removed = [];
const getEntityCursor = () => globalEntityCursor;
const resizeWorld = (world, size) => {
  world[$size] = size;
  world[$componentMap].forEach((c2) => {
    resizeStore(c2.store, size);
  });
  world[$queryMap].forEach((q2) => {
    q2.indices = resize(q2.indices, size);
    q2.enabled = resize(q2.enabled, size);
  });
  world[$entityEnabled] = resize(world[$entityEnabled], size);
  world[$entityIndices] = resize(world[$entityIndices], size);
  for (let i2 = 0; i2 < world[$entityMasks].length; i2++) {
    const masks = world[$entityMasks][i2];
    world[$entityMasks][i2] = resize(masks, size);
  }
};
const addEntity = (world) => {
  const enabled = world[$entityEnabled];
  const eid = removed.length > 0 ? removed.shift() : globalEntityCursor++;
  enabled[eid] = 1;
  world[$entityIndices][eid] = world[$entityArray].push(eid) - 1;
  if (globalEntityCursor >= world[$warningSize]) {
    const size = world[$size];
    const amount = Math.ceil(size / 2 / 4) * 4;
    resizeWorld(world, size + amount);
    world[$warningSize] = world[$size] - world[$size] / 5;
    console.info(`\u{1F47E} bitECS - resizing world from ${size} to ${size + amount}`);
  }
  return eid;
};
const removeEntity = (world, eid) => {
  const enabled = world[$entityEnabled];
  if (enabled[eid] === 0)
    return;
  world[$queries].forEach((query) => {
    queryRemoveEntity(world, query, eid);
  });
  removed.push(eid);
  enabled[eid] = 0;
  const index = world[$entityIndices][eid];
  const swapped = world[$entityArray].pop();
  if (swapped !== eid) {
    world[$entityArray][index] = swapped;
    world[$entityIndices][swapped] = index;
  }
  world[$entityIndices][eid] = NONE$1;
  for (let i2 = 0; i2 < world[$entityMasks].length; i2++)
    world[$entityMasks][i2][eid] = 0;
};
const $queries = Symbol("queries");
const $queryMap = Symbol("queryMap");
const $dirtyQueries = Symbol("$dirtyQueries");
const $queryComponents = Symbol("queryComponents");
const NONE = 2 ** 32;
const enterQuery = (query) => (world) => {
  if (!world[$queryMap].has(query))
    registerQuery(world, query);
  const q2 = world[$queryMap].get(query);
  return q2.entered.splice(0);
};
const registerQuery = (world, query) => {
  let components = [];
  let notComponents = [];
  let changedComponents = [];
  query[$queryComponents].forEach((c2) => {
    if (typeof c2 === "function") {
      if (c2.name === "QueryNot") {
        notComponents.push(c2());
      }
      if (c2.name === "QueryChanged") {
        changedComponents.push(c2());
        components.push(c2());
      }
    } else {
      components.push(c2);
    }
  });
  const mapComponents = (c2) => world[$componentMap].get(c2);
  const size = components.concat(notComponents).reduce((a2, c2) => c2[$storeSize] > a2 ? c2[$storeSize] : a2, 0);
  const entities = [];
  const changed = [];
  const indices = new Uint32Array(size).fill(NONE);
  const enabled = new Uint8Array(size);
  const generations = components.concat(notComponents).map((c2) => {
    if (!world[$componentMap].has(c2))
      registerComponent(world, c2);
    return c2;
  }).map(mapComponents).map((c2) => c2.generationId).reduce((a2, v2) => {
    if (a2.includes(v2))
      return a2;
    a2.push(v2);
    return a2;
  }, []);
  const reduceBitmasks = (a2, c2) => {
    if (!a2[c2.generationId])
      a2[c2.generationId] = 0;
    a2[c2.generationId] |= c2.bitflag;
    return a2;
  };
  const masks = components.map(mapComponents).reduce(reduceBitmasks, {});
  const notMasks = notComponents.map(mapComponents).reduce((a2, c2) => {
    if (!a2[c2.generationId]) {
      a2[c2.generationId] = 0;
      a2[c2.generationId] |= c2.bitflag;
    }
    return a2;
  }, {});
  const flatProps = components.map((c2) => Object.getOwnPropertySymbols(c2).includes($storeFlattened) ? c2[$storeFlattened] : [c2]).reduce((a2, v2) => a2.concat(v2), []);
  const toRemove = [];
  const entered = [];
  const exited = [];
  world[$queryMap].set(query, {
    entities,
    changed,
    enabled,
    components,
    notComponents,
    changedComponents,
    masks,
    notMasks,
    generations,
    indices,
    flatProps,
    toRemove,
    entered,
    exited
  });
  world[$queries].add(query);
  for (let eid = 0; eid < getEntityCursor(); eid++) {
    if (!world[$entityEnabled][eid])
      continue;
    if (queryCheckEntity(world, query, eid)) {
      queryAddEntity(world, query, eid);
    }
  }
};
const diff = (q2) => {
  q2.changed.length = 0;
  const flat = q2.flatProps;
  for (let i2 = 0; i2 < q2.entities.length; i2++) {
    const eid = q2.entities[i2];
    let dirty = false;
    for (let pid = 0; pid < flat.length; pid++) {
      const prop = flat[pid];
      if (ArrayBuffer.isView(prop[eid])) {
        for (let i3 = 0; i3 < prop[eid].length; i3++) {
          if (prop[eid][i3] !== prop[eid][$queryShadow][i3]) {
            dirty = true;
            prop[eid][$queryShadow][i3] = prop[eid][i3];
          }
        }
      } else {
        if (prop[eid] !== prop[$queryShadow][eid]) {
          dirty = true;
          prop[$queryShadow][eid] = prop[eid];
        }
      }
    }
    if (dirty)
      q2.changed.push(eid);
  }
  return q2.changed;
};
const defineQuery = (components) => {
  const query = function(world) {
    if (!world[$queryMap].has(query))
      registerQuery(world, query);
    const q2 = world[$queryMap].get(query);
    queryCommitRemovals(world, q2);
    if (q2.changedComponents.length)
      return diff(q2);
    return q2.entities;
  };
  query[$queryComponents] = components;
  return query;
};
const queryCheckEntity = (world, query, eid) => {
  const {
    masks,
    notMasks,
    generations
  } = world[$queryMap].get(query);
  for (let i2 = 0; i2 < generations.length; i2++) {
    const generationId = generations[i2];
    const qMask = masks[generationId];
    const qNotMask = notMasks[generationId];
    const eMask = world[$entityMasks][generationId][eid];
    if (qNotMask && (eMask & qNotMask) !== 0) {
      return false;
    }
    if (qMask && (eMask & qMask) !== qMask) {
      return false;
    }
  }
  return true;
};
const queryCheckComponent = (world, query, component) => {
  const {
    generationId,
    bitflag
  } = world[$componentMap].get(component);
  const {
    masks
  } = world[$queryMap].get(query);
  const mask = masks[generationId];
  return (mask & bitflag) === bitflag;
};
const queryAddEntity = (world, query, eid) => {
  const q2 = world[$queryMap].get(query);
  if (q2.enabled[eid])
    return;
  q2.enabled[eid] = true;
  q2.entities.push(eid);
  q2.indices[eid] = q2.entities.length - 1;
  q2.entered.push(eid);
};
const queryCommitRemovals = (world, q2) => {
  while (q2.toRemove.length) {
    const eid = q2.toRemove.pop();
    const index = q2.indices[eid];
    if (index === NONE)
      continue;
    const swapped = q2.entities.pop();
    if (swapped !== eid) {
      q2.entities[index] = swapped;
      q2.indices[swapped] = index;
    }
    q2.indices[eid] = NONE;
  }
  world[$dirtyQueries].delete(q2);
};
const commitRemovals = (world) => {
  world[$dirtyQueries].forEach((q2) => {
    queryCommitRemovals(world, q2);
  });
};
const queryRemoveEntity = (world, query, eid) => {
  const q2 = world[$queryMap].get(query);
  if (!q2.enabled[eid])
    return;
  q2.enabled[eid] = false;
  q2.toRemove.push(eid);
  world[$dirtyQueries].add(q2);
  q2.exited.push(eid);
};
const $componentMap = Symbol("componentMap");
const defineComponent = (schema) => createStore(schema);
const incrementBitflag = (world) => {
  world[$bitflag] *= 2;
  if (world[$bitflag] >= 2 ** 32) {
    world[$bitflag] = 1;
    world[$entityMasks].push(new Uint32Array(world[$size]));
  }
};
const registerComponent = (world, component) => {
  world[$componentMap].set(component, {
    generationId: world[$entityMasks].length - 1,
    bitflag: world[$bitflag],
    store: component
  });
  if (component[$storeSize] < world[$size]) {
    resizeStore(component, world[$size]);
  }
  incrementBitflag(world);
};
const hasComponent = (world, component, eid) => {
  const registeredComponent = world[$componentMap].get(component);
  if (!registeredComponent)
    return;
  const {
    generationId,
    bitflag
  } = registeredComponent;
  const mask = world[$entityMasks][generationId][eid];
  return (mask & bitflag) === bitflag;
};
const addComponent = (world, component, eid, reset = false) => {
  if (!world[$componentMap].has(component))
    registerComponent(world, component);
  if (hasComponent(world, component, eid))
    return;
  const {
    generationId,
    bitflag
  } = world[$componentMap].get(component);
  world[$entityMasks][generationId][eid] |= bitflag;
  world[$queries].forEach((query) => {
    if (!queryCheckComponent(world, query, component))
      return;
    const match = queryCheckEntity(world, query, eid);
    if (match)
      queryAddEntity(world, query, eid);
  });
  if (reset)
    resetStoreFor(component, eid);
};
const removeComponent = (world, component, eid, reset = false) => {
  const {
    generationId,
    bitflag
  } = world[$componentMap].get(component);
  if (!(world[$entityMasks][generationId][eid] & bitflag))
    return;
  world[$queries].forEach((query) => {
    if (!queryCheckComponent(world, query, component))
      return;
    const match = queryCheckEntity(world, query, eid);
    if (match)
      queryRemoveEntity(world, query, eid);
  });
  world[$entityMasks][generationId][eid] &= ~bitflag;
  if (reset)
    resetStoreFor(component, eid);
};
const $size = Symbol("size");
const $warningSize = Symbol("warningSize");
const $bitflag = Symbol("bitflag");
const createWorld = (size = 1e4) => {
  const world = {};
  world[$size] = size;
  world[$entityEnabled] = new Uint8Array(size);
  world[$entityMasks] = [new Uint32Array(size)];
  world[$entityArray] = [];
  world[$entityIndices] = new Uint32Array(size);
  world[$bitflag] = 1;
  world[$componentMap] = new Map();
  world[$queryMap] = new Map();
  world[$queries] = new Set();
  world[$dirtyQueries] = new Set();
  world[$warningSize] = size - size / 5;
  return world;
};
const defineSystem = (update) => {
  const system = (world) => {
    update(world);
    commitRemovals(world);
    return world;
  };
  Object.defineProperty(system, "name", {
    value: (update.name || "AnonymousSystem") + "_internal",
    configurable: true
  });
  return system;
};
const pipe = (...fns) => (input) => {
  fns = Array.isArray(fns[0]) ? fns[0] : fns;
  let tmp = input;
  for (let i2 = 0; i2 < fns.length; i2++) {
    const fn = fns[i2];
    tmp = fn(tmp);
  }
  return tmp;
};
const Types = TYPES_ENUM;
let A;
const I = new Array(32).fill(void 0);
function g(A2) {
  return I[A2];
}
I.push(void 0, null, true, false);
let C = I.length;
function B(A2) {
  const B2 = g(A2);
  return function(A3) {
    A3 < 36 || (I[A3] = C, C = A3);
  }(A2), B2;
}
function Q(A2) {
  C === I.length && I.push(I.length + 1);
  const g2 = C;
  return C = I[g2], I[g2] = A2, g2;
}
let E = new TextDecoder("utf-8", {ignoreBOM: true, fatal: true});
E.decode();
let i = null;
function D() {
  return i !== null && i.buffer === A.memory.buffer || (i = new Uint8Array(A.memory.buffer)), i;
}
function o(A2, I2) {
  return E.decode(D().subarray(A2, A2 + I2));
}
function S(A2) {
  return A2 == null;
}
let G = null;
let k = null;
function w() {
  return k !== null && k.buffer === A.memory.buffer || (k = new Int32Array(A.memory.buffer)), k;
}
function U(A2) {
  const I2 = typeof A2;
  if (I2 == "number" || I2 == "boolean" || A2 == null)
    return `${A2}`;
  if (I2 == "string")
    return `"${A2}"`;
  if (I2 == "symbol") {
    const I3 = A2.description;
    return I3 == null ? "Symbol" : `Symbol(${I3})`;
  }
  if (I2 == "function") {
    const I3 = A2.name;
    return typeof I3 == "string" && I3.length > 0 ? `Function(${I3})` : "Function";
  }
  if (Array.isArray(A2)) {
    const I3 = A2.length;
    let g3 = "[";
    I3 > 0 && (g3 += U(A2[0]));
    for (let C3 = 1; C3 < I3; C3++)
      g3 += ", " + U(A2[C3]);
    return g3 += "]", g3;
  }
  const g2 = /\[object ([^\]]+)\]/.exec(toString.call(A2));
  let C2;
  if (!(g2.length > 1))
    return toString.call(A2);
  if (C2 = g2[1], C2 == "Object")
    try {
      return "Object(" + JSON.stringify(A2) + ")";
    } catch (A3) {
      return "Object";
    }
  return A2 instanceof Error ? `${A2.name}: ${A2.message}
${A2.stack}` : C2;
}
let J = 0, K = new TextEncoder("utf-8");
const M = typeof K.encodeInto == "function" ? function(A2, I2) {
  return K.encodeInto(A2, I2);
} : function(A2, I2) {
  const g2 = K.encode(A2);
  return I2.set(g2), {read: A2.length, written: g2.length};
};
let F = 32;
function h(A2) {
  if (F == 1)
    throw new Error("out of js stack");
  return I[--F] = A2, F;
}
function a(A2, I2) {
  if (!(A2 instanceof I2))
    throw new Error(`expected instance of ${I2.name}`);
  return A2.ptr;
}
let y = null;
function q() {
  return y !== null && y.buffer === A.memory.buffer || (y = new Float32Array(A.memory.buffer)), y;
}
function N(A2, I2) {
  return q().subarray(A2 / 4, A2 / 4 + I2);
}
let R = null;
function s() {
  return R !== null && R.buffer === A.memory.buffer || (R = new Uint32Array(A.memory.buffer)), R;
}
function Y(A2, I2) {
  const g2 = I2(4 * A2.length);
  return q().set(A2, g2 / 4), J = A2.length, g2;
}
function c(A2, I2) {
  const g2 = I2(4 * A2.length);
  return s().set(A2, g2 / 4), J = A2.length, g2;
}
function l(I2, g2) {
  try {
    return I2.apply(this, g2);
  } catch (I3) {
    A.__wbindgen_exn_store(Q(I3));
  }
}
Object.freeze({Ball: 0, 0: "Ball", Fixed: 1, 1: "Fixed", Prismatic: 2, 2: "Prismatic", Revolute: 3, 3: "Revolute"}), Object.freeze({Disabled: 0, 0: "Disabled", VelocityBased: 1, 1: "VelocityBased", AccelerationBased: 2, 2: "AccelerationBased", ForceBased: 3, 3: "ForceBased"}), Object.freeze({Dynamic: 0, 0: "Dynamic", Static: 1, 1: "Static", KinematicPositionBased: 2, 2: "KinematicPositionBased", KinematicVelocityBased: 3, 3: "KinematicVelocityBased"}), Object.freeze({Ball: 0, 0: "Ball", Cuboid: 1, 1: "Cuboid", Capsule: 2, 2: "Capsule", Segment: 3, 3: "Segment", Polyline: 4, 4: "Polyline", Triangle: 5, 5: "Triangle", TriMesh: 6, 6: "TriMesh", HeightField: 7, 7: "HeightField", Compound: 8, 8: "Compound", ConvexPolyhedron: 9, 9: "ConvexPolyhedron", Cylinder: 10, 10: "Cylinder", Cone: 11, 11: "Cone", RoundCuboid: 12, 12: "RoundCuboid", RoundTriangle: 13, 13: "RoundTriangle", RoundCylinder: 14, 14: "RoundCylinder", RoundCone: 15, 15: "RoundCone", RoundConvexPolyhedron: 16, 16: "RoundConvexPolyhedron"});
class L {
  static __wrap(A2) {
    const I2 = Object.create(L.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawbroadphase_free(I2);
  }
  constructor() {
    var I2 = A.rawbroadphase_new();
    return L.__wrap(I2);
  }
}
class H {
  static __wrap(A2) {
    const I2 = Object.create(H.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawccdsolver_free(I2);
  }
  constructor() {
    var I2 = A.rawccdsolver_new();
    return H.__wrap(I2);
  }
}
class p {
  static __wrap(A2) {
    const I2 = Object.create(p.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawcolliderset_free(I2);
  }
  coTranslation(I2) {
    var g2 = A.rawcolliderset_coTranslation(this.ptr, I2);
    return v.__wrap(g2);
  }
  coRotation(I2) {
    var g2 = A.rawcolliderset_coRotation(this.ptr, I2);
    return m.__wrap(g2);
  }
  coSetTranslation(I2, g2, C2, B2) {
    A.rawcolliderset_coSetTranslation(this.ptr, I2, g2, C2, B2);
  }
  coSetTranslationWrtParent(I2, g2, C2, B2) {
    A.rawcolliderset_coSetTranslationWrtParent(this.ptr, I2, g2, C2, B2);
  }
  coSetRotation(I2, g2, C2, B2, Q2) {
    A.rawcolliderset_coSetRotation(this.ptr, I2, g2, C2, B2, Q2);
  }
  coSetRotationWrtParent(I2, g2, C2, B2, Q2) {
    A.rawcolliderset_coSetRotationWrtParent(this.ptr, I2, g2, C2, B2, Q2);
  }
  coIsSensor(I2) {
    return A.rawcolliderset_coIsSensor(this.ptr, I2) !== 0;
  }
  coShapeType(I2) {
    return A.rawcolliderset_coShapeType(this.ptr, I2) >>> 0;
  }
  coHalfExtents(I2) {
    var g2 = A.rawcolliderset_coHalfExtents(this.ptr, I2);
    return g2 === 0 ? void 0 : v.__wrap(g2);
  }
  coRadius(I2) {
    try {
      const B2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawcolliderset_coRadius(B2, this.ptr, I2);
      var g2 = w()[B2 / 4 + 0], C2 = q()[B2 / 4 + 1];
      return g2 === 0 ? void 0 : C2;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  coHalfHeight(I2) {
    try {
      const B2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawcolliderset_coHalfHeight(B2, this.ptr, I2);
      var g2 = w()[B2 / 4 + 0], C2 = q()[B2 / 4 + 1];
      return g2 === 0 ? void 0 : C2;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  coRoundRadius(I2) {
    try {
      const B2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawcolliderset_coRoundRadius(B2, this.ptr, I2);
      var g2 = w()[B2 / 4 + 0], C2 = q()[B2 / 4 + 1];
      return g2 === 0 ? void 0 : C2;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  coVertices(I2) {
    try {
      const B2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawcolliderset_coVertices(B2, this.ptr, I2);
      var g2 = w()[B2 / 4 + 0], C2 = w()[B2 / 4 + 1];
      let Q2;
      return g2 !== 0 && (Q2 = N(g2, C2).slice(), A.__wbindgen_free(g2, 4 * C2)), Q2;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  coIndices(I2) {
    try {
      const B2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawcolliderset_coIndices(B2, this.ptr, I2);
      var g2 = w()[B2 / 4 + 0], C2 = w()[B2 / 4 + 1];
      let Q2;
      return g2 !== 0 && (Q2 = function(A2, I3) {
        return s().subarray(A2 / 4, A2 / 4 + I3);
      }(g2, C2).slice(), A.__wbindgen_free(g2, 4 * C2)), Q2;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  coHeightfieldHeights(I2) {
    try {
      const B2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawcolliderset_coHeightfieldHeights(B2, this.ptr, I2);
      var g2 = w()[B2 / 4 + 0], C2 = w()[B2 / 4 + 1];
      let Q2;
      return g2 !== 0 && (Q2 = N(g2, C2).slice(), A.__wbindgen_free(g2, 4 * C2)), Q2;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  coHeightfieldScale(I2) {
    var g2 = A.rawcolliderset_coHeightfieldScale(this.ptr, I2);
    return g2 === 0 ? void 0 : v.__wrap(g2);
  }
  coHeightfieldNRows(I2) {
    try {
      const B2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawcolliderset_coHeightfieldNRows(B2, this.ptr, I2);
      var g2 = w()[B2 / 4 + 0], C2 = w()[B2 / 4 + 1];
      return g2 === 0 ? void 0 : C2 >>> 0;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  coHeightfieldNCols(I2) {
    try {
      const B2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawcolliderset_coHeightfieldNCols(B2, this.ptr, I2);
      var g2 = w()[B2 / 4 + 0], C2 = w()[B2 / 4 + 1];
      return g2 === 0 ? void 0 : C2 >>> 0;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  coParent(I2) {
    return A.rawcolliderset_coParent(this.ptr, I2) >>> 0;
  }
  coFriction(I2) {
    return A.rawcolliderset_coFriction(this.ptr, I2);
  }
  coDensity(I2) {
    try {
      const B2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.rawcolliderset_coDensity(B2, this.ptr, I2);
      var g2 = w()[B2 / 4 + 0], C2 = q()[B2 / 4 + 1];
      return g2 === 0 ? void 0 : C2;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  coCollisionGroups(I2) {
    return A.rawcolliderset_coCollisionGroups(this.ptr, I2) >>> 0;
  }
  coSolverGroups(I2) {
    return A.rawcolliderset_coSolverGroups(this.ptr, I2) >>> 0;
  }
  coActiveHooks(I2) {
    return A.rawcolliderset_coActiveHooks(this.ptr, I2) >>> 0;
  }
  coActiveCollisionTypes(I2) {
    return A.rawcolliderset_coActiveCollisionTypes(this.ptr, I2);
  }
  coActiveEvents(I2) {
    return A.rawcolliderset_coActiveEvents(this.ptr, I2) >>> 0;
  }
  coSetSensor(I2, g2) {
    A.rawcolliderset_coSetSensor(this.ptr, I2, g2);
  }
  coSetRestitution(I2, g2) {
    A.rawcolliderset_coSetRestitution(this.ptr, I2, g2);
  }
  coSetFriction(I2, g2) {
    A.rawcolliderset_coSetFriction(this.ptr, I2, g2);
  }
  coFrictionCombineRule(I2) {
    return A.rawcolliderset_coFrictionCombineRule(this.ptr, I2) >>> 0;
  }
  coSetFrictionCombineRule(I2, g2) {
    A.rawcolliderset_coSetFrictionCombineRule(this.ptr, I2, g2);
  }
  coRestitutionCombineRule(I2) {
    return A.rawcolliderset_coRestitutionCombineRule(this.ptr, I2) >>> 0;
  }
  coSetRestitutionCombineRule(I2, g2) {
    A.rawcolliderset_coSetRestitutionCombineRule(this.ptr, I2, g2);
  }
  coSetCollisionGroups(I2, g2) {
    A.rawcolliderset_coSetCollisionGroups(this.ptr, I2, g2);
  }
  coSetSolverGroups(I2, g2) {
    A.rawcolliderset_coSetSolverGroups(this.ptr, I2, g2);
  }
  coSetActiveHooks(I2, g2) {
    A.rawcolliderset_coSetActiveHooks(this.ptr, I2, g2);
  }
  coSetActiveEvents(I2, g2) {
    A.rawcolliderset_coSetActiveEvents(this.ptr, I2, g2);
  }
  coSetActiveCollisionTypes(I2, g2) {
    A.rawcolliderset_coSetActiveCollisionTypes(this.ptr, I2, g2);
  }
  coSetShape(I2, g2) {
    a(g2, P);
    var C2 = g2.ptr;
    g2.ptr = 0, A.rawcolliderset_coSetShape(this.ptr, I2, C2);
  }
  constructor() {
    var I2 = A.rawcolliderset_new();
    return p.__wrap(I2);
  }
  len() {
    return A.rawcolliderset_len(this.ptr) >>> 0;
  }
  contains(I2) {
    return A.rawcolliderset_contains(this.ptr, I2) !== 0;
  }
  createCollider(I2, g2, C2, B2, Q2, E2, i2, D2, o2, S2, G2, k2, U2, J2, K2, M2, F2, h2, y2, q2, N2, R2) {
    try {
      const c2 = A.__wbindgen_add_to_stack_pointer(-16);
      a(I2, P), a(g2, v), a(C2, m), a(E2, v), a(i2, v), a(D2, m), a(R2, V), A.rawcolliderset_createCollider(c2, this.ptr, I2.ptr, g2.ptr, C2.ptr, B2, Q2, E2.ptr, i2.ptr, D2.ptr, o2, S2, G2, k2, U2, J2, K2, M2, F2, h2, y2, q2, N2, R2.ptr);
      var s2 = w()[c2 / 4 + 0], Y2 = w()[c2 / 4 + 1];
      return s2 === 0 ? void 0 : Y2 >>> 0;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  remove(I2, g2, C2, B2) {
    a(g2, r), a(C2, V), A.rawcolliderset_remove(this.ptr, I2, g2.ptr, C2.ptr, B2);
  }
  isHandleValid(I2) {
    return A.rawcolliderset_contains(this.ptr, I2) !== 0;
  }
  forEachColliderHandle(g2) {
    try {
      A.rawcolliderset_forEachColliderHandle(this.ptr, h(g2));
    } finally {
      I[F++] = void 0;
    }
  }
}
class t {
  static __wrap(A2) {
    const I2 = Object.create(t.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawcontactmanifold_free(I2);
  }
  normal() {
    var I2 = A.rawcontactmanifold_normal(this.ptr);
    return v.__wrap(I2);
  }
  local_n1() {
    var I2 = A.rawcontactmanifold_local_n1(this.ptr);
    return v.__wrap(I2);
  }
  local_n2() {
    var I2 = A.rawcontactmanifold_local_n1(this.ptr);
    return v.__wrap(I2);
  }
  subshape1() {
    return A.rawcontactmanifold_subshape1(this.ptr) >>> 0;
  }
  subshape2() {
    return A.rawcontactmanifold_subshape1(this.ptr) >>> 0;
  }
  num_contacts() {
    return A.rawcontactmanifold_num_contacts(this.ptr) >>> 0;
  }
  contact_local_p1(I2) {
    var g2 = A.rawcontactmanifold_contact_local_p1(this.ptr, I2);
    return g2 === 0 ? void 0 : v.__wrap(g2);
  }
  contact_local_p2(I2) {
    var g2 = A.rawcontactmanifold_contact_local_p1(this.ptr, I2);
    return g2 === 0 ? void 0 : v.__wrap(g2);
  }
  contact_dist(I2) {
    return A.rawcontactmanifold_contact_dist(this.ptr, I2);
  }
  contact_fid1(I2) {
    return A.rawcontactmanifold_contact_fid1(this.ptr, I2) >>> 0;
  }
  contact_fid2(I2) {
    return A.rawcontactmanifold_contact_fid2(this.ptr, I2) >>> 0;
  }
  contact_impulse(I2) {
    return A.rawcontactmanifold_contact_impulse(this.ptr, I2);
  }
  contact_tangent_impulse_x(I2) {
    return A.rawcontactmanifold_contact_tangent_impulse_x(this.ptr, I2);
  }
  contact_tangent_impulse_y(I2) {
    return A.rawcontactmanifold_contact_tangent_impulse_y(this.ptr, I2);
  }
  num_solver_contacts() {
    return A.rawcontactmanifold_num_solver_contacts(this.ptr) >>> 0;
  }
  solver_contact_point(I2) {
    var g2 = A.rawcontactmanifold_solver_contact_point(this.ptr, I2);
    return g2 === 0 ? void 0 : v.__wrap(g2);
  }
  solver_contact_dist(I2) {
    return A.rawcontactmanifold_solver_contact_dist(this.ptr, I2);
  }
  solver_contact_friction(I2) {
    return A.rawcontactmanifold_solver_contact_friction(this.ptr, I2);
  }
  solver_contact_restitution(I2) {
    return A.rawcontactmanifold_solver_contact_restitution(this.ptr, I2);
  }
  solver_contact_tangent_velocity(I2) {
    var g2 = A.rawcontactmanifold_solver_contact_tangent_velocity(this.ptr, I2);
    return v.__wrap(g2);
  }
}
class T {
  static __wrap(A2) {
    const I2 = Object.create(T.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawcontactpair_free(I2);
  }
  collider1() {
    return A.rawcontactpair_collider1(this.ptr) >>> 0;
  }
  collider2() {
    return A.rawcontactpair_collider2(this.ptr) >>> 0;
  }
  numContactManifolds() {
    return A.rawcontactpair_numContactManifolds(this.ptr) >>> 0;
  }
  contactManifold(I2) {
    var g2 = A.rawcontactpair_contactManifold(this.ptr, I2);
    return g2 === 0 ? void 0 : t.__wrap(g2);
  }
}
class n {
  static __wrap(A2) {
    const I2 = Object.create(n.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawdeserializedworld_free(I2);
  }
  takeGravity() {
    var I2 = A.rawdeserializedworld_takeGravity(this.ptr);
    return I2 === 0 ? void 0 : v.__wrap(I2);
  }
  takeIntegrationParameters() {
    var I2 = A.rawdeserializedworld_takeIntegrationParameters(this.ptr);
    return I2 === 0 ? void 0 : O.__wrap(I2);
  }
  takeIslandManager() {
    var I2 = A.rawdeserializedworld_takeIslandManager(this.ptr);
    return I2 === 0 ? void 0 : r.__wrap(I2);
  }
  takeBroadPhase() {
    var I2 = A.rawdeserializedworld_takeBroadPhase(this.ptr);
    return I2 === 0 ? void 0 : L.__wrap(I2);
  }
  takeNarrowPhase() {
    var I2 = A.rawdeserializedworld_takeNarrowPhase(this.ptr);
    return I2 === 0 ? void 0 : f.__wrap(I2);
  }
  takeBodies() {
    var I2 = A.rawdeserializedworld_takeBodies(this.ptr);
    return I2 === 0 ? void 0 : V.__wrap(I2);
  }
  takeColliders() {
    var I2 = A.rawdeserializedworld_takeColliders(this.ptr);
    return I2 === 0 ? void 0 : p.__wrap(I2);
  }
  takeJoints() {
    var I2 = A.rawdeserializedworld_takeJoints(this.ptr);
    return I2 === 0 ? void 0 : Z.__wrap(I2);
  }
}
class e {
  static __wrap(A2) {
    const I2 = Object.create(e.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_raweventqueue_free(I2);
  }
  constructor(I2) {
    var g2 = A.raweventqueue_new(I2);
    return e.__wrap(g2);
  }
  drainContactEvents(g2) {
    try {
      A.raweventqueue_drainContactEvents(this.ptr, h(g2));
    } finally {
      I[F++] = void 0;
    }
  }
  drainIntersectionEvents(g2) {
    try {
      A.raweventqueue_drainIntersectionEvents(this.ptr, h(g2));
    } finally {
      I[F++] = void 0;
    }
  }
  clear() {
    A.raweventqueue_clear(this.ptr);
  }
}
class O {
  static __wrap(A2) {
    const I2 = Object.create(O.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawintegrationparameters_free(I2);
  }
  constructor() {
    var I2 = A.rawintegrationparameters_new();
    return O.__wrap(I2);
  }
  get dt() {
    return A.rawintegrationparameters_dt(this.ptr);
  }
  get erp() {
    return A.rawintegrationparameters_erp(this.ptr);
  }
  get jointErp() {
    return A.rawintegrationparameters_jointErp(this.ptr);
  }
  get warmstartCoeff() {
    return A.rawintegrationparameters_warmstartCoeff(this.ptr);
  }
  get allowedLinearError() {
    return A.rawintegrationparameters_allowedLinearError(this.ptr);
  }
  get predictionDistance() {
    return A.rawintegrationparameters_predictionDistance(this.ptr);
  }
  get allowedAngularError() {
    return A.rawintegrationparameters_allowedAngularError(this.ptr);
  }
  get maxLinearCorrection() {
    return A.rawintegrationparameters_maxLinearCorrection(this.ptr);
  }
  get maxAngularCorrection() {
    return A.rawintegrationparameters_maxAngularCorrection(this.ptr);
  }
  get maxVelocityIterations() {
    return A.rawintegrationparameters_maxVelocityIterations(this.ptr) >>> 0;
  }
  get maxPositionIterations() {
    return A.rawintegrationparameters_maxPositionIterations(this.ptr) >>> 0;
  }
  get minIslandSize() {
    return A.rawintegrationparameters_minIslandSize(this.ptr) >>> 0;
  }
  get maxCcdSubsteps() {
    return A.rawintegrationparameters_maxCcdSubsteps(this.ptr) >>> 0;
  }
  set dt(I2) {
    A.rawintegrationparameters_set_dt(this.ptr, I2);
  }
  set erp(I2) {
    A.rawintegrationparameters_set_erp(this.ptr, I2);
  }
  set jointErp(I2) {
    A.rawintegrationparameters_set_jointErp(this.ptr, I2);
  }
  set warmstartCoeff(I2) {
    A.rawintegrationparameters_set_warmstartCoeff(this.ptr, I2);
  }
  set allowedLinearError(I2) {
    A.rawintegrationparameters_set_allowedLinearError(this.ptr, I2);
  }
  set predictionDistance(I2) {
    A.rawintegrationparameters_set_predictionDistance(this.ptr, I2);
  }
  set allowedAngularError(I2) {
    A.rawintegrationparameters_set_allowedAngularError(this.ptr, I2);
  }
  set maxLinearCorrection(I2) {
    A.rawintegrationparameters_set_maxLinearCorrection(this.ptr, I2);
  }
  set maxAngularCorrection(I2) {
    A.rawintegrationparameters_set_maxAngularCorrection(this.ptr, I2);
  }
  set maxVelocityIterations(I2) {
    A.rawintegrationparameters_set_maxVelocityIterations(this.ptr, I2);
  }
  set maxPositionIterations(I2) {
    A.rawintegrationparameters_set_maxPositionIterations(this.ptr, I2);
  }
  set minIslandSize(I2) {
    A.rawintegrationparameters_set_minIslandSize(this.ptr, I2);
  }
  set maxCcdSubsteps(I2) {
    A.rawintegrationparameters_set_maxCcdSubsteps(this.ptr, I2);
  }
}
class r {
  static __wrap(A2) {
    const I2 = Object.create(r.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawislandmanager_free(I2);
  }
  constructor() {
    var I2 = A.rawislandmanager_new();
    return r.__wrap(I2);
  }
  forEachActiveRigidBodyHandle(g2) {
    try {
      A.rawislandmanager_forEachActiveRigidBodyHandle(this.ptr, h(g2));
    } finally {
      I[F++] = void 0;
    }
  }
}
class d {
  static __wrap(A2) {
    const I2 = Object.create(d.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawjointparams_free(I2);
  }
  static ball(I2, g2) {
    a(I2, v), a(g2, v);
    var C2 = A.rawjointparams_ball(I2.ptr, g2.ptr);
    return d.__wrap(C2);
  }
  static prismatic(I2, g2, C2, B2, Q2, E2, i2, D2, o2) {
    a(I2, v), a(g2, v), a(C2, v), a(B2, v), a(Q2, v), a(E2, v);
    var S2 = A.rawjointparams_prismatic(I2.ptr, g2.ptr, C2.ptr, B2.ptr, Q2.ptr, E2.ptr, i2, D2, o2);
    return S2 === 0 ? void 0 : d.__wrap(S2);
  }
  static fixed(I2, g2, C2, B2) {
    a(I2, v), a(g2, m), a(C2, v), a(B2, m);
    var Q2 = A.rawjointparams_fixed(I2.ptr, g2.ptr, C2.ptr, B2.ptr);
    return d.__wrap(Q2);
  }
  static revolute(I2, g2, C2, B2) {
    a(I2, v), a(g2, v), a(C2, v), a(B2, v);
    var Q2 = A.rawjointparams_revolute(I2.ptr, g2.ptr, C2.ptr, B2.ptr);
    return Q2 === 0 ? void 0 : d.__wrap(Q2);
  }
}
class Z {
  static __wrap(A2) {
    const I2 = Object.create(Z.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawjointset_free(I2);
  }
  jointBodyHandle1(I2) {
    return A.rawjointset_jointBodyHandle1(this.ptr, I2) >>> 0;
  }
  jointBodyHandle2(I2) {
    return A.rawjointset_jointBodyHandle2(this.ptr, I2) >>> 0;
  }
  jointType(I2) {
    return A.rawjointset_jointType(this.ptr, I2) >>> 0;
  }
  jointFrameX1(I2) {
    var g2 = A.rawjointset_jointFrameX1(this.ptr, I2);
    return m.__wrap(g2);
  }
  jointFrameX2(I2) {
    var g2 = A.rawjointset_jointFrameX2(this.ptr, I2);
    return m.__wrap(g2);
  }
  jointAnchor1(I2) {
    var g2 = A.rawjointset_jointAnchor1(this.ptr, I2);
    return v.__wrap(g2);
  }
  jointAnchor2(I2) {
    var g2 = A.rawjointset_jointAnchor2(this.ptr, I2);
    return v.__wrap(g2);
  }
  jointAxis1(I2) {
    var g2 = A.rawjointset_jointAxis1(this.ptr, I2);
    return g2 === 0 ? void 0 : v.__wrap(g2);
  }
  jointAxis2(I2) {
    var g2 = A.rawjointset_jointAxis2(this.ptr, I2);
    return g2 === 0 ? void 0 : v.__wrap(g2);
  }
  jointLimitsEnabled(I2) {
    return A.rawjointset_jointLimitsEnabled(this.ptr, I2) !== 0;
  }
  jointLimitsMin(I2) {
    return A.rawjointset_jointLimitsMin(this.ptr, I2);
  }
  jointLimitsMax(I2) {
    return A.rawjointset_jointLimitsMax(this.ptr, I2);
  }
  jointConfigureMotorModel(I2, g2) {
    A.rawjointset_jointConfigureMotorModel(this.ptr, I2, g2);
  }
  jointConfigureBallMotorVelocity(I2, g2, C2, B2, Q2) {
    A.rawjointset_jointConfigureBallMotorVelocity(this.ptr, I2, g2, C2, B2, Q2);
  }
  jointConfigureBallMotorPosition(I2, g2, C2, B2, Q2, E2, i2) {
    A.rawjointset_jointConfigureBallMotorPosition(this.ptr, I2, g2, C2, B2, Q2, E2, i2);
  }
  jointConfigureBallMotor(I2, g2, C2, B2, Q2, E2, i2, D2, o2, S2) {
    A.rawjointset_jointConfigureBallMotor(this.ptr, I2, g2, C2, B2, Q2, E2, i2, D2, o2, S2);
  }
  jointConfigureUnitMotorVelocity(I2, g2, C2) {
    A.rawjointset_jointConfigureUnitMotorVelocity(this.ptr, I2, g2, C2);
  }
  jointConfigureUnitMotorPosition(I2, g2, C2, B2) {
    A.rawjointset_jointConfigureUnitMotorPosition(this.ptr, I2, g2, C2, B2);
  }
  jointConfigureUnitMotor(I2, g2, C2, B2, Q2) {
    A.rawjointset_jointConfigureUnitMotor(this.ptr, I2, g2, C2, B2, Q2);
  }
  constructor() {
    var I2 = A.rawjointset_new();
    return Z.__wrap(I2);
  }
  createJoint(I2, g2, C2, B2) {
    return a(I2, V), a(g2, d), A.rawjointset_createJoint(this.ptr, I2.ptr, g2.ptr, C2, B2) >>> 0;
  }
  remove(I2, g2, C2, B2) {
    a(g2, r), a(C2, V), A.rawjointset_remove(this.ptr, I2, g2.ptr, C2.ptr, B2);
  }
  len() {
    return A.rawjointset_len(this.ptr) >>> 0;
  }
  contains(I2) {
    return A.rawjointset_contains(this.ptr, I2) !== 0;
  }
  forEachJointHandle(g2) {
    try {
      A.rawjointset_forEachJointHandle(this.ptr, h(g2));
    } finally {
      I[F++] = void 0;
    }
  }
}
class f {
  static __wrap(A2) {
    const I2 = Object.create(f.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawnarrowphase_free(I2);
  }
  constructor() {
    var I2 = A.rawnarrowphase_new();
    return f.__wrap(I2);
  }
  contacts_with(I2, g2) {
    A.rawnarrowphase_contacts_with(this.ptr, I2, Q(g2));
  }
  contact_pair(I2, g2) {
    var C2 = A.rawnarrowphase_contact_pair(this.ptr, I2, g2);
    return C2 === 0 ? void 0 : T.__wrap(C2);
  }
  intersections_with(I2, g2) {
    A.rawnarrowphase_intersections_with(this.ptr, I2, Q(g2));
  }
  intersection_pair(I2, g2) {
    return A.rawnarrowphase_intersection_pair(this.ptr, I2, g2) !== 0;
  }
}
class W {
  static __wrap(A2) {
    const I2 = Object.create(W.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawphysicspipeline_free(I2);
  }
  constructor() {
    var I2 = A.rawphysicspipeline_new();
    return W.__wrap(I2);
  }
  step(I2, g2, C2, B2, Q2, E2, i2, D2, o2) {
    a(I2, v), a(g2, O), a(C2, r), a(B2, L), a(Q2, f), a(E2, V), a(i2, p), a(D2, Z), a(o2, H), A.rawphysicspipeline_step(this.ptr, I2.ptr, g2.ptr, C2.ptr, B2.ptr, Q2.ptr, E2.ptr, i2.ptr, D2.ptr, o2.ptr);
  }
  stepWithEvents(I2, g2, C2, B2, E2, i2, D2, o2, S2, G2, k2, w2, U2) {
    a(I2, v), a(g2, O), a(C2, r), a(B2, L), a(E2, f), a(i2, V), a(D2, p), a(o2, Z), a(S2, H), a(G2, e), A.rawphysicspipeline_stepWithEvents(this.ptr, I2.ptr, g2.ptr, C2.ptr, B2.ptr, E2.ptr, i2.ptr, D2.ptr, o2.ptr, S2.ptr, G2.ptr, Q(k2), Q(w2), Q(U2));
  }
}
class j {
  static __wrap(A2) {
    const I2 = Object.create(j.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawpointcolliderprojection_free(I2);
  }
  colliderHandle() {
    return A.rawpointcolliderprojection_colliderHandle(this.ptr) >>> 0;
  }
  point() {
    var I2 = A.rawpointcolliderprojection_point(this.ptr);
    return v.__wrap(I2);
  }
  isInside() {
    return A.rawpointcolliderprojection_isInside(this.ptr) !== 0;
  }
}
class b {
  static __wrap(A2) {
    const I2 = Object.create(b.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawquerypipeline_free(I2);
  }
  constructor() {
    var I2 = A.rawquerypipeline_new();
    return b.__wrap(I2);
  }
  update(I2, g2, C2) {
    a(I2, r), a(g2, V), a(C2, p), A.rawquerypipeline_update(this.ptr, I2.ptr, g2.ptr, C2.ptr);
  }
  castRay(I2, g2, C2, B2, Q2, E2) {
    a(I2, p), a(g2, v), a(C2, v);
    var i2 = A.rawquerypipeline_castRay(this.ptr, I2.ptr, g2.ptr, C2.ptr, B2, Q2, E2);
    return i2 === 0 ? void 0 : X.__wrap(i2);
  }
  castRayAndGetNormal(I2, g2, C2, B2, Q2, E2) {
    a(I2, p), a(g2, v), a(C2, v);
    var i2 = A.rawquerypipeline_castRayAndGetNormal(this.ptr, I2.ptr, g2.ptr, C2.ptr, B2, Q2, E2);
    return i2 === 0 ? void 0 : x.__wrap(i2);
  }
  intersectionsWithRay(g2, C2, B2, Q2, E2, i2, D2) {
    try {
      a(g2, p), a(C2, v), a(B2, v), A.rawquerypipeline_intersectionsWithRay(this.ptr, g2.ptr, C2.ptr, B2.ptr, Q2, E2, i2, h(D2));
    } finally {
      I[F++] = void 0;
    }
  }
  intersectionWithShape(I2, g2, C2, B2, Q2) {
    try {
      const D2 = A.__wbindgen_add_to_stack_pointer(-16);
      a(I2, p), a(g2, v), a(C2, m), a(B2, P), A.rawquerypipeline_intersectionWithShape(D2, this.ptr, I2.ptr, g2.ptr, C2.ptr, B2.ptr, Q2);
      var E2 = w()[D2 / 4 + 0], i2 = w()[D2 / 4 + 1];
      return E2 === 0 ? void 0 : i2 >>> 0;
    } finally {
      A.__wbindgen_add_to_stack_pointer(16);
    }
  }
  projectPoint(I2, g2, C2, B2) {
    a(I2, p), a(g2, v);
    var Q2 = A.rawquerypipeline_projectPoint(this.ptr, I2.ptr, g2.ptr, C2, B2);
    return Q2 === 0 ? void 0 : j.__wrap(Q2);
  }
  intersectionsWithPoint(g2, C2, B2, Q2) {
    try {
      a(g2, p), a(C2, v), A.rawquerypipeline_intersectionsWithPoint(this.ptr, g2.ptr, C2.ptr, B2, h(Q2));
    } finally {
      I[F++] = void 0;
    }
  }
  castShape(I2, g2, C2, B2, Q2, E2, i2) {
    a(I2, p), a(g2, v), a(C2, m), a(B2, v), a(Q2, P);
    var D2 = A.rawquerypipeline_castShape(this.ptr, I2.ptr, g2.ptr, C2.ptr, B2.ptr, Q2.ptr, E2, i2);
    return D2 === 0 ? void 0 : z.__wrap(D2);
  }
  intersectionsWithShape(g2, C2, B2, Q2, E2, i2) {
    try {
      a(g2, p), a(C2, v), a(B2, m), a(Q2, P), A.rawquerypipeline_intersectionsWithShape(this.ptr, g2.ptr, C2.ptr, B2.ptr, Q2.ptr, E2, h(i2));
    } finally {
      I[F++] = void 0;
    }
  }
  collidersWithAabbIntersectingAabb(g2, C2, B2) {
    try {
      a(g2, v);
      var Q2 = g2.ptr;
      g2.ptr = 0, a(C2, v);
      var E2 = C2.ptr;
      C2.ptr = 0, A.rawquerypipeline_collidersWithAabbIntersectingAabb(this.ptr, Q2, E2, h(B2));
    } finally {
      I[F++] = void 0;
    }
  }
}
class x {
  static __wrap(A2) {
    const I2 = Object.create(x.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawraycolliderintersection_free(I2);
  }
  colliderHandle() {
    return A.rawpointcolliderprojection_colliderHandle(this.ptr) >>> 0;
  }
  normal() {
    var I2 = A.rawraycolliderintersection_normal(this.ptr);
    return v.__wrap(I2);
  }
  toi() {
    return A.rawintegrationparameters_erp(this.ptr);
  }
}
class X {
  static __wrap(A2) {
    const I2 = Object.create(X.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawraycollidertoi_free(I2);
  }
  colliderHandle() {
    return A.rawpointcolliderprojection_colliderHandle(this.ptr) >>> 0;
  }
  toi() {
    return A.rawintegrationparameters_erp(this.ptr);
  }
}
class V {
  static __wrap(A2) {
    const I2 = Object.create(V.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawrigidbodyset_free(I2);
  }
  rbTranslation(I2) {
    var g2 = A.rawrigidbodyset_rbTranslation(this.ptr, I2);
    return v.__wrap(g2);
  }
  rbRotation(I2) {
    var g2 = A.rawrigidbodyset_rbRotation(this.ptr, I2);
    return m.__wrap(g2);
  }
  rbSleep(I2) {
    A.rawrigidbodyset_rbSleep(this.ptr, I2);
  }
  rbIsSleeping(I2) {
    return A.rawrigidbodyset_rbIsSleeping(this.ptr, I2) !== 0;
  }
  rbIsMoving(I2) {
    return A.rawrigidbodyset_rbIsMoving(this.ptr, I2) !== 0;
  }
  rbNextTranslation(I2) {
    var g2 = A.rawrigidbodyset_rbNextTranslation(this.ptr, I2);
    return v.__wrap(g2);
  }
  rbNextRotation(I2) {
    var g2 = A.rawrigidbodyset_rbNextRotation(this.ptr, I2);
    return m.__wrap(g2);
  }
  rbSetTranslation(I2, g2, C2, B2, Q2) {
    A.rawrigidbodyset_rbSetTranslation(this.ptr, I2, g2, C2, B2, Q2);
  }
  rbSetRotation(I2, g2, C2, B2, Q2, E2) {
    A.rawrigidbodyset_rbSetRotation(this.ptr, I2, g2, C2, B2, Q2, E2);
  }
  rbSetLinvel(I2, g2, C2) {
    a(g2, v), A.rawrigidbodyset_rbSetLinvel(this.ptr, I2, g2.ptr, C2);
  }
  rbSetAngvel(I2, g2, C2) {
    a(g2, v), A.rawrigidbodyset_rbSetAngvel(this.ptr, I2, g2.ptr, C2);
  }
  rbSetNextKinematicTranslation(I2, g2, C2, B2) {
    A.rawrigidbodyset_rbSetNextKinematicTranslation(this.ptr, I2, g2, C2, B2);
  }
  rbSetNextKinematicRotation(I2, g2, C2, B2, Q2) {
    A.rawrigidbodyset_rbSetNextKinematicRotation(this.ptr, I2, g2, C2, B2, Q2);
  }
  rbLinvel(I2) {
    var g2 = A.rawrigidbodyset_rbLinvel(this.ptr, I2);
    return v.__wrap(g2);
  }
  rbAngvel(I2) {
    var g2 = A.rawrigidbodyset_rbAngvel(this.ptr, I2);
    return v.__wrap(g2);
  }
  rbLockTranslations(I2, g2, C2) {
    A.rawrigidbodyset_rbLockRotations(this.ptr, I2, g2, C2);
  }
  rbLockRotations(I2, g2, C2) {
    A.rawrigidbodyset_rbLockRotations(this.ptr, I2, g2, C2);
  }
  rbRestrictRotations(I2, g2, C2, B2, Q2) {
    A.rawrigidbodyset_rbRestrictRotations(this.ptr, I2, g2, C2, B2, Q2);
  }
  rbDominanceGroup(I2) {
    return A.rawrigidbodyset_rbDominanceGroup(this.ptr, I2);
  }
  rbSetDominanceGroup(I2, g2) {
    A.rawrigidbodyset_rbSetDominanceGroup(this.ptr, I2, g2);
  }
  rbEnableCcd(I2, g2) {
    A.rawrigidbodyset_rbEnableCcd(this.ptr, I2, g2);
  }
  rbMass(I2) {
    return A.rawrigidbodyset_rbMass(this.ptr, I2);
  }
  rbWakeUp(I2) {
    A.rawrigidbodyset_rbWakeUp(this.ptr, I2);
  }
  rbIsCcdEnabled(I2) {
    return A.rawrigidbodyset_rbIsCcdEnabled(this.ptr, I2) !== 0;
  }
  rbNumColliders(I2) {
    return A.rawrigidbodyset_rbNumColliders(this.ptr, I2) >>> 0;
  }
  rbCollider(I2, g2) {
    return A.rawrigidbodyset_rbCollider(this.ptr, I2, g2) >>> 0;
  }
  rbBodyType(I2) {
    return A.rawrigidbodyset_rbBodyType(this.ptr, I2) >>> 0;
  }
  rbIsStatic(I2) {
    return A.rawrigidbodyset_rbIsStatic(this.ptr, I2) !== 0;
  }
  rbIsKinematic(I2) {
    return A.rawrigidbodyset_rbIsKinematic(this.ptr, I2) !== 0;
  }
  rbIsDynamic(I2) {
    return A.rawrigidbodyset_rbIsDynamic(this.ptr, I2) !== 0;
  }
  rbLinearDamping(I2) {
    return A.rawrigidbodyset_rbLinearDamping(this.ptr, I2);
  }
  rbAngularDamping(I2) {
    return A.rawrigidbodyset_rbAngularDamping(this.ptr, I2);
  }
  rbSetLinearDamping(I2, g2) {
    A.rawrigidbodyset_rbSetLinearDamping(this.ptr, I2, g2);
  }
  rbSetAngularDamping(I2, g2) {
    A.rawrigidbodyset_rbSetAngularDamping(this.ptr, I2, g2);
  }
  rbGravityScale(I2) {
    return A.rawrigidbodyset_rbGravityScale(this.ptr, I2);
  }
  rbSetGravityScale(I2, g2, C2) {
    A.rawrigidbodyset_rbSetGravityScale(this.ptr, I2, g2, C2);
  }
  rbApplyForce(I2, g2, C2) {
    a(g2, v), A.rawrigidbodyset_rbApplyForce(this.ptr, I2, g2.ptr, C2);
  }
  rbApplyImpulse(I2, g2, C2) {
    a(g2, v), A.rawrigidbodyset_rbApplyImpulse(this.ptr, I2, g2.ptr, C2);
  }
  rbApplyTorque(I2, g2, C2) {
    a(g2, v), A.rawrigidbodyset_rbApplyTorque(this.ptr, I2, g2.ptr, C2);
  }
  rbApplyTorqueImpulse(I2, g2, C2) {
    a(g2, v), A.rawrigidbodyset_rbApplyTorqueImpulse(this.ptr, I2, g2.ptr, C2);
  }
  rbApplyForceAtPoint(I2, g2, C2, B2) {
    a(g2, v), a(C2, v), A.rawrigidbodyset_rbApplyForceAtPoint(this.ptr, I2, g2.ptr, C2.ptr, B2);
  }
  rbApplyImpulseAtPoint(I2, g2, C2, B2) {
    a(g2, v), a(C2, v), A.rawrigidbodyset_rbApplyImpulseAtPoint(this.ptr, I2, g2.ptr, C2.ptr, B2);
  }
  constructor() {
    var I2 = A.rawrigidbodyset_new();
    return V.__wrap(I2);
  }
  createRigidBody(I2, g2, C2, B2, Q2, E2, i2, D2, o2, S2, G2, k2, w2, U2, J2, K2, M2, F2, h2) {
    return a(I2, v), a(g2, m), a(E2, v), a(i2, v), a(D2, v), a(o2, v), a(S2, m), A.rawrigidbodyset_createRigidBody(this.ptr, I2.ptr, g2.ptr, C2, B2, Q2, E2.ptr, i2.ptr, D2.ptr, o2.ptr, S2.ptr, G2, k2, w2, U2, J2, K2, M2, F2, h2) >>> 0;
  }
  remove(I2, g2, C2, B2) {
    a(g2, r), a(C2, p), a(B2, Z), A.rawrigidbodyset_remove(this.ptr, I2, g2.ptr, C2.ptr, B2.ptr);
  }
  len() {
    return A.rawrigidbodyset_len(this.ptr) >>> 0;
  }
  contains(I2) {
    return A.rawrigidbodyset_contains(this.ptr, I2) !== 0;
  }
  forEachRigidBodyHandle(g2) {
    try {
      A.rawrigidbodyset_forEachRigidBodyHandle(this.ptr, h(g2));
    } finally {
      I[F++] = void 0;
    }
  }
}
class m {
  static __wrap(A2) {
    const I2 = Object.create(m.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawrotation_free(I2);
  }
  constructor(I2, g2, C2, B2) {
    var Q2 = A.rawrotation_new(I2, g2, C2, B2);
    return m.__wrap(Q2);
  }
  static identity() {
    var I2 = A.rawrotation_identity();
    return m.__wrap(I2);
  }
  get x() {
    return A.rawintegrationparameters_dt(this.ptr);
  }
  get y() {
    return A.rawrotation_y(this.ptr);
  }
  get z() {
    return A.rawintegrationparameters_erp(this.ptr);
  }
  get w() {
    return A.rawintegrationparameters_jointErp(this.ptr);
  }
}
class u {
  static __wrap(A2) {
    const I2 = Object.create(u.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawserializationpipeline_free(I2);
  }
  constructor() {
    var I2 = A.rawserializationpipeline_new();
    return u.__wrap(I2);
  }
  serializeAll(I2, g2, C2, Q2, E2, i2, D2, o2) {
    return a(I2, v), a(g2, O), a(C2, r), a(Q2, L), a(E2, f), a(i2, V), a(D2, p), a(o2, Z), B(A.rawserializationpipeline_serializeAll(this.ptr, I2.ptr, g2.ptr, C2.ptr, Q2.ptr, E2.ptr, i2.ptr, D2.ptr, o2.ptr));
  }
  deserializeAll(I2) {
    var g2 = A.rawserializationpipeline_deserializeAll(this.ptr, Q(I2));
    return g2 === 0 ? void 0 : n.__wrap(g2);
  }
}
class P {
  static __wrap(A2) {
    const I2 = Object.create(P.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawshape_free(I2);
  }
  static cuboid(I2, g2, C2) {
    var B2 = A.rawshape_cuboid(I2, g2, C2);
    return P.__wrap(B2);
  }
  static roundCuboid(I2, g2, C2, B2) {
    var Q2 = A.rawshape_roundCuboid(I2, g2, C2, B2);
    return P.__wrap(Q2);
  }
  static ball(I2) {
    var g2 = A.rawshape_ball(I2);
    return P.__wrap(g2);
  }
  static capsule(I2, g2) {
    var C2 = A.rawshape_capsule(I2, g2);
    return P.__wrap(C2);
  }
  static cylinder(I2, g2) {
    var C2 = A.rawshape_cylinder(I2, g2);
    return P.__wrap(C2);
  }
  static roundCylinder(I2, g2, C2) {
    var B2 = A.rawshape_roundCylinder(I2, g2, C2);
    return P.__wrap(B2);
  }
  static cone(I2, g2) {
    var C2 = A.rawshape_cone(I2, g2);
    return P.__wrap(C2);
  }
  static roundCone(I2, g2, C2) {
    var B2 = A.rawshape_roundCone(I2, g2, C2);
    return P.__wrap(B2);
  }
  static polyline(I2, g2) {
    var C2 = Y(I2, A.__wbindgen_malloc), B2 = J, Q2 = c(g2, A.__wbindgen_malloc), E2 = J, i2 = A.rawshape_polyline(C2, B2, Q2, E2);
    return P.__wrap(i2);
  }
  static trimesh(I2, g2) {
    var C2 = Y(I2, A.__wbindgen_malloc), B2 = J, Q2 = c(g2, A.__wbindgen_malloc), E2 = J, i2 = A.rawshape_trimesh(C2, B2, Q2, E2);
    return P.__wrap(i2);
  }
  static heightfield(I2, g2, C2, B2) {
    var Q2 = Y(C2, A.__wbindgen_malloc), E2 = J;
    a(B2, v);
    var i2 = A.rawshape_heightfield(I2, g2, Q2, E2, B2.ptr);
    return P.__wrap(i2);
  }
  static segment(I2, g2) {
    a(I2, v), a(g2, v);
    var C2 = A.rawshape_segment(I2.ptr, g2.ptr);
    return P.__wrap(C2);
  }
  static triangle(I2, g2, C2) {
    a(I2, v), a(g2, v), a(C2, v);
    var B2 = A.rawshape_triangle(I2.ptr, g2.ptr, C2.ptr);
    return P.__wrap(B2);
  }
  static roundTriangle(I2, g2, C2, B2) {
    a(I2, v), a(g2, v), a(C2, v);
    var Q2 = A.rawshape_roundTriangle(I2.ptr, g2.ptr, C2.ptr, B2);
    return P.__wrap(Q2);
  }
  static convexHull(I2) {
    var g2 = Y(I2, A.__wbindgen_malloc), C2 = J, B2 = A.rawshape_convexHull(g2, C2);
    return B2 === 0 ? void 0 : P.__wrap(B2);
  }
  static roundConvexHull(I2, g2) {
    var C2 = Y(I2, A.__wbindgen_malloc), B2 = J, Q2 = A.rawshape_roundConvexHull(C2, B2, g2);
    return Q2 === 0 ? void 0 : P.__wrap(Q2);
  }
  static convexMesh(I2, g2) {
    var C2 = Y(I2, A.__wbindgen_malloc), B2 = J, Q2 = c(g2, A.__wbindgen_malloc), E2 = J, i2 = A.rawshape_convexMesh(C2, B2, Q2, E2);
    return i2 === 0 ? void 0 : P.__wrap(i2);
  }
  static roundConvexMesh(I2, g2, C2) {
    var B2 = Y(I2, A.__wbindgen_malloc), Q2 = J, E2 = c(g2, A.__wbindgen_malloc), i2 = J, D2 = A.rawshape_roundConvexMesh(B2, Q2, E2, i2, C2);
    return D2 === 0 ? void 0 : P.__wrap(D2);
  }
}
class z {
  static __wrap(A2) {
    const I2 = Object.create(z.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawshapecollidertoi_free(I2);
  }
  colliderHandle() {
    return A.rawpointcolliderprojection_colliderHandle(this.ptr) >>> 0;
  }
  toi() {
    return A.rawintegrationparameters_erp(this.ptr);
  }
  witness1() {
    var I2 = A.rawraycolliderintersection_normal(this.ptr);
    return v.__wrap(I2);
  }
  witness2() {
    var I2 = A.rawraycolliderintersection_normal(this.ptr);
    return v.__wrap(I2);
  }
  normal1() {
    var I2 = A.rawshapecollidertoi_normal1(this.ptr);
    return v.__wrap(I2);
  }
  normal2() {
    var I2 = A.rawshapecollidertoi_normal1(this.ptr);
    return v.__wrap(I2);
  }
}
class v {
  static __wrap(A2) {
    const I2 = Object.create(v.prototype);
    return I2.ptr = A2, I2;
  }
  __destroy_into_raw() {
    const A2 = this.ptr;
    return this.ptr = 0, A2;
  }
  free() {
    const I2 = this.__destroy_into_raw();
    A.__wbg_rawvector_free(I2);
  }
  static zero() {
    var I2 = A.rawvector_zero();
    return v.__wrap(I2);
  }
  constructor(I2, g2, C2) {
    var B2 = A.rawvector_new(I2, g2, C2);
    return v.__wrap(B2);
  }
  get x() {
    return A.rawintegrationparameters_dt(this.ptr);
  }
  set x(I2) {
    A.rawintegrationparameters_set_dt(this.ptr, I2);
  }
  get y() {
    return A.rawrotation_y(this.ptr);
  }
  set y(I2) {
    A.rawvector_set_y(this.ptr, I2);
  }
  get z() {
    return A.rawintegrationparameters_erp(this.ptr);
  }
  set z(I2) {
    A.rawintegrationparameters_set_erp(this.ptr, I2);
  }
  xyz() {
    var I2 = A.rawvector_xyz(this.ptr);
    return v.__wrap(I2);
  }
  yxz() {
    var I2 = A.rawvector_yxz(this.ptr);
    return v.__wrap(I2);
  }
  zxy() {
    var I2 = A.rawvector_zxy(this.ptr);
    return v.__wrap(I2);
  }
  xzy() {
    var I2 = A.rawvector_xzy(this.ptr);
    return v.__wrap(I2);
  }
  yzx() {
    var I2 = A.rawvector_yzx(this.ptr);
    return v.__wrap(I2);
  }
  zyx() {
    var I2 = A.rawvector_zyx(this.ptr);
    return v.__wrap(I2);
  }
}
async function _(I2) {
  I2 === void 0 && (I2 = new URL("rapier_wasm3d_bg.wasm", "<deleted>"));
  const C2 = {wbg: {}};
  C2.wbg.__wbindgen_object_drop_ref = function(A2) {
    B(A2);
  }, C2.wbg.__wbindgen_number_new = function(A2) {
    return Q(A2);
  }, C2.wbg.__wbg_rawraycolliderintersection_new = function(A2) {
    return Q(x.__wrap(A2));
  }, C2.wbg.__wbindgen_string_new = function(A2, I3) {
    return Q(o(A2, I3));
  }, C2.wbg.__wbg_now_b1c5cb547e270797 = function(A2) {
    return g(A2).now();
  }, C2.wbg.__wbg_newnoargs_68424965d85fcb08 = function(A2, I3) {
    return Q(new Function(o(A2, I3)));
  }, C2.wbg.__wbg_get_75d36ef8b2e1d918 = function() {
    return l(function(A2, I3) {
      return Q(Reflect.get(g(A2), g(I3)));
    }, arguments);
  }, C2.wbg.__wbg_call_9698e9b9c4668ae0 = function() {
    return l(function(A2, I3) {
      return Q(g(A2).call(g(I3)));
    }, arguments);
  }, C2.wbg.__wbindgen_object_clone_ref = function(A2) {
    return Q(g(A2));
  }, C2.wbg.__wbg_call_4438b4bab9ab5268 = function() {
    return l(function(A2, I3, C3) {
      return Q(g(A2).call(g(I3), g(C3)));
    }, arguments);
  }, C2.wbg.__wbg_call_f325895c60cbae4d = function() {
    return l(function(A2, I3, C3, B2) {
      return Q(g(A2).call(g(I3), g(C3), g(B2)));
    }, arguments);
  }, C2.wbg.__wbg_call_6adf041b33106f49 = function() {
    return l(function(A2, I3, C3, B2, E3) {
      return Q(g(A2).call(g(I3), g(C3), g(B2), g(E3)));
    }, arguments);
  }, C2.wbg.__wbg_bind_8d4d32f38fd23f21 = function(A2, I3, C3, B2) {
    return Q(g(A2).bind(g(I3), g(C3), g(B2)));
  }, C2.wbg.__wbg_buffer_eb2155f17856c20b = function(A2) {
    return Q(g(A2).buffer);
  }, C2.wbg.__wbg_self_3df7c33e222cd53b = function() {
    return l(function() {
      return Q(self.self);
    }, arguments);
  }, C2.wbg.__wbg_window_0f90182e6c405ff2 = function() {
    return l(function() {
      return Q(window.window);
    }, arguments);
  }, C2.wbg.__wbg_globalThis_787cfd4f25a35141 = function() {
    return l(function() {
      return Q(globalThis.globalThis);
    }, arguments);
  }, C2.wbg.__wbg_global_af2eb7b1369372ed = function() {
    return l(function() {
      return Q(global.global);
    }, arguments);
  }, C2.wbg.__wbindgen_is_undefined = function(A2) {
    return g(A2) === void 0;
  }, C2.wbg.__wbg_newwithbyteoffsetandlength_7d07f77c6d0d8e26 = function(A2, I3, C3) {
    return Q(new Uint8Array(g(A2), I3 >>> 0, C3 >>> 0));
  }, C2.wbg.__wbg_length_0b194abde938d0c6 = function(A2) {
    return g(A2).length;
  }, C2.wbg.__wbg_new_ff8b26f7b2d7e2fb = function(A2) {
    return Q(new Uint8Array(g(A2)));
  }, C2.wbg.__wbg_set_67cdd115b9cb141f = function(A2, I3, C3) {
    g(A2).set(g(I3), C3 >>> 0);
  }, C2.wbg.__wbindgen_number_get = function(I3, C3) {
    const B2 = g(C3);
    var Q2 = typeof B2 == "number" ? B2 : void 0;
    (G !== null && G.buffer === A.memory.buffer || (G = new Float64Array(A.memory.buffer)), G)[I3 / 8 + 1] = S(Q2) ? 0 : Q2, w()[I3 / 4 + 0] = !S(Q2);
  }, C2.wbg.__wbindgen_boolean_get = function(A2) {
    const I3 = g(A2);
    return typeof I3 == "boolean" ? I3 ? 1 : 0 : 2;
  }, C2.wbg.__wbindgen_debug_string = function(I3, C3) {
    var B2 = function(A2, I4, g2) {
      if (g2 === void 0) {
        const g3 = K.encode(A2), C5 = I4(g3.length);
        return D().subarray(C5, C5 + g3.length).set(g3), J = g3.length, C5;
      }
      let C4 = A2.length, B3 = I4(C4);
      const Q3 = D();
      let E3 = 0;
      for (; E3 < C4; E3++) {
        const I5 = A2.charCodeAt(E3);
        if (I5 > 127)
          break;
        Q3[B3 + E3] = I5;
      }
      if (E3 !== C4) {
        E3 !== 0 && (A2 = A2.slice(E3)), B3 = g2(B3, C4, C4 = E3 + 3 * A2.length);
        const I5 = D().subarray(B3 + E3, B3 + C4);
        E3 += M(A2, I5).written;
      }
      return J = E3, B3;
    }(U(g(C3)), A.__wbindgen_malloc, A.__wbindgen_realloc), Q2 = J;
    w()[I3 / 4 + 1] = Q2, w()[I3 / 4 + 0] = B2;
  }, C2.wbg.__wbindgen_throw = function(A2, I3) {
    throw new Error(o(A2, I3));
  }, C2.wbg.__wbindgen_memory = function() {
    return Q(A.memory);
  }, (typeof I2 == "string" || typeof Request == "function" && I2 instanceof Request || typeof URL == "function" && I2 instanceof URL) && (I2 = fetch(I2));
  const {instance: E2, module: i2} = await async function(A2, I3) {
    if (typeof Response == "function" && A2 instanceof Response) {
      if (typeof WebAssembly.instantiateStreaming == "function")
        try {
          return await WebAssembly.instantiateStreaming(A2, I3);
        } catch (I4) {
          if (A2.headers.get("Content-Type") == "application/wasm")
            throw I4;
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", I4);
        }
      const g2 = await A2.arrayBuffer();
      return await WebAssembly.instantiate(g2, I3);
    }
    {
      const g2 = await WebAssembly.instantiate(A2, I3);
      return g2 instanceof WebAssembly.Instance ? {instance: g2, module: A2} : g2;
    }
  }(await I2, C2);
  return A = E2.exports, _.__wbindgen_wasm_module = i2, A;
}
var $, AA = function(A2, I2, g2) {
  this.x = A2, this.y = I2, this.z = g2;
}, IA = function() {
  function A2() {
  }
  return A2.new = function(A3, I2, g2) {
    return new AA(A3, I2, g2);
  }, A2.intoRaw = function(A3) {
    return new v(A3.x, A3.y, A3.z);
  }, A2.zeros = function() {
    return A2.new(0, 0, 0);
  }, A2.fromRaw = function(I2) {
    if (!I2)
      return null;
    var g2 = A2.new(I2.x, I2.y, I2.z);
    return I2.free(), g2;
  }, A2;
}(), gA = function(A2, I2, g2, C2) {
  this.x = A2, this.y = I2, this.z = g2, this.w = C2;
}, CA = function() {
  function A2() {
  }
  return A2.identity = function() {
    return new gA(0, 0, 0, 1);
  }, A2.fromRaw = function(A3) {
    if (!A3)
      return null;
    var I2 = new gA(A3.x, A3.y, A3.z, A3.w);
    return A3.free(), I2;
  }, A2.intoRaw = function(A3) {
    return new m(A3.x, A3.y, A3.z, A3.w);
  }, A2;
}();
!function(A2) {
  A2[A2.Dynamic = 0] = "Dynamic", A2[A2.Static = 1] = "Static", A2[A2.KinematicPositionBased = 2] = "KinematicPositionBased", A2[A2.KinematicVelocityBased = 3] = "KinematicVelocityBased";
}($ || ($ = {}));
var BA, QA, EA = function() {
  function A2(A3, I2) {
    this.rawSet = A3, this.handle = I2;
  }
  return A2.prototype.isValid = function() {
    return this.rawSet.contains(this.handle);
  }, A2.prototype.lockTranslations = function(A3, I2) {
    return this.rawSet.rbLockTranslations(this.handle, A3, I2);
  }, A2.prototype.lockRotations = function(A3, I2) {
    return this.rawSet.rbLockRotations(this.handle, A3, I2);
  }, A2.prototype.restrictRotations = function(A3, I2, g2, C2) {
    return this.rawSet.rbRestrictRotations(this.handle, A3, I2, g2, C2);
  }, A2.prototype.dominanceGroup = function() {
    return this.rawSet.rbDominanceGroup(this.handle);
  }, A2.prototype.setDominanceGroup = function(A3) {
    this.rawSet.rbSetDominanceGroup(this.handle, A3);
  }, A2.prototype.enableCcd = function(A3) {
    this.rawSet.rbEnableCcd(this.handle, A3);
  }, A2.prototype.translation = function() {
    var A3 = this.rawSet.rbTranslation(this.handle);
    return IA.fromRaw(A3);
  }, A2.prototype.rotation = function() {
    var A3 = this.rawSet.rbRotation(this.handle);
    return CA.fromRaw(A3);
  }, A2.prototype.nextTranslation = function() {
    var A3 = this.rawSet.rbNextTranslation(this.handle);
    return IA.fromRaw(A3);
  }, A2.prototype.nextRotation = function() {
    var A3 = this.rawSet.rbNextRotation(this.handle);
    return CA.fromRaw(A3);
  }, A2.prototype.setTranslation = function(A3, I2) {
    this.rawSet.rbSetTranslation(this.handle, A3.x, A3.y, A3.z, I2);
  }, A2.prototype.setLinvel = function(A3, I2) {
    var g2 = IA.intoRaw(A3);
    this.rawSet.rbSetLinvel(this.handle, g2, I2), g2.free();
  }, A2.prototype.gravityScale = function() {
    return this.rawSet.rbGravityScale(this.handle);
  }, A2.prototype.setGravityScale = function(A3, I2) {
    this.rawSet.rbSetGravityScale(this.handle, A3, I2);
  }, A2.prototype.setRotation = function(A3, I2) {
    this.rawSet.rbSetRotation(this.handle, A3.x, A3.y, A3.z, A3.w, I2);
  }, A2.prototype.setAngvel = function(A3, I2) {
    var g2 = IA.intoRaw(A3);
    this.rawSet.rbSetAngvel(this.handle, g2, I2), g2.free();
  }, A2.prototype.setNextKinematicTranslation = function(A3) {
    this.rawSet.rbSetNextKinematicTranslation(this.handle, A3.x, A3.y, A3.z);
  }, A2.prototype.setNextKinematicRotation = function(A3) {
    this.rawSet.rbSetNextKinematicRotation(this.handle, A3.x, A3.y, A3.z, A3.w);
  }, A2.prototype.linvel = function() {
    return IA.fromRaw(this.rawSet.rbLinvel(this.handle));
  }, A2.prototype.angvel = function() {
    return IA.fromRaw(this.rawSet.rbAngvel(this.handle));
  }, A2.prototype.mass = function() {
    return this.rawSet.rbMass(this.handle);
  }, A2.prototype.sleep = function() {
    this.rawSet.rbSleep(this.handle);
  }, A2.prototype.wakeUp = function() {
    this.rawSet.rbWakeUp(this.handle);
  }, A2.prototype.isCcdEnabled = function() {
    this.rawSet.rbIsCcdEnabled(this.handle);
  }, A2.prototype.numColliders = function() {
    return this.rawSet.rbNumColliders(this.handle);
  }, A2.prototype.collider = function(A3) {
    return this.rawSet.rbCollider(this.handle, A3);
  }, A2.prototype.bodyType = function() {
    return this.rawSet.rbBodyType(this.handle);
  }, A2.prototype.isSleeping = function() {
    return this.rawSet.rbIsSleeping(this.handle);
  }, A2.prototype.isMoving = function() {
    return this.rawSet.rbIsMoving(this.handle);
  }, A2.prototype.isStatic = function() {
    return this.rawSet.rbIsStatic(this.handle);
  }, A2.prototype.isKinematic = function() {
    return this.rawSet.rbIsKinematic(this.handle);
  }, A2.prototype.isDynamic = function() {
    return this.rawSet.rbIsDynamic(this.handle);
  }, A2.prototype.linearDamping = function() {
    return this.rawSet.rbLinearDamping(this.handle);
  }, A2.prototype.angularDamping = function() {
    return this.rawSet.rbAngularDamping(this.handle);
  }, A2.prototype.setLinearDamping = function(A3) {
    this.rawSet.rbSetLinearDamping(this.handle, A3);
  }, A2.prototype.setAngularDamping = function(A3) {
    this.rawSet.rbSetAngularDamping(this.handle, A3);
  }, A2.prototype.applyForce = function(A3, I2) {
    var g2 = IA.intoRaw(A3);
    this.rawSet.rbApplyForce(this.handle, g2, I2), g2.free();
  }, A2.prototype.applyImpulse = function(A3, I2) {
    var g2 = IA.intoRaw(A3);
    this.rawSet.rbApplyImpulse(this.handle, g2, I2), g2.free();
  }, A2.prototype.applyTorque = function(A3, I2) {
    var g2 = IA.intoRaw(A3);
    this.rawSet.rbApplyTorque(this.handle, g2, I2), g2.free();
  }, A2.prototype.applyTorqueImpulse = function(A3, I2) {
    var g2 = IA.intoRaw(A3);
    this.rawSet.rbApplyTorqueImpulse(this.handle, g2, I2), g2.free();
  }, A2.prototype.applyForceAtPoint = function(A3, I2, g2) {
    var C2 = IA.intoRaw(A3), B2 = IA.intoRaw(I2);
    this.rawSet.rbApplyForceAtPoint(this.handle, C2, B2, g2), C2.free(), B2.free();
  }, A2.prototype.applyImpulseAtPoint = function(A3, I2, g2) {
    var C2 = IA.intoRaw(A3), B2 = IA.intoRaw(I2);
    this.rawSet.rbApplyImpulseAtPoint(this.handle, C2, B2, g2), C2.free(), B2.free();
  }, A2;
}(), iA = function() {
  function A2(A3) {
    this.status = A3, this.translation = IA.zeros(), this.rotation = CA.identity(), this.gravityScale = 1, this.linvel = IA.zeros(), this.mass = 0, this.translationsEnabled = true, this.centerOfMass = IA.zeros(), this.angvel = IA.zeros(), this.principalAngularInertia = IA.zeros(), this.angularInertiaLocalFrame = CA.identity(), this.rotationsEnabledX = true, this.rotationsEnabledY = true, this.rotationsEnabledZ = true, this.linearDamping = 0, this.angularDamping = 0, this.canSleep = true, this.ccdEnabled = false, this.dominanceGroup = 0;
  }
  return A2.newDynamic = function() {
    return new A2($.Dynamic);
  }, A2.newKinematicPositionBased = function() {
    return new A2($.KinematicPositionBased);
  }, A2.newKinematicVelocityBased = function() {
    return new A2($.KinematicVelocityBased);
  }, A2.newStatic = function() {
    return new A2($.Static);
  }, A2.prototype.setDominanceGroup = function(A3) {
    return this.dominanceGroup = A3, this;
  }, A2.prototype.setTranslation = function(A3, I2, g2) {
    if (typeof A3 != "number" || typeof I2 != "number" || typeof g2 != "number")
      throw TypeError("The translation components must be numbers.");
    return this.translation = {x: A3, y: I2, z: g2}, this;
  }, A2.prototype.setRotation = function(A3) {
    return this.rotation = A3, this;
  }, A2.prototype.setGravityScale = function(A3) {
    return this.gravityScale = A3, this;
  }, A2.prototype.setAdditionalMass = function(A3) {
    return this.mass = A3, this;
  }, A2.prototype.lockTranslations = function() {
    return this.translationsEnabled = false, this;
  }, A2.prototype.setLinvel = function(A3, I2, g2) {
    if (typeof A3 != "number" || typeof I2 != "number" || typeof g2 != "number")
      throw TypeError("The linvel components must be numbers.");
    return this.linvel = {x: A3, y: I2, z: g2}, this;
  }, A2.prototype.setAngvel = function(A3) {
    return this.angvel = A3, this;
  }, A2.prototype.setAdditionalMassProperties = function(A3, I2, g2, C2) {
    return this.mass = A3, this.centerOfMass = I2, this.principalAngularInertia = g2, this.angularInertiaLocalFrame = C2, this;
  }, A2.prototype.setAdditionalPrincipalAngularInertia = function(A3) {
    return this.principalAngularInertia = A3, this;
  }, A2.prototype.restrictRotations = function(A3, I2, g2) {
    return this.rotationsEnabledX = A3, this.rotationsEnabledY = I2, this.rotationsEnabledZ = g2, this;
  }, A2.prototype.lockRotations = function() {
    return this.restrictRotations(false, false, false);
  }, A2.prototype.setLinearDamping = function(A3) {
    return this.linearDamping = A3, this;
  }, A2.prototype.setAngularDamping = function(A3) {
    return this.angularDamping = A3, this;
  }, A2.prototype.setCanSleep = function(A3) {
    return this.canSleep = A3, this;
  }, A2.prototype.setCcdEnabled = function(A3) {
    return this.ccdEnabled = A3, this;
  }, A2;
}(), DA = function() {
  function A2(A3) {
    this.raw = A3 || new V();
  }
  return A2.prototype.free = function() {
    this.raw.free(), this.raw = void 0;
  }, A2.prototype.createRigidBody = function(A3) {
    var I2 = IA.intoRaw(A3.translation), g2 = CA.intoRaw(A3.rotation), C2 = IA.intoRaw(A3.linvel), B2 = IA.intoRaw(A3.centerOfMass), Q2 = IA.intoRaw(A3.angvel), E2 = IA.intoRaw(A3.principalAngularInertia), i2 = CA.intoRaw(A3.angularInertiaLocalFrame), D2 = this.raw.createRigidBody(I2, g2, A3.gravityScale, A3.mass, A3.translationsEnabled, B2, C2, Q2, E2, i2, A3.rotationsEnabledX, A3.rotationsEnabledY, A3.rotationsEnabledZ, A3.linearDamping, A3.angularDamping, A3.status, A3.canSleep, A3.ccdEnabled, A3.dominanceGroup);
    return I2.free(), g2.free(), C2.free(), B2.free(), Q2.free(), E2.free(), i2.free(), D2;
  }, A2.prototype.remove = function(A3, I2, g2, C2) {
    this.raw.remove(A3, I2.raw, g2.raw, C2.raw);
  }, A2.prototype.len = function() {
    return this.raw.len();
  }, A2.prototype.contains = function(A3) {
    return this.raw.contains(A3);
  }, A2.prototype.get = function(A3) {
    return this.raw.contains(A3) ? new EA(this.raw, A3) : null;
  }, A2.prototype.forEachRigidBody = function(A3) {
    var I2 = this;
    this.forEachRigidBodyHandle(function(g2) {
      A3(new EA(I2.raw, g2));
    });
  }, A2.prototype.forEachRigidBodyHandle = function(A3) {
    this.raw.forEachRigidBodyHandle(A3);
  }, A2.prototype.forEachActiveRigidBody = function(A3, I2) {
    var g2 = this;
    A3.forEachActiveRigidBodyHandle(function(A4) {
      I2(new EA(g2.raw, A4));
    });
  }, A2;
}(), oA = function() {
  function A2(A3) {
    this.raw = A3 || new O();
  }
  return A2.prototype.free = function() {
    this.raw.free(), this.raw = void 0;
  }, Object.defineProperty(A2.prototype, "dt", {get: function() {
    return this.raw.dt;
  }, set: function(A3) {
    this.raw.dt = A3;
  }, enumerable: false, configurable: true}), Object.defineProperty(A2.prototype, "erp", {get: function() {
    return this.raw.erp;
  }, set: function(A3) {
    this.raw.erp = A3;
  }, enumerable: false, configurable: true}), Object.defineProperty(A2.prototype, "jointErp", {get: function() {
    return this.raw.jointErp;
  }, set: function(A3) {
    this.raw.jointErp = A3;
  }, enumerable: false, configurable: true}), Object.defineProperty(A2.prototype, "warmstartCoeff", {get: function() {
    return this.raw.warmstartCoeff;
  }, set: function(A3) {
    this.raw.warmstartCoeff = A3;
  }, enumerable: false, configurable: true}), Object.defineProperty(A2.prototype, "allowedLinearError", {get: function() {
    return this.raw.allowedLinearError;
  }, set: function(A3) {
    this.raw.allowedLinearError = A3;
  }, enumerable: false, configurable: true}), Object.defineProperty(A2.prototype, "predictionDistance", {get: function() {
    return this.raw.predictionDistance;
  }, set: function(A3) {
    this.raw.predictionDistance = A3;
  }, enumerable: false, configurable: true}), Object.defineProperty(A2.prototype, "allowedAngularError", {get: function() {
    return this.raw.allowedAngularError;
  }, set: function(A3) {
    this.raw.allowedAngularError = A3;
  }, enumerable: false, configurable: true}), Object.defineProperty(A2.prototype, "maxLinearCorrection", {get: function() {
    return this.raw.maxLinearCorrection;
  }, set: function(A3) {
    this.raw.maxLinearCorrection = A3;
  }, enumerable: false, configurable: true}), Object.defineProperty(A2.prototype, "maxAngularCorrection", {get: function() {
    return this.raw.maxAngularCorrection;
  }, set: function(A3) {
    this.raw.maxAngularCorrection = A3;
  }, enumerable: false, configurable: true}), Object.defineProperty(A2.prototype, "maxVelocityIterations", {get: function() {
    return this.raw.maxVelocityIterations;
  }, set: function(A3) {
    this.raw.maxVelocityIterations = A3;
  }, enumerable: false, configurable: true}), Object.defineProperty(A2.prototype, "maxPositionIterations", {get: function() {
    return this.raw.maxPositionIterations;
  }, set: function(A3) {
    this.raw.maxPositionIterations = A3;
  }, enumerable: false, configurable: true}), Object.defineProperty(A2.prototype, "minIslandSize", {get: function() {
    return this.raw.minIslandSize;
  }, set: function(A3) {
    this.raw.minIslandSize = A3;
  }, enumerable: false, configurable: true}), Object.defineProperty(A2.prototype, "maxCcdSubsteps", {get: function() {
    return this.raw.maxCcdSubsteps;
  }, set: function(A3) {
    this.raw.maxCcdSubsteps = A3;
  }, enumerable: false, configurable: true}), A2;
}(), SA = function(A2, I2) {
  return (SA = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(A3, I3) {
    A3.__proto__ = I3;
  } || function(A3, I3) {
    for (var g2 in I3)
      Object.prototype.hasOwnProperty.call(I3, g2) && (A3[g2] = I3[g2]);
  })(A2, I2);
};
function GA(A2, I2) {
  if (typeof I2 != "function" && I2 !== null)
    throw new TypeError("Class extends value " + String(I2) + " is not a constructor or null");
  function g2() {
    this.constructor = A2;
  }
  SA(A2, I2), A2.prototype = I2 === null ? Object.create(I2) : (g2.prototype = I2.prototype, new g2());
}
function kA(A2, I2, g2, C2) {
  return new (g2 || (g2 = Promise))(function(B2, Q2) {
    function E2(A3) {
      try {
        D2(C2.next(A3));
      } catch (A4) {
        Q2(A4);
      }
    }
    function i2(A3) {
      try {
        D2(C2.throw(A3));
      } catch (A4) {
        Q2(A4);
      }
    }
    function D2(A3) {
      var I3;
      A3.done ? B2(A3.value) : (I3 = A3.value, I3 instanceof g2 ? I3 : new g2(function(A4) {
        A4(I3);
      })).then(E2, i2);
    }
    D2((C2 = C2.apply(A2, I2 || [])).next());
  });
}
function wA(A2, I2) {
  var g2, C2, B2, Q2, E2 = {label: 0, sent: function() {
    if (1 & B2[0])
      throw B2[1];
    return B2[1];
  }, trys: [], ops: []};
  return Q2 = {next: i2(0), throw: i2(1), return: i2(2)}, typeof Symbol == "function" && (Q2[Symbol.iterator] = function() {
    return this;
  }), Q2;
  function i2(Q3) {
    return function(i3) {
      return function(Q4) {
        if (g2)
          throw new TypeError("Generator is already executing.");
        for (; E2; )
          try {
            if (g2 = 1, C2 && (B2 = 2 & Q4[0] ? C2.return : Q4[0] ? C2.throw || ((B2 = C2.return) && B2.call(C2), 0) : C2.next) && !(B2 = B2.call(C2, Q4[1])).done)
              return B2;
            switch (C2 = 0, B2 && (Q4 = [2 & Q4[0], B2.value]), Q4[0]) {
              case 0:
              case 1:
                B2 = Q4;
                break;
              case 4:
                return E2.label++, {value: Q4[1], done: false};
              case 5:
                E2.label++, C2 = Q4[1], Q4 = [0];
                continue;
              case 7:
                Q4 = E2.ops.pop(), E2.trys.pop();
                continue;
              default:
                if (!(B2 = E2.trys, (B2 = B2.length > 0 && B2[B2.length - 1]) || Q4[0] !== 6 && Q4[0] !== 2)) {
                  E2 = 0;
                  continue;
                }
                if (Q4[0] === 3 && (!B2 || Q4[1] > B2[0] && Q4[1] < B2[3])) {
                  E2.label = Q4[1];
                  break;
                }
                if (Q4[0] === 6 && E2.label < B2[1]) {
                  E2.label = B2[1], B2 = Q4;
                  break;
                }
                if (B2 && E2.label < B2[2]) {
                  E2.label = B2[2], E2.ops.push(Q4);
                  break;
                }
                B2[2] && E2.ops.pop(), E2.trys.pop();
                continue;
            }
            Q4 = I2.call(A2, E2);
          } catch (A3) {
            Q4 = [6, A3], C2 = 0;
          } finally {
            g2 = B2 = 0;
          }
        if (5 & Q4[0])
          throw Q4[1];
        return {value: Q4[0] ? Q4[1] : void 0, done: true};
      }([Q3, i3]);
    };
  }
}
!function(A2) {
  A2[A2.Ball = 0] = "Ball", A2[A2.Fixed = 1] = "Fixed", A2[A2.Prismatic = 2] = "Prismatic", A2[A2.Revolute = 3] = "Revolute";
}(BA || (BA = {})), function(A2) {
  A2[A2.Disabled = 0] = "Disabled", A2[A2.VelocityBased = 1] = "VelocityBased", A2[A2.AccelerationBased = 2] = "AccelerationBased", A2[A2.ForceBased = 3] = "ForceBased";
}(QA || (QA = {}));
var UA, JA = function() {
  function A2(A3, I2) {
    this.rawSet = A3, this.handle = I2;
  }
  return A2.prototype.isValid = function() {
    return this.rawSet.contains(this.handle);
  }, A2.prototype.bodyHandle1 = function() {
    return this.rawSet.jointBodyHandle1(this.handle);
  }, A2.prototype.bodyHandle2 = function() {
    return this.rawSet.jointBodyHandle2(this.handle);
  }, A2.prototype.type = function() {
    return this.rawSet.jointType(this.handle);
  }, A2.prototype.frameX1 = function() {
    return CA.fromRaw(this.rawSet.jointFrameX1(this.handle));
  }, A2.prototype.frameX2 = function() {
    return CA.fromRaw(this.rawSet.jointFrameX2(this.handle));
  }, A2.prototype.anchor1 = function() {
    return IA.fromRaw(this.rawSet.jointAnchor1(this.handle));
  }, A2.prototype.anchor2 = function() {
    return IA.fromRaw(this.rawSet.jointAnchor2(this.handle));
  }, A2.prototype.axis1 = function() {
    return IA.fromRaw(this.rawSet.jointAxis1(this.handle));
  }, A2.prototype.axis2 = function() {
    return IA.fromRaw(this.rawSet.jointAxis2(this.handle));
  }, A2;
}(), KA = function(A2) {
  function I2() {
    return A2 !== null && A2.apply(this, arguments) || this;
  }
  return GA(I2, A2), I2.prototype.limitsEnabled = function() {
    return this.rawSet.jointLimitsEnabled(this.handle);
  }, I2.prototype.limitsMin = function() {
    return this.rawSet.jointLimitsMin(this.handle);
  }, I2.prototype.limitsMax = function() {
    return this.rawSet.jointLimitsMax(this.handle);
  }, I2.prototype.configureMotorModel = function(A3) {
    this.rawSet.jointConfigureMotorModel(this.handle, A3);
  }, I2.prototype.configureMotorVelocity = function(A3, I3) {
    this.rawSet.jointConfigureUnitMotorVelocity(this.handle, A3, I3);
  }, I2.prototype.configureMotorPosition = function(A3, I3, g2) {
    this.rawSet.jointConfigureUnitMotorPosition(this.handle, A3, I3, g2);
  }, I2.prototype.configureMotor = function(A3, I3, g2, C2) {
    this.rawSet.jointConfigureUnitMotor(this.handle, A3, I3, g2, C2);
  }, I2;
}(JA), MA = function(A2) {
  function I2() {
    return A2 !== null && A2.apply(this, arguments) || this;
  }
  return GA(I2, A2), I2;
}(JA), FA = function(A2) {
  function I2() {
    return A2 !== null && A2.apply(this, arguments) || this;
  }
  return GA(I2, A2), I2;
}(KA), hA = function(A2) {
  function I2() {
    return A2 !== null && A2.apply(this, arguments) || this;
  }
  return GA(I2, A2), I2.prototype.configureMotorModel = function(A3) {
    this.rawSet.jointConfigureMotorModel(this.handle, A3);
  }, I2.prototype.configureMotorVelocity = function(A3, I3) {
    this.rawSet.jointConfigureBallMotorVelocity(this.handle, A3.x, A3.y, A3.z, I3);
  }, I2.prototype.configureMotorPosition = function(A3, I3, g2) {
    this.rawSet.jointConfigureBallMotorPosition(this.handle, A3.w, A3.x, A3.y, A3.z, I3, g2);
  }, I2.prototype.configureMotor = function(A3, I3, g2, C2) {
    this.rawSet.jointConfigureBallMotor(this.handle, A3.w, A3.x, A3.y, A3.z, I3.x, I3.y, I3.z, g2, C2);
  }, I2;
}(JA), aA = function(A2) {
  function I2() {
    return A2 !== null && A2.apply(this, arguments) || this;
  }
  return GA(I2, A2), I2;
}(KA), yA = function() {
  function A2() {
  }
  return A2.ball = function(I2, g2) {
    var C2 = new A2();
    return C2.anchor1 = I2, C2.anchor2 = g2, C2.jointType = BA.Ball, C2;
  }, A2.fixed = function(I2, g2, C2, B2) {
    var Q2 = new A2();
    return Q2.anchor1 = I2, Q2.anchor2 = C2, Q2.frame1 = g2, Q2.frame2 = B2, Q2.jointType = BA.Fixed, Q2;
  }, A2.prismatic = function(I2, g2, C2, B2, Q2, E2) {
    var i2 = new A2();
    return i2.anchor1 = I2, i2.axis1 = g2, i2.tangent1 = C2, i2.anchor2 = B2, i2.axis2 = Q2, i2.tangent2 = E2, i2.jointType = BA.Prismatic, i2;
  }, A2.revolute = function(I2, g2, C2, B2) {
    var Q2 = new A2();
    return Q2.anchor1 = I2, Q2.anchor2 = C2, Q2.axis1 = g2, Q2.axis2 = B2, Q2.jointType = BA.Revolute, Q2;
  }, A2.prototype.intoRaw = function() {
    var A3, I2, g2, C2 = IA.intoRaw(this.anchor1), B2 = IA.intoRaw(this.anchor2), Q2 = false, E2 = 0, i2 = 0;
    switch (this.jointType) {
      case BA.Ball:
        g2 = d.ball(C2, B2);
        break;
      case BA.Fixed:
        var D2 = CA.intoRaw(this.frame1), o2 = CA.intoRaw(this.frame2);
        g2 = d.fixed(C2, D2, B2, o2), D2.free(), o2.free();
        break;
      case BA.Prismatic:
        A3 = IA.intoRaw(this.axis1), I2 = IA.intoRaw(this.axis2), this.limitsEnabled && (Q2 = true, E2 = this.limits[0], i2 = this.limits[1]);
        var S2 = IA.intoRaw(this.tangent1), G2 = IA.intoRaw(this.tangent2);
        g2 = d.prismatic(C2, A3, S2, B2, I2, G2, Q2, E2, i2), S2.free(), G2.free(), A3.free(), I2.free();
        break;
      case BA.Revolute:
        A3 = IA.intoRaw(this.axis1), I2 = IA.intoRaw(this.axis2), g2 = d.revolute(C2, A3, B2, I2), A3.free(), I2.free();
    }
    return C2.free(), B2.free(), g2;
  }, A2;
}(), qA = function() {
  function A2(A3) {
    this.raw = A3 || new Z();
  }
  return A2.prototype.free = function() {
    this.raw.free(), this.raw = void 0;
  }, A2.prototype.createJoint = function(A3, I2, g2, C2) {
    var B2 = I2.intoRaw(), Q2 = this.raw.createJoint(A3.raw, B2, g2, C2);
    return B2.free(), Q2;
  }, A2.prototype.remove = function(A3, I2, g2, C2) {
    this.raw.remove(A3, I2.raw, g2.raw, C2);
  }, A2.prototype.len = function() {
    return this.raw.len();
  }, A2.prototype.contains = function(A3) {
    return this.raw.contains(A3);
  }, A2.prototype.get = function(A3) {
    if (!this.raw.contains(A3))
      return null;
    switch (this.raw.jointType(A3)) {
      case BA.Ball:
        return new hA(this.raw, A3);
      case BA.Prismatic:
        return new FA(this.raw, A3);
      case BA.Fixed:
        return new MA(this.raw, A3);
      case BA.Revolute:
        return new aA(this.raw, A3);
    }
  }, A2.prototype.forEachJoint = function(A3) {
    var I2 = this;
    this.raw.forEachJointHandle(function(g2) {
      A3(new JA(I2.raw, g2));
    });
  }, A2.prototype.forEachJointHandle = function(A3) {
    this.raw.forEachJointHandle(A3);
  }, A2;
}();
!function(A2) {
  A2[A2.Average = 0] = "Average", A2[A2.Min = 1] = "Min", A2[A2.Multiply = 2] = "Multiply", A2[A2.Max = 3] = "Max";
}(UA || (UA = {}));
var NA, RA = function() {
  function A2(A3) {
    this.raw = A3 || new H();
  }
  return A2.prototype.free = function() {
    this.raw.free(), this.raw = void 0;
  }, A2;
}(), sA = function() {
  function A2(A3) {
    this.raw = A3 || new r();
  }
  return A2.prototype.free = function() {
    this.raw.free(), this.raw = void 0;
  }, A2.prototype.forEachActiveRigidBodyHandle = function(A3) {
    this.raw.forEachActiveRigidBodyHandle(A3);
  }, A2;
}(), YA = function() {
  function A2(A3) {
    this.raw = A3 || new L();
  }
  return A2.prototype.free = function() {
    this.raw.free(), this.raw = void 0;
  }, A2;
}(), cA = function() {
  function A2(A3) {
    this.raw = A3 || new f(), this.tempManifold = new lA(null);
  }
  return A2.prototype.free = function() {
    this.raw.free(), this.raw = void 0;
  }, A2.prototype.contactsWith = function(A3, I2) {
    this.raw.contacts_with(A3, I2);
  }, A2.prototype.intersectionsWith = function(A3, I2) {
    this.raw.intersections_with(A3, I2);
  }, A2.prototype.contactPair = function(A3, I2, g2) {
    var C2 = this.raw.contact_pair(A3, I2);
    if (C2) {
      var B2 = C2.collider1() != A3, Q2 = void 0;
      for (Q2 = 0; Q2 < C2.numContactManifolds(); ++Q2)
        this.tempManifold.raw = C2.contactManifold(Q2), this.tempManifold.raw && g2(this.tempManifold, B2), this.tempManifold.free();
      C2.free();
    }
  }, A2.prototype.intersectionPair = function(A3, I2) {
    return this.raw.intersection_pair(A3, I2);
  }, A2;
}(), lA = function() {
  function A2(A3) {
    this.raw = A3;
  }
  return A2.prototype.free = function() {
    this.raw.free(), this.raw = void 0;
  }, A2.prototype.normal = function() {
    return IA.fromRaw(this.raw.normal());
  }, A2.prototype.localNormal1 = function() {
    return IA.fromRaw(this.raw.local_n1());
  }, A2.prototype.localNormal2 = function() {
    return IA.fromRaw(this.raw.local_n2());
  }, A2.prototype.subshape1 = function() {
    return this.raw.subshape1();
  }, A2.prototype.subshape2 = function() {
    return this.raw.subshape2();
  }, A2.prototype.numContacts = function() {
    return this.raw.num_contacts();
  }, A2.prototype.localContactPoint1 = function(A3) {
    return IA.fromRaw(this.raw.contact_local_p1(A3));
  }, A2.prototype.localContactPoint2 = function(A3) {
    return IA.fromRaw(this.raw.contact_local_p2(A3));
  }, A2.prototype.contactDist = function(A3) {
    return this.raw.contact_dist(A3);
  }, A2.prototype.contactFid1 = function(A3) {
    return this.raw.contact_fid1(A3);
  }, A2.prototype.contactFid2 = function(A3) {
    return this.raw.contact_fid2(A3);
  }, A2.prototype.contactImpulse = function(A3) {
    return this.raw.contact_impulse(A3);
  }, A2.prototype.contactTangentImpulseX = function(A3) {
    return this.raw.contact_tangent_impulse_x(A3);
  }, A2.prototype.contactTangentImpulseY = function(A3) {
    return this.raw.contact_tangent_impulse_y(A3);
  }, A2.prototype.numSolverContacts = function() {
    return this.raw.num_solver_contacts();
  }, A2.prototype.solverContactPoint = function(A3) {
    return IA.fromRaw(this.raw.solver_contact_point(A3));
  }, A2.prototype.solverContactDist = function(A3) {
    return this.raw.solver_contact_dist(A3);
  }, A2.prototype.solverContactFriction = function(A3) {
    return this.raw.solver_contact_friction(A3);
  }, A2.prototype.solverContactRestitution = function(A3) {
    return this.raw.solver_contact_restitution(A3);
  }, A2.prototype.solverContactTangentVelocity = function(A3) {
    return IA.fromRaw(this.raw.solver_contact_tangent_velocity(A3));
  }, A2;
}();
!function(A2) {
  A2[A2.Ball = 0] = "Ball", A2[A2.Cuboid = 1] = "Cuboid", A2[A2.Capsule = 2] = "Capsule", A2[A2.Segment = 3] = "Segment", A2[A2.Polyline = 4] = "Polyline", A2[A2.Triangle = 5] = "Triangle", A2[A2.TriMesh = 6] = "TriMesh", A2[A2.HeightField = 7] = "HeightField", A2[A2.ConvexPolyhedron = 9] = "ConvexPolyhedron", A2[A2.Cylinder = 10] = "Cylinder", A2[A2.Cone = 11] = "Cone", A2[A2.RoundCuboid = 12] = "RoundCuboid", A2[A2.RoundTriangle = 13] = "RoundTriangle", A2[A2.RoundCylinder = 14] = "RoundCylinder", A2[A2.RoundCone = 15] = "RoundCone", A2[A2.RoundConvexPolyhedron = 16] = "RoundConvexPolyhedron";
}(NA || (NA = {}));
var LA, HA = function() {
  function A2(A3) {
    this.radius = A3;
  }
  return A2.prototype.intoRaw = function() {
    return P.ball(this.radius);
  }, A2;
}(), pA = function() {
  function A2(A3, I2, g2) {
    this.halfExtents = IA.new(A3, I2, g2);
  }
  return A2.prototype.intoRaw = function() {
    return P.cuboid(this.halfExtents.x, this.halfExtents.y, this.halfExtents.z);
  }, A2;
}(), tA = function() {
  function A2(A3, I2, g2, C2) {
    this.halfExtents = IA.new(A3, I2, g2), this.borderRadius = C2;
  }
  return A2.prototype.intoRaw = function() {
    return P.roundCuboid(this.halfExtents.x, this.halfExtents.y, this.halfExtents.z, this.borderRadius);
  }, A2;
}(), TA = function() {
  function A2(A3, I2) {
    this.halfHeight = A3, this.radius = I2;
  }
  return A2.prototype.intoRaw = function() {
    return P.capsule(this.halfHeight, this.radius);
  }, A2;
}(), nA = function() {
  function A2(A3, I2) {
    this.a = A3, this.b = I2;
  }
  return A2.prototype.intoRaw = function() {
    var A3 = IA.intoRaw(this.a), I2 = IA.intoRaw(this.b), g2 = P.segment(A3, I2);
    return A3.free(), I2.free(), g2;
  }, A2;
}(), eA = function() {
  function A2(A3, I2, g2) {
    this.a = A3, this.b = I2, this.c = g2;
  }
  return A2.prototype.intoRaw = function() {
    var A3 = IA.intoRaw(this.a), I2 = IA.intoRaw(this.b), g2 = IA.intoRaw(this.c), C2 = P.triangle(A3, I2, g2);
    return A3.free(), I2.free(), g2.free(), C2;
  }, A2;
}(), OA = function() {
  function A2(A3, I2, g2, C2) {
    this.a = A3, this.b = I2, this.c = g2, this.borderRadius = C2;
  }
  return A2.prototype.intoRaw = function() {
    var A3 = IA.intoRaw(this.a), I2 = IA.intoRaw(this.b), g2 = IA.intoRaw(this.c), C2 = P.roundTriangle(A3, I2, g2, this.borderRadius);
    return A3.free(), I2.free(), g2.free(), C2;
  }, A2;
}(), rA = function() {
  function A2(A3, I2) {
    this.vertices = A3, this.indices = I2 || new Uint32Array(0);
  }
  return A2.prototype.intoRaw = function() {
    return P.polyline(this.vertices, this.indices);
  }, A2;
}(), dA = function() {
  function A2(A3, I2) {
    this.vertices = A3, this.indices = I2;
  }
  return A2.prototype.intoRaw = function() {
    return P.trimesh(this.vertices, this.indices);
  }, A2;
}(), ZA = function() {
  function A2(A3, I2) {
    this.vertices = A3, this.indices = I2;
  }
  return A2.prototype.intoRaw = function() {
    return this.indices ? P.convexMesh(this.vertices, this.indices) : P.convexHull(this.vertices);
  }, A2;
}(), fA = function() {
  function A2(A3, I2, g2) {
    this.vertices = A3, this.indices = I2, this.borderRadius = g2;
  }
  return A2.prototype.intoRaw = function() {
    return this.indices ? P.roundConvexMesh(this.vertices, this.indices, this.borderRadius) : P.roundConvexHull(this.vertices, this.borderRadius);
  }, A2;
}(), WA = function() {
  function A2(A3, I2, g2, C2) {
    this.nrows = A3, this.ncols = I2, this.heights = g2, this.scale = C2;
  }
  return A2.prototype.intoRaw = function() {
    var A3 = IA.intoRaw(this.scale), I2 = P.heightfield(this.nrows, this.ncols, this.heights, A3);
    return A3.free(), I2;
  }, A2;
}(), jA = function() {
  function A2(A3, I2) {
    this.halfHeight = A3, this.radius = I2;
  }
  return A2.prototype.intoRaw = function() {
    return P.cylinder(this.halfHeight, this.radius);
  }, A2;
}(), bA = function() {
  function A2(A3, I2, g2) {
    this.borderRadius = g2, this.halfHeight = A3, this.radius = I2;
  }
  return A2.prototype.intoRaw = function() {
    return P.roundCylinder(this.halfHeight, this.radius, this.borderRadius);
  }, A2;
}(), xA = function() {
  function A2(A3, I2) {
    this.halfHeight = A3, this.radius = I2;
  }
  return A2.prototype.intoRaw = function() {
    return P.cone(this.halfHeight, this.radius);
  }, A2;
}(), XA = function() {
  function A2(A3, I2, g2) {
    this.halfHeight = A3, this.radius = I2, this.borderRadius = g2;
  }
  return A2.prototype.intoRaw = function() {
    return P.roundCone(this.halfHeight, this.radius, this.borderRadius);
  }, A2;
}();
!function(A2) {
  A2[A2.DYNAMIC_DYNAMIC = 1] = "DYNAMIC_DYNAMIC", A2[A2.DYNAMIC_KINEMATIC = 12] = "DYNAMIC_KINEMATIC", A2[A2.DYNAMIC_STATIC = 2] = "DYNAMIC_STATIC", A2[A2.KINEMATIC_KINEMATIC = 52224] = "KINEMATIC_KINEMATIC", A2[A2.KINEMATIC_STATIC = 8704] = "KINEMATIC_STATIC", A2[A2.STATIC_STATIC = 32] = "STATIC_STATIC", A2[A2.DEFAULT = 15] = "DEFAULT", A2[A2.ALL = 60943] = "ALL";
}(LA || (LA = {}));
var VA, mA = function() {
  function A2(A3, I2) {
    this.rawSet = A3, this.handle = I2;
  }
  return A2.prototype.isValid = function() {
    return this.rawSet.contains(this.handle);
  }, A2.prototype.translation = function() {
    return IA.fromRaw(this.rawSet.coTranslation(this.handle));
  }, A2.prototype.rotation = function() {
    return CA.fromRaw(this.rawSet.coRotation(this.handle));
  }, A2.prototype.isSensor = function() {
    return this.rawSet.coIsSensor(this.handle);
  }, A2.prototype.setSensor = function(A3) {
    this.rawSet.coSetSensor(this.handle, A3);
  }, A2.prototype.setShape = function(A3) {
    var I2 = A3.intoRaw();
    this.rawSet.coSetShape(this.handle, I2), I2.free();
  }, A2.prototype.setRestitution = function(A3) {
    this.rawSet.coSetRestitution(this.handle, A3);
  }, A2.prototype.setFriction = function(A3) {
    this.rawSet.coSetFriction(this.handle, A3);
  }, A2.prototype.frictionCombineRule = function() {
    return this.rawSet.coFrictionCombineRule(this.handle);
  }, A2.prototype.setFrictionCombineRule = function(A3) {
    this.rawSet.coSetFrictionCombineRule(this.handle, A3);
  }, A2.prototype.restitutionCombineRule = function() {
    return this.rawSet.coRestitutionCombineRule(this.handle);
  }, A2.prototype.setRestitutionCombineRule = function(A3) {
    this.rawSet.coSetRestitutionCombineRule(this.handle, A3);
  }, A2.prototype.setCollisionGroups = function(A3) {
    this.rawSet.coSetCollisionGroups(this.handle, A3);
  }, A2.prototype.setSolverGroups = function(A3) {
    this.rawSet.coSetSolverGroups(this.handle, A3);
  }, A2.prototype.activeHooks = function() {
    this.rawSet.coActiveHooks(this.handle);
  }, A2.prototype.setActiveHooks = function(A3) {
    this.rawSet.coSetActiveHooks(this.handle, A3);
  }, A2.prototype.activeEvents = function() {
    return this.rawSet.coActiveEvents(this.handle);
  }, A2.prototype.setActiveEvents = function(A3) {
    this.rawSet.coSetActiveEvents(this.handle, A3);
  }, A2.prototype.activeCollisionTypes = function() {
    return this.rawSet.coActiveCollisionTypes(this.handle);
  }, A2.prototype.setActiveCollisionTypes = function(A3) {
    this.rawSet.coSetActiveCollisionTypes(this.handle, A3);
  }, A2.prototype.setTranslation = function(A3) {
    this.rawSet.coSetTranslation(this.handle, A3.x, A3.y, A3.z);
  }, A2.prototype.setTranslationWrtParent = function(A3) {
    this.rawSet.coSetTranslationWrtParent(this.handle, A3.x, A3.y, A3.z);
  }, A2.prototype.setRotation = function(A3) {
    this.rawSet.coSetRotation(this.handle, A3.x, A3.y, A3.z, A3.w);
  }, A2.prototype.setRotationWrtParent = function(A3) {
    this.rawSet.coSetRotationWrtParent(this.handle, A3.x, A3.y, A3.z, A3.w);
  }, A2.prototype.shapeType = function() {
    return this.rawSet.coShapeType(this.handle);
  }, A2.prototype.halfExtents = function() {
    return IA.fromRaw(this.rawSet.coHalfExtents(this.handle));
  }, A2.prototype.radius = function() {
    return this.rawSet.coRadius(this.handle);
  }, A2.prototype.roundRadius = function() {
    return this.rawSet.coRoundRadius(this.handle);
  }, A2.prototype.halfHeight = function() {
    return this.rawSet.coHalfHeight(this.handle);
  }, A2.prototype.vertices = function() {
    return this.rawSet.coVertices(this.handle);
  }, A2.prototype.indices = function() {
    return this.rawSet.coIndices(this.handle);
  }, A2.prototype.heightfieldHeights = function() {
    return this.rawSet.coHeightfieldHeights(this.handle);
  }, A2.prototype.heightfieldScale = function() {
    var A3 = this.rawSet.coHeightfieldScale(this.handle);
    return IA.fromRaw(A3);
  }, A2.prototype.heightfieldNRows = function() {
    return this.rawSet.coHeightfieldNRows(this.handle);
  }, A2.prototype.heightfieldNCols = function() {
    return this.rawSet.coHeightfieldNCols(this.handle);
  }, A2.prototype.parent = function() {
    return this.rawSet.coParent(this.handle);
  }, A2.prototype.friction = function() {
    return this.rawSet.coFriction(this.handle);
  }, A2.prototype.density = function() {
    return this.rawSet.coDensity(this.handle);
  }, A2.prototype.collisionGroups = function() {
    return this.rawSet.coCollisionGroups(this.handle);
  }, A2.prototype.solverGroups = function() {
    return this.rawSet.coSolverGroups(this.handle);
  }, A2;
}(), uA = function() {
  function A2(A3) {
    this.shape = A3, this.useMassProps = false, this.density = 1, this.friction = 0.5, this.restitution = 0, this.rotation = CA.identity(), this.translation = IA.zeros(), this.isSensor = false, this.collisionGroups = 4294967295, this.solverGroups = 4294967295, this.frictionCombineRule = UA.Average, this.restitutionCombineRule = UA.Average, this.activeCollisionTypes = LA.DEFAULT, this.activeEvents = 0, this.activeHooks = 0, this.mass = 0, this.centerOfMass = IA.zeros(), this.principalAngularInertia = IA.zeros(), this.angularInertiaLocalFrame = CA.identity();
  }
  return A2.ball = function(I2) {
    return new A2(new HA(I2));
  }, A2.capsule = function(I2, g2) {
    return new A2(new TA(I2, g2));
  }, A2.segment = function(I2, g2) {
    return new A2(new nA(I2, g2));
  }, A2.triangle = function(I2, g2, C2) {
    return new A2(new eA(I2, g2, C2));
  }, A2.roundTriangle = function(I2, g2, C2, B2) {
    return new A2(new OA(I2, g2, C2, B2));
  }, A2.polyline = function(I2, g2) {
    return new A2(new rA(I2, g2));
  }, A2.trimesh = function(I2, g2) {
    return new A2(new dA(I2, g2));
  }, A2.cuboid = function(I2, g2, C2) {
    return new A2(new pA(I2, g2, C2));
  }, A2.roundCuboid = function(I2, g2, C2, B2) {
    return new A2(new tA(I2, g2, C2, B2));
  }, A2.heightfield = function(I2, g2, C2, B2) {
    return new A2(new WA(I2, g2, C2, B2));
  }, A2.cylinder = function(I2, g2) {
    return new A2(new jA(I2, g2));
  }, A2.roundCylinder = function(I2, g2, C2) {
    return new A2(new bA(I2, g2, C2));
  }, A2.cone = function(I2, g2) {
    return new A2(new xA(I2, g2));
  }, A2.roundCone = function(I2, g2, C2) {
    return new A2(new XA(I2, g2, C2));
  }, A2.convexHull = function(I2) {
    return new A2(new ZA(I2, null));
  }, A2.convexMesh = function(I2, g2) {
    return new A2(new ZA(I2, g2));
  }, A2.roundConvexHull = function(I2, g2) {
    return new A2(new fA(I2, null, g2));
  }, A2.roundConvexMesh = function(I2, g2, C2) {
    return new A2(new fA(I2, g2, C2));
  }, A2.prototype.setTranslation = function(A3, I2, g2) {
    if (typeof A3 != "number" || typeof I2 != "number" || typeof g2 != "number")
      throw TypeError("The translation components must be numbers.");
    return this.translation = {x: A3, y: I2, z: g2}, this;
  }, A2.prototype.setRotation = function(A3) {
    return this.rotation = A3, this;
  }, A2.prototype.setSensor = function(A3) {
    return this.isSensor = A3, this;
  }, A2.prototype.setDensity = function(A3) {
    return this.useMassProps = false, this.density = A3, this;
  }, A2.prototype.setMassProperties = function(A3, I2, g2, C2) {
    return this.useMassProps = true, this.mass = A3, this.centerOfMass = I2, this.principalAngularInertia = g2, this.angularInertiaLocalFrame = C2, this;
  }, A2.prototype.setRestitution = function(A3) {
    return this.restitution = A3, this;
  }, A2.prototype.setFriction = function(A3) {
    return this.friction = A3, this;
  }, A2.prototype.setFrictionCombineRule = function(A3) {
    return this.frictionCombineRule = A3, this;
  }, A2.prototype.setRestitutionCombineRule = function(A3) {
    return this.restitutionCombineRule = A3, this;
  }, A2.prototype.setCollisionGroups = function(A3) {
    return this.collisionGroups = A3, this;
  }, A2.prototype.setSolverGroups = function(A3) {
    return this.solverGroups = A3, this;
  }, A2.prototype.setActiveHooks = function(A3) {
    return this.activeHooks = A3, this;
  }, A2.prototype.setActiveEvents = function(A3) {
    return this.activeEvents = A3, this;
  }, A2.prototype.setActiveCollisionTypes = function(A3) {
    return this.activeCollisionTypes = A3, this;
  }, A2;
}(), PA = function() {
  function A2(A3) {
    this.raw = A3 || new p();
  }
  return A2.prototype.free = function() {
    this.raw.free(), this.raw = void 0;
  }, A2.prototype.createCollider = function(A3, I2, g2) {
    var C2 = g2 != null && g2 != null;
    if (C2 && isNaN(g2))
      throw Error("Cannot create a collider with a parent rigid-body handle that is not a number.");
    var B2 = I2.shape.intoRaw(), Q2 = IA.intoRaw(I2.translation), E2 = CA.intoRaw(I2.rotation), i2 = IA.intoRaw(I2.centerOfMass), D2 = IA.intoRaw(I2.principalAngularInertia), o2 = CA.intoRaw(I2.angularInertiaLocalFrame), S2 = this.raw.createCollider(B2, Q2, E2, I2.useMassProps, I2.mass, i2, D2, o2, I2.density, I2.friction, I2.restitution, I2.frictionCombineRule, I2.restitutionCombineRule, I2.isSensor, I2.collisionGroups, I2.solverGroups, I2.activeCollisionTypes, I2.activeHooks, I2.activeEvents, C2, C2 ? g2 : 0, A3.raw);
    return B2.free(), Q2.free(), E2.free(), i2.free(), D2.free(), o2.free(), S2;
  }, A2.prototype.remove = function(A3, I2, g2, C2) {
    this.raw.remove(A3, I2.raw, g2.raw, C2);
  }, A2.prototype.get = function(A3) {
    return this.raw.contains(A3) ? new mA(this.raw, A3) : null;
  }, A2.prototype.len = function() {
    return this.raw.len();
  }, A2.prototype.contains = function(A3) {
    return this.raw.contains(A3);
  }, A2.prototype.forEachCollider = function(A3) {
    var I2 = this;
    this.forEachColliderHandle(function(g2) {
      A3(new mA(I2.raw, g2));
    });
  }, A2.prototype.forEachColliderHandle = function(A3) {
    this.raw.forEachColliderHandle(A3);
  }, A2;
}(), zA = function() {
  function A2(A3, I2) {
    this.origin = A3, this.dir = I2;
  }
  return A2.prototype.pointAt = function(A3) {
    return {x: this.origin.x + this.dir.x * A3, y: this.origin.y + this.dir.y * A3, z: this.origin.z + this.dir.z * A3};
  }, A2;
}(), vA = function() {
  function A2(A3, I2, g2) {
    this.colliderHandle = A3, this.toi = I2, this.normal = g2;
  }
  return A2.fromRaw = function(I2) {
    if (!I2)
      return null;
    var g2 = new A2(I2.colliderHandle(), I2.toi(), IA.fromRaw(I2.normal()));
    return I2.free(), g2;
  }, A2;
}(), _A = function() {
  function A2(A3, I2) {
    this.colliderHandle = A3, this.toi = I2;
  }
  return A2.fromRaw = function(I2) {
    if (!I2)
      return null;
    var g2 = new A2(I2.colliderHandle(), I2.toi());
    return I2.free(), g2;
  }, A2;
}(), $A = function() {
  function A2(A3, I2, g2) {
    this.colliderHandle = A3, this.point = I2, this.isInside = g2;
  }
  return A2.fromRaw = function(I2) {
    if (!I2)
      return null;
    var g2 = new A2(I2.colliderHandle(), IA.fromRaw(I2.point()), I2.isInside());
    return I2.free(), g2;
  }, A2;
}(), AI = function() {
  function A2(A3, I2, g2, C2, B2, Q2) {
    this.colliderHandle = A3, this.toi = I2, this.witness1 = g2, this.witness2 = C2, this.normal1 = B2, this.normal2 = Q2;
  }
  return A2.fromRaw = function(I2) {
    if (!I2)
      return null;
    var g2 = new A2(I2.colliderHandle(), I2.toi(), IA.fromRaw(I2.witness1()), IA.fromRaw(I2.witness2()), IA.fromRaw(I2.normal1()), IA.fromRaw(I2.normal2()));
    return I2.free(), g2;
  }, A2;
}(), II = function() {
  function A2(A3) {
    this.raw = A3 || new W();
  }
  return A2.prototype.free = function() {
    this.raw.free(), this.raw = void 0;
  }, A2.prototype.step = function(A3, I2, g2, C2, B2, Q2, E2, i2, D2, o2, S2) {
    var G2 = IA.intoRaw(A3);
    o2 ? this.raw.stepWithEvents(G2, I2.raw, g2.raw, C2.raw, B2.raw, Q2.raw, E2.raw, i2.raw, D2.raw, o2.raw, S2, S2 ? S2.filterContactPair : null, S2 ? S2.filterIntersectionPair : null) : this.raw.step(G2, I2.raw, g2.raw, C2.raw, B2.raw, Q2.raw, E2.raw, i2.raw, D2.raw), G2.free();
  }, A2;
}(), gI = function() {
  function A2(A3) {
    this.raw = A3 || new b();
  }
  return A2.prototype.free = function() {
    this.raw.free(), this.raw = void 0;
  }, A2.prototype.update = function(A3, I2, g2) {
    this.raw.update(A3.raw, I2.raw, g2.raw);
  }, A2.prototype.castRay = function(A3, I2, g2, C2, B2) {
    var Q2 = IA.intoRaw(I2.origin), E2 = IA.intoRaw(I2.dir), i2 = _A.fromRaw(this.raw.castRay(A3.raw, Q2, E2, g2, C2, B2));
    return Q2.free(), E2.free(), i2;
  }, A2.prototype.castRayAndGetNormal = function(A3, I2, g2, C2, B2) {
    var Q2 = IA.intoRaw(I2.origin), E2 = IA.intoRaw(I2.dir), i2 = vA.fromRaw(this.raw.castRayAndGetNormal(A3.raw, Q2, E2, g2, C2, B2));
    return Q2.free(), E2.free(), i2;
  }, A2.prototype.intersectionsWithRay = function(A3, I2, g2, C2, B2, Q2) {
    var E2 = IA.intoRaw(I2.origin), i2 = IA.intoRaw(I2.dir);
    this.raw.intersectionsWithRay(A3.raw, E2, i2, g2, C2, B2, function(A4) {
      return Q2(vA.fromRaw(A4));
    }), E2.free(), i2.free();
  }, A2.prototype.intersectionWithShape = function(A3, I2, g2, C2, B2) {
    var Q2 = IA.intoRaw(I2), E2 = CA.intoRaw(g2), i2 = C2.intoRaw(), D2 = this.raw.intersectionWithShape(A3.raw, Q2, E2, i2, B2);
    return Q2.free(), E2.free(), i2.free(), D2;
  }, A2.prototype.projectPoint = function(A3, I2, g2, C2) {
    var B2 = IA.intoRaw(I2), Q2 = $A.fromRaw(this.raw.projectPoint(A3.raw, B2, g2, C2));
    return B2.free(), Q2;
  }, A2.prototype.intersectionsWithPoint = function(A3, I2, g2, C2) {
    var B2 = IA.intoRaw(I2);
    this.raw.intersectionsWithPoint(A3.raw, B2, g2, C2), B2.free();
  }, A2.prototype.castShape = function(A3, I2, g2, C2, B2, Q2, E2) {
    var i2 = IA.intoRaw(I2), D2 = CA.intoRaw(g2), o2 = IA.intoRaw(C2), S2 = B2.intoRaw(), G2 = AI.fromRaw(this.raw.castShape(A3.raw, i2, D2, o2, S2, Q2, E2));
    return i2.free(), D2.free(), o2.free(), S2.free(), G2;
  }, A2.prototype.intersectionsWithShape = function(A3, I2, g2, C2, B2, Q2) {
    var E2 = IA.intoRaw(I2), i2 = CA.intoRaw(g2), D2 = C2.intoRaw();
    this.raw.intersectionsWithShape(A3.raw, E2, i2, D2, B2, Q2), E2.free(), i2.free(), D2.free();
  }, A2.prototype.collidersWithAabbIntersectingAabb = function(A3, I2, g2) {
    var C2 = IA.intoRaw(A3), B2 = IA.intoRaw(I2);
    this.raw.collidersWithAabbIntersectingAabb(C2, B2, g2), C2.free(), B2.free();
  }, A2;
}(), CI = function() {
  function A2(A3) {
    this.raw = A3 || new u();
  }
  return A2.prototype.free = function() {
    this.raw.free(), this.raw = void 0;
  }, A2.prototype.serializeAll = function(A3, I2, g2, C2, B2, Q2, E2, i2) {
    var D2 = IA.intoRaw(A3), o2 = this.raw.serializeAll(D2, I2.raw, g2.raw, C2.raw, B2.raw, Q2.raw, E2.raw, i2.raw);
    return D2.free(), o2;
  }, A2.prototype.deserializeAll = function(A3) {
    return BI.fromRaw(this.raw.deserializeAll(A3));
  }, A2;
}(), BI = function() {
  function A2(A3, I2, g2, C2, B2, Q2, E2, i2, D2, o2, S2, G2) {
    this.gravity = A3, this.integrationParameters = new oA(I2), this.islands = new sA(g2), this.broadPhase = new YA(C2), this.narrowPhase = new cA(B2), this.bodies = new DA(Q2), this.colliders = new PA(E2), this.joints = new qA(i2), this.ccdSolver = new RA(D2), this.queryPipeline = new gI(o2), this.physicsPipeline = new II(S2), this.serializationPipeline = new CI(G2);
  }
  return A2.prototype.free = function() {
    this.integrationParameters.free(), this.islands.free(), this.broadPhase.free(), this.narrowPhase.free(), this.bodies.free(), this.colliders.free(), this.joints.free(), this.ccdSolver.free(), this.queryPipeline.free(), this.physicsPipeline.free(), this.serializationPipeline.free(), this.integrationParameters = void 0, this.islands = void 0, this.broadPhase = void 0, this.narrowPhase = void 0, this.bodies = void 0, this.colliders = void 0, this.ccdSolver = void 0, this.joints = void 0, this.queryPipeline = void 0, this.physicsPipeline = void 0, this.serializationPipeline = void 0;
  }, A2.fromRaw = function(I2) {
    return I2 ? new A2(IA.fromRaw(I2.takeGravity()), I2.takeIntegrationParameters(), I2.takeIslandManager(), I2.takeBroadPhase(), I2.takeNarrowPhase(), I2.takeBodies(), I2.takeColliders(), I2.takeJoints()) : null;
  }, A2.prototype.takeSnapshot = function() {
    return this.serializationPipeline.serializeAll(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.joints);
  }, A2.restoreSnapshot = function(A3) {
    return new CI().deserializeAll(A3);
  }, A2.prototype.step = function(A3, I2) {
    this.physicsPipeline.step(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.joints, this.ccdSolver, A3, I2), this.queryPipeline.update(this.islands, this.bodies, this.colliders);
  }, Object.defineProperty(A2.prototype, "timestep", {get: function() {
    return this.integrationParameters.dt;
  }, set: function(A3) {
    this.integrationParameters.dt = A3;
  }, enumerable: false, configurable: true}), Object.defineProperty(A2.prototype, "maxVelocityIterations", {get: function() {
    return this.integrationParameters.maxVelocityIterations;
  }, set: function(A3) {
    this.integrationParameters.maxVelocityIterations = A3;
  }, enumerable: false, configurable: true}), Object.defineProperty(A2.prototype, "maxPositionIterations", {get: function() {
    return this.integrationParameters.maxPositionIterations;
  }, set: function(A3) {
    this.integrationParameters.maxPositionIterations = A3;
  }, enumerable: false, configurable: true}), A2.prototype.createRigidBody = function(A3) {
    return this.bodies.get(this.bodies.createRigidBody(A3));
  }, A2.prototype.createCollider = function(A3, I2) {
    return this.colliders.get(this.colliders.createCollider(this.bodies, A3, I2));
  }, A2.prototype.createJoint = function(A3, I2, g2) {
    return this.joints.get(this.joints.createJoint(this.bodies, A3, I2.handle, g2.handle));
  }, A2.prototype.getRigidBody = function(A3) {
    return this.bodies.get(A3);
  }, A2.prototype.getCollider = function(A3) {
    return this.colliders.get(A3);
  }, A2.prototype.getJoint = function(A3) {
    return this.joints.get(A3);
  }, A2.prototype.removeRigidBody = function(A3) {
    this.bodies.remove(A3.handle, this.islands, this.colliders, this.joints);
  }, A2.prototype.removeCollider = function(A3, I2) {
    this.colliders.remove(A3.handle, this.islands, this.bodies, I2);
  }, A2.prototype.removeJoint = function(A3, I2) {
    this.joints.remove(A3.handle, this.islands, this.bodies, I2);
  }, A2.prototype.forEachCollider = function(A3) {
    this.colliders.forEachCollider(A3);
  }, A2.prototype.forEachColliderHandle = function(A3) {
    this.colliders.forEachColliderHandle(A3);
  }, A2.prototype.forEachRigidBody = function(A3) {
    this.bodies.forEachRigidBody(A3);
  }, A2.prototype.forEachRigidBodyHandle = function(A3) {
    this.bodies.forEachRigidBodyHandle(A3);
  }, A2.prototype.forEachActiveRigidBody = function(A3) {
    this.bodies.forEachActiveRigidBody(this.islands, A3);
  }, A2.prototype.forEachActiveRigidBodyHandle = function(A3) {
    this.islands.forEachActiveRigidBodyHandle(A3);
  }, A2.prototype.castRay = function(A3, I2, g2, C2) {
    return this.queryPipeline.castRay(this.colliders, A3, I2, g2, C2);
  }, A2.prototype.castRayAndGetNormal = function(A3, I2, g2, C2) {
    return this.queryPipeline.castRayAndGetNormal(this.colliders, A3, I2, g2, C2);
  }, A2.prototype.intersectionsWithRay = function(A3, I2, g2, C2, B2) {
    this.queryPipeline.intersectionsWithRay(this.colliders, A3, I2, g2, C2, B2);
  }, A2.prototype.intersectionWithShape = function(A3, I2, g2, C2) {
    return this.queryPipeline.intersectionWithShape(this.colliders, A3, I2, g2, C2);
  }, A2.prototype.projectPoint = function(A3, I2, g2) {
    return this.queryPipeline.projectPoint(this.colliders, A3, I2, g2);
  }, A2.prototype.intersectionsWithPoint = function(A3, I2, g2) {
    this.queryPipeline.intersectionsWithPoint(this.colliders, A3, I2, g2);
  }, A2.prototype.castShape = function(A3, I2, g2, C2, B2, Q2) {
    return this.queryPipeline.castShape(this.colliders, A3, I2, g2, C2, B2, Q2);
  }, A2.prototype.intersectionsWithShape = function(A3, I2, g2, C2, B2) {
    this.queryPipeline.intersectionsWithShape(this.colliders, A3, I2, g2, C2, B2);
  }, A2.prototype.collidersWithAabbIntersectingAabb = function(A3, I2, g2) {
    this.queryPipeline.collidersWithAabbIntersectingAabb(A3, I2, g2);
  }, A2.prototype.contactsWith = function(A3, I2) {
    this.narrowPhase.contactsWith(A3, I2);
  }, A2.prototype.intersectionsWith = function(A3, I2) {
    this.narrowPhase.intersectionsWith(A3, I2);
  }, A2.prototype.contactPair = function(A3, I2, g2) {
    this.narrowPhase.contactPair(A3, I2, g2);
  }, A2.prototype.intersectionPair = function(A3, I2) {
    return this.narrowPhase.intersectionPair(A3, I2);
  }, A2;
}();
!function(A2) {
  A2[A2.INTERSECTION_EVENTS = 1] = "INTERSECTION_EVENTS", A2[A2.CONTACT_EVENTS = 2] = "CONTACT_EVENTS";
}(VA || (VA = {}));
var QI, EI, iI = function() {
  function A2(A3, I2) {
    this.raw = I2 || new e(A3);
  }
  return A2.prototype.free = function() {
    this.raw.free(), this.raw = void 0;
  }, A2.prototype.drainContactEvents = function(A3) {
    this.raw.drainContactEvents(A3);
  }, A2.prototype.drainIntersectionEvents = function(A3) {
    this.raw.drainIntersectionEvents(A3);
  }, A2.prototype.clear = function() {
    this.raw.clear();
  }, A2;
}();
!function(A2) {
  A2[A2.FILTER_CONTACT_PAIRS = 1] = "FILTER_CONTACT_PAIRS", A2[A2.FILTER_INTERSECTION_PAIRS = 2] = "FILTER_INTERSECTION_PAIRS";
}(QI || (QI = {})), function(A2) {
  A2[A2.EMPTY = 0] = "EMPTY", A2[A2.COMPUTE_IMPULSE = 1] = "COMPUTE_IMPULSE";
}(EI || (EI = {}));
for (var DI = {byteLength: function(A2) {
  var I2 = JI(A2), g2 = I2[0], C2 = I2[1];
  return 3 * (g2 + C2) / 4 - C2;
}, toByteArray: function(A2) {
  var I2, g2, C2 = JI(A2), B2 = C2[0], Q2 = C2[1], E2 = new GI(function(A3, I3, g3) {
    return 3 * (I3 + g3) / 4 - g3;
  }(0, B2, Q2)), i2 = 0, D2 = Q2 > 0 ? B2 - 4 : B2;
  for (g2 = 0; g2 < D2; g2 += 4)
    I2 = SI[A2.charCodeAt(g2)] << 18 | SI[A2.charCodeAt(g2 + 1)] << 12 | SI[A2.charCodeAt(g2 + 2)] << 6 | SI[A2.charCodeAt(g2 + 3)], E2[i2++] = I2 >> 16 & 255, E2[i2++] = I2 >> 8 & 255, E2[i2++] = 255 & I2;
  Q2 === 2 && (I2 = SI[A2.charCodeAt(g2)] << 2 | SI[A2.charCodeAt(g2 + 1)] >> 4, E2[i2++] = 255 & I2);
  Q2 === 1 && (I2 = SI[A2.charCodeAt(g2)] << 10 | SI[A2.charCodeAt(g2 + 1)] << 4 | SI[A2.charCodeAt(g2 + 2)] >> 2, E2[i2++] = I2 >> 8 & 255, E2[i2++] = 255 & I2);
  return E2;
}, fromByteArray: function(A2) {
  for (var I2, g2 = A2.length, C2 = g2 % 3, B2 = [], Q2 = 16383, E2 = 0, i2 = g2 - C2; E2 < i2; E2 += Q2)
    B2.push(KI(A2, E2, E2 + Q2 > i2 ? i2 : E2 + Q2));
  C2 === 1 ? (I2 = A2[g2 - 1], B2.push(oI[I2 >> 2] + oI[I2 << 4 & 63] + "==")) : C2 === 2 && (I2 = (A2[g2 - 2] << 8) + A2[g2 - 1], B2.push(oI[I2 >> 10] + oI[I2 >> 4 & 63] + oI[I2 << 2 & 63] + "="));
  return B2.join("");
}}, oI = [], SI = [], GI = typeof Uint8Array != "undefined" ? Uint8Array : Array, kI = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", wI = 0, UI = kI.length; wI < UI; ++wI)
  oI[wI] = kI[wI], SI[kI.charCodeAt(wI)] = wI;
function JI(A2) {
  var I2 = A2.length;
  if (I2 % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var g2 = A2.indexOf("=");
  return g2 === -1 && (g2 = I2), [g2, g2 === I2 ? 0 : 4 - g2 % 4];
}
function KI(A2, I2, g2) {
  for (var C2, B2, Q2 = [], E2 = I2; E2 < g2; E2 += 3)
    C2 = (A2[E2] << 16 & 16711680) + (A2[E2 + 1] << 8 & 65280) + (255 & A2[E2 + 2]), Q2.push(oI[(B2 = C2) >> 18 & 63] + oI[B2 >> 12 & 63] + oI[B2 >> 6 & 63] + oI[63 & B2]);
  return Q2.join("");
}
function MI() {
  return kA(this, void 0, void 0, function() {
    return wA(this, function(A2) {
      switch (A2.label) {
        case 0:
          return [4, _(DI.toByteArray("AGFzbQEAAAABmQhvYAJ/fwBgA39/fwBgBH9/f38AYAJ/fwF/YAF/AX5gA39/fwF/YAF/AGABfwF/YAV/f39/fwBgBn9/f399fwBgAX8BfWAFf39/fX8AYAABf2AGf39/f39/AGAEf39/fQF/YAN/f38BfWADf399AGADf399AX9gBH9/f38BfWAHf39/f39/fwBgAn9/AX1gAn99AGAEf39/fwF/YAV/f39/fQBgCH9/f39/f31/AX9gBn9/f39/fwF/YAZ/f319fX0AYAAAYAV/f39/fwF/YAF9AX1gDn9/f39/f39/f39/f39/AGAJf39/f39/f399AGAIf39/f39/f30AYAZ/f39/f30AYAR/f399AGAFf399fX0AYAN9fX0Bf2AIf39/f39/f38AYAt/f39/f39/f319fwBgB39/f399f38AYAV/f31/fwBgA399fQBgBH99fX0AYAJ9fQF/YAJ9fQF9YAl/f39/f39/f38AYAp/f39/f39/f39/AGAKf39/f39/fX9/fwBgGH9/f39/f31/f399fX1/f39/f39/f39/fwBgCH9/f39/fX9/AGAJf39/f399f39/AGAIf39/f31/f38AYAR/f31/AGAEf399fQBgB39/fX19fX8AYAV/fn9+fwBgBH99f38AYAh/fX9/f39/fwBgBn99fX9/fQBgCX9/f39/f31/fwF/YAd/f39/fX9/AX9gFH9/f319f39/f39/f39/fX1/f39/AX9gA319fwF/YAR9fX19AX9gC39/f39/f39/f39/AGARf39/f39/f39/f39/f39/f38AYBJ/f39/f39/f39/f399f319fX0AYA9/f39/f39/f39/f399fX8AYAp/f39/f39/f319AGAJf39/f39/f31/AGANf39/f39/f319fX19fQBgCX9/f39/f35+fgBgB39/f39/f30AYAl/f39/f399f38AYAh/f39/fX1/fwBgC39/f31/f31/fX1/AGAFf39/fX0AYAl/f31/f39/f38AYAZ/f319fX8AYAh/f319fX19fQBgC39/fX19fX19fX19AGAFf398f38AYAN/fX8AYAZ/fX9/f38AYAl/fX9/f39/f38AYAp/fX9/f39/f39/AGAQf31/f39/f39/f39/f39/fwBgBX99f399AGAIf31/fX99f38AYAV/fX19fQBgBH98f38AYAJ+fwBgCX9/f39/f39/fwF/YAl/f39/f39/fX0Bf2AFf39/f30Bf2AEf399fQF/YAJ/fgF/YAN/fX8Bf2AEf31/fwF/YAZ/fX9/f38Bf2ADf3x/AX9gBH98f38Bf2ADfn9/AX9gAX0Bf2ABfAF/YAF+AX5gBH5+f38BfmAGf39/f39/AX1gBH9/f30BfWAAAXxgAX8BfAKyBxwDd2JnGl9fd2JpbmRnZW5fb2JqZWN0X2Ryb3BfcmVmAAYDd2JnFV9fd2JpbmRnZW5fbnVtYmVyX25ldwBoA3diZyRfX3diZ19yYXdyYXljb2xsaWRlcmludGVyc2VjdGlvbl9uZXcABwN3YmcVX193YmluZGdlbl9zdHJpbmdfbmV3AAMDd2JnGl9fd2JnX25vd19iMWM1Y2I1NDdlMjcwNzk3AG4Dd2JnIF9fd2JnX25ld25vYXJnc182ODQyNDk2NWQ4NWZjYjA4AAMDd2JnGl9fd2JnX2dldF83NWQzNmVmOGIyZTFkOTE4AAMDd2JnG19fd2JnX2NhbGxfOTY5OGU5YjljNDY2OGFlMAADA3diZxtfX3diaW5kZ2VuX29iamVjdF9jbG9uZV9yZWYABwN3YmcbX193YmdfY2FsbF80NDM4YjRiYWI5YWI1MjY4AAUDd2JnG19fd2JnX2NhbGxfZjMyNTg5NWM2MGNiYWU0ZAAWA3diZxtfX3diZ19jYWxsXzZhZGYwNDFiMzMxMDZmNDkAHAN3YmcbX193YmdfYmluZF84ZDRkMzJmMzhmZDIzZjIxABYDd2JnHV9fd2JnX2J1ZmZlcl9lYjIxNTVmMTc4NTZjMjBiAAcDd2JnG19fd2JnX3NlbGZfM2RmN2MzM2UyMjJjZDUzYgAMA3diZx1fX3diZ193aW5kb3dfMGY5MDE4MmU2YzQwNWZmMgAMA3diZyFfX3diZ19nbG9iYWxUaGlzXzc4N2NmZDRmMjVhMzUxNDEADAN3YmcdX193YmdfZ2xvYmFsX2FmMmViN2IxMzY5MzcyZWQADAN3YmcXX193YmluZGdlbl9pc191bmRlZmluZWQABwN3YmcxX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfN2QwN2Y3N2M2ZDBkOGUyNgAFA3diZx1fX3diZ19sZW5ndGhfMGIxOTRhYmRl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BAQDBQcKBwcKBwoHBwcHCgcHBwcKBwcHBwcHBAQABgEEBwFwAewG7AYFAwEAEQYJAX8BQYCAwAALB4hLpgIGbWVtb3J5AgAHdmVyc2lvbgCRChdfX3diZ19yYXdjY2Rzb2x2ZXJfZnJlZQC1CBByYXdjY2Rzb2x2ZXJfbmV3ANAJI19fd2JnX3Jhd2ludGVncmF0aW9ucGFyYW1ldGVyc19mcmVlANcKHHJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19uZXcAsgkbcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX2R0AIsLHHJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19lcnAA5QohcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX2pvaW50RXJwAOYKJ3Jhd2ludGVncmF0aW9ucGFyYW1ldGVyc193YXJtc3RhcnRDb2VmZgDnCityYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfYWxsb3dlZExpbmVhckVycm9yAOgKK3Jhd2ludGVncmF0aW9ucGFyYW1ldGVyc19wcmVkaWN0aW9uRGlzdGFuY2UA6QoscmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX2FsbG93ZWRBbmd1bGFyRXJyb3IA6goscmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX21heExpbmVhckNvcnJlY3Rpb24A6wotcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX21heEFuZ3VsYXJDb3JyZWN0aW9uAOwKLnJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19tYXhWZWxvY2l0eUl0ZXJhdGlvbnMA7QoucmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX21heFBvc2l0aW9uSXRlcmF0aW9ucwDuCiZyYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfbWluSXNsYW5kU2l6ZQDvCidyYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfbWF4Q2NkU3Vic3RlcHMA8AofcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3NldF9kdADxCiByYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfc2V0X2VycADDCiVyYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfc2V0X2pvaW50RXJwAMQKK3Jhd2ludGVncmF0aW9ucGFyYW1ldGVyc19zZXRfd2FybXN0YXJ0Q29lZmYAxQovcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3NldF9hbGxvd2VkTGluZWFyRXJyb3IAxgovcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3NldF9wcmVkaWN0aW9uRGlzdGFuY2UAxwowcmF3aW50ZWdyYXRpb25wYXJhbWV0ZXJzX3NldF9hbGxvd2VkQW5ndWxhckVycm9yAMgKMHJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19zZXRfbWF4TGluZWFyQ29ycmVjdGlvbgDJCjFyYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfc2V0X21heEFuZ3VsYXJDb3JyZWN0aW9uAMoKMnJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19zZXRfbWF4VmVsb2NpdHlJdGVyYXRpb25zAMsKMnJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19zZXRfbWF4UG9zaXRpb25JdGVyYXRpb25zAMwKKnJhd2ludGVncmF0aW9ucGFyYW1ldGVyc19zZXRfbWluSXNsYW5kU2l6ZQDNCityYXdpbnRlZ3JhdGlvbnBhcmFtZXRlcnNfc2V0X21heENjZFN1YnN0ZXBzAM4KG19fd2JnX3Jhd2lzbGFuZG1hbmFnZXJfZnJlZQDIBRRyYXdpc2xhbmRtYW5hZ2VyX25ldwD3Bi1yYXdpc2xhbmRtYW5hZ2VyX2ZvckVhY2hBY3RpdmVSaWdpZEJvZHlIYW5kbGUA9ggccmF3am9pbnRzZXRfam9pbnRCb2R5SGFuZGxlMQC8BxxyYXdqb2ludHNldF9qb2ludEJvZHlIYW5kbGUyAK4HFXJhd2pvaW50c2V0X2pvaW50VHlwZQDtBxhyYXdqb2ludHNldF9qb2ludEZyYW1lWDEAvQcYcmF3am9pbnRzZXRfam9pbnRGcmFtZVgyAL4HGHJhd2pvaW50c2V0X2pvaW50QW5jaG9yMQCPBhhyYXdqb2ludHNldF9qb2ludEFuY2hvcjIAkAYWcmF3am9pbnRzZXRfam9pbnRBeGlzMQDUBRZyYXdqb2ludHNldF9qb2ludEF4aXMyANUFHnJhd2pvaW50c2V0X2pvaW50TGltaXRzRW5hYmxlZADEBxpyYXdqb2ludHNldF9qb2ludExpbWl0c01pbgDKBxpyYXdqb2ludHNldF9qb2ludExpbWl0c01heADLByRyYXdqb2ludHNldF9qb2ludENvbmZpZ3VyZU1vdG9yTW9kZWwAwgkrcmF3am9pbnRzZXRfam9pbnRDb25maWd1cmVCYWxsTW90b3JWZWxvY2l0eQDXBytyYXdqb2ludHNldF9qb2ludENvbmZpZ3VyZUJhbGxNb3RvclBvc2l0aW9uAM8GI3Jhd2pvaW50c2V0X2pvaW50Q29uZmlndXJlQmFsbE1vdG9yAJsGK3Jhd2pvaW50c2V0X2pvaW50Q29uZmlndXJlVW5pdE1vdG9yVmVsb2NpdHkA2AcrcmF3am9pbnRzZXRfam9pbnRDb25maWd1cmVVbml0TW90b3JQb3NpdGlvbgDOByNyYXdqb2ludHNldF9qb2ludENvbmZpZ3VyZVVuaXRNb3RvcgDFBxlfX3diZ19yYXdqb2ludHBhcmFtc19mcmVlANcKE3Jhd2pvaW50cGFyYW1zX2JhbGwA2QUYcmF3am9pbnRwYXJhbXNfcHJpc21hdGljALQEFHJhd2pvaW50cGFyYW1zX2ZpeGVkAP8CF3Jhd2pvaW50cGFyYW1zX3Jldm9sdXRlAI0FFl9fd2JnX3Jhd2pvaW50c2V0X2ZyZWUA0AYPcmF3am9pbnRzZXRfbmV3APgGF3Jhd2pvaW50c2V0X2NyZWF0ZUpvaW50ANMHEnJhd2pvaW50c2V0X3JlbW92ZQD7Bw9yYXdqb2ludHNldF9sZW4AxgkUcmF3am9pbnRzZXRfY29udGFpbnMA1QgecmF3am9pbnRzZXRfZm9yRWFjaEpvaW50SGFuZGxlAPcIHXJhd3JpZ2lkYm9keXNldF9yYlRyYW5zbGF0aW9uAN0GGnJhd3JpZ2lkYm9keXNldF9yYlJvdGF0aW9uAOwGF3Jhd3JpZ2lkYm9keXNldF9yYlNsZWVwAOoIHHJhd3JpZ2lkYm9keXNldF9yYklzU2xlZXBpbmcA/AcacmF3cmlnaWRib2R5c2V0X3JiSXNNb3ZpbmcA/QchcmF3cmlnaWRib2R5c2V0X3JiTmV4dFRyYW5zbGF0aW9uAN4GHnJhd3JpZ2lkYm9keXNldF9yYk5leHRSb3RhdGlvbgDfBiByYXdyaWdpZGJvZHlzZXRfcmJTZXRUcmFuc2xhdGlvbgDlBh1yYXdyaWdpZGJvZHlzZXRfcmJTZXRSb3RhdGlvbgDUCRtyYXdyaWdpZGJvZHlzZXRfcmJTZXRMaW52ZWwAgQcbcmF3cmlnaWRib2R5c2V0X3JiU2V0QW5ndmVsAIIHLXJhd3JpZ2lkYm9keXNldF9yYlNldE5leHRLaW5lbWF0aWNUcmFuc2xhdGlvbgD+BypyYXdyaWdpZGJvZHlzZXRfcmJTZXROZXh0S2luZW1hdGljUm90YXRpb24A/wkYcmF3cmlnaWRib2R5c2V0X3JiTGludmVsAOAGGHJhd3JpZ2lkYm9keXNldF9yYkFuZ3ZlbADhBh9yYXdyaWdpZGJvZHlzZXRfcmJMb2NrUm90YXRpb25zAKYHI3Jhd3JpZ2lkYm9keXNldF9yYlJlc3RyaWN0Um90YXRpb25zAPUGIHJhd3JpZ2lkYm9keXNldF9yYkRvbWluYW5jZUdyb3VwAOIHI3Jhd3JpZ2lkYm9keXNldF9yYlNldERvbWluYW5jZUdyb3VwANYIG3Jhd3JpZ2lkYm9keXNldF9yYkVuYWJsZUNjZAC9CBZyYXdyaWdpZGJvZHlzZXRfcmJNYXNzAP8HGHJhd3JpZ2lkYm9keXNldF9yYldha2VVcADXCB5yYXdyaWdpZGJvZHlzZXRfcmJJc0NjZEVuYWJsZWQAgAgecmF3cmlnaWRib2R5c2V0X3JiTnVtQ29sbGlkZXJzANkHGnJhd3JpZ2lkYm9keXNldF9yYkNvbGxpZGVyAPAGGnJhd3JpZ2lkYm9keXNldF9yYkJvZHlUeXBlAM8HGnJhd3JpZ2lkYm9keXNldF9yYklzU3RhdGljAIEIHXJhd3JpZ2lkYm9keXNldF9yYklzS2luZW1hdGljAIIIG3Jhd3JpZ2lkYm9keXNldF9yYklzRHluYW1pYwCDCB9yYXdyaWdpZGJvZHlzZXRfcmJMaW5lYXJEYW1waW5nAO4HIHJhd3JpZ2lkYm9keXNldF9yYkFuZ3VsYXJEYW1waW5nAO8HInJhd3JpZ2lkYm9keXNldF9yYlNldExpbmVhckRhbXBpbmcA2AgjcmF3cmlnaWRib2R5c2V0X3JiU2V0QW5ndWxhckRhbXBpbmcAvggecmF3cmlnaWRib2R5c2V0X3JiR3Jhdml0eVNjYWxlAIQIIXJhd3JpZ2lkYm9keXNldF9yYlNldEdyYXZpdHlTY2FsZQC2CBxyYXdyaWdpZGJvZHlzZXRfcmJBcHBseUZvcmNlAIMHHnJhd3JpZ2lkYm9keXNldF9yYkFwcGx5SW1wdWxzZQCEBx1yYXdyaWdpZGJvZHlzZXRfcmJBcHBseVRvcnF1ZQCFByRyYXdyaWdpZGJvZHlzZXRfcmJBcHBseVRvcnF1ZUltcHVsc2UAhgcjcmF3cmlnaWRib2R5c2V0X3JiQXBwbHlGb3JjZUF0UG9pbnQA9QUlcmF3cmlnaWRib2R5c2V0X3JiQXBwbHlJbXB1bHNlQXRQb2ludAD2BRpfX3diZ19yYXdyaWdpZGJvZHlzZXRfZnJlZQCVBhNyYXdyaWdpZGJvZHlzZXRfbmV3ANsHH3Jhd3JpZ2lkYm9keXNldF9jcmVhdGVSaWdpZEJvZHkA+wMWcmF3cmlnaWRib2R5c2V0X3JlbW92ZQDfBRNyYXdyaWdpZGJvZHlzZXRfbGVuAMcJGHJhd3JpZ2lkYm9keXNldF9jb250YWlucwDZCCZyYXdyaWdpZGJvZHlzZXRfZm9yRWFjaFJpZ2lkQm9keUhhbmRsZQD4CBhfX3diZ19yYXdicm9hZHBoYXNlX2ZyZWUA6wgRcmF3YnJvYWRwaGFzZV9uZXcAswkccmF3Y29sbGlkZXJzZXRfY29UcmFuc2xhdGlvbgDiBhlyYXdjb2xsaWRlcnNldF9jb1JvdGF0aW9uAOMGH3Jhd2NvbGxpZGVyc2V0X2NvU2V0VHJhbnNsYXRpb24AhQgocmF3Y29sbGlkZXJzZXRfY29TZXRUcmFuc2xhdGlvbldydFBhcmVudACGCBxyYXdjb2xsaWRlcnNldF9jb1NldFJvdGF0aW9uAIAKJXJhd2NvbGxpZGVyc2V0X2NvU2V0Um90YXRpb25XcnRQYXJlbnQAgQoZcmF3Y29sbGlkZXJzZXRfY29Jc1NlbnNvcgCHCBpyYXdjb2xsaWRlcnNldF9jb1NoYXBlVHlwZQC0CRxyYXdjb2xsaWRlcnNldF9jb0hhbGZFeHRlbnRzAIcGF3Jhd2NvbGxpZGVyc2V0X2NvUmFkaXVzAOMHG3Jhd2NvbGxpZGVyc2V0X2NvSGFsZkhlaWdodADkBxxyYXdjb2xsaWRlcnNldF9jb1JvdW5kUmFkaXVzANEGGXJhd2NvbGxpZGVyc2V0X2NvVmVydGljZXMAiAYYcmF3Y29sbGlkZXJzZXRfY29JbmRpY2VzAIkGI3Jhd2NvbGxpZGVyc2V0X2NvSGVpZ2h0ZmllbGRIZWlnaHRzAIoGIXJhd2NvbGxpZGVyc2V0X2NvSGVpZ2h0ZmllbGRTY2FsZQCSBSFyYXdjb2xsaWRlcnNldF9jb0hlaWdodGZpZWxkTlJvd3MA5QchcmF3Y29sbGlkZXJzZXRfY29IZWlnaHRmaWVsZE5Db2xzAOYHF3Jhd2NvbGxpZGVyc2V0X2NvUGFyZW50AP8GGXJhd2NvbGxpZGVyc2V0X2NvRnJpY3Rpb24A+AcYcmF3Y29sbGlkZXJzZXRfY29EZW5zaXR5AJYHIHJhd2NvbGxpZGVyc2V0X2NvQ29sbGlzaW9uR3JvdXBzALEHHXJhd2NvbGxpZGVyc2V0X2NvU29sdmVyR3JvdXBzALIHHHJhd2NvbGxpZGVyc2V0X2NvQWN0aXZlSG9va3MAiAglcmF3Y29sbGlkZXJzZXRfY29BY3RpdmVDb2xsaXNpb25UeXBlcwDwBx1yYXdjb2xsaWRlcnNldF9jb0FjdGl2ZUV2ZW50cwCJCBpyYXdjb2xsaWRlcnNldF9jb1NldFNlbnNvcgC/CB9yYXdjb2xsaWRlcnNldF9jb1NldFJlc3RpdHV0aW9uANoIHHJhd2NvbGxpZGVyc2V0X2NvU2V0RnJpY3Rpb24A2wgkcmF3Y29sbGlkZXJzZXRfY29GcmljdGlvbkNvbWJpbmVSdWxlAPEHJ3Jhd2NvbGxpZGVyc2V0X2NvU2V0RnJpY3Rpb25Db21iaW5lUnVsZQCrCCdyYXdjb2xsaWRlcnNldF9jb1Jlc3RpdHV0aW9uQ29tYmluZVJ1bGUA8gcqcmF3Y29sbGlkZXJzZXRfY29TZXRSZXN0aXR1dGlvbkNvbWJpbmVSdWxlAKwII3Jhd2NvbGxpZGVyc2V0X2NvU2V0Q29sbGlzaW9uR3JvdXBzAMwHIHJhd2NvbGxpZGVyc2V0X2NvU2V0U29sdmVyR3JvdXBzAM0HH3Jhd2NvbGxpZGVyc2V0X2NvU2V0QWN0aXZlSG9va3MArQggcmF3Y29sbGlkZXJzZXRfY29TZXRBY3RpdmVFdmVudHMArggocmF3Y29sbGlkZXJzZXRfY29TZXRBY3RpdmVDb2xsaXNpb25UeXBlcwCvCBlyYXdjb2xsaWRlcnNldF9jb1NldFNoYXBlALcHGV9fd2JnX3Jhd2NvbGxpZGVyc2V0X2ZyZWUAhgUScmF3Y29sbGlkZXJzZXRfbmV3AJEHEnJhd2NvbGxpZGVyc2V0X2xlbgDHCRdyYXdjb2xsaWRlcnNldF9jb250YWlucwDcCB1yYXdjb2xsaWRlcnNldF9jcmVhdGVDb2xsaWRlcgDPAxVyYXdjb2xsaWRlcnNldF9yZW1vdmUAiwYkcmF3Y29sbGlkZXJzZXRfZm9yRWFjaENvbGxpZGVySGFuZGxlAPkIGV9fd2JnX3Jhd25hcnJvd3BoYXNlX2ZyZWUAxAQScmF3bmFycm93cGhhc2VfbmV3ALUJHHJhd25hcnJvd3BoYXNlX2NvbnRhY3RzX3dpdGgAyAkbcmF3bmFycm93cGhhc2VfY29udGFjdF9wYWlyAIoIIXJhd25hcnJvd3BoYXNlX2ludGVyc2VjdGlvbnNfd2l0aADJCSByYXduYXJyb3dwaGFzZV9pbnRlcnNlY3Rpb25fcGFpcgCqCR1fX3diZ19yYXdjb250YWN0bWFuaWZvbGRfZnJlZQDXChhyYXdjb250YWN0cGFpcl9jb2xsaWRlcjEAwAgYcmF3Y29udGFjdHBhaXJfY29sbGlkZXIyALAIInJhd2NvbnRhY3RwYWlyX251bUNvbnRhY3RNYW5pZm9sZHMA1QkecmF3Y29udGFjdHBhaXJfY29udGFjdE1hbmlmb2xkAMYHGXJhd2NvbnRhY3RtYW5pZm9sZF9ub3JtYWwAlAcbcmF3Y29udGFjdG1hbmlmb2xkX2xvY2FsX24xAJgHHHJhd2NvbnRhY3RtYW5pZm9sZF9zdWJzaGFwZTEA8QkfcmF3Y29udGFjdG1hbmlmb2xkX251bV9jb250YWN0cwDWCSNyYXdjb250YWN0bWFuaWZvbGRfY29udGFjdF9sb2NhbF9wMQD9BR9yYXdjb250YWN0bWFuaWZvbGRfY29udGFjdF9kaXN0APwIH3Jhd2NvbnRhY3RtYW5pZm9sZF9jb250YWN0X2ZpZDEA/QgfcmF3Y29udGFjdG1hbmlmb2xkX2NvbnRhY3RfZmlkMgD+CCJyYXdjb250YWN0bWFuaWZvbGRfY29udGFjdF9pbXB1bHNlAIYJLHJhd2NvbnRhY3RtYW5pZm9sZF9jb250YWN0X3RhbmdlbnRfaW1wdWxzZV94AIcJLHJhd2NvbnRhY3RtYW5pZm9sZF9jb250YWN0X3RhbmdlbnRfaW1wdWxzZV95AIgJJnJhd2NvbnRhY3RtYW5pZm9sZF9udW1fc29sdmVyX2NvbnRhY3RzANcJJ3Jhd2NvbnRhY3RtYW5pZm9sZF9zb2x2ZXJfY29udGFjdF9wb2ludADrBSZyYXdjb250YWN0bWFuaWZvbGRfc29sdmVyX2NvbnRhY3RfZGlzdADGCCpyYXdjb250YWN0bWFuaWZvbGRfc29sdmVyX2NvbnRhY3RfZnJpY3Rpb24AtwgtcmF3Y29udGFjdG1hbmlmb2xkX3NvbHZlcl9jb250YWN0X3Jlc3RpdHV0aW9uALgIMnJhd2NvbnRhY3RtYW5pZm9sZF9zb2x2ZXJfY29udGFjdF90YW5nZW50X3ZlbG9jaXR5ANcGJV9fd2JnX3Jhd3BvaW50Y29sbGlkZXJwcm9qZWN0aW9uX2ZyZWUA1wopcmF3cG9pbnRjb2xsaWRlcnByb2plY3Rpb25fY29sbGlkZXJIYW5kbGUAwQggcmF3cG9pbnRjb2xsaWRlcnByb2plY3Rpb25fcG9pbnQAmQcjcmF3cG9pbnRjb2xsaWRlcnByb2plY3Rpb25faXNJbnNpZGUA8golX193YmdfcmF3cmF5Y29sbGlkZXJpbnRlcnNlY3Rpb25fZnJlZQDXCiFyYXdyYXljb2xsaWRlcmludGVyc2VjdGlvbl9ub3JtYWwAmgccX193YmdfcmF3cmF5Y29sbGlkZXJ0b2lfZnJlZQDXChNfX3diZ19yYXdzaGFwZV9mcmVlAIkJD3Jhd3NoYXBlX2N1Ym9pZACQCRRyYXdzaGFwZV9yb3VuZEN1Ym9pZACKCQ1yYXdzaGFwZV9iYWxsAJ0JEHJhd3NoYXBlX2NhcHN1bGUAuAcRcmF3c2hhcGVfY3lsaW5kZXIAlwkWcmF3c2hhcGVfcm91bmRDeWxpbmRlcgCRCQ1yYXdzaGFwZV9jb25lAJgJEnJhd3NoYXBlX3JvdW5kQ29uZQCSCRFyYXdzaGFwZV9wb2x5bGluZQDcBxByYXdzaGFwZV90cmltZXNoAN0HFHJhd3NoYXBlX2hlaWdodGZpZWxkAJQGEHJhd3NoYXBlX3NlZ21lbnQA7gURcmF3c2hhcGVfdHJpYW5nbGUA6AQWcmF3c2hhcGVfcm91bmRUcmlhbmdsZQDYBBNyYXdzaGFwZV9jb252ZXhIdWxsAPMHGHJhd3NoYXBlX3JvdW5kQ29udmV4SHVsbADqBxNyYXdzaGFwZV9jb252ZXhNZXNoALMHGHJhd3NoYXBlX3JvdW5kQ29udmV4TWVzaACtBx5fX3diZ19yYXdzaGFwZWNvbGxpZGVydG9pX2ZyZWUA1wobcmF3c2hhcGVjb2xsaWRlcnRvaV9ub3JtYWwxAJsHFl9fd2JnX3Jhd3JvdGF0aW9uX2ZyZWUA1woPcmF3cm90YXRpb25fbmV3AJIKFHJhd3JvdGF0aW9uX2lkZW50aXR5ALcKDXJhd3JvdGF0aW9uX3kA8woOcmF3dmVjdG9yX3plcm8A9AoNcmF3dmVjdG9yX25ldwCmCg9yYXd2ZWN0b3Jfc2V0X3kAzwoNcmF3dmVjdG9yX3h5egChCA1yYXd2ZWN0b3JfeXh6AKIIDXJhd3ZlY3Rvcl96eHkAowgNcmF3dmVjdG9yX3h6eQCkCA1yYXd2ZWN0b3JfeXp4AKUIDXJhd3ZlY3Rvcl96eXgApggYX193YmdfcmF3ZXZlbnRxdWV1ZV9mcmVlAF8RcmF3ZXZlbnRxdWV1ZV9uZXcA0AcgcmF3ZXZlbnRxdWV1ZV9kcmFpbkNvbnRhY3RFdmVudHMApQklcmF3ZXZlbnRxdWV1ZV9kcmFpbkludGVyc2VjdGlvbkV2ZW50cwCmCRNyYXdldmVudHF1ZXVlX2NsZWFyAI8HHV9fd2JnX3Jhd3BoeXNpY3NwaXBlbGluZV9mcmVlAMkBFnJhd3BoeXNpY3NwaXBlbGluZV9uZXcA7AgXcmF3cGh5c2ljc3BpcGVsaW5lX3N0ZXAAxQQhcmF3cGh5c2ljc3BpcGVsaW5lX3N0ZXBXaXRoRXZlbnRzALgEG19fd2JnX3Jhd3F1ZXJ5cGlwZWxpbmVfZnJlZQC1CBRyYXdxdWVyeXBpcGVsaW5lX25ldwDRCRdyYXdxdWVyeXBpcGVsaW5lX3VwZGF0ZQDmBhhyYXdxdWVyeXBpcGVsaW5lX2Nhc3RSYXkAgQUkcmF3cXVlcnlwaXBlbGluZV9jYXN0UmF5QW5kR2V0Tm9ybWFsANEEJXJhd3F1ZXJ5cGlwZWxpbmVfaW50ZXJzZWN0aW9uc1dpdGhSYXkAggYmcmF3cXVlcnlwaXBlbGluZV9pbnRlcnNlY3Rpb25XaXRoU2hhcGUAggUdcmF3cXVlcnlwaXBlbGluZV9wcm9qZWN0UG9pbnQA+wQncmF3cXVlcnlwaXBlbGluZV9pbnRlcnNlY3Rpb25zV2l0aFBvaW50AOQGGnJhd3F1ZXJ5cGlwZWxpbmVfY2FzdFNoYXBlAJIDJ3Jhd3F1ZXJ5cGlwZWxpbmVfaW50ZXJzZWN0aW9uc1dpdGhTaGFwZQChBTJyYXdxdWVyeXBpcGVsaW5lX2NvbGxpZGVyc1dpdGhBYWJiSW50ZXJzZWN0aW5nQWFiYgD0BB9fX3diZ19yYXdkZXNlcmlhbGl6ZWR3b3JsZF9mcmVlAPsBIHJhd2Rlc2VyaWFsaXplZHdvcmxkX3Rha2VHcmF2aXR5AJwHLnJhd2Rlc2VyaWFsaXplZHdvcmxkX3Rha2VJbnRlZ3JhdGlvblBhcmFtZXRlcnMApwcmcmF3ZGVzZXJpYWxpemVkd29ybGRfdGFrZUlzbGFuZE1hbmFnZXIAwQQjcmF3ZGVzZXJpYWxpemVkd29ybGRfdGFrZUJyb2FkUGhhc2UA+QYkcmF3ZGVzZXJpYWxpemVkd29ybGRfdGFrZU5hcnJvd1BoYXNlAMIEH3Jhd2Rlc2VyaWFsaXplZHdvcmxkX3Rha2VCb2RpZXMAyQUicmF3ZGVzZXJpYWxpemVkd29ybGRfdGFrZUNvbGxpZGVycwCKBR9yYXdkZXNlcmlhbGl6ZWR3b3JsZF90YWtlSm9pbnRzAL0EJXJhd3NlcmlhbGl6YXRpb25waXBlbGluZV9zZXJpYWxpemVBbGwAtwMncmF3c2VyaWFsaXphdGlvbnBpcGVsaW5lX2Rlc2VyaWFsaXplQWxsAJ0HGV9fd2JnX3Jhd2NvbnRhY3RwYWlyX2ZyZWUA1woUX193YmdfcmF3dmVjdG9yX2ZyZWUA1woccmF3c2hhcGVjb2xsaWRlcnRvaV93aXRuZXNzMQCaBxxyYXdzaGFwZWNvbGxpZGVydG9pX3dpdG5lc3MyAJoHG3Jhd3NoYXBlY29sbGlkZXJ0b2lfbm9ybWFsMgCbBxxyYXdjb250YWN0bWFuaWZvbGRfc3Vic2hhcGUyAPEJHHJhd3NlcmlhbGl6YXRpb25waXBlbGluZV9uZXcAkwsjcmF3Y29udGFjdG1hbmlmb2xkX2NvbnRhY3RfbG9jYWxfcDIA/QUicmF3cmlnaWRib2R5c2V0X3JiTG9ja1RyYW5zbGF0aW9ucwCmBxtyYXdjb250YWN0bWFuaWZvbGRfbG9jYWxfbjIAmAcpcmF3cmF5Y29sbGlkZXJpbnRlcnNlY3Rpb25fY29sbGlkZXJIYW5kbGUAwQggcmF3cmF5Y29sbGlkZXJ0b2lfY29sbGlkZXJIYW5kbGUAwQgicmF3c2hhcGVjb2xsaWRlcnRvaV9jb2xsaWRlckhhbmRsZQDBCCNfX3diZ19yYXdzZXJpYWxpemF0aW9ucGlwZWxpbmVfZnJlZQDXCg9yYXd2ZWN0b3Jfc2V0X3gA8QoPcmF3dmVjdG9yX3NldF96AMMKHHJhd2NvbGxpZGVyc2V0X2lzSGFuZGxlVmFsaWQA3AgecmF3cmF5Y29sbGlkZXJpbnRlcnNlY3Rpb25fdG9pAOUKFXJhd3JheWNvbGxpZGVydG9pX3RvaQDlChdyYXdzaGFwZWNvbGxpZGVydG9pX3RvaQDlCg1yYXdyb3RhdGlvbl94AIsLDXJhd3JvdGF0aW9uX3oA5QoNcmF3cm90YXRpb25fdwDmCgtyYXd2ZWN0b3JfeACLCwtyYXd2ZWN0b3JfeQDzCgtyYXd2ZWN0b3JfegDlChFfX3diaW5kZ2VuX21hbGxvYwCjChJfX3diaW5kZ2VuX3JlYWxsb2MAkAsfX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcgCbDA9fX3diaW5kZ2VuX2ZyZWUAuQsUX193YmluZGdlbl9leG5fc3RvcmUAzAsJvw0BAEEBC+sGxQuYDPMB7AycDKwMqwyHDJ4MnQyfCZsLiguxCcsE9QikCccL6Qi1C7cMnwzGC7YM6wzrDO0MjArZAosE6wxvUmCaDPUK7AxqNiYuP/oBOSCgCZwLuAy5CqAMuAq6CrgK3Am/B/QHuwqOBdIEwATWBcoLygvKC8oLwgiHB4sJnwO/AqgDoAf8BLQIpQzgBYUK1wzlC9gM1gzUDOsLrQyqC8MGsAaMDGGNDF6KDIYBiwxatwy2C5UHkQuVC9sGlAuVC50LmQuUC5QLlguXC+wM0grLC4oK4wibBewMogmf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NQAAQiCGDAELEIwLrUIghkIBhAsiXkIgiKchTCBepwRAIEwhCwwBCwJ+IA4oAgAiA0EETwRAIAEgA0F8ajYCBCABIAEoAgAiA0EEajYCACADNQAAQiCGDAELEIwLrUIghkIBhAsiXkIgiKchTSBepwRAIE0hCwwBCwJ+IA4oAgAiA0EETwRAIAEgA0F8ajYCBCABIAEoAgAiA0EEajYCACADNQAAQiCGDAELEIwLrUIghkIBhAsiXkIgiKchTiBepwRAIE4hCwwBCwJ+IA4oAgAiA0EETwRAIAEgA0F8ajYCBCABIAEoAgAiA0EEajYCACADNQAAQiCGDAELEIwLrUIghkIBhAsiXkIgiKchTyBepwRAIE8hCwwBCwJ+IA4oAgAiA0EETwRAIAEgA0F8ajYCBCABIAEoAgAiA0EEajYCACADNQAAQiCGDAELEIwLrUIghkIBhAsiXkIgiKchUCBepwRAIFAhCwwBCwJ+IA4oAgAiA0EETwRAIAEgA0F8ajYCBCABIAEoAgAiA0EEajYCACADNQAAQiCGDAELEIwLrUIghkIBhAsiXkIgiKchUSBepwRAIFEhCwwBCwJ+IA4oAgAiA0EETwRAIAEgA0F8ajYCBCABIAEoAgAiA0EEajYCACADNQAAQiCGDAELEIwLrUIghkIBhAsiXkIgiKchUiBepwRAIFIhCwwBCwJ+IA4oAgAiA0EETwRAIAEgA0F8ajYCBCABIAEoAgAiA0EEajYCACADNQAAQiCGDAELEIwLrUIghkIBhAsiXkIgiKchUyBepwRAIFMhCwwBCwJ+IA4oAgAiA0EETwRAIAEgA0F8ajYCBCABIAEoAgAiA0EEajYCACADNQAAQiCGDAELEIwLrUIghkIBhAsiXkIgiKchVCBepwRAIFQhCwwBCwJ+IA4oAgAiA0EETwRAIAEgA0F8ajYCBCABIAEoAgAiA0EEajYCACADNQAAQiCGDAELEIwLrUIghkIBhAsiXkIgiKchVSBepwRAIFUhCwwBCwJ+IA4oAgAiA0EETwRAIAEgA0F8ajYCBCABIAEoAgAiA0EEajYCACADNQAAQiCGDAELEIwLrUIghkIBhAsiXkIgiKchViBepwRAIFYhCwwBCwJ+IA4oAgAiA0EITwRAIAEgA0F4ajYCBCABIAEoAgAiA0EIajYCAAJ+IAMpAAAiXkKA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IGJCCIinIUggaKchBSBqpyE3IG+nITQgASAEQXBqNgIEIAEgASgCACIGQRBqNgIAIAJBqARqIDIoAgA2AgAgAkGYBGogKCgCADYCACACQfgBaiIEQQhqIDwpAwA3AwAgBEEQaiA7KQMANwMAIARBGGogJSkDADcDACAEQSBqIDopAwA3AwAgAiACKQPABDcDoAQgAiACKQOwBDcDkAQgAiACKQPQBDcD+AEgBkEIaikAACFiIAYpAAAhaCACQeICaiACQeYCai0AADoAACACIAIvAeQCOwHgAiBiQiCGIGhCIIiEIWAgYkIgiCFqIGFCCIinISggaKchCkEBITILIAJBiARqIAJBqARqKAIANgIAIAJB+ANqIAJBmARqKAIANgIAIAJByANqIgRBCGogAkH4AWoiBkEIaikDADcDACAEQRBqIAZBEGopAwA3AwAgBEEYaiAGQRhqKQMANwMAIARBIGogBkEgaikDADcDACACIAIpA6AENwOABCACIAIpA5AENwPwAyACIAIpA/gBNwPIAyACQd4CaiACQeICai0AADoAACACIAIvAeACOwHcAiBqQiCGIGBCIIiEIWIgCq0gYEIghoQhYEEADAQLEIwLIQMMAgsgAigC/AEhAwwBCyACKAL8ASEDC0EBCwRAIAIoAvACIQQgAigC+AIiAQRAIAFBoAJsIQsgBCEBA0ACQCABKAIARQ0AIAFBhAJqKAIAIgVFDQAgAUGAAmooAgAiBkUNACAFQQN0RQ0AIAYQ2gELIAFBoAJqIQEgC0HgfWoiCw0ACwsgAigC9AIiAUUNDyABQaACbEUNDyAEENoBDA8LIAlBf2ohCSACQcADaiIlIAJBiARqKAIANgIAIAJBsANqIjogAkH4A2ooAgA2AgAgAkGAA2oiBEEIaiI7IAJByANqIgZBCGoiCikDADcDACAEQRBqIjwgBkEQaikDADcDACAEQRhqIkkgBkEYaikDADcDACAEQSBqIkogBkEgaikDADcDACACIAIpA4AENwO4AyACIAIpA/ADNwOoAyACIAIpA8gDNwOAAyACQf4CaiIGIAJB3gJqLQAAOgAAIAIgAi8B3AI7AfwCIAogJSgCADYCACACQZAFaiIlIDooAgA2AgAgAiACKQO4AzcDyAMgAiACKQOoAzcDiAUgAkH4AWoiBEEIaiI6IDspAwA3AwAg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agwCCyABKAIAIgNBCGoiAigCACEFIANBBGooAgAgBWtBA00EQCADIAVBBBCfBiACKAIAIQULIAIgBUEEajYCACADKAIAIAVqQQE2AAAgBygCBCEEIAEoAgAiA0EIaiICKAIAIQUgA0EEaigCACAFa0EDTQRAIAMgBUEEEJ8GIAIoAgAhBQsgAiAFQQRqNgIAIAMoAgAgBWogBDYAACAMIAE2AgwgDEEMaiAHQRhqEMwEIgINBCAHQShqIAEQnwUiAg0EIAwgATYCDCAMQQxqIAdBNGoQzAQiAg0EIAdBxABqIAEQnwUiAg0EIAdB0ABqIAdBpAFqLQAAIQggASgCACIDQQhqIgIoAgAiBSADQQRqKAIARgRAIAMgBUEBEJ8GIAIoAgAhBQsgAiAFQQFqNgIAIAMoAgAgBWogCDoAACAMIAE2AgwgARCfBSICDQQgB0HcAGoqAgAhEyABKAIAIgNBCGoiAigCACEFIANBBGooAgAgBWtBA00EQCADIAVBBBCfBiACKAIAIQULIAIgBUEEajYCACADKAIAIAVqIBM4AAAgB0HgAGogARCfBSICDQQgDEEMaiAHQewAahDMBCICDQQgB0H8AGogARCfBSICDQQgByoCiAEhEyABKAIAIgNBCGoiAigCACEFIANBBGooAgAgBWtBA00EQCADIAVBBBCfBiACKAIAIQULIAIgBUEEajYCACADKAIAIAVqIBM4AAAgB0GMAWoqAgAhEyABKAIAIgNBBGoiBSgCACADQQhqIgIoAgAiBGtBA00EQCADIARBBBCfBiACKAIAIQQLIAMoAgAgBGogEzgAACACIARBBGoiBDYCACAHKgKQASETIAUoAgAgBGtBA00EQCADIARBBBCfBiACKAIAIQQLIAMoAgAgBGogEzgAACACIARBBGoiBDYCACAHQZQBaioCACETIAUoAgAgBGtBA00EQCADIARBBBCfBiACKAIAIQQLIAMoAgAgBGogEzgAACACIARBBGoiBDYCACAHKgKYASETIAUoAgAgBGtBA00EQCADIARBBBCfBiACKAIAIQQLIAMoAgAgBGogEzgAACACIARBBGoiBDYCACAHQZwBaioCACETIAUoAgAgBGtBA00EQCADIARBBBCfBiACKAIAIQQLIAMoAgAgBGogEzgAACACIARBBGoiBDYCACAHKgKgASETIAUoAgAgBGtBA00EQCADIARBBBCfBiACKAIAIQQLIAIgBEEEajYCACADKAIAIARqIBM4AAAgB0GoAWogARCfBSICDQQgB0G0AWogARCfBSICDQQgB0HEAWoqAgAhEyAHKgLAASEUIAEoAgAiAkEEaiIFKAIAIAJBCGoiBCgCACIDa0EDTQRAIAIgA0EEEJ8GIAQoAgAhAwsgAigCACADaiAUOAAAIAQgA0EEaiIDNgIAIAUoAgAgA2tBA00EQCACIANBBBCfBiAEKAIAIQMLIAQgA0EEajYCACACKAIAIANqIBM4AAAgB0HIAWogARCfBSICDQQgB0HUAWogARCfBSICDQQgByoC4AEhEyABKAIAIgNBCGoiAigCACEFIANBBGooAgAgBWtBA00EQCADIAVBBBCfBiACKAIAIQULIAIgBUEEajYCACADKAIAIAVqIBM4AAAgB0HkAWoqAgAhEyABKAIAIgNBBGoiBSgCACADQQhqIgQoAgAiAmtBA00EQCADIAJBBBCfBiAEKAIAIQILIAMoAgAgAmogEzgAACAEIAJBBGoiAjYCACAHKgLoASETIAUoAgAgAmtBA00EQCADIAJBBBCfBiAEKAIAIQILIAMoAgAgAmogEzgAACAEIAJBBGoiAjYCACAHQewBai0AACEIIAIgBSgCAEYEQCADIAJBARCfBiAEKAIAIQILIAMoAgAgAmogCEH/AXFBAEc6AAAgBCACQQFqIgI2AgAgBy0A7QEhCCACIAUoAgBGBEAgAyACQQEQnwYgBCgCACECCyAEIAJBAWo2AgAgAygCACACaiAIQf8BcUEARzoAACAHNQLwASERIAEoAgAiA0EEaiIFKAIAIANBCGoiBCgCACICa0EHTQRAIAMgAkEIEJ8GIAQoAgAhAgsgAygCACACaiARNwAAIAQgAkEIaiICNgIAIAdB9AFqNQIAIREgBSgCACACa0EHTQRAIAMgAkEIEJ8GIAQoAgAhAgsgAygCACACaiARNwAAIAQgAkEIaiICNgIAIAc1AvgBIREgBSgCACACa0EHTQRAIAMgAkEIEJ8GIAQoAgAhAgsgAygCACACaiARNwAAIAQgAkEIaiICNgIAIAdB/AFqKAIAIQggBSgCACACa0EDTQRAIAMgAkEEEJ8GIAQoAgAhAgsgBCACQQRqNgIAIAMoAgAgAmogCDYAACAHKAKIAiEDIAcoAoACIQIgASgCACIEQQRqIgkoAgAgBEEIaiIKKAIAIghrQQdNBEAgBCAIQQgQnwYgCigCACEICyAKIAhBCGoiBTYCACAEKAIAIAhqIAOtNwAAIAMEQCADQQN0IAJqIQgDQCACQQRqKAIAIQ0gAigCACEDIAkoAgAgBWtBA00EQCAEIAVBBBCfBiAKKAIAIQULIAQoAgAgBWogAzYAACAKIAVBBGoiAzYCACAJKAIAIANrQQNNBEAgBCADQQQQnwYgCigCACEDCyAKIANBBGoiBTYCACAEKAIAIANqIA02AAAgCCACQQhqIgJHDQALCyAHQYwCaioCACETIAEoAgAiA0EEaiIFKAIAIANBCGoiBCgCACICa0EDTQRAIAMgAkEEEJ8GIAQoAgAhAgsgAygCACACaiATOAAAIAQgAkEEaiICNgIAIAcqApACIRMgBSgCACACa0EDTQRAIAMgAkEEEJ8GIAQoAgAhAgsgAygCACACaiATOAAAIAQgAkEEaiICNgIAIAdBlAJqLQAAIQggAiAFKAIARgRAIAMgAkEBEJ8GIAQoAgAhAgsgBCACQQFqNgIAIAMoAgAgAmogCEH/AXFBAEc6AAAgBygCmAIhBCABKAIAIgNBCGoiAigCACEFIANBBGooAgAgBWtBA00EQCADIAVBBBCfBiACKAIAIQULIAIgBUEEajYCACADKAIAIAVqIAQ2AAACQAJAAkACQAJAIAdBnAJqLQAAQQFrDgMBAgMAC0EAIQIgASgCACIFQQhqIgQoAgAhAyAFQQRqKAIAIANrQQNLDQMgBSADQQQQnwYgBCgCACEDDAMLQQEhAiABKAIAIgVBCGoiBCgCACEDIAVBBGooAgAgA2tBA0sNAiAFIANBBBCfBiAEKAIAIQMMAgtBAiECIAEoAgAiBUEIaiIEKAIAIQMgBUEEaigCACADa0EDSw0BIAUgA0EEEJ8GIAQoAgAhAwwBC0EDIQIgASgCACIFQQhqIgQoAgAhAyAFQQRqKAIAIANrQQNLDQAgBSADQQQQnwYgBCgCACEDCyAFKAIAIANqIAI2AAAgBUEIaiADQQRqNgIAIActAJ0CIQQgASgCACIDQQhqIgIoAgAiBSADQQRqKAIARgRAIAMgBUEBEJ8GIAIoAgAhBQsgAiAFQQFqNgIAIAMoAgAgBWogBDoAACAHQRBqKQMAIREgBykDCCESIAEoAgAiA0EIaiIFKAIAIQIgA0EEaigCACACa0EPTQRAIAMgAkEQEJ8GIANBCGooAgAhAgsgAygCACACaiIDIBE3AAggAyASNwAAIAJBEGoMAQsgB0EIaigCACEIIAEoAgAiA0EEaiEEIANBCGoiBSgCACICIAQoAgBGBEAgAyACQQEQnwYgA0EIaigCACECCyADKAIAIAJqQQE6AAAgA0EIaiIKIAJBAWoiAjYCACAEKAIAIAJrQQNNBEAgAyACQQQQnwYgCigCACECCyADKAIAIAJqIAg2AAAgAkEEagshAyAFIAM2AgAgCyAHQaACaiIHRw0ACwsgBigCDCEEIAEoAgAiA0EIaiICKAIAIQUgA0EEaigCACAFa0EDTQRAIAMgBUEEEJ8GIAIoAgAhBQsgAiAFQQRqNgIAIAMoAgAgBWogBDYAAAJ/IAZBEGooAgBBAUcEQCABKAIAIgRBCGoiAigCACIDIARBBGooAgBGBEAgBCADQQEQnwYgBEEIaigCACEDCyAEKAIAIANqQQA6AAAgA0EBagwBCyAGQRRqKAIAIQUgASgCACIEQQRqIQcgBEEIaiICKAIAIgMgBygCAEYEQCAEIANBARCfBiAEQQhqKAIAIQMLIAQoAgAgA2pBAToAACAEQQhqIANBAWoiAzYCACAHKAIAIANrQQNNBEAgBCADQQQQnwYgBEEIaigCACEDCyAEKAIAIANqIAU2AAAgA0EEagshBSACIAU2AgAgBjUCGCERIAEoAgAiA0EIaiICKAIAIQUgA0EEaigCACAFa0EHTQRAIAMgBUEIEJ8GIAIoAgAhBQsgAiAFQQhqNgIAIAMoAgAgBWogETcAACAGQSRqKAIAIQMgBigCHCECIAEoAgAiBEEIaigCACEGIARBBGooAgAgBmtBB00EQCAEIAZBCBCfBiAEQQhqKAIAIQYLIARBCGoiByAGQQhqIgU2AgAgBCgCACAGaiADrTcAACADBEAgA0EDdCACaiEGA0AgAkEEaigCACEIIAIoAgAhAyAEQQRqIgooAgAgBWtBA00EQCAEIAVBBBCfBiAHKAIAIQULIAQoAgAgBWogAzYAACAHIAVBBGoiAzYCACAKKAIAIANrQQNNBEAgBCADQQQQnwYgBygCACEDCyAHIANBBGoiBTYCACAEKAIAIANqIAg2AAAgBiACQQhqIgJHDQALCyAAKAIYIggoAgghBCAIKAIAIQogASgCACIDQQhqKAIAIQIgA0EEaigCACACa0EHTQRAIAMgAkEIEJ8GIANBCGooAgAhAgsgA0EIaiACQQhqNgIAIAMoAgAgAmogBK03AAAgBARAIARBoAFsIQlBACEHA0ACfwJAIAcgCmoiBSgCAEEBRwRAIAEoAgAiAkEIaiIEKAIAIQMgAkEEaigCACADa0EDTQRAIAIgA0EEEJ8GIAQoAgAhAwsgBCADQQRqNgIAIAIoAgAgA2pBADYAACAFQQRqKAIAQQFGDQEgASgCACIDQQhqIgUoAgAiAiADQQRqKAIARgRAIAMgAkEBEJ8GIANBCGooAgAhAgsgAygCACACakEAOgAAIAJBAWoMAgsgASgCACICQQhqIgQoAgAhAyACQQRqKAIAIANrQQNNBEAgAiADQQQQnwYgBCgCACEDCyAEIANBBGo2AgAgAigCACADakEBNgAAIAVBBGooAgAhBiABKAIAIgJBCGoiBCgCACEDIAJBBGooAgAgA2tBA00EQCACIANBBBCfBiAEKAIAIQMLIAQgA0EEajYCACACKAIAIANqIAY2AAACQCAFQZwBai0AAEEBRwRAQQAhBCABKAIAIgNBCGoiBigCACECIANBBGooAgAgAmtBA0sNASADIAJBBBCfBiAGKAIAIQIMAQtBASEEIAEoAgAiA0EIaiIGKAIAIQIgA0EEaigCACACa0EDSw0AIAMgAkEEEJ8GIAYoAgAhAgsgAygCACACaiAENgAAIANBCGogAkEEajYCACAFQRhqKAIAIAVBHGooAgAgARBEIgINBAJAIAVBIGooAgBBAUcEQCAFQSRqKgIAIRMgASgCACIDQQRqIgYoAgAgA0EIaiIEKAIAIgJrQQNNBEAgAyACQQQQnwYgBCgCACECCyADKAIAIAJqQQA2AAAgBCACQQRqIgI2AgAgBigCACACa0EDTQRAIAMgAkEEEJ8GIAQoAgAhAgsgBCACQQRqNgIAIAMoAgAgAmogEzgAAAwBCyAFQSRqKAIAIQMgASgCACIEQQhqIgYoAgAhAiAEQQRqKAIAIAJrQQNNBEAgBCACQQQQnwYgBigCACECCyAGIAJBBGo2AgAgBCgCACACakEBNgAAIAwgATYCDCADIAEQnwUiAg0FIAMqAgwhEyABKAIAIgRBCGoiBigCACECIARBBGooAgAgAmtBA00EQCAEIAJBBBCfBiAGKAIAIQILIAYgAkEEajYCACAEKAIAIAJqIBM4AAAgA0EQaiABEJ8FIgINBSAMQQxqIANBHGoQzAQiAg0FCyAFQShqKAIAIQYgASgCACICQQhqIgQoAgAhAyACQQRqKAIAIANrQQNNBEAgAiADQQQQnwYgBCgCACEDCyAEIANBBGo2AgAgAigCACADaiAGNgAAAkAgBUEsaigCAEEBRwRAIAEoAgAiAkEIaiIEKAIAIgMgAkEEaigCAEYEQCACIANBARCfBiAEKAIAIQMLIAQgA0EBajYCACACKAIAIANqQQA6AAAMAQsCfyABKAIAIgJBCGoiBigCACIEIAJBBGooAgBHBEAgAgwBCyACIARBARCfBiAGKAIAIQQgASgCAAshAyAGIARBAWo2AgAgAigCACAEakEBOgAAIAVBNGooAgAhBiAFQTBqKAIAIQsgA0EEaiINKAIAIANBCGoiBCgCACICa0EDTQRAIAMgAkEEEJ8GIAQoAgAhAgsgAygCACACaiALNgAAIAQgAkEEaiICNgIAIA0oAgAgAmtBA00EQCADIAJBBBCfBiAEKAIAIQILIAQgAkEEajYCACADKAIAIAJqIAY2AAAgDCABNgIMIAxBDGogBUE4ahDMBCICDQUgBUHIAGogARCfBSICDQULIAwgATYCDCAMQQxqIAVB1ABqEMwEIgINBCAFQeQAaiABEJ8FIgINBCAMIAE2AgwgBUHwAGoqAgAhEyABKAIAIgJBCGoiBCgCACEDIAJBBGooAgAgA2tBA00EQCACIANBBBCfBiAEKAIAIQMLIAQgA0EEajYCACACKAIAIANqIBM4AAAgBUH0AGoqAgAhEyABKAIAIgJBCGoiBCgCACEDIAJBBGooAgAgA2tBA00EQCACIANBBBCfBiAEKAIAIQMLIAQgA0EEajYCACACKAIAIANqIBM4AAAgDEEMaiIDIAVB+ABqLQAAENwFIAMgBUH5AGotAAAQ3AUgBUGUAWovAQAhCyABKAIAIgNBBGoiBCgCACADQQhqIgIoAgAiBmtBAU0EQCADIAZBAhCfBiACKAIAIQYLIAMoAgAgBmogCzsAACACIAZBAmoiBjYCACAFQYABaigCACELIAVB/ABqKAIAIQ0gBCgCACAGa0EDTQRAIAMgBkEEEJ8GIAIoAgAhBgsgAygCACAGaiANNgAAIAIgBkEEaiIGNgIAIAQoAgAgBmtBA00EQCADIAZBBBCfBiACKAIAIQYLIAMoAgAgBmogCzYAACACIAZBBGoiBjYCACAFQYgBaigCACELIAVBhAFqKAIAIQ0gBCgCACAGa0EDTQRAIAMgBkEEEJ8GIAIoAgAhBgsgAygCACAGaiANNgAAIAIgBkEEaiIGNgIAIAQoAgAgBmtBA00EQCADIAZBBBCfBiACKAIAIQYLIAMoAgAgBmogCzYAACACIAZBBGoiBjYCACAFQYwBaigCACELIAQoAgAgBmtBA00EQCADIAZBBBCfBiACKAIAIQYLIAMoAgAgBmogCzYAACACIAZBBGoiBjYCACAFQZABaigCACELIAQoAgAgBmtBA00EQCADIAZBBBCfBiACKAIAIQYLIAIgBkEEajYCACADKAIAIAZqIAs2AAAgBUGYAWooAgAhBiABKAIAIgJBCGoiBCgCACEDIAJBBGooAgAgA2tBA00EQCACIANBBBCfBiAEKAIAIQMLIAQgA0EEajYCACACKAIAIANqIAY2AAAgBUEQaikDACERIAVBCGopAwAhEiABKAIAIgNBCGoiBSgCACECIANBBGooAgAgAmtBD00EQCADIAJBEBCfBiADQQhqKAIAIQILIAMoAgAgAmoiAyARNwAIIAMgEjcAACACQRBqDAELIAVBCGooAgAhBiABKAIAIgNBBGohBCADQQhqIgUoAgAiAiAEKAIARgRAIAMgAkEBEJ8GIANBCGooAgAhAgsgAygCACACakEBOgAAIANBCGoiCyACQQFqIgI2AgAgBCgCACACa0EDTQRAIAMgAkEEEJ8GIAsoAgAhAgsgAygCACACaiAGNgAAIAJBBGoLIQMgBSADNgIAIAkgB0GgAWoiB0cNAAsLIAgoAgwhBCABKAIAIgJBCGooAgAhAyACQQRqKAIAIANrQQNNBEAgAiADQQQQnwYgAkEIaigCACEDCyACQQhqIANBBGo2AgAgAigCACADaiAENgAAAn8gCEEQaigCAEEBRwRAIAEoAgAiBEEIaiICKAIAIgMgBEEEaigCAEYEQCAEIANBARCfBiAEQQhqKAIAIQMLIAQoAgAgA2pBADoAACADQQFqDAELIAhBFGooAgAhByABKAIAIgRBBGohBiAEQQhqIgIoAgAiAyAGKAIARgRAIAQgA0EBEJ8GIARBCGooAgAhAwsgBCgCACADakEBOgAAIARBCGoiBSADQQFqIgM2AgAgBigCACADa0EDTQRAIAQgA0EEEJ8GIAUoAgAhAwsgBCgCACADaiAHNgAAIANBBGoLIQUgAiAFNgIAIAg1AhghESABKAIAIgNBCGoiAigCACEFIANBBGooAgAgBWtBB00EQCADIAVBCBCfBiACKAIAIQULIAIgBUEIajYCACADKAIAIAVqIBE3AAAgCEEkaigCACEDIAgoAhwhAiABKAIAIgRBCGooAgAhBiAEQQRqKAIAIAZrQQdNBEAgBCAGQQgQnwYgBEEIaigCACEGCyAEQQhqIgcgBkEIaiIFNgIAIAQoAgAgBmogA603AAAgAwRAIANBA3QgAmohBgNAIAJBBGooAgAhCiACKAIAIQMgBEEEaiIJKAIAIAVrQQNNBEAgBCAFQQQQnwYgBygCACEFCyAEKAIAIAVqIAM2AAAgByAFQQRqIgM2AgAgCSgCACADa0EDTQRAIAQgA0EEEJ8GIAcoAgAhAwsgByADQQRqIgU2AgAgBCgCACADaiAKNgAAIAYgAkEIaiICRw0ACwsgCEEwaigCACEDIAgoAighAiABKAIAIgRBCGooAgAhBiAEQQRqKAIAIAZrQQdNBEAgBCAGQQgQnwYgBEEIaigCACEGCyAEQQhqIgcgBkEIaiIFNgIAIAQoAgAgBmogA603AAAgAwRAIANBA3QgAmohBgNAIAJBBGooAgAhCCACKAIAIQMgBEEEaiIKKAIAIAVrQQNNBEAgBCAFQQQQnwYgBygCACEFCyAEKAIAIAVqIAM2AAAgByAFQQRqIgM2AgAgCigCACADa0EDTQRAIAQgA0EEEJ8GIAcoAgAhAwsgByADQQRqIgU2AgAgBCgCACADaiAINgAAIAYgAkEIaiICRw0ACwsgACgCHCIIKAIIIQMgCCgCACECIAEoAgAiAEEIaigCACEGIABBBGooAgAgBmtBB00EQCAAIAZBCBCfBiAAQQhqKAIAIQYLIABBCGoiBCAGQQhqIgU2AgAgACgCACAGaiADrTcAACADBEAgA0EDdCACaiEHIABBBGohBgNAIAIoAgAhAyAGKAIAIAVrQQNNBEAgACAFQQQQnwYgBCgCACEFCyAAKAIAIAVqIAM2AAAgBCAFQQRqIgM2AgAgAkEEaigCACEKIAYoAgAgA2tBA00EQCAAIANBBBCfBiAEKAIAIQMLIAQgA0EEaiIFNgIAIAAoAgAgA2ogCjYAACAHIAJBCGoiAkcNAAsLIAhBFGooAgAhBCAIKAIMIQMgASgCACIAQQhqKAIAIQYgAEEEaigCACAGa0EHTQRAIAAgBkEIEJ8GIABBCGooAgAhBgsgAEEIaiICIAZBCGoiBTYCACAAKAIAIAZqIAStNwAAIAQEQCAEQQxsIQogAEEEaiEEA0ACfwJAIAMoAgBBAUcEQCAEKAIAIAVrQQNNBEAgACAFQQQQnwYgAigCACEFCyACIAVBBGoiBjYCACAAKAIAIAVqQQA2AAAgA0EEaigCAEEBRg0BIAYgBCgCAEYEQCAAIAZBARCfBiACKAIAIQYLIAAoAgAgBmpBADoAACAGQQFqDAILIAQoAgAgBWtBA00EQCAAIAVBBBCfBiACKAIAIQULIAAoAgAgBWpBATYAACACIAVBBGoiBTYCACADQQRqKAIAIQYgBCgCACAFa0EDTQRAIAAgBUEEEJ8GIAIoAgAhBQsgACgCACAFaiAGNgAAIAIgBUEEaiIFNgIAIANBCGooAgAhBiAEKAIAIAVrQQNNBEAgACAFQQQQnwYgAigCACEFCyAAKAIAIAVqIAY2AAAgBUEEagwBCyADQQhqKAIAIQcgBiAEKAIARgRAIAAgBkEBEJ8GIAIoAgAhBgsgACgCACAGakEBOgAAIAIgBkEBaiIFNgIAIAQoAgAgBWtBA00EQCAAIAVBBBCfBiACKAIAIQULIAAoAgAgBWogBzYAACAFQQRqCyEFIANBDGohAyACIAU2AgAgCkF0aiIKDQALCyAIQRhqKAIAIQIgAEEEaigCACAFa0EDTQRAIAAgBUEEEJ8GIABBCGooAgAhBQsgAEEIaiAFQQRqIgM2AgAgACgCACAFaiACNgAAAn8gCEEcaigCAEEBRwRAIAMgAEEEaigCAEYEQCAAIANBARCfBiAAQQhqKAIAIQMLIAAoAgAgA2pBADoAACADQQFqDAELIAhBIGooAgAhAiADIABBBGoiBCgCAEYEQCAAIANBARCfBiAAQQhqKAIAIQMLIAAoAgAgA2pBAToAACAAQQhqIgYgA0EBaiIFNgIAIAQoAgAgBWtBA00EQCAAIAVBBBCfBiAGKAIAIQULIAAoAgAgBWogAjYAACAFQQRqCyEFIABBCGoiAyAFNgIAIAhBJGo1AgAhESAAQQRqKAIAIAVrQQdNBEAgACAFQQgQnwYgAygCACEFCyADIAVBCGo2AgAgACgCACAFaiARNwAAIAhBMGooAgAhAiAIKAIoIQUgASgCACIAQQhqKAIAIQYgAEEEaigCACAGa0EHTQRAIAAgBkEIEJ8GIABBCGooAgAhBgsgAEEIaiIDIAZBCGoiBzYCACAAKAIAIAZqIAKtNwAAIAIEQCACQQR0IAVqIQYDQCAFQQRqKAIAIQQgBSgCACEKIABBBGoiAigCACAHa0EDTQRAIAAgB0EEEJ8GIAMoAgAhBwsgACgCACAHaiAKNgAAIAMgB0EEaiIHNgIAIAIoAgAgB2tBA00EQCAAIAdBBBCfBiADKAIAIQcLIAAoAgAgB2ogBDYAACADIAdBBGoiBzYCACAFQQxqKAIAIQogBUEIaigCACEEIAIoAgAgB2tBA00EQCAAIAdBBBCfBiADKAIAIQcLIAAoAgAgB2ogBDYAACADIAdBBGoiBDYCACACKAIAIARrQQNNBEAgACAEQQQQnwYgAygCACEECyADIARBBGoiBzYCACAAKAIAIARqIAo2AAAgBiAFQRBqIgVHDQALCyAIQTxqKAIAIQMgCEE0aigCACEFIAEoAgAiAEEIaigCACEHIABBBGooAgAgB2tBB00EQCAAIAdBCBCfBiAAQQhqKAIAIQcLIABBCGogB0EIajYCACAAKAIAIAdqIAOtNwAAIANFBEBBACECDAELIANB5AFsIAVqIQYDQCAFQQRqKAIAIQQgBSgCACEHIAEoAgAiAEEEaiIIKAIAIABBCGoiAygCACICa0EDTQRAIAAgAkEEEJ8GIAMoAgAhAgsgACgCACACaiAHNgAAIAMgAkEEaiICNgIAIAgoAgAgAmtBA00EQCAAIAJBBBCfBiADKAIAIQILIAMgAkEEajYCACAAKAIAIAJqIAQ2AAAgBUEMaigCACEEIAUoAgghByABKAIAIgBBBGoiCCgCACAAQQhqIgMoAgAiAmtBA00EQCAAIAJBBBCfBiADKAIAIQILIAAoAgAgAmogBzYAACADIAJBBGoiAjYCACAIKAIAIAJrQQNNBEAgACACQQQQnwYgAygCACECCyADIAJBBGo2AgAgACgCACACaiAENgAAIAVBFGooAgAhBCAFKAIQIQcgASgCACIAQQRqIggoAgAgAEEIaiIDKAIAIgJrQQNNBEAgACACQQQQnwYgAygCACECCyAAKAIAIAJqIAc2AAAgAyACQQRqIgI2AgAgCCgCACACa0EDTQRAIAAgAkEEEJ8GIAMoAgAhAgsgAyACQQRqNgIAIAAoAgAgAmogBDYAAAJAAkACQAJAAkAgBSgCGEEBaw4DAQIDAAsgBUEcaiABKAIAIgBBCGoiAigCACEDIABBBGooAgAgA2tBA00EQCAAIANBBBCfBiACKAIAIQMLIAIgA0EEajYCACAAKAIAIANqQQA2AAAgDCABNgIMIAEQnwUiAg0FIAVBKGogARCfBSICDQUgBUE0aiABEJ8FIgINBSAFQUBrIAEQnwUiAg0FIAxBDGogBUHMAGoQzAQiAg0FIAUqAlwhEyABKAIAIgBBCGoiAigCACEDIABBBGooAgAgA2tBA00EQCAAIANBBBCfBiACKAIAIQMLIAIgA0EEajYCACAAKAIAIANqIBM4AAAgBSoCYCETIAEoAgAiAEEIaiICKAIAIQMgAEEEaigCACADa0EDTQRAIAAgA0EEEJ8GIAIoAgAhAwsgAiADQQRqNgIAIAAoAgAgA2ogEzgAACAFKgJkIRMgASgCACIAQQhqIgIoAgAhAyAAQQRqKAIAIANrQQNNBEAgACADQQQQnwYgAigCACEDCyACIANBBGo2AgAgACgCACADaiATOAAAIAVB6ABqIAEQnwUiAg0FIAxBDGogBS0AlAEQ3AUgBS0AlQEhBCABKAIAIgBBCGoiAigCACIDIABBBGooAgBGBEAgACADQQEQnwYgAigCACEDCyACIANBAWo2AgAgACgCACADaiAEQf8BcUEARzoAACAFQfQAaiABEJ8FIgINBSAFQYABaiABEJ8FIgINBSAFKgKMASETIAEoAgAiAEEIaiICKAIAIQMgAEEEaigCACADa0EDTQRAIAAgA0EEEJ8GIAIoAgAhAwsgAiADQQRqNgIAIAAoAgAgA2ogEzgAACAFKgKQASETIAEoAgAiAEEIaiICKAIAIQMgAEEEaigCACADa0EDTQRAIAAgA0EEEJ8GIAIoAgAhAwsgAiADQQRqNgIAIAAoAgAgA2ogEzgAAAwDCyAFQRxqIQQgASgCACIAQQhqIgIoAgAhAyAAQQRqKAIAIANrQQNNBEAgACADQQQQnwYgAigCACEDCyACIANBBGo2AgAgACgCACADakEBNgAAIAwgATYCDCAMQQxqIAQQzAQiAg0EIAVBLGogARCfBSICDQQgDCABNgIMIAxBDGogBUE4ahDMBCICDQQgBUHIAGogARCfBSICDQQgASgCACIAQQRqIgIoAgAgAEEIaiIDKAIAIgRrQQdNBEAgACAEQQgQnwYgAygCACEECyAAKAIAIARqQgY3AAAgAyAEQQhqIgQ2AgAgBSoCVCETIAIoAgAgBGtBA00EQCAAIARBBBCfBiADKAIAIQQLIAAoAgAgBGogEzgAACADIARBBGoiBDYCACAFKgJYIRMgAigCACAEa0EDTQRAIAAgBEEEEJ8GIAMoAgAhBAsgACgCACAEaiATOAAAIAMgBEEEaiIENgIAIAUqAlwhEyACKAIAIARrQQNNBEAgACAEQQQQnwYgAygCACEECyAAKAIAIARqIBM4AAAgAyAEQQRqIgQ2AgAgBSoCYCETIAIoAgAgBGtBA00EQCAAIARBBBCfBiADKAIAIQQLIAAoAgAgBGogEzgAACADIARBBGoiBDYCACAFKgJkIRMgAigCACAEa0EDTQRAIAAgBEEEEJ8GIAMoAgAhBAsgACgCACAEaiATOAAAIAMgBEEEaiIENgIAIAUqAmghEyACKAIAIARrQQNNBEAgACAEQQQQnwYgAygCACEECyADIARBBGo2AgAgACgCACAEaiATOAAADAILIAVBHGohBCABKAIAIgBBCGoiAigCACEDIABBBGooAgAgA2tBA00EQCAAIANBBBCfBiACKAIAIQMLIAIgA0EEajYCACAAKAIAIANqQQI2AAAgDCABNgIMIAQgARCfBSICDQMgBUEoaiABEJ8FIgINAyAFQTRqIAEQnwUiAg0DIAVBQGsgARCfBSICDQNBzAAhAwNAIANBDGoiAEHwAEcEQCADIAVqIAAhAyABEJ8FIgJFDQEMBQsLIAVB/ABqIQdB5AAhAwNAIANBDGoiAEGIAUcEQCADIAVqIAAhAyABEJ8FIgJFDQEMBQsLIAxBDGogBxCfBCICDQMgBS0AtAEhByABKAIAIgBBCGoiAigCACIDIABBBGooAgBGBEAgACADQQEQnwYgAigCACEDCyACIANBAWo2AgAgACgCACADaiAHQf8BcUEARzoAACAFQZQBaioCACETIAUqApABIRQgASgCACIAQQRqIgcoAgAgAEEIaiIDKAIAIgJrQQNNBEAgACACQQQQnwYgAygCACECCyAAKAIAIAJqIBQ4AAAgAyACQQRqIgI2AgAgBygCACACa0EDTQRAIAAgAkEEEJ8GIAMoAgAhAgsgAyACQQRqNgIAIAAoAgAgAmogEzgAACAFKgKYASETIAEoAgAiAEEIaiICKAIAIQMgAEEEaigCACADa0EDTQRAIAAgA0EEEJ8GIAIoAgAhAwsgAiADQQRqNgIAIAAoAgAgA2ogEzgAACAFKgKcASETIAEoAgAiAEEIaiICKAIAIQMgAEEEaigCACADa0EDTQRAIAAgA0EEEJ8GIAIoAgAhAwsgAiADQQRqNgIAIAAoAgAgA2ogEzgAACAFKgKgASETIAEoAgAiAEEIaiICKAIAIQMgAEEEaigCACADa0EDTQRAIAAgA0EEEJ8GIAIoAgAhAwsgAiADQQRqNgIAIAAoAgAgA2ogEzgAACAFKgKkASETIAEoAgAiAEEIaiICKAIAIQMgAEEEaigCACADa0EDTQRAIAAgA0EEEJ8GIAIoAgAhAwsgAiADQQRqNgIAIAAoAgAgA2ogEzgAACAFKgKoASETIAEoAgAiAEEIaiICKAIAIQMgAEEEaigCACADa0EDTQRAIAAgA0EEEJ8GIAIoAgAhAwsgAiADQQRqNgIAIAAoAgAgA2ogEzgAACAFKgKsASETIAEoAgAiAEEIaiICKAIAIQMgAEEEaigCACADa0EDTQRAIAAgA0EEEJ8GIAIoAgAhAwsgAiADQQRqNgIAIAAoAgAgA2ogEzgAACAFKgKwASETIAEoAgAiAEEIaiICKAIAIQMgAEEEaigCACADa0EDTQRAIAAgA0EEEJ8GIAIoAgAhAwsgAiADQQRqNgIAIAAoAgAgA2ogEzgAACAMQQxqIAQtAJkBENwFDAELIAVBHGogASgCACIAQQhqIgIoAgAhAyAAQQRqKAIAIANrQQNNBEAgACADQQQQnwYgAigCACEDCyACIANBBGo2AgAgACgCACADakEDNgAAIAwgATYCDCABEJ8FIgINAiAFQShqIAEQnwUiAg0CIAVBNGogARCfBSICDQIgBUFAayABEJ8FIgINAkHMACEDA0AgA0EMaiIAQfAARwRAIAMgBWogACEDIAEQnwUiAkUNAQwECwsgBUH8AGohBEHkACEDA0AgA0EMaiIAQYgBRwRAIAMgBWogACEDIAEQnwUiAkUNAQwECwsgDEEMaiAEEJ8EIgINAiAFLQDQASEEIAEoAgAiAEEIaiICKAIAIgMgAEEEaigCAEYEQCAAIANBARCfBiACKAIAIQMLIAIgA0EBajYCACAAKAIAIANqIARB/wFxQQBHOgAAIAVBlAFqKgIAIRMgBSoCkAEhFCABKAIAIgBBBGoiBCgCACAAQQhqIgMoAgAiAmtBA00EQCAAIAJBBBCfBiADKAIAIQILIAAoAgAgAmogFDgAACADIAJBBGoiAjYCACAEKAIAIAJrQQNNBEAgACACQQQQnwYgAygCACECCyADIAJBBGo2AgAgACgCACACaiATOAAAIAUqApgBIRMgASgCACIAQQhqIgIoAgAhAyAAQQRqKAIAIANrQQNNBEAgACADQQQQnwYgAigCACEDCyACIANBBGo2AgAgACgCACADaiATOAAAIAUqApwBIRMgASgCACIAQQhqIgIoAgAhAyAAQQRqKAIAIANrQQNNBEAgACADQQQQnwYgAigCACEDCyACIANBBGo2AgAgACgCACADaiATOAAAIAUqAqABIRMgASgCACIAQQhqIgIoAgAhAyAAQQRqKAIAIANrQQNNBEAgACADQQQQnwYgAigCACEDCyACIANBBGo2AgAgACgCACADaiATOAAAIAUqAqQBIRMgASgCACIAQQhqIgIoAgAhAyAAQQRqKAIAIANrQQNNBEAgACADQQQQnwYgAigCACEDCyACIANBBGo2AgAgACgCACADaiATOAAAIAUqAqgBIRMgASgCACIAQQhqIgIoAgAhAyAAQQRqKAIAIANrQQNNBEAgACADQQQQnwYgAigCACEDCyACIANBBGo2AgAgACgCACADaiATOAAAIAUqAqwBIRMgASgCACIAQQhqIgIoAgAhAyAAQQRqKAIAIANrQQNNBEAgACADQQQQnwYgAigCACEDCyACIANBBGo2AgAgACgCACADaiATOAAAIAUqArABIRMgASgCACIAQQhqIgIoAgAhAyAAQQRqKAIAIANrQQNNBEAgACADQQQQnwYgAigCACEDCyACIANBBGo2AgAgACgCACADaiATOAAAIAxBDGogBS0A0QEQ3AUgBSoCtAEhEyABKAIAIgBBCGoiAigCACEDIABBBGooAgAgA2tBA00EQCAAIANBBBCfBiACKAIAIQMLIAIgA0EEajYCACAAKAIAIANqIBM4AAAgBUG4AWogARCfBSICDQIgBUHEAWogARCfBSICDQILIAVB2AFqKAIAIQQgBSgC1AEhByABKAIAIgBBBGoiCCgCACAAQQhqIgIoAgAiA2tBA00EQCAAIANBBBCfBiACKAIAIQMLIAAoAgAgA2ogBzYAACACIANBBGoiAzYCACAIKAIAIANrQQNNBEAgACADQQQQnwYgAigCACEDCyACIANBBGo2AgAgACgCACADaiAENgAAIAVB4AFqKAIAIQQgBSgC3AEhByAFQeQBaiEFIAEoAgAiAEEEaiIIKAIAIABBCGoiAigCACIDa0EDTQRAIAAgA0EEEJ8GIAIoAgAhAwsgACgCACADaiAHNgAAIAIgA0EEaiIDNgIAIAgoAgAgA2tBA00EQCAAIANBBBCfBiACKAIAIQMLIAIgA0EEajYCACAAKAIAIANqIAQ2AABBACECIAUgBkcNAAsLIAxBEGokACACC+OlAQIGf0F9IwBB4ABrIgUkAAJAAkACQAJAAkACQAJAAkACfQJAAn0CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIAQQFrDggBAgMEBQYHFwALIAAoAgQiBiADTw0HAkAgAEEIaigCACIEIANJBEBDAACAPyFKIARBHGwgAmoiCEEUaioCACFFIAgqAggiRyAAQYABaioCACIXlCAIKgIAIjcgAEGIAWoqAgAiFZSTIgogCpIhIiAIKgIEIjggFZQgRyAAQYQBaioCACIMlJMiCiAKkiEaIEcgAEEYaioCACIPlCA3IABBIGoqAgAiI5STIgogCpIhMiA4ICOUIEcgAEEcaioCACINlJMiCiAKkiEuIAZBHGwgAmoiBEEYaioCACE2IAQqAgAiOSAAQfgAaioCACIRlCAEKgIEIjogAEH0AGoqAgAiFJSTIgogCpIhHyAEKgIIIjsgFJQgOSAAQfwAaioCACILlJMiCiAKkiEZIDogAEEUaioCACITlCA7IABBEGoqAgAiEJSTIgogCpIhHCA5IBCUIDogAEEM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KSArIARBCGoqAgAgL5SSISsgKiAEQQRqKgIAIC+UkiEqIA8gBEEMaiIERw0ACwsgLosiLiAsiyIsICwgLl8bIi4gLYsiLCAsIC5fGyEsIAUhBANAIAQgBCoCACApkyAslTgCACAEQQhqIgYgBioCACArkyAslTgCACAEQQRqIgYgBioCACAqkyAslTgCACAPIARBDGoiBEcNAAtD//9//yEpQQAhCiADKgKQASEtIAMqAowBISsgAyoCiAEhLEEAIQYgBSEEA0AgLCAEKgIAlCArIARBBGoqAgCUkiAtIARBCGoqAgCUkiIqICleIQcgKiApIAcbISlBASAKIAcbIQogBiALIAcbIQsgBkEBaiEGIA8gBEEMaiIERw0ACyAKBEAgK4whK0P//3//ISlBACEKQQAhBiAFIQQDQCAEQQRqKgIAICuUICwgBCoCAJSTIC0gBEEIaioCAJSTIiogKV4hByAqICkgBxshKUEBIAogBxshCiAGIA0gBxshDSAGQQFqIQYgDyAEQQxqIgRHDQALIApFDQUgCyAZTw0EIA0gGUkEQCANQQxsIAVqIhJBCGohFCASQQRqIRAgC0EMbCAFaiIYQQhqIREgGEEEaiEMQX8hG0MAAAAAISsgBSEEA0AgCSEGIARBCGoqAgAhMyAEQQRqKgIAITQgBCoCACExIAMgEioCACIwIBgqAgAiL5MiKSAplCAQKgIAIi4gDCoCACItkyIpICmUkiAUKgIAIiwgESoCACIqkyIpICmUkkMAAAAAkhCrASIyOALoASADIDEgMJMiKSAplCA0IC6TIikgKZSSIDMgLJMiKSAplJJDAAAAAJIQqwEiLDgCkAIgAyAvIDGTIikgKZQgLSA0kyIpICmUkiAqIDOTIikgKZSSQwAAAACSEKsBIik4AtgCAkAgMiAsXkUEQCADQdgCaiIIIANB6AFqIgkgMiApXiIVGyEHIAkgA0GQAmoiCSAVGyEKIAkgCCAVGyEOIBUNASAsICleQQFzDQEgA0HoAWohByADQdgCaiEKIANBkAJqIQ4MAQsgA0HYAmoiByADQegBaiIJIDIgKV4iCBshCiAJIAcgCBshDiADQZACaiEHIAhBAXMNACAsICleQQFzDQAgA0HYAmohByADQZACaiEKIANB6AFqIQ4LIAZBAWohCSAOKgIAIiwgCioCACIqkyEp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aiALQQEQxQUgAygC0AEhCwsgAygCyAEgC0ECdGogBjYCACADIAtBAWo2AtABDAQLIAMoAogCIgsgAygChAJGBEAgDiALQQEQxQUgAygCiAIhCwsgAygCgAIgC0ECdGogBjYCACADIAtBAWo2AogCDAMLIAMoAqwCIApGBEAgA0GoAmogCkEBEMUFIAMoArACIQogAygCqAIhCQsgCkECdCAJaiAGNgIAIAMgCkEBaiIKNgKwAgwCCyAMIAhBtLTCABDPCAALIAwgCEG0tMIAEM8IAAsgB0EIaiEHIAggBkEBaiIGRw0ACwwFC0GossIAQSNBzLLCABDbCQALIAUgCEGUtMIAEM8IAAsgBSAIQfyywgAQzwgAC0HIt8EAQStB7LLCABDbCQALQci3wQBBK0HcssIAENsJAAsgA0HYAWpBABC4BSADKALYASIQIAMoAuABIgVBKGxqIgYgAykD6AE3AgAgBkEIaiADQegBaiIJQQhqKQMANwIAIAZBEGogCUEQaikDADcCACAGQRhqIAlBGGopAwA3AgAgBkEgaiAJQSBqKQMANwIAIAMgBUEBaiIFNgLgASADQdgCaiIJQSBqIgcgA0GQAmoiCkEgaikDADcDACAJQRhqIgsgCkEYaikDADcDACAJQRBqIgYgCkEQaikDADcDACAJQQhqIgkgCkEIaikDADcDACADIAMpA5ACNwPYAiADKALcASAFRgRAIANB2AFqIAUQuAUgAygC2AEhECADKALgASEFCyAFQShsIBBqIgogAykD2AI3AgAgCkEgaiAHKQMANwIAIApBGGogCykDADcCACAKQRBqIAYpAwA3AgAgCkEIaiAJKQMANwIAIAMgBUEBaiIMNgLgAQJAAkAgDCAFSQRAIANCADcC7AEgAyAaNgLoAQwBCyADKALQASEJIAMoAsgBIRVBACEOA0ACQAJAAkACQAJAAkACQAJAAkACQCAMIA5LBEAgDkEobCIRIBBqIgotACRFDQogCkEgaigCACIGRQ0KIApBJGogCigCGCEFIAZBAnQhDSAKKgIAISwgCkEEaioCACErQ///f/8hKUEAIQoDQCAFKAIAIhQgCE8NAiAsIBRBA3QgBGoiBioCAJQgKyAGQQRqKgIAlJIiKiApXiEGICogKSAGGyEpQQEgCiAGGyEKIBQgCyAGGyELIAVBBGohBSAN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QQN0RQ0AIAAQ2gELAkAgAygCTCIBRQ0AIAMoAkgiAEUNACABQQJ0RQ0AIAAQ2gELIAMoAjwiAUUNACADKAI4IgBFDQAgAUEMbEUNACAAENoBCyADQaADaiQADwsgBiACQZjJwgAQzwgACyAIIAJBmMnCABDPCAALEJYMAAtBGEEEQdCewwAoAgAiAEG/BiAAGxEAAAALQdi+wgBBOUGUv8IAENsJAAsgByAIQbS0wgAQzwgAC4p8BDp/BH4SfQJ8IwBB0AVrIhEkACAALQDIAwRAIABCADcDMCAAQgA3AxggAEIANwPgASAAQgA3A6gBIABB2AFqQQA2AgAgAEGQAWpCADcDACAAQfgAakIANwMAIABB4ABqQgA3AwAgAEHIAGpCADcDACAAQcADakEANgIAIABBwAJqQgA3AwAgAEGoAmpCADcDACAAQZACakIANwMAIABB+AFqQgA3AwAgAEHAAWpCADcDACAAQagDakIANwMAIABBkANqQgA3AwAgAEH4AmpCADcDACAAQdgCakIANwMAIABB4AJqQgA3AwAgAEIANwMAIABBEGoQigc5AwAgAEIBNwMICyAGIAcgCSgCACAJQQhqIiwoAgAQqgIgAyAGIAcgCCgCACAIKAIIIAkQqAEgACACQSRqKgIAIAMgBCAFIAYgByAJKAIAICwoAgAgCigCACAKKAIIIA0gDiAPIBBBARC3BCAsKAIAIRIgLEEANgIAIBIEQCAJKAIAIgggEkEDdGohFSAHKAIIIRQgBygCACEXA0ACQCAUIAgoAgAiEk0NACASQaABbCAXaiISKAIAQQFHDQAgEigCBCAIQQRqKAIARw0AIBJBKGpBADYCAAsgFSAIQQhqIghHDQALCyAKQQA2AgggAioCACFSIBFBEGogAkHEABCeChogAEHcA2ohPyAAQdADaiFAIAtBKGohMyAFQQhqIS0gA0EwaiFDIANBPGohNCARKAJQIjhBASA4GyErQZjAwAAoAgAhHiARQbwDaiE1IANBIGohJyADQRhqITkgAEHYA2ohOiAAQeQDaiE7IABBiARqITEgAEGEBGohRCAAQYAEaiFFAkACQAJAAkACQAJAAkACQAJAAkACQAJAA0ACQCA4RUVBACArQQFHG0UEQCARIFI4AhBBACErIFIhUEMAAAAAIVIMAQsCfwJAIANBCGoiGCgC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AiAiDCAIKAIkKAIMEQQAISYgCwRAIAxBACAmQvu0o92VhrKQvH9RGyIMDQMLIAlBACAFIAYoApwBEQcAGw0DIApBACADIAQoApwBEQcAGw0EIAhBGGogAyANEQAAIAgoAhwhCSAIKAIYIRQgCEEQaiAFIA4RAAAgFARAIAgoAhAiHQ0GCyAIQQhqIAMgBCgCpAERAAAgCCgCCCIJRQ0GIAhB0ABqIgMgASACIAkgCCgCDCAFIAYgBxCZASAAQTBqIANBMGopAwA3AgAgAEEoaiADQShqKQMANwIAIABBIGogA0EgaikDADcCACAAQRhqIANBGGopAwA3AgAgAEEQaiADQRBqKQMANwIAIABBCGogA0EIaikDADcCACAAIAgpA1A3AgAMIQsCf0EAIAIqAhAiKiAqlCACQRRqKgIAIjMgM5SSIAJBGGoqAgAiLSAtlJJDAAAAAJIiLyAJKgIAIikgCioCACIrkiI1IAeSIgcgB5RdQQFzDQAaQwAAgD8hLEMAAAAAIQcgL0MAAAAAXARAIC0gLxCrASIolSEHICogKJUhLCAzICiVIScLICsgByACKgIMIjIgLCACQQRqKgIAIiiUICcgAioCACItlJMiKiAqkiI0lCAoICcgAkEIaioCACIulCAHICiUkyIqICqSIjaUIC0gByAtlCAsIC6UkyIqICqSIjiUk5KSjCIqlCExICsgJyAyIDiUIC0gNJQgLiA2lJOSkowiM5QhMCArICwgMiA2lCAuIDiUICggNJSTkpKMIi2UISsgKSAHlCEuICkgJ5QhKCApICyUITIgLxCrASA1kyEpQQELIQEgACAyOAIEIAAgATYCACAAQTRqICk4AgAgAEEwaiAqOAIAIABBLGogMzgCACAAQShqIC04AgAgAEEkaiAHOAIAIABBIGogJzgCACAAQRxqICw4AgAgAEEYaiAxOAIAIABBFGogMDgCACAAQRBqICs4AgAgAEEMaiAuOAIAIABBCGogKDgCAAwgCyAIQdAAaiIBIAIgCyANIAgoAjQgBxDiAiAAQTBqIAFBMGopAwA3AgAgAEEoaiABQShqKQMANwIAIABBIGogAUEgaikDADcCACAAQRhqIAFBGGopAwA3AgAgAEEQaiABQRBqKQMANwIAIABBCGogAUEIaikDADcCACAAIAgpA1A3AgAMHwsgCEHQAGog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QRhqIh4gCykDADcDACAIQRBqIh8gDSkDADcDACAIQQhqIiAgBykDADcDACAEIAQpA5gENwPIAiAELQDYBCEhIAQoAsgBIQggBCgCwAEhHCAEQQM2AqADIARCgICAgCA3ApgDIARBAzYC4AMgBEKAgICAEDcC2AMgBiAcIAggBSADEO0CIAVBOGogCSkDADcDACAFQTBqIAwpAwA3AwAgBUEoaiAOKQMANwMAIAVBIGogCikDADcDACAFQRhqIAspAwA3AwAgBUEQaiANKQMANwMAIAVBCGogBykDADcDACAEIAQpA5gENwOYAyAELQDYBCEcIAQoAsgBIQUgBCgCwAEhCCAEQQE2ApADIARCgICAgDA3AogDIARBADYC4AMgBEKCgICAEDcC2AMgBiAIIAUgBEGIA2ogAxDtAiADQThqIAkpAwA3AwAgA0EwaiAMKQMANwMAIANBKGogDikDADcDACADQSBqIAopAwA3AwAgA0EYaiALKQMANwMAIANBEGogDSkDADcDACADQQhqIAcpAwA3AwAgBCAEKQOYBDcD2AMgBC0A2AQhIiAJIBMpAwA3AwAgDCAUKQMANwMAIA4gFSkDADcDACAKIBYpAwA3AwAgCyAXKQMANwMAIA0gDykDADcDACAHIBEpAwA3AwAgBCAEKQOIAjcDmAQgBCgC0AEiBSAEKALUASIDRgRAIARBzAFqIAMQxAUgBCgC0AEhBSAEKALUASEDCyAEKALMASIIIANBBnRqIgYgBCkDmAQ3AgAgBkEoaiAOKQMANwIAIAZBIGogCikDADcCACAGQRhqIAspAwA3AgAgBkEQaiANKQMANwIAIAZBCGogBykDADcCACAGQTBqIAwpAwA3AgAgBkE4aiAJKQMANwIAIAQgA0EBaiIDNgLUASAJIBIpAwA3AwAgDCAZKQMANwMAIA4gGikDADcDACAKIBspAwA3AwAgCyAeKQMANwMAIA0gHykDADcDACAHICApAwA3AwAgBCAEKQPIAjcDmAQgAyAFRgRAIARBzAFqIAUQxAUgBCgC0AEhBSAEKALMASEIIAQoAtQBIQMLIANBBnQgCGoiBiAEKQOYBDcCACAGQShqIARBmARqIgdBKGoiCSkDADcCACAGQSBqIAdBIGoiDCkDADcCACAGQRhqIAdBGGoiDikDADcCACAGQRBqIAdBEGoiCikDADcCACAGQQhqIAdBCGoiCykDADcCACAGQThqIAdBOGoiDSkDADcCACAGQTBqIAdBMGoiBykDADcCACAEIANBAWoiBjYC1AEgDSAEQZgDaiIDQThqKQMANwMAIAcgA0EwaikDADcDACAJIANBKGopAwA3AwAgDCADQSBqKQMANwMAIA4gA0EYaikDADcDACAKIANBEGopAwA3AwAgCyADQQhqKQMANwMAIAQgBCkDmAM3A5gEIAUgBkYEQCAEQcwBaiAFEMQFIAQoAswBIQggBCgC1AEhBiAEKALQASEFCyAGQQZ0IAhqIgMgBCkDmAQ3AgAgA0EoaiAJKQMANwIAIANBIGogDCkDADcCACADQRhqIA4pAwA3AgAgA0EQaiAKKQMANwIAIANBCGogCykDADcCACADQThqIA0pAwA3AgAgA0EwaiAHKQMANwIAIAQgBkEBaiIGNgLUASANIARB2ANqIgNBOGopAwA3AwAgByADQTBqKQMANwMAIAkgA0EoaikDADcDACAMIANBIGopAwA3AwAgDiADQRhqKQMANwMAIAogA0EQaikDADcDACALIANBCGopAwA3AwAgBCAEKQPYAzcDmAQgBSAGRgRAIARBzAFqIAUQxAUgBCgCzAEhCCAEKALUASEGCyAGQQZ0IAhqIgMgBCkDmAQ3AgAgA0EoaiAEQZgEaiIFQShqKQMANwIAIANBIGogBUEgaikDADcCACADQRhqIAVBGGopAwA3AgAgA0EQaiAFQRBqKQMANwIAIANBCGogBUEIaikDADcCACADQThqIAVBOGopAwA3AgAgA0EwaiAFQTBqKQMANwIAIAQgBkEBaiIDNgLUAUH/AXEEQCADRQ0HIAQoAsgBRQ0IIAhBGGoqAgAgBCgCwAEiAyoCAJQgCEEcaioCACADQQRqKgIAlJIgCEEgaioCACADQQhqKgIAlJIiKEMAAKC1XQ0SICiMISggBCgC7AEiBSEGIAQoAugBIAVGBEAgBEHkAWogBRDCBSAEKALsASEGCyAEKALkASIHIAZBA3RqIgMgKDgCBCADQQA2AgAgBCAGQQFqNgLsASAFQQN0IAdqIgMqAgQhKCADKAIAIQZBACEDAkAgBUUNAANAQQBBfyAoIAUiA0F/akEBdiIFQQN0IAdqIghBBGoqAgAiKWAiCRtBAUECIAkbICggKV8b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NwMAIBRBCGogFykDADcDACAEIAQpA5gENwPYAyAELQDYBCEIIBggGikDADcDACAZIBspAwA3AwAgHSAcKQMANwMAIB8gHikDADcDACAVICApAwA3AwAgFiAQKQMANwMAIBcgESkDADcDACAEIAQpA4gCNwOYBCAEKALUASIFIAQoAtABIhBGBEAgBEHMAWogBRDEBSAEKALQASEQIAQoAtQBIQULIAQoAswBIgMgBUEGdGoiESAEKQOYBDcCACARQShqIB0pAwA3AgAgEUEgaiAfKQMANwIAIBFBGGogFSkDADcCACARQRBqIBYpAwA3AgAgEUEIaiAXKQMANwIAIBFBMGogGSkDADcCACARQThqIBgpAwA3AgAgBCAFQQFqIgU2AtQBIBggEikDADcDACAZIA0pAwA3AwAgHSAMKQMANwMAIB8gDikDADcDACAVIAYpAwA3AwAgFiAJKQMANwMAIBcgBykDADcDACAEIAQpA8gCNwOYBCAFIBBGBEAgBEHMAWogEBDEBSAEKALQASEQIAQoAtQBIQUgBCgCzAEhAwsgBUEGdCADaiIGIAQpA5gENwIAIAZBKGogBEGYBGoiB0EoaiIRKQMANwIAIAZBIGogB0EgaiISKQMANwIAIAZBGGogB0EYaiINKQMANwIAIAZBEGogB0EQaiIMKQMANwIAIAZBCGogB0EIaiIOKQMANwIAIAZBOGogB0E4aiIJKQMANwIAIAZBMGogB0EwaiIHKQMANwIAIAQgBUEBaiIGNgLUASAJIARBmANqIgVBOGopAwA3AwAgByAFQTBqKQMANwMAIBEgBUEoaikDADcDACASIAVBIGopAwA3AwAgDSAFQRhqKQMANwMAIAwgBUEQaikDADcDACAOIAVBCGopAwA3AwAgBCAEKQOYAzcDmAQgBiAQRgRAIARBzAFqIBAQxAUgBCgC0AEhECAEKALUASEGIAQoAswBIQMLIAZBBnQgA2oiBSAEKQOYBDcCACAFQShqIBEpAwA3AgAgBUEgaiASKQMANwIAIAVBGGogDSkDADcCACAFQRBqIAwpAwA3AgAgBUEIaiAOKQMANwIAIAVBOGogCSkDADcCACAFQTBqIAcpAwA3AgAgBCAGQQFqIgY2AtQBIAkgBEHYA2oiBUE4aikDADcDACAHIAVBMGopAwA3AwAgESAFQShqKQMA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AyAEQQI2AqADIARCgYCAgDA3ApgDIARBADYC4AMgBEKDgICAIDcC2AMgESADIAUgByASEO0CIARByAJqIgNBOGoiEyAYKQMANwMAIANBMGoiFyAZKQMANwMAIANBKGoiECAdKQMANwMAIANBIGoiDCAfKQMANwMAIANBGGoiCSAUKQMANwMAIANBEGoiCCAVKQMANwMAIANBCGoiBiAWKQMANwMAIAQgBCkDmAQ3A8gCIAQtANgEIQ4gBCgCyAEhBSAEKALAASEDIARBAzYCoAMgBEKAgICAIDcCmAMgBEEDNgLgAyAEQoCAgIAQNwLYAyARIAMgBSAHIBIQ7QIgB0E4aiAYKQMANwMAIAdBMGogGSkDADcDACAHQShqIB0pAwA3AwAgB0EgaiAfKQMANwMAIAdBGGogFCkDADcDACAHQRBqIBUpAwA3AwAgB0EIaiAWKQMANwMAIAQgBCkDmAQ3A5gDIAQtANgEIQ0gBCgCyAEhBSAEKALAASEDIARBATYCkAMgBEKAgICAMDcCiAMgBEEANgLgAyAEQoKAgIAQNwLYAyARIAMgBSAEQYgDaiASEO0CIBJBOGogGCkDADcDACASQTBqIBkpAwA3AwAgEkEoaiAdKQMANwMAIBJBIGogHykDADcDACASQRhqIBQpAwA3AwAgEkEQaiAVKQMANwMAIBJBCGogFikDADcDACAEIAQpA5gENwPYAyAELQDYBCEHIBggGikDADcDACAZIBspAwA3AwAgHSAcKQMANwMAIB8gHikDADcDACAUICApAwA3AwAgFSALKQMANwMAIBYgCikDADcDACAEIAQpA4gCNwOYBCAEKALUASIDIAQoAtABIgVGBEAgBEHMAWogAxDEBSAEKALQASEFIAQoAtQBIQMLIAQoAswBIgsgA0EGdGoiCiAEKQOYBDcCACAKQShqIB0pAwA3AgAgCkEgaiAfKQMANwIAIApBGGogFCkDADcCACAKQRBqIBUpAwA3AgAgCkEIaiAWKQMANwIAIApBMGogGSkDADcCACAKQThqIBgpAwA3AgAgBCADQQFqIgM2AtQBIBggEykDADcDACAZIBcpAwA3AwAgHSAQKQMANwMAIB8gDCkDADcDACAUIAkpAwA3AwAgFSAIKQMANwMAIBYgBikDADcDACAEIAQpA8gCNwOYBCADIAVGBEAgBEHMAWogBRDEBSAEKALQASEFIAQoAswBIQsgBCgC1AEhAwsgA0EGdCALaiIKIAQpA5gENwIAIApBKGogBEGYBGoiBkEoaiITKQMANwIAIApBIGogBkEgaiIXKQMANwIAIApBGGogBkEYaiIQKQMANwIAIApBEGogBkEQaiIMKQMANwIAIApBCGogBkEIaiIJKQMANwIAIApBOGogBkE4aiIIKQMANwIAIApBMGogBkEwaiIGKQMANwIAIAQgA0EBaiIDNgLUASAIIARBmANqIgpBOGopAwA3AwAgBiAKQTBqKQMANwMAIBMgCkEoaikDADcDACAXIApBIGopAwA3AwAgECAKQRhqKQMANwMAIAwgCkEQaikDADcDACAJIApBCGopAwA3AwAgBCAEKQOYAzcDmAQgAyAFRgRAIARBzAFqIAUQxAUgBCgC0AEhBSAEKALMASELIAQoAtQBIQMLIANBBnQgC2oiCiAEKQOYBDcCACAKQShqIBMpAwA3AgAgCkEgaiAXKQMANwIAIApBGGogECkDADcCACAKQRBqIAwpAwA3AgAgCkEIaiAJKQMANwIAIApBOGogCCkDADcCACAKQTBqIAYpAwA3AgAgBCADQQFqIgM2AtQBIAggBEHYA2oiCEE4aikDADcDACAGIAhBMGopAwA3AwAgEyAIQShqKQMANwMAIBcgCEEgaikDADcDACAQIAhBGGopAwA3AwAgDCAIQRBqKQMANwMAIAkgCEEIaikDADcDACAEIAQpA9gDNwOYBCADIAVGBEAgBEHMAWogBRDEBSAEKALMASELIAQoAtQBIQMLIANBBnQgC2oiBiAEKQOYBDcCACAGQShqIARBmARqIgVBKGopAwA3AgAgBkEgaiAFQSBqKQMANwIAIAZBGGogBUEYaikDADcCACAGQRBqIAVBEGopAwA3AgAgBkEIaiAFQQhqKQMANwIAIAZBOGogBUE4aikDADcCACAGQTBqIAVBMGopAwA3AgAgBCADQQFqIgM2AtQBQf8BcQRAIANFDQcgBCgCyAFFDQggC0EYaioCACAEKALAASIDKgIAlCALQRxqKgIAIANBBGoqAgCUkiALQSBqKgIAIANBCGoqAgCUkiIiQwAAoLVdDRIgIowhIiAEKALsASIFIQMgBCgC6AEgBUYEQCAEQeQBaiAFEMIFIAQoAuwBIQMLIAQo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CGogCykDADcDACAEIAQpA5gENwPYAyAELQDYBCEgIAggEikDADcDACAJIBMpAwA3AwAgDCAUKQMANwMAIA0gFSkDADcDACAKIBYpAwA3AwAgDiAPKQMANwMAIAsgECkDADcDACAEIAQpA4gCNwOYBCAEKALUASIDIAQoAtABIgVGBEAgBEHMAWogAxDEBSAEKALQASEFIAQoAtQBIQMLIAQoAswBIgcgA0EGdGoiBiAEKQOYBDcCACAGQShqIAwpAwA3AgAgBkEgaiANKQMANwIAIAZBGGogCikDADcCACAGQRBqIA4pAwA3AgAgBkEIaiALKQMANwIAIAZBMGogCSkDADcCACAGQThqIAgpAwA3AgAgBCADQQFqIgM2AtQBIAggESkDADcDACAJIBgpAwA3AwAgDCAZKQMANwMAIA0gGikDADcDACAKIBwpAwA3AwAgDiAdKQMANwMAIAsgHikDADcDACAEIAQpA8gCNwOYBCADIAVGBEAgBEHMAWogBRDEBSAEKALQASEFIAQoAswBIQcgBCgC1AEhAwsgA0EGdCAHaiIGIAQpA5gENwIAIAZBKGogBEGYBGoiCEEoaiIJKQMANwIAIAZBIGogCEEgaiIMKQMANwIAIAZBGGogCEEYaiINKQMANwIAIAZBEGogCEEQaiIKKQMANwIAIAZBCGogCEEIaiIOKQMANwIAIAZBOGogCEE4aiILKQMANwIAIAZBMGogCEEwaiIIKQMANwIAIAQgA0EBaiIDNgLUASALIARBmANqIgZBOGopAwA3AwAgCCAGQTBqKQMANwMAIAkgBkEoaikDADcDACAMIAZBIGopAwA3AwAgDSAGQRhqKQMANwMAIAogBkEQaikDADcDACAOIAZBCGopAwA3AwAgBCAEKQOYAzcDmAQgAyAFRgRAIARBzAFqIAUQxAUgBCgC0AEhBSAEKALMASEHIAQoAtQBIQMLIANBBnQgB2oiBiAEKQOYBDcCACAGQShqIAkpAwA3AgAgBkEgaiAMKQMANwIAIAZBGGogDSkDADcCACAGQRBqIAopAwA3AgAgBkEIaiAOKQMANwIAIAZBOGogCykDADcCACAGQTBqIAgpAwA3AgAgBCADQQFqIgM2AtQBIAsgBEHYA2oiBkE4aikDADcDACAIIAZBMGopAwA3AwAgCSAGQShqKQMANwMAIAwg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IAdNDQIgBCgCzAEgB0EGdGpBFGogA0F/ajYCACAEKALUASIDRQ0DIAQoAswBIANBBnRqQVBqIAc2AgAgBEEANgLgASAOQZDOAEYNASAEQYgDaiASEJkDIA5BAWohDiAEKAKIA0EBRg0ACwwFCyAAQQE6AAwgACACKQIANwIAIABBCGogAkEIaigCADYCACAEQcABahDYBgwJCyAHIANBrN/BABDPCAALQci3wQBBK0G838EAENsJAAtByLfBAEErQfzdwQAQ2wkAC0EBIANBvNzBABDPCAALIAQoAtQBIgEgDE0NASAEQdgDaiIBIAQoAswBIAxBBnRqIAQoAsABIAQoAsgBEJAEIARBmARqIgJBCGoiAyABQQhqKAIANgIAIAJBFGogAUEUaigCADYCACAEIAQpAuQDNwKkBCAEQfABaiIBQQhqIAMpAwA3AwAgAUEQaiACQRBqKQMANwMAIAQgBCkD2AM3A/ABCyAAIAQpA/ABNwIAIABBCGogBEH4AWooAgA2AgAgAEEBOgAMIARBwAFqENgGDAMLIAwgAUGM3sEAEM8IAAtDAAAAACEmQwAAAAAhJUMAAAAAISQLIABBADoADCAAICY4AgggACAlOAIEIAAgJDgCAAsgBEHgBGokAA8LQcDOwQBBKEHw4MEAENsJAAuNVgMefwF+Dn0jAEHgBGsiBCQAIARBGGpBADYCACAEQbgBakEANgIAIARCADcDECAEQgA3A7ABIARCgoCAgDA3AwggBEKAgICAEDcDACAEQcQAakEAQewAEOQKGkMAAIA/ISYgAioCACIkICSUIAIqAgQiJSAllJIgAioCCCIoICiUkkMAAAAAkiIpQwAAgCheQQFzRQRAICggKRCrASImlSEnICUgJpUhIyAkICaVISYLICcgJ5QgIyAjlCAmICaUkpJDAAAAAJIQqwEhKSAEQUBrICg4AgAgBEE8aiAlOAIAIARBOGogJDgCACAEQTRqICcgKZUiKyABKgIMIieUIAEoAghB/////wdxIgkgK7xBgICAgHhxcr6SIis4AgAgBEEwaiAnICMgKZUiI5QgASgCBEH/////B3EiDCAjvEGAgICAeHFyvpIiIzgCACAEQSxqICcgJiAplSImlCABKAIAQf////8HcSINICa8QYCAgIB4cXK+kiImOAIAIARBKGogKyAokzgCACAE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gICAEDcC2AMgByAbIAYgBSADEO0CIAVBOGogCCkDADcDACAFQTBqIAkpAwA3AwAgBUEoaiAMKQMANwMAIAVBIGogDSkDADcDACAFQRhqIAopAwA3AwAgBUEQaiAOKQMANwMAIAVBCGogCykDADcDACAEIAQpA5gENwOYAyAELQDYBCEbIAQoAsgBIQUgBCgCwAEhBiAEQQE2ApADIARCgICAgDA3AogDIARBADYC4AMgBEKCgICAEDcC2AMgByAGIAUgBEGIA2ogAxDtAiADQThqIAgpAwA3AwAgA0EwaiAJKQMANwMAIANBKGogDCkDADcDACADQSBqIA0pAwA3AwAgA0EYaiAKKQMANwMAIANBEGogDikDADcDACADQQhqIAspAwA3AwAgBCAEKQOYBDcD2AMgBC0A2AQhICAIIBEpAwA3AwAgCSASKQMANwMAIAwgFCkDADcDACANIBUpAwA3AwAgCiAWKQMANwMAIA4gDykDADcDACALIBApAwA3AwAgBCAEKQOIAjcDmAQgBCgC1AEiAyAEKALQASIFRgRAIARBzAFqIAMQxAUgBCgC0AEhBSAEKALUASEDCyAEKALMASIHIANBBnRqIgYgBCkDmAQ3AgAgBkEoaiAMKQMANwIAIAZBIGogDSkDADcCACAGQRhqIAopAwA3AgAgBkEQaiAOKQMANwIAIAZBCGogCykDADcCACAGQTBqIAkpAwA3AgAgBkE4aiAIKQMANwIAIAQgA0EBaiIDNgLUASAIIBMpAwA3AwAgCSAYKQMANwMAIAwgGSkDADcDACANIBopAwA3AwAgCiAcKQMANwMAIA4gHSkDADcDACALIB4pAwA3AwAgBCAEKQPIAjcDmAQgAyAFRgRAIARBzAFqIAUQxAUgBCgC0AEhBSAEKALMASEHIAQoAtQBIQMLIANBBnQgB2oiBiAEKQOYBDcCACAGQShqIARBmARqIghBKGoiCSkDADcCACAGQSBqIAhBIGoiDCkDADcCACAGQRhqIAhBGGoiDSkDADcCACAGQRBqIAhBEGoiCikDADcCACAGQQhqIAhBCGoiDikDADcCACAGQThqIAhBOGoiCykDADcCACAGQTBqIAhBMGoiCCkDADcCACAEIANBAWoiAzYC1AEgCyAEQZgDaiIGQThqKQMANwMAIAggBkEwaikDADcDACAJIAZB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CCkDADcDACAGQTBqIhggCSkDADcDACAGQShqIhkgDCkDADcDACAGQSBqIhogDSkDADcDACAGQRhqIhwgCikDADcDACAGQRBqIh0gDikDADcDACAGQQhqIh4gCykDADcDACAEIAQpA5gENwPIAiAELQDYBCEfIAQoAsgBIQYgBCgCwAEhGyAEQQM2AqADIARCgICAgCA3ApgDIARBAzYC4AMgBEKAgICAEDcC2AMgByAbIAYgBSADEO0CIAVBOGogCCkDADcDACAFQTBqIAkpAwA3AwAgBUEoaiAMKQMANwMAIAVBIGogDSkDADcDACAFQRhqIAopAwA3AwAgBUEQaiAOKQMANwMAIAVBCGogCykDADcDACAEIAQpA5gENwOYAyAELQDYBCEbIAQoAsgBIQUgBCgCwAEhBiAEQQE2ApADIARCgICAgDA3AogDIARBADYC4AMgBEKCgICAEDcC2AMgByAGIAUgBEGIA2ogAxDtAiADQThqIAgpAwA3AwAgA0EwaiAJKQMANwMAIANBKGogDCkDADcDACADQSBqIA0pAwA3AwAgA0EYaiAKKQMANwMAIANBEGogDikDADcDACADQQhqIAspAwA3AwAgBCAEKQOYBDcD2AMgBC0A2AQhICAIIBIpAwA3AwAgCSATKQMANwMAIAwgFCkDADcDACANIBUpAwA3AwAgCiAWKQMANwMAIA4gDykDADcDACALIBApAwA3AwAgBCAEKQOIAjcDmAQgBCgC1AEiAyAEKALQASIFRgRAIARBzAFqIAMQxAUgBCgC0AEhBSAEKALUASEDCyAEKALMASIHIANBBnRqIgYgBCkDmAQ3AgAgBkEoaiAMKQMANwIAIAZBIGogDSkDADcCACAGQRhqIAopAwA3AgAgBkEQaiAOKQMANwIAIAZBCGogCykDADcCACAGQTBqIAkpAwA3AgAgBkE4aiAIKQMANwIAIAQgA0EBaiIDNgLUASAIIBEpAwA3AwAgCSAYKQMANwMAIAwgGSkDADcDACANIBopAwA3AwAgCiAcKQMANwMAIA4gHSkDADcDACALIB4pAwA3AwAgBCAEKQPIAjcDmAQgAyAFRgRAIARBzAFqIAUQxAUgBCgC0AEhBSAEKALMASEHIAQoAtQBIQMLIANBBnQgB2oiBiAEKQOYBDcCACAGQShqIARBmARqIghBKGoi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IANBAWoiAzYCyAELIAQoAsABIQcgBEECNgKgAyAEQoCAgIAQNwKYAyAEQQE2AuADIARCgYCAgBA3AtgDIARBmARqIgUgByADIARBmANqIgcgBEHYA2oiAxDtAiAHQThqIgYgBUE4aiIIKQMANwMAIAdBMGoiEiAFQTBqIgkpAwA3AwAgB0EoaiITIAVBKGoiDCkDADcDACAHQSBqIhQgBUEgaiINKQMANwMAIAdBGGoiFSAFQRhqIgopAwA3AwAgB0EQaiIWIAVBEGoiDikDADcDACAHQQhqIgcgBUEIaiILKQMANwMAIAQgBCkDmAQ3A5gDIAQoAsgBIQ8gBCgCwAEhECAEQQE2AtACIARCgICAgCA3AsgCIARBADYC4AMgBEIANwLYAyAFIBAgDyAEQcgCaiADEO0CIANBOGoiDyAIKQMANwMAIANBMGoiECAJKQMANwMAIANBKGoiFyAMKQMANwMAIANBIGoiESANKQMANwMAIANBGGoiGCAKKQMANwMAIANBEGoiGSAOKQMANwMAIANBCGoiGiALKQMANwMAIAQgBCkDmAQ3A9gDIAggBikDADcDACAJIBIpAwA3AwAgDCATKQMANwMAIA0gFCkDADcDACAKIBUpAwA3AwAgDiAWKQMANwMAIAsgBykDADcDACAEIAQpA5gDNwOYBCAEKALQASIFIAQoAtQBIgdGBEAgBEHMAWogBxDEBSAEKALUASEHIAQoAtABIQULIAQoAswBIgMgB0EGdGoiBiAEKQOYBDcCACAGQShqIAwpAwA3AgAgBkEgaiANKQMANwIAIAZBGGogCikDADcCACAGQRBqIA4pAwA3AgAgBkEIaiALKQMANwIAIAZBMGogCSkDADcCACAGQThqIAgpAwA3AgAgBCAHQQFqIgc2AtQBIAggDykDADcDACAJIBApAwA3AwAgDCAXKQMANwMAIA0gESkDADcDACAKIBgpAwA3AwAgDiAZKQMANwMAIAsgGikDADcDACAEIAQpA9gDNwOYBCAFIAdGBEAgBEHMAWogBRDEBSAEKALUASEHIAQoAswBIQMLIAdBBnQgA2oiAyAEKQOYBDcCACADQShqIARBmARqIgVBKGopAwA3AgAgA0EgaiAFQSBqKQMANwIAIANBGGogBUEYaikDADcCACADQRBqIAVBEGopAwA3AgAgA0EIaiAF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QQhqKAIAIgM2AgAgCCACKQIAIhE3A7ABIAAgATYCACAAIAgpA4ABNwIEIABBDGogCEGIAWooAgA2AgAgAEEQaiARNwIAIABBGGogAzYCAAwBCyAAQQM2AgALIAhBsARqJAALzUsDF38Dfhd9IwBBkARrIgYkAAJAAkACQAJAAkAgAC0ATARAIABBLGohGyABKAIAIgcgASgCCEEDdGohCyABKAIMIgogAUEUaigCAEEDdGohECACKAIIIQ0gAigCACERIABBMGohEiAAQThqIRYgAEE0aiEMAkACQAJAAkACQANAAkACfwJAIAdFDQAgByALRg0AIAciCEEIagwBCyAKRQ0BIAogEEYNASAKIghBCGohCkEACyEHIA0gCCgCACIBTQ0KIAFBoAJsIBFqIgEoAgBBAUcNCiABKAIEIAhBBGooAgBHDQogAUGIAmooAgAiCUUNASABQYACaigCACEBIAlBA3QhCQNAIAAoAkQiCCABKAIAIg5NDQMgACgCKCIIIAAoAjwgDkEEdGooAgAiFU0NBCAAKAIgIBVBB3RqIggtAHlFBEAgCEH5AGpBAToAACAWKAIAIghBf2ohDiAIIBIoAgAiCCAAKAIsayAOcWtBAUYEQCAbEJYEIBYoAgBBf2ohDiASKAIAIQgLIBIgCEEBaiAOcTYCACAMKAIAIAhBAnRqIBU2AgALIAFBCGohASAJQXhqIgkNAAsMAQsLIARBAWsOAgMCBAsgDiAIQdDEwAAQzwgACyAVIAhB4MTAABDPCAALIAAoAiwiASAAQTBqIg8oAgAiCEYNAyAAKgJIIS4gAEE4aiEaIABBNGohHANAIAAgGigCAEF/aiABQQFqcSIENgIsIBwoAgAgAUECdGooAgAiASAAKAIoIhJJBH8gACgCICETIAZC////+////79/NwOIAyAGQv////v3//+/fzcDgAMgBkL////79///v/8ANwP4AiAGQv////v///+/fzcD8AIgBkL////79///v383A+gCIAZC////+/f//7//ADcD4AIgBkL////7////v383A9gCIAZC////+/f//79/NwPQAiAGQv////v3//+//wA3A8gCIAZC////+////79/NwPAAiAGQv////v3//+/fzcDuAIgBkL////79///v/8ANwOwAiABQQd0IBNqIhhB4ABqIRUgGEH4AGohFiACKAIIIQ4gAigCACELIAMoAgghECADKAIAIQ0gACgCPCERIAAoAkQhDCAGQbACaiEIQQAhCQJAA0ACQCAJIBVqKAIAIQcCQCAWLQAARQRAIAcgEk8NASAGQbADaiIBIAdBB3QgE2oQsgMgCEEQaiABQRBqKQMANwIAIAhBCGogAUEIaikDADcCACAIIAYpA7ADNwIADAELIAcgDE8NACAQIAdBBHQgEWoiBygCCCIBTQ0BIAFBoAFsIA1qIhQoAgBBAUcNASAUKAIEIAdBDGooAgBHDQEgFEEYaiEZIBRB1ABqIRcCQCAUQSxqKAIAQQFGBEAgDiAUQTBqKAIAIgFNDQ0gAUGgAmwgC2oiASgCAEEBRw0NIAEoAgQgFEE0aigCAEcNDSABQbQBaioCACEqIAFBuAFqKgIAISsgAUG8AWoqAgAhLCABQaABaioCACEiIAFBlAFqKgIAIS8gAUGMAWoqAgAhIyABQdwBaioCACEoIAFBnAFqKgIAITAgAUHUAWoqAgAhKSABQZABaioCACExIAFB2AFqKgIAISQgAUGYAWoqAgAhJSABQagBaioCACEnIAFByAFqKgIAISAgAUGsAWoqAgAhJiABQcwBaioCACEhIAYgAUHQAWoqAgAgAUGIAWoqAgAiLZQgBZQgAUGwAWoqAgCSOAK4AyAGICYgISAtlCAFlJI4ArQDIAYgJyAgIC2UIAWUkjgCsAMgBiAsICIgLyAplCAwICSUkiAiICiUkiIglCAvICMgKZQgMSAklJIgLyAolJIiJpQgMCAxICmUICUgJJSSIDAgKJSSIiGUkpIgBZSSOALEAyAGICsgMCAglCAxICaUICUgIZSSkiAFlJI4AsADIAYgKiAvICCUICMgJpQgMSAhlJKSIAWUkjgCvAMgBkGgAWogBkGwA2oiCiAFIAFBGGogAUHQAGoQ/QEgFEHIAGoqAgAhKiAUQdAAaioCACErIBRBzABqKgIAISwgBiAGKgKsASItIBRBxABqKgIAIieUIAYqAqABIiIgFEE4aioCACIglJMgBioCpAEiIyAUQTxqKgIAIiaUkyAGKgKoASIlIBRBQGsqAgAiIZSTOAK8AyAGICUgJ5QgIiAmlCAtICGUkiAjICCUk5I4ArgDIAYgJSAglCAjICeUIC0gJpQgIiAhlJOSkjgCtAMgBiAjICGUIC0gIJQgIiAnlJKSICUgJpSTOAKwAyAGIAYqArgBICsgLSAiICyUICMgKpSTIiEgIZIiIJQgIiAlICqUICIgK5STIiEgIZIiJpQgIyAjICuUICUgLJSTIiEgIZIiIZSTkpKSOALIAyAGIAYqArQBICwgLSAmlCAlICGUICIgIJSTkpKSOALEAyAGIAYqArABICogLSAhlCAjICCUICUgJpSTkpKSOALAAyAGQZABaiIHIBlBBGooAgAiATYCBCAHIBkoAgAgASgCCEEHakF4cWo2AgAgBkGYA2ogBigCkAEgFyAKIAYoApQBKAKwARECAAwBCyAGQZgBaiIHIBlBBGooAgAiATYCBCAHIBkoAgAgASgCCEEHakF4cWo2AgAgBkGYA2ogBigCmAEgFyAGKAKcASgCgAERAQALIAggBikDmAM3AgAgCEEQaiAGQZgDaiIBQRBqKQMANwIAIAhBCGogAUEIaikDADcCAAsgCEEYaiEIIAlBBGoiCUEQRw0BDAILCwwICyAGQaABaiIHIAZBsAJqQeAAEJ4KGiAGQbADaiIBIAcQmgQgByAYIAEQ8QICQAJAIAYtAKABRQ0AIAYtAKEBRQ0AIAYtAKIBRQ0AIAYtAKMBRQ0AIA8oAgAhCAwBCyAYIAZBsANqQeAAEKAIIQEgBiAuOAKsASAGIC44AqgBIAYgLjgCpAEgBiAuOAKgASABIAZBoAFqEKUCIAEoAnAhByAaKAIAIgFBf2ohCCABIA8oAgAiASAEayAIcWtBAUYEQCAbEJYEIBooAgBBf2ohCCAPKAIAIQELIA8gAUEBaiAIcSIINgIAIBwoAgAgAUECdGogBzYCAAsgGEEAOgB5IBsoAgAFIAQLIgEgCEcNAAsMAwsgACgCLCIBIABBMGoiGCgCACIIRg0CIAAqAkghIyAAQThqIRwgAEE0aiETA0AgACAcKAIAQX9qIAFBAWpxIgQ2AiwgEygCACABQQJ0aigCACIBIAAoAigiFUkEfyAAKAIgIRcgBkL////7////v383A4gDIAZC////+/f//79/NwOAAyAGQv////v3//+//wA3A/gCIAZC////+////79/NwPwAiAGQv////v3//+/fzcD6AIgBkL////79///v/8ANwPgAiAGQv////v///+/fzcD2AIgBkL////79///v383A9ACIAZC////+/f//7//ADcDyAIgBkL////7////v383A8ACIAZC////+/f//79/NwO4AiAGQv////v3//+//wA3A7ACIAFBB3QgF2oiGUHgAGohFiAZQfgAaiEOIAIoAgghCyACKAIAIRAgAygCCCENIAMoAgAhESAAKAI8IQwgACgCRCEKIAZBsAJqIQFBACEIAkADQAJAIAggFmooAgAhCQJAIA4tAABFBEAgCSAVTw0BIAZBsANqIgcgCUEHdCAXahCyAyABQRBqIAdBEGopAwA3AgAgAUEIaiAHQQhqKQMANwIAIAEgBikDsAM3AgAMAQsgCSAKTw0AIA0gCUEEdCAMaiIJKAIIIgdNDQEgB0GgAWwgEWoiDygCAEEBRw0BIA8oAgQgCUEMaigCAEcNASAPQRhqIRogD0HUAGohEgJAIA9BLGooAgBBAUYEQCALIA9BMGooAgAiB00NDCAHQaACbCAQaiIHKAIAQQFHDQwgBygCBCAPQTRqKAIARw0MIAdBxABqKgIAISYgB0HIAGoqAgAhISAHQcwAaioCACEFIA9ByABqKgIAISUgD0HQAGoqAgAhLSAPQcwAaioCACEqIAYgB0FAayoCACIiIA9BxABqKgIAIiuUIAdBNGoqAgAiKCAPQThqKgIAIiyUkyAHQThqKgIAIikgD0E8aioCACInlJMgB0E8aioCACIkIA9BQGsqAgAiIJSTOAK8AyAGICQgK5QgKCAnlCAiICCUkiApICyUk5I4ArgDIAYgJCAslCApICuUICIgJ5QgKCAglJOSkjgCtAMgBiApICCUICIgLJQgKCArlJKSICQgJ5STOAKwAyAGIAUgLSAiICggKpQgKSAllJMiBSAFkiInlCAoICQgJZQgKCAtlJMiBSAFkiIglCApICkgLZQgJCAqlJMiBSAFkiIFlJOSkpI4AsgDIAYgISAqICIgIJQgJCAFlCAoICeUk5KSkjgCxAMgBiAmICUgIiAFlCApICeUICQgIJSTkpKSOALAAyAGQYABaiIJIBpBBGooAgAiBzYCBCAJIBooAgAgBygCCEEHakF4cWo2AgAgBkGgAWogBigCgAEgEiAGQbADaiAGKAKEASgCsAERAgAMAQsgBkGIAWoiCSAaQQRqKAIAIgc2AgQgCSAaKAIAIAcoAghBB2pBeHFqNgIAIAZBoAFqIAYoAogBIBIgBigCjAEoAoABEQEACyABIAYpA6ABNwIAIAFBEGogBkGgAWoiB0EQaikDADcCACABQQhqIAdBCGopAwA3AgALIAFBGGohASAIQQRqIghBEEcNAQwCCwsMBwsgBkGgAWoiByAGQbACakHgABCeChogBkGwA2oiASAHEJoEIAcgGSABEPECAkACQCAGLQCgAUUNACAGLQChAUUNACAGLQCiAUUNACAGLQCjAUUNACAYKAIAIQgMAQsgGSAGQbADakHgABCgCCEBIAYgIzgCrAEgBiAjOAKoASAGICM4AqQBIAYgIzgCoAEgASAGQaABahClAiABKAJwIQcgHCgCACIBQX9qIQggASAYKAIAIgEgBGsgCHFrQQFGBEAgGxCWBCAcKAIAQX9qIQggGCgCACEBCyAYIAFBAWogCHEiCDYCACATKAIAIAFBAnRqIAc2AgALIBlBADoAeSAbKAIABSAECyIBIAhHDQALDAILIAAoAiwiASAAQTBqIgsoAgAiCUYNASAAKgJIISAgAEE0aiINKAIAIQIgAEE4aiIRKAIAIQcDQCAAIAFBAWogB0F/anEiBDYCLAJAIAFBAnQgAmooAgAiASAAKAIoIhdPBEAgBCEBDAELIAAoAiAiEiABQQd0aiITKAJgIQEgACgCPCEVIAAoAkQhFiAGAn0CfQJAAkACQCATLQB4BEAgASAWTw0BIAMoAgggAUEEdCAVaiIIKAIIIgFNDQsgAygCACABQaABbGoiDCgCAEEBRw0LIAwoAgQgCEEMaigCAEcNCyAGQfgAaiIKIAxBGGoiCEEEaigCACIBNgIEIAogCCgCACABKAIIQQdqQXhxajYCACAGQbADaiAGKAJ4IAxB1ABqIAYoAnwoAoABEQEADAMLIAEgF0kNAQtD//9/fyEyQ///f/8hM0P//3//ITRD//9/fyE1Q///f38hNkP//3//DAILIAZBsANqIAFBB3QgEmoQsgMLIAYqAsQDITMgBioCwAMhNCAGKgK4AyEyIAYqArQDITUgBioCsAMhNiAGKgK8AwshJiATQeAAaiIMKAIEIQECfQJAAkAgE0H4AGoiEC0AAARAIAEgFk8NAiADKAIIIAFBBHQgFWoiCCgCCCIBTQ0KIAMoAgAgAUGgAWxqIg4oAgBBAUcNCiAOKAIEIAhBDGooAgBHDQogBkHwAGoiCiAOQRhqIghBBGooAgAiATYCBCAKIAgoAgAgASgCCEEHakF4cWo2AgAgBkGwA2ogBigCcCAOQdQAaiAGKAJ0KAKAAREBAAwBCyABIBdPDQEgBkGwA2ogAUEHdCASahCyAwsgBioCwAMhLiAGKgK8AyEvIAYqArgDITAgBioCtAMhMSAGKgKwAyEoIAYqAsQDDAELQ///f38hMEP//3//IS5D//9//yEvQ///f38hMUP//39/IShD//9//wshISATKAJoIQECfQJAAkAgEC0AAARAIAEgFk8NAiADKAIIIAFBBHQgFWoiCCgCCCIBTQ0KIAMoAgAgAUGgAWxqIg4oAgBBAUcNCiAOKAIEIAhBDGooAgBHDQogBkHoAGoiCiAOQRhqIghBBGooAgAiATYCBCAKIAgoAgAgASgCCEEHakF4cWo2AgAgBkGwA2ogBigCaCAOQdQAaiAGKAJsKAKAAREBAAwBCyABIBdPDQEgBkGwA2ogAUEHdCASahCyAwsgBioCwAMhKSAGKgK8AyEkIAYqArgDISIgBioCtAMhIyAGKgKwAyElIAYqAsQDDAELQ///f38hIkP//3//ISlD//9//yEkQ///f38hI0P//39/ISVD//9//wshBSAMKAIMIQECQAJAIBAtAAAEQCABIBZPDQIgAygCCCABQQR0IBVqIggoAggiAU0NCSADKAIAIAFBoAFsaiIMKAIAQQFHDQkgDCgCBCAIQQxqKAIARw0JIAZB4ABqIgogDEEYaiIIQQRqKAIAIgE2AgQgCiAIKAIAIAEoAghBB2pBeHFqNgIAIAZBsANqIAYoAmAgDEHUAGogBigCZCgCgAERAQAMAQsgASAXTw0BIAZBsANqIAFBB3QgEmoQsgMLIAYqAsADIS0gBioCvAMhKiAGKgK4AyErIAYqArQDISwgBioCsAMhJyAGKgLEAwwBC0P//39/IStD//9//yEtQ///f/8hKkP//39/ISxD//9/fyEnQ///f/8LOAL8ASAGIC04AvgBIAYgKjgC9AEgBiArOALwASAGICw4AuwBIAYgJzgC6AEgBiAFOALkASAGICk4AuABIAYgJDgC3AEgBiAiOALYASAGICM4AtQBIAYgJTgC0AEgBiAhOALMASAGIC44AsgBIAYgLzgCxAEgBiAwOALAASAGIDE4ArwBIAYgKDgCuAEgBiAzOAK0ASAGIDQ4ArABIAYgJjgCrAEgBiAyOAKoASAGIDU4AqQBIAYgNjgCoAEgBkGwA2oiASAGQaABahCaBCAGQbACaiATIAEQ8QICQCAGLQCwAkUNACAGLQCxAkUNACAGLQCyAkUNACAGLQCzAkUNACAEIQEgE0EAOgB5DAELIBMgBkGwA2pB4AAQoAghCiAGICA4ArwCIAYgIDgCuAIgBiAgOAK0AiAGICA4ArACIAogBkGwAmoQpQIgCigCcCEIIAcgB0F/aiIBIAkgBGtxa0EBRgRAIBsQlgQgDSgCACECIAsoAgAhCSARKAIAIgdBf2ohAQsgCUECdCACaiAINgIAIAsgCUEBaiABcSIJNgIAIAAoAiwhASAKQQA6AHkLIAEgCUcNAAsMAQsgACoCSCEtIABBxABqQQA2AgAgAEEoakEANgIAIAYgAEEIajYCjAICQAJAIANBGGooAgAiCkH/////A3EiByAKRw0AAkAgCkECdCIBQQBOBEAgByAKRkECdCEAIAFFBEAgAEUNCEEAIQEMAgsgASAAEMgLIgdFDQcgAUECdkEAIAcbIQEgByEADAELIAZBCGoiAEEANgIEDAcLIAZBADYCmAIgBiABNgKUAiAGIAA2ApACIAqtQhh+Ih1CIIinIgcNAAJAIB2nIgFBAE4EQCAHRUECdCEAIAFFBEAgAEUNCEEAIQEMAgsgAUEYbiABIAAQyAsiB0UNB0EAIAcbIQEgByEADAELIAZBEGoiAEEANgIEDAcLQQAhCSAGQQA2AqgCIAYgADYCoAIgBiABNgKkAiABIApJBEAgBkGgAmpBACAKELEFIAYoAqgCIQkgBigCoAIhAAsgCUEYbCAAaiEAIApBAk8EQCAKQX9qIQEDQCAAQv////v3//+//wA3AgAgAEEQakL////7////v383AgAgAEEIakL////79///v383AgAgAEEYaiEAIAFBf2oiAQ0ACyAJIApqQX9qIQkLIAYhCCAKBEAgAEL////79///v383AgggAEL////79///v/8ANwIAIABBEGpC////+////79/NwIAIAlBAWohCQsgCCAJNgKoAiAIQdgAaiIAQQA6AAQgAEF/NgIAIANBGGooAgAiDEH/////AHEiByAMRw0AAkAgDEEEdCIBQQBOBEAgByAMRkECdCEAIAgtAFwhCiAIKAJYIQkgAUUEQCAA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IgBBADoABCAAQX82AgAgBi0ALCEBIAYoAighACAGKAKMAiEDIAZBsANqIAJB4AAQngoaIANBIGooAgAiCCADQRxqKAIARgRAIANBGGogCBDDBSADKAIgIQgLIAMoAhggCEEHdGogBkGwA2oiAkHgABCeCiIEIAYvAJgDOwB1IARB9wBqIAZBmgNqLQAAOgAAIAQgBigBoAE2AXogBEH+AGogBkGkAWovAQA7AQAgBEH0AGogAToAACAEIAA2AnAgBEHoAGpCfzcDACAEQoGAgIBwNwNgIARBADsBeCADIAhBAWo2AiAgBkEgaiIAQQA6AAQgAEEANgIAIAIgBigCjAIgBigCkAIgBigCmAIgBigCoAIgBigCqAIgBigCICAGLQAkIC0QciAGQZgDaiIAQRBqIAZBxANqKQIAIh43AwAgAEEIaiAGQbwDaikCACIfNwMAIAYgBikCtAMiHTcDmAMgBigCjAIiACAdNwIAIABBCGogHzcCACAAQRBqIB43AgAgBkGgAWoiAEEQaiAeNwMAIABBCGogHzcDACAGQfgBakL////7////v383AwAgBkHwAWpC////+/f//79/NwMAIAZB4AFqQv////v///+/fzcDACAGQdgBakL////79///v383AwAgBkHIAWpC////+////79/NwMAIABBIGpC////+/f//79/NwMAIAYgHTcDoAEgBkL////79///v/8ANwPoASAGQv////v3//+//wA3A9ABIAZC////+/f//7//ADcDuAEgAiAAEJoEIAYoAowCIgBBIGooAgBFDQEgACgCGCAGQbADakHgABCeChoCQCAGKAKkAiIBRQ0AIAYoAqACIgBFDQAgAUEYbEUNACAAENoBCyAGKAKUAiIBRQ0AIAYoApACIgBFDQAgAUECdEUNACAAENoBCyAGQZAEaiQADwtBAEEAQfDFwAAQzwgAC0GAvsAAQStBlOXAABDbCQALIAEgAEHQnsMAKAIAIgBBvwYgABsRAAAACyAAIAc2AgAQlgwAC8RBAxp/Bn4BfSMAQeACayICJAACQCAAIhgCfyABKAIEIgBFBEAgGEEANgIEQQAMAQsgASAAQX9qNgIEAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEoAgAiASgCBCIAQQRPBEAgASAAQXxqIgQ2AgQgASABKAIAIgNBBGoiBjYCAAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAygAACIFDhMBAgMEBQYHCAkKCwwNDg8QERITAAsgAkEBOgCQASACIAWtNwOYASACQZABakHoisAAQeyEwAAQ9AUhAAwoCwJ+IARBBE8EQCABIABBeGo2AgQgASADQQhqNgIAIAM1AARCIIYMAQsQjAutQiCGQgGECyIcQiCIpyEDIBynBEAgAyEADCgLQQAhAAwUCyACQZABaiABELIEQQEhACACKAKQAUEBRwRAIAJBnAFqKAIAIQYgAkGYAWoqAgAhIiACKAKUASEDDBQLIAIoApQBIQAMJgsgAkGQAWogARCyBCACKAKUASEAIAIoApABQQFGDSUgAkGcAWooAgAhBiACQZgBaiIDKgIAISIgAkGQAWogARCyBCACKAKUASEEIAIoApABQQFGBEAgBCEADCYLIAMpAwAhHgJ+IAEoAgQiA0EETwRAIAEgA0F8ajYCBCABIAEoAgAiA0EEajYCACADNQAAQiCGDAELEIwLrUIghkIBhAsiHEIgiKchCSAcpwRAIAkhAAwmCyAeQiCIpyENIAAhA0ECIQAMEgsgAkGQAWogARCyBCACKAKQAUEBRgRAIAIoApQBIQAMJQsgAkGcAWooAgAhBiACQZgBaiIAKgIAISIgAigClAEhAyACQZABaiABELIEIAIoApABQQFGBEAgAigClAEhAAwlCyAAKQMAIh5CIIinIQ0gAigClAEhBEEDIQAMEQsgAkGQAWogARCyBCACKAKQAUEBRgRAIAIoApQBIQAMJAsgAkGcAWooAgAhBiACQZgBaiIAKgIAISIgAigClAEhAyACQZABaiABELIEIAIoApABQQFGBEAgAigClAEhAAwkCyAAKQMAIR4gAigClAEhBCACQZABaiABELIEIAIoApABQQFGBEAgAigClAEhAAwkCyAeQiCIpyENIAJBmAFqKQMAIh1CIIinIQ8gAigClAEhCUEEIQAMEAsgAkEDNgLMAiACIAE2AsgCIAJBkAFqIAJByAJqEFggAigCkAFBAUYNESACQawBaigCACIARQRAQQBBwIXAAEHshMAAEN4FIQAMIwsgAkGYAmogAkGkAWopAgA3AwAgAkGQAmogAkGcAWopAgA3AwAgAkGkAmogAkGwAWopAwA3AgAgAkGsAmogAkG4AWopAwA3AgAgAkG0AmogAkHAAWopAwA3AgAgAkG8AmogAkHIAWopAwA3AgAgAkHEAmogAkHQAWooAgA2AgAgAiACKQKUATcDiAIgAiAANgKgAiACQZABaiACQcgCahCcBAJAIAIoApABQQFHBEAgAigClAEiB0UEQEEBQcCFwABB7ITAABDeBSEADCQLIAJBmAFqKQMAIRwgAigCzAIEQCACKALIAiIBKAIEIgBBB00EQBCMCyEADCQLIAEgAEF4aiIGNgIEIAEgASgCACIAQQhqNgIAIAApAAAQpwYiHkIgiKchACAepw0jAkAgAEGAICAAQYAgSRsiA0UEQEEEIQUMAQsgA0EMbCIEQQQQyAsiBUUNFgtBACEEIAJBADYCmAEgAiADNgKUASACIAU2ApABIAAEQANAAkACQCAGQQRJDQAgASAGQXxqIgY2AgQgASABKAIAIgNBBGo2AgAgBkEESQ0AIAMoAAAhCCABIAZBfGoiBjYCBCABIANBCGo2AgAgBkEDSw0BCxCMCyEAIAIoApQBIgFFDSYgAigCkAEiA0UNJiABQQxsRQ0mIAMQ2gEMJgsgAEF/aiEAIAM1AAQhHiABIAZBfGoiBjYCBCABIANBDGo2AgAgAzUACEIghiAehCEeIAIoApQBIARGBEAgAkGQAWogBEEBEK0FIAIoApABIQUgAigCmAEhBAsgBEEMbCAFaiIDIB43AgQgAyAINgIAIAIgBEEBaiIENgKYASAADQALIAIoApABIQULIAUNAgtBAkHAhcAAQeyEwAAQ3gUhAAwiCyACKAKUASEADCILIAIpApQBIh9CIIinIRIgHEIgiKchDCACKQKsAiIgQiCIpyEIIAIpAqQCIh1CIIinIQ8gAkG4AmopAwAiIUIgiKchCyACQZgCaikDACIeQiCIpyENIAJBxAJqKAIAIQogAkHAAmooAgAhEyACQbQCaigCACEUIAIoAqACIQkgAigClAIhBCACKAKQAiEGIAIqAowCISIgAigCiAIhAyAfpyEWIBynIRUgIKchDiAhpyEQQQUhAAwPCyACQQM2AswCIAIgATYCyAIgAkGQAWogAkHIAmoQWCACKAKQAUEBRg0SIAJBrAFqKAIAIgBFBEBBAEHEhsAAQeyEwAAQ3gUhAAwiCyACQZgCaiACQaQBaikCADcDACACQZACaiACQZwBaikCADcDACACQaQCaiACQbABaikDADcCACACQawCaiACQbgBaikDADcCACACQbQCaiACQcABaikDADcCACACQbwCaiACQcgBaikDADcCACACQcQCaiACQdABaigCADYCACACIAIpApQBNwOIAiACIAA2AqACIAJBkAFqIAJByAJqEJwEAkAgAigCkAFBAUcEQCACKAKUASIHRQRAQQFBxIbAAEHshMAAEN4FIQAMIQsgAkGYAWopAwAhHCACKALMAgRAIAIoAsgCIgEoAgQiAEEHTQRAEIwLIQAMIQsgASAAQXhqIgY2AgQgASABKAIAIgBBCGo2AgAgACkAABCnBiIeQiCIpyEAIB6nDSACQCAAQYAgIABBgCBJGyIERQRAQQQhBQwBCyAEQQN0IgNBBBDICyIFRQ0XC0EAIQMgAkEANgKYASACIAQ2ApQBIAIgBTYCkAEgAARAA0ACQCAGQQRPBEAgASAGQXxqIgY2AgQgASABKAIAIgRBBGo2AgAgBkEDSw0BCxCMCyEAIAIoApQBIgFFDSMgAigCkAEiA0UNIyABQQN0RQ0jIAMQ2gEMIwsgAEF/aiEAIAQ1AAAhHiABIAZBfGoiBjYCBCABIARBCGo2AgAgBDUABEIghiAehCEeIAIoApQBIANGBEAgAkGQAWogA0EBEMEFIAIoApABIQUgAigCmAEhAwsgA0EDdCAFaiAeNwIAIAIgA0EBaiIDNgKYASAADQALIAIoApABIQULIAUNAgtBAkHEhsAAQeyEwAAQ3gUhAAwfCyACKAKUASEADB8LIAIpApQBIh9CIIinIRIgHEIgiKchDCACKQKsAiIgQiCIpyEIIAIpAqQCIh1CIIinIQ8gAkG4AmopAwAiIUIgiKchCyACQZgCaikDACIeQiCIpyENIAJBxAJqKAIAIQogAkHAAmooAgAhEyACQbQCaigCACEUIAIoAqACIQkgAigClAIhBCACKAKQAiEGIAIqAowCISIgAigCiAIhAyAfpyEWIBynIRUgIKchDiAhpyEQQQYhAAwOCyACQZABaiABELIEIAIoApQBIQMgAigCkAFBAUcEQCACQZwBaigCACEGIAJBmAFqKgIAISJBByEADA4LIAMhAAwgCyAEQQdNBEAQjAshAAwgCyABIABBdGoiBTYCBCABIANBDGo2AgAgAykABBCnBiIcQiCIpyEEIBynBEAgBCEADCALAkAgBEGAICAEQYAgSRsiBkUEQEEEIQMMAQsgBkECdCIAQQQQyAsiA0UNEwsgAkEANgKYASACIAY2ApQBIAIgAzYCkAEgBARAIAVBBEkNFEEAIQYDQAJ+IAVBBE8EQCABIAVBfGoiBTYCBCABIAEoAgAiAEEEajYCACAANQAAQiCGDAELEIwLrUIghkIBhAsiHEIgiKchACAcpwRAIAIoApQBIQYgAigCkAEhAwwdCyAEQX9qIQQgAigClAEgBkYEQCACQZABaiAGQQEQxQUgAigCmAEhBiACKAKQASEDCyAGQQJ0IANqIAA2AgAgAiAGQQFqIgY2ApgBIAQNAAsgAigCkAEhAwsgA0UEQEEAIAJByAJqQdyFwAAQ3gUhAAwgCyACKQKUASEcAn4gBUEITwRAIAEgBUF4aiIFNgIEIAEgASgCACIAQQhqNgIAAn8gACkAACIdQoCAgIAQWgRAIAJBAToAkAEgAiAdNwOYAUIBIR4gAkGQAWogAkHIAmpBzILAABD0BQwBCyAdpwutQiCGIB6EDAELEIwLrUIghkIBhAsiHkIgiKchBAJAAkAgHqcEQCAEIQAMAQsCfiAFQQhPBEAgASAFQXhqNgIEIAEgASgCACIAQQhqNgIAAn8gACkAACIdQoCAgIAQWgRAIAJBAToAkAEgAiAdNwOYAUIBIR4gAkGQAWogAkHIAmpBzILAABD0BQwBC0IAIR4gHacLrUIghiAehAwBCxCMC61CIIZCAYQLIh1CIIgiHqchACAdp0UNAQsgHKciAUUNICABQQJ0RQ0gIAMQ2gEMIAsgHKchCSAcQiCIpyIGIAAgBGwiAEcEQCACQaQBakECNgIAIAJBlAJqQQI2AgAgAiAANgLYAiACQgI3ApQBIAJBzKjAADYCkAEgAkECNgKMAiACIAY2AtwCIAIgAkGIAmoiADYCoAEgAiACQdwCajYCkAIgAiACQdgCajYCiAIgAkHIAmoiASACQZABahDQBCAAIAEQzAggAkGbAWogAEEIaigCADYAACACIAIpA4gCNwCTAUEQQQQQyAsiAEUNIiAAQQg6AAAgACACKQCQATcAASAAQQhqIAJBlwFqKQAANwAAAkAgAigCyAIiAUUNACACKALMAkUNACABENoBCyAJRQ0gIAlBAnRFDSAgAxDaAQwgCyACQZABaiABELIEIAIoApABQQFGBEAgAigClAEhAAwaCyACQZgBaiIFKQMAIRwgAigClAEhDSACQZABaiABELIEIAIoApQBIQAgAigCkAFBAUYNGSAFKQMAISAgAkGQAWogARCyBCACKAKUASEUIAIoApABQQFGBEAgFCEADBoLIAJBmAFqKQMAISECfiABKAIEIgVBCE8EQCABIAVBeGoiBTYCBCABIAEoAgAiCEEIajYCAAJ+IAgpAAAiHUKAgICAEFoEQCACQQE6AJABIAIgHTcDmAEgAkGQAWogAkHIAmpBzILAABD0BSEHQgEMAQsgHachB0IACyAHrUIghoQMAQsQjAutQiCGQgGECyIdQiCIpyETIB2nBEAgEyEADBoLIAVBB00EQBCMCyEADBoLIAEgBUF4aiIINgIEIAEgASgCACIFQQhqNgIAIAUpAAAQpwYiHUIgiKchBSAdpwRAIAUhAAwaCwJAIAVBgCAgBUGAIEkbIgdFBEBBASEKQQAhBwwBCyAHQQEQyAsiCkUNFQsgAkEANgKYASACIAo2ApABIAIgBzYClAEgBQRAIAhFDRZBACEHIAghCwNAAn8gC0UEQBCMC61CIIZCAYQhHUEADAELIAEgC0F/aiIINgIEIAEgASgCACILQQFqNgIAIAsxAABCCIYhHSAICyELIB1CAYNQRQRAIAIoApQBIQcMGwsgBUF/aiEFIB1CCIinIQwgAigClAEgB0YEQCACQZABaiAHEKAGIAIoApABIQogAigCmAEhBwsgByAKaiAMOgAAIAIgB0EBaiIHNgKYASAFDQALIAIoApABIQoLIApFBEBBACACQcgCakHshcAAEN4FIQAMGgsgAikClAEhHQJ+IAhBCE8EQCABIAhBeGoiCDYCBCABIAEoAgAiBUEIajYCAAJ+IAUpAAAiH0KAgICAEFoEQCACQQE6AJABIAIgHzcDmAEgAkGQAWogAkHIAmpBzILAABD0BSEFQgEMAQsgH6chBUIACyAFrUIghoQMAQsQjAutQiCGQgGECyIfQiCIpyEMAkAgH6cEfyAMBQJ+IAhBCE8EQCABIAhBeGo2AgQgASABKAIAIgFBCGo2AgACfiABKQAAIh9CgICAgBBaBEAgAkEBOgCQASACIB83A5gBIAJBkAFqIAJByAJqQcyCwAAQ9AUhAUIBDAELIB+nIQFCAAsgAa1CIIaEDAELEIwLrUIghkIBhAsiH0IgiKchBSAfp0UNASAFCyEAIB2nRQ0aIAoQ2gEMGgsgHachByAFIAxsIgEgHUIgiKciFUcEQCACQaQBakECNgIAIAJBlAJqQQI2AgAgAiABNgLYAiACQgI3ApQBIAJBzKjAADYCkAEgAkECNgKMAiACIBU2AtwCIAIgAkGIAmoiADYCoAEgAiACQdwCajYCkAIgAiACQdgCajYCiAIgAkHIAmoiASACQZABahDQBCAAIAEQzAggAkGbAWogAEEIaigCADYAACACIAIpA4gCNwCTAUEQQQQQyAsiAEUNIiAAQQg6AAAgACACKQCQATcAASAAQQhqIAJBlwFqKQAANwAAAkAgAigCyAIiAUUNACACKALMAkUNACABENoBCyAHRQ0aIAoQ2gEMGgsgHEIgiCEdICFCIIinIQsgIEIgiKchCCAhpyEQICCnIQ4gCb4hIiAcpyEJIAAhD0EIIQAMDAsgAkGQAWogARCtAUEBIREgAigCkAFBAUYNCSACQfQBaigCACEBIAJB8AFqKAIAIRkgAkHsAWooAgAhFyACQeABaigCACEFIAJB1AFqKAIAIQcgAkHQAWooAgAhCiACQcwBaigCACETIAJBwAFqKAIAIRQgAkGsAWooAgAhCSACQaABaigCACEEIAJBnAFqKAIAIQYgAkGYAWoqAgAhIiACQaQBaikCACEeIAJBsAFqKQMAIR0gAkG4AWopAwAhHCACQcQBaikCACEfIAJB2AFqKQMAISAgAkHkAWopAgAhISACKAKUASEDIAJBiAFqIAJBgAJqKAIANgIAIAIgAkH4AWopAwA3A4ABICFCIIinIRIgIEIgiKchDCAfQiCIpyELIBxCIIinIQggHUIgiKchDyAeQiCIpyENICGnIRYgIKchFSAfpyEQIBynIQ5BACERQQkMCgsgAkGQAWogARB6QQEhESACKAKQAUEBRg0IIAJB5AFqKQIAIhxCIIinIRIgAkHYAWopAwAiH0IgiKchDCACQcQBaikCACIgQiCIpyELIAJBuAFqKQMAIiFCIIinIQggAkGwAWopAwAiHUIgiKchDyACQaQBaikCACIeQiCIpyENIAJB8AFqKAIAIRkgAkHsAWooAgAh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IAYqApABICGVIio4ApABIAcgByoCACAiICqUkzgCACAGICE4AoABICgQqwEhISARIBEqAgAgBioCiAEiIiAilJMiKDgCACAOIA4qAgAgIiAGKgKMAZSTIio4AgAgByAHKgIAICGVOAIAIA0gDSoCACAiIAYqApABlJMiLTgCACATICE4AgAgECAQKgIAICGVIiI4AgAgDyAPKgIAICGVIiE4AgAgESAoICIgIpSTIig4AgAgDiAqICIgIZSTOAIAIA0gLSAiIAcqAgCUkzgCACAoEKsBISEgDSANKgIAICGVOAIAIBEgITgCACAOIA4qAgAgIZUiITgCACAUIBQqAgAgBioCjAEiIiAilJMgDyoCACIoICiUkyAhICGUkyIqOAIAIBIgEioCACAiIAYqApABlJMgKCAHKgIAlJMgISANKgIAlJM4AgAgFCAqEKsBIiE4AgAgEiASKgIAICGVIiE4AgAgFSAVKgIAIAYqApABIiIgIpSTIAcqAgAiIiAilJMgDSoCACIiICKUkyAhICGUkyIhOAIAIBUgIRCrATgCACAGQRhqIgcgA0HkABCeChogAyAHEJ0BIEwgaSA/IF2UIC4gUpSTkiJgIGogQSBflCAvIFuUk5IiaZMiIZQgTyBtIEAgUpQgPyBclJOSImogbiBEIFuUIEEgXpSTkiJtkyIilCBaIGsgLiBclCBAIF2Uk5IiayBsIC8gXpQgRCBflJOSImyTIiiUkpIgASoCGCJGlCFOICwgIZQgMiAilCAzICiUkpIgRpQhRyAwIDogKyA+lCAmIDiUkyIhICGSIi2UICsgKSA4lCArIDCUkyIhICGSIiWUICYgJiAwlCApID6UkyIhICGSIjCUk5KSISEgOCA6IDCUICYgLZQgKSAllJOSkiEiIDsgJyAkIDGUICAgQpSTIiYgJpIiJpQgJCAjIEKUICQgO5STIiggKJIiOJQgICAgIDuUICMgMZSTIiggKJIiO5STkpIhKCBCICcgO5QgICAmlCAjIDiUk5KSISogPiA6ICWUICkgMJQgKyAtlJOSkiE6IDEgJyA4lCAjIDuUICQgJpSTkpIhLSAbKgIAIB0qAgCTIEaUIUggGSoCACAaKgIAkyBGlCFKIBwqAgAgHioCAJMgRpQhSSABKgIcQwAAAABDAACAPyABKgIAIiSVICRDAAAAAFsbIm6U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NwMAICUgJCkDADcDACAnICYpAwA3AwAgCyACKQMANwMAICkgKC0AADoAACAJIAkpA6AENwOgBSAJIBA6ANQFIAlB4ARqIAlBoAVqIAoQnAMgCS0AlAULIQIgCUGgBWoiCkEIaiILIA9BCGopAgA3AwAgCkEQaiIQIA9BEGopAgA3AwAgCkEYaiITIA9BGGopAgA3AwAgCkEgaiIUIA9BIGopAgA3AwAgCkEoaiIXIA9BKGopAgA3AwAgCUGiBGoiGCAZQQJqLQAAOgAAIAkgDykCADcDoAUgCSAZLwAAOwGgBCACQf8BcUEERg0AIAkqAuAEIS8gCCAJLwGgBDsAACAIQUtqIC84AgAgCEFHaiASNgIAIAhBQ2ogETYCACAIQU9qIgogCSkDoAU3AgAgCEF/aiACOgAAIApBCGogCykDADcCACAKQRBqIBApAwA3AgAgCkEYaiATKQMANwIAIApBIGogFCkDADcCACAKQShqIBcpAwA3AgAgCEECaiAYLQAAOgAAIAQgLzgCACADIC8gB106AAALIAVBBGohBSAIQUBrIQggA0EBaiEDIARBBGohBCAsQgF8IixCBFINAAsgCUHgBWoiAkEIaiAJQcAHaiIDQQhqKQMANwMAIAJBEGogA0EQaikDADcDACACQRhqIANBGGopAwA3AwAgAkEgaiADQSBqKQMANwMAIAJBKGogA0EoaikDADcDACACQTBqIANBMGopAwA3AwAgAkE4aiADQThqKAIANgIAIAkgCSkDwAc3A+AFIAkoArwHIQUgCSoCtAchMyAJKgKwByExIAkqAqwHITAgCSoCqAchLyAJQaAFaiICQQhqIAxBCGopAAA3AwAgAkEQaiAMQRBqKQAANwMAIAJBGGogDEEYaikAADcDACACQSBqIAxBIGopAAA3AwAgAkEoaiAMQShqKQAANwMAIAJBMGogDEEwaikAADcDACACQTdqIAxBN2opAAA3AAAgCUHgBGoiAkEIaiAOQQhqKQAANwMAIAJBEGogDkEQaikAADcDACACQRhqIA5BGGopAAA3AwAgAkEgaiAOQSBqKQAANwMAIAJBKGogDkEoaikAADcDACACQTBqIA5BMGopAAA3AwAgAkE3aiAOQTdqKQAANwAAIAkgDCkAADcDoAUgCSAOKQAANwPgBCAJLQD8ByECIAktALwIIQMgCS0A/AghBCAJQaAEaiIIQTdqIA1BN2opAAA3AAAgCEEwaiANQTBqKQAANwMAIAhBKGogDUEoaikAADcDACAIQSBqIA1BIGopAAA3AwAgCEEYaiANQRhqKQAANwMAIAhBEGogDUEQaikAADcDACAIQQhqIA1BCGopAAA3AwAgCSANKQAANwOgBCAJLQC8CSEIIAlBkgRqIBVBAmotAAA6AAAgCSAVLwAAOwGQBAsgCUHAB2oiCkE4aiAJQeAFaiILQThqKAIANgIAIApBMGogC0EwaikDADcDACAKQShqIAtBKGopAwA3AwAgCkEgaiALQSBqKQMANwMAIApBGGogC0EYaikDADcDACAKQRBqIAtBEGopAwA3AwAgCkEIaiALQQhqKQMANwMAIAkgCSkD4AU3A8AHIAkgAjoA/AcgDCAJKQOgBTcAACAMQQhqIAlBoAVqIgJBCGopAwA3AAAgDEEQaiACQRBqKQMANwAAIAxBGGogAkEYaikDADcAACAMQSBqIAJBIGopAwA3AAAgDEEoaiACQShqKQMANwAAIAxBMGogAkEwaikDADcAACAMQTdqIAJBN2opAAA3AAAgCSADOgC8CCAOIAkpA+AENwAAIA5BCGogCUHgBGoiAkEIaikDADcAACAOQRBqIAJBEGopAwA3AAAgDkEYaiACQRhqKQMANwAAIA5BIGogAkEgaikDADcAACAOQShqIAJBKGopAwA3AAAgDkEwaiACQTBqKQMANwAAIA5BN2ogAkE3aikAADcAACAJIAQ6APwIIA1BN2ogCUGgBGoiAkE3aikAADcAACANQTBqIAJBMGopAwA3AAAgDUEoaiACQShqKQMANwAAIA1BIGogAkEgaikDADcAACANQRhqIAJBGGopAwA3AAAgDUEQaiACQRBqKQMANwAAIA1BCGogAkEIaikDADcAACANIAkpA6AENwAAIAkgCDoAvAkgFUECaiAJQZIEai0AADoAACAVIAkvAZAEOwAAIAkgMzgCrAYgCSAxOAKoBiAJIDA4AqQGIAkgLzgCoAYgBUEVdkH4AXEgBUEOdkH8AXEgBUEHdkH+AXEgBUH/AXFycnKtIS4gHCgCACELIAEoAkQhEUEAIQRCACEsA0AgLCItQgF8ISwCQCAuIC2IQgGDUA0AIAktAIgEBEAgBEECdCIFIAlBoAZqaioCACIv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QQQhBEEAIQcCfUMAAAAAIB5FDQAaQwAAAAAgJUIEg1ANABogHigCACEiIAkoAtwHIgRB0AFqKAIAIAlBBDoA1AcgBCgCzAEhBCgCDCEHIAkgCUHcB2o2AvQHIAkgCUGgB2o2AvAHIAQgIiAJQfAHakHg78EAIAcRAgAgCS0A1AciBEEERgRAQQAhB0MAAAAADAELIAlBqAhqIgdBCGogCykCADcDACAHQRBqIAxBEGopAgA3AwAgB0EYaiAMQRhqKQIANwMAIAdBIGogDEEgaikCADcDACAHQShqIAxBKGopAgA3AwAgCUGmCGogDUECai0AADoAACAJIAwpAgA3A6gIIAkgDS8AADsBpAggCSoCoAciQiApXSEHIEILISgCQCAdRQ0AICVCCINQDQAgHSgCACEjIAkoAtwHIgZB0AFqKAIAIAlBBDoA1AcgBigCzAEhBigCDCEKIAkgCUHcB2o2AvQHIAkgCUGgB2o2AvAHIAYgIyAJQfAHakHg78EAIAoRAgAgCS0A1AciBkEERg0AIAlB8AdqIgpBCGogCykCADcDACAKQRBqIAxBEGopAgA3AwAgCkEYaiAMQRhqKQIANwMAIApBIGogDEEgaikCADcDACAKQShqIAxBKGopAgA3AwAgCUHuB2ogDUECai0AADoAACAJIAwpAgA3A/AHIAkgDS8AADsB7AcgCSoCoAciQyApXSEVIEMhKgsgCUGABWoiC0EoaiAJQaAJaiIKQShqKQMANwMAIAtBIGogCkEgaikDADcDACALQRhqIApBGGopAwA3AwAgC0EQaiAKQRBqKQMANwMAIAtBCGogCkEIaikDADcDACAJQcgEaiILQQhqIAlB4AhqIgpBCGopAwA3AwAgC0EQaiAKQRBqKQMANwMAIAtBGGogCkEYaikDADcDACALQSBqIApBIGopAwA3AwAgC0EoaiAKQShqKQMANwMAIAkgCSkDoAk3A4AFIAkgCSkD4Ag3A8gEIAlBkARqIgtBKGogCUGoCGoiCkEoaikDADcDACALQSBqIApBIGopAwA3AwAgC0EYaiAKQRhqKQMANwMAIAtBEGogCkEQaikDADcDACALQQhqIApBCGopAwA3AwAgCUHQA2oiCkEoaiAJQfAHaiILQShqKQMANwMAIApBIGogC0EgaikDADcDACAKQRhqIAtBGGopAwA3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IAogCSkDADcCACAHIAgpAwA3AgAgBCACKQMANwIAIAFBBGohBCABQQxqDAMLIAEpAiAhEyABIAIpAgA3AiAgA0FAayIEQSBqIgUgAUFAayIGKAIANgIAIARBGGoiCyABQThqIgkpAgA3AwAgBEEQaiIKIAFBMGoiCCkCADcDACAEQQhqIgQgAUEoaiIHKQIANwMAIAcgAkEIaiIHKQIANwIAIAggAkEQaiIIKQIANwIAIAkgAkEYaiIJKQIANwIAIAYgAkEgaiIGKAIANgIAIAMgEzcDQCACIAMpA0A3AgAgBiAFKAIANgIAIAkgCykDADcCACAIIAopAwA3AgAgByAEKQMANwIAIAFBCGohAgwRCyABKQIgIRMgASAFKQIANwIgIANBQGsiAkEgaiIEIAFBQGsiBigCADYCACACQRhqIgsgAUE4aiIJKQIANwMAIAJBEGoiCiABQTBqIggpAgA3AwAgAkEIaiICIAFBKGoiBykCADcDACAHIAVBCGoiBykCADcCACAIIAVBEGoiCCkCADcCACAJIAVBGGoiCSkCADcCACAGIAVBIGoiBigCADYCACADIBM3A0AgBSADKQNANwIAIAYgBCgCADYCACAJIAspAwA3AgAgCCAKKQMANwIAIAcgAikDADcCACABQQxqIQIMEAsgASkCICETIAEgAikCADcCICADQUBrIgZBIGoiCyABQUBrIggoAgA2AgAgBkEYaiIJIAFBOGoiBykCADcDACAGQRBqIgogAUEwaiINKQIANwMAIAZBCGoiBiABQShqIg4pAgA3AwAgDiACQQhqIg4pAgA3AgAgDSACQRBqIg0pAgA3AgAgByACQRhqIgcpAgA3AgAgCCACQSBqIggoAgA2AgAgAyATNwNAIAIgAykDQDcCACAIIAsoAgA2AgAgByAJKQMANwIAIA0gCikDADcCACAOIAYpAwA3AgAgASgCCCECIAEgASgCADYCCCABIAI2AgAgCyAEQSBqIgIoAgA2AgAgCSAEQRhqIggpAgA3AwAgCiAEQRBqIgcpAgA3AwAgBiAEQQhqIg0pAgA3AwAgBCkCACETIAQgBSkCADcCACANIAVBCGoiBCkCADcCACAHIAVBEGoiBykCADcCACAIIAVBGGoiCCkCADcCACACIAVBIGoiAigCADYCACADIBM3A0AgBSADKQNANwIAIAIgCygCADYCACAIIAkpAwA3AgAgByAKKQMANwIAIAQgBikDADcCACABQQRqIQQgAUEMagshAiAXIRgMDwsgBUEETw0IIANBQGsiAkEgaiIEIAFBQGsiBigCADYCACACQRhqIgkgAUE4aiIKKQIANwMAIAJBEGoiDCABQTBqIggpAgA3AwAgAkEIaiIHIAFBKGoiDSkCADcDACABQSBqIAVBJGxqIgJBIGoiDigCACEPIAJBGGoiECkCACETIAJBEGoiESkCACEUIAJBCGoiEikCACEVIAEpAiAhFiABIAIpAgA3AiAgDSAVNwIAIAggFDcCACAKIBM3AgAgBiAPNgIAIAMgFjcDQCACIAMpA0A3AgAgEiAHKQMANwIAIBEgDCkDADcCACAQIAkpAwA3AgAgDiAEKAIANgIAIAEoAgAhAiABIAVBAnQgAWoiBCgCADYCACAEIAI2AgAgAUEANgK8ASABQYCAgPwDNgKwAQwMCyAFDgMBAgMLCyADQThqKAIAIQIgASAXOAKwASABQbgBaiACNgIAIAFBtAFqIBg4AgAMCgsgAUEBNgK8ASABIBc4ArABIAFBtAFqIBg4AgAMCQsgASkCICETIAEgAikCADcCICADQUBrIgRBIGoiBSABQUBrIgYoAgA2AgAgBEEYaiIJIAFBOGoiCikCADcDACAEQRBqIgwgAUEwaiIIKQIANwMAIARBCGoiBCABQShqIgcpAgA3AwAgByACQQhqIgcpAgA3AgAgCCACQRBqIggpAgA3AgAgCiACQRhqIgopAgA3AgAgBiACQSBqIgYoAgA2AgAgAyATNwNAIAIgAykDQDcCACAGIAUoAgA2AgAgCiAJKQMANwIAIAggDCkDADcCACAHIAQpAwA3AgAgAUEBNgK8ASABQbQBaiAXOAIAIAEgGDgCsAEgASgCCCECIAEgASgCADYCCCABIAI2AgAMCAsgBCkCACETIAQgAikCADcCACADQUBrIgVBIGoiBiAEQSBqIgkoAgA2AgAgBUEYaiIKIARBGGoiDCkCADcDACAFQRBqIgggBEEQaiIHKQIANwMAIAVBCGoiBSAEQQhqIgQpAgA3AwAgBCACQQhqIgQpAgA3AgAgByACQRBqIgcpAgA3AgAgDCACQRhqIgwpAgA3AgAgCSACQSBqIgkoAgA2AgAgAyATNwNAIAIgAykDQDcCACAJIAYoAgA2AgAgDCAKKQMANwIAIAcgCCkDADcCACAEIAUpAwA3AgAgAUEBNgK8ASABQbQBaiAYOAIAIAEgFzgCsAEgASABKQIEQiCJNwIEDAcLIANBGGoiBEEIaiIGIAFBKGooAgA2AgAgBEEUaiABQcwAaigCADYCACADIAEpAiA3AxggAyABQcQAaiICKQIANwIkIANBADYCECADQgA3AwggA0FAayIFIAQgA0EIahDjAiAGIAVBCGopAwA3AwAgAyADKQNANwMYIAVBFGooAgAhBCADKAJQRQ0DIANB2ABqKgIAIRcgASAENgKwASABQbQBaiAXOAIADAQLIAFBgICA/AM2ArABIAAgASkCIDcCACAAQQhqIAFBKGooAgA2AgAMCwsgBkEEQbi3wQAQzwgACyAFQQRBuLfBABDPCAALAkACQCAEDgIAAQMLIAFBADYCvAEgAUGAgID8AzYCsAEMAQsgASkCICETIAEgAikCADcCICADQUBrIgRBIGoiBSABQUBrIgYoAgA2AgAgBEEYaiILIAFBOGoiCSkCADcDACAEQRBqIgogAUEwaiIMKQIANwMAIARBCGoiBCABQShqIggpAgA3AwAgCCACQQhqIggpAgA3AgAgDCACQRBqIgwpAgA3AgAgCSACQRhqIgkpAgA3AgAgBiACQSBqIgYoAgA2AgAgAyATNwNAIAIgAykDQDcCACAGIAUoAgA2AgAgCSALKQMANwIAIAwgCikDADcCACAIIAQpAwA3AgAgAUEANgK8ASABQYCAgPwDNgKwASABIAEpAgBCIIk3AgALIAAgAykDGDcCACAAQQhqIANBIGooAgA2AgAMBwtBwM7BAEEoQfjjwQAQ2wkACyAAIAMpAwg3AgAgAEEIaiALKAIANgIADAULIAEhBCAZIRggFyEZCyAEKAIAIQUgBCACKAIANgIAIAIgBTYCACAYIRcLIAEgFzgCsAEgAUG0AWogGTgCAEEBCzYCvAELIAAgAykDCDcCACAAQQhqIAwoAgA2AgALIANBgAFqJAALgB4CAX8hfSMAQYABayIEJAAgAUEcaioCACEOIAFBIGoqAgAhDyABQRBqKgIAIQggASoCGCEQIAEqAgwhCiABKgIAIQYgASoCBCEJIAQgAUEUaioCACINIAEqAggiB5MiETgCECAEIAggCZMiEjgC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HGooAgAhAiALIC44AsgCIAsgLTgCxAIgCyAsOALAAiALQbAGaiACIAtBwAJqIgYQuwIgCygCgAQiAigCICEMIAtByAdqIg9BCGoiEiACQQhqKAIANgIAIAsgAikCADcDyAcgBiAMIA8QuwIgCygCgAQiAioCFCEIIAIqAhAhLCACKAIYIQICQCALKgKoBiItIAsqAqwGIi5gRQRAIAtBADYCsAcgC0HIB2ogAiALQcACaiAuIAtBrAZqIAtBsAZqIC0gC0GoBmogLCAIIAtBsAdqEFQgCy0A/AciBkEERg0BIBogHCkCADcCACAZIBEpAgA3AgAgGCAbKQIANwIAIBcgECkCADcCACAaQQhqIBxBCGooAgA2AgAgGUEIaiARQQhqKAIANgIAIBhBCGogG0EIaigCADYCACAXQQhqIBBBCGooAgA2AgAgCyALKgLIBzgC8AYMAQsgC0EANgLIByALQfAGaiACIAtBsAZqIC0gC0GoBmogC0HAAmogLiALQawGaiAsIAggC0HIB2oQVCALLQCkByEGCwJAIAZB/wFxQQRGDQAgCyoC8AYhCAJAAkACQCAOBEAgCyAgNgK8ByALICE2ArgHIAsgIjYCtAcgCyAfNgKwByAIIAsqAoQEXQ0BDAQLIAsoAqQGIgJBBE8NASALQZwEaiACaiAIIAsqAoQEXToAACALQYgEaiACQQJ0aiAIOAIADAMLIAsoAqQGIgJBA0sNASALQbAHaiACQQJ0aigCACICRQ0CIAsgAigCACICNgLEByALKAKABCIGKAIkIAZBKGooAgAoAgwhBiALIAtBxAdqNgLgByALIAtBoARqNgLcByALIAtBhARqNgLYByALIAtBnARqNgLUByALIAtBpAZqNgLQByALIAtBiARqNgLMByALIAtBgARqNgLIByACIAtByAdqQfTvwQAgBhECAAwCCyACQQRBnOnBABDPCAALIAJBBEGs6cEAEM8IAAsgBEEDRwRAIARBAWohBCADQQRqIQMgByoCACEIIAdBBGohBwwBCwsgFCALKQOIBDcCACAUQQhqIgQgHikDADcCACASIAtBoARqIgJBCGoiBikDADcDACARIAJBEGoiBykDADcDACALQcgHaiIDQRhqIg4gAkEYaiIMKQMANwMAIANBIGoiDyACQSBqIhUpAwA3AwAgECACQShqIiMpAwA3AwAgA0EwaiIDIAJBMGoiJCkDADcDACALIAspA6AENwPIByALKAKcBCECIAtBsgdqIiUgE0ECaiImLQAAOgAAIAsgEy8AADsBsAcgCy0A2AQhJyALQcACaiIoIBZBtAEQngoaICQgAykDADcDACAjIBApAwA3AwAgFSAPKQMANwMAIAwgDikDADcDACAHIBEpAwA3AwAgBiASKQMANwMAIAsgCykDyAc3A6AEIAsgJzoA2AQgEyALLwGwBzsAACAmICUtAAA6AAAgFiAoQbQBEJ4KGiALIAQpAgA3A/gGIAsgFCkCADcD8AYgAkEVdkH4AXEgAkEOdkH8AXEgAkEHdkH+AXEgAkH/AXFycnKtISogHSgCACESIA0oAjwhDkEAIQZCACEpA0AgKSIrQgF8ISkCQCAqICuIQgGDUA0AIAstAJgCBEAgBkECdCIEIAtB8AZqaioCACIIIAldQQFzDQEgC0GgBGogBkE8bGoiA0E4ai0AACICQQRGDQEgBCALakGAAmooAgAgDk8NASAKIAMpAAA3AAAgCkEwaiADQTBqKQAANwAAIApBKGogA0EoaikAADcAACAKQSBqIANBIGopAAA3AAAgCkEYaiADQRhqKQAANwAAIApBEGogA0EQaikAADcAACAKQQhqIANBCGopAAA3AAAgC0HOAGogA0E7ai0AADoAACALIAMvADk7AUwgC0HQAGoiAUE3aiALQbAGaiIDQTdqKAAANgAAIAFBMGogA0EwaikAADcDACABQShqIANBKGopAAA3AwAgAUEgaiADQSBqKQAANwMAIAFBGGogA0EYaikAADcDACABQRBqIANBEGopAAA3AwAgAUEIaiADQQhqKQAANwMAIAsgCykAsAY3A1AgAiEBIAghCQwBCyAGQQJ0IgIgC2pBgAJqKAIAIgwgEk8NACALQfAGaiACaioCAIwhCCALKAJIIgMhBCALKAJEIANGBEAgC0FAayADEMIFIAsoAkghBAsgCygCQCIHIARBA3RqIgIgCDgCBCACIAw2AgAgCyAEQQFqNgJIIANBA3QgB2oiAioCBCEIIAIoAgAhDEEAIQICQCADRQ0AA0BBAEF/IAggA0F/akEBdiIEQQN0IAdqIg9BBGoqAgAiLGAiFRtBAUECIBUbIAggLF8bQX9qQf8BcUEBSwRAIAMhAgwCCyADQQN0IAdqIA8pAgA3AgAgBCIDDQALCyACQQN0IAdqIgIgCDgCBCACIAw2AgALIAZBAWohBiApQgRSDQALIAtBkAFqIAtBQGsQmQMgCygCkAFBAUYNAQwCCwsgAiADQbzJwQAQzwgACyALQcACaiICQQhqIAtB0ABqIgNBCGopAwA3AwAgAkEQaiADQRBqKQMANwMAIAJBGGogA0EYaikDADcDACACQSBqIANBIGopAwA3AwAgAkEoaiADQShqKQMANwMAIAJBMGogA0EwaikDADcDACACQTdqIANBN2ooAAA2AAAgC0GiAWogC0HOAGotAAA6AAAgCyALKQNQNwPAAiALIAsvAUw7AaABAkAgCygCRCICRQ0AIAsoAkAiA0UNACACQQN0RQ0AIAMQ2gELIAFB/wFxQQRHDQELIABBBDoANAwBCyAAIAsvAaABOwA1IAtBoARqIgJBN2oiBCALQcACaiIDQTdqKAAANgAAIAJBMGogA0EwaikDADcDACACQShqIANBKGopAwA3AwAgAkEgaiADQSBqKQMANwMAIAJBGGogA0EYaikDADcDACACQRBqIANBEGopAwA3AwAgAkEIaiADQQhqKQMANwMAIABBN2ogC0GiAWotAAA6AAAgCyALKQPAAjcDoAQgACABOgA0IABBMGogBCgAADYAACAAQShqIAtBzwRqKQAANwAAIABBIGogC0HHBGopAAA3AAAgAEEYaiALQb8EaikAADcAACAAQRBqIAtBtwRqKQAANwAAIABBCGogC0GvBGopAAA3AAAgACALKQCnBDcAAAsgC0GACGokAAu0HgIOfwJ+IwBBkAJrIgIkACABQRFqIQYgAS0AECEJAkACQAJAAkACQAJAIAAoAgBBAWsOAgIBAAsgACgCBCEEIAJB4AFqIAFBCGopAgA3AwAgAkHOAGogBkECai0AADoAACACIAEpAgA3A9gBIAIgBi8AADsBTCACQgA3A5gBIAIgBDYC9AEgAkHQAGoiCEFAa0EANgIAIAJBiAFqQgA3AwAgAkIANwNoIAJCADcDUCACQgA3A4ABIAQoAowBIQAgBCgCQCEBIAIgCDYCIAJAIAAgAXENACAEQYwBaiEHIARBQGshCiACQTBqQQRyIQ0gAkHQAGohCANAQQAhAwNAAkACQCAEKAKAASAAQX9qIAFxIg5BGGxqIg8oAgAi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BSgCkAFBAUYNAAsLIAVBqAFqIAVBiAFqKQMANwMAIAUgBSkDgAE3A6ABAkAgBSgCdCICRQ0AIAUoAnAiBEUNACACQQN0RQ0AIAQQ2gELQQQgAEEERg0AGiATIAUpA6ABNwIAIBNBCGogBUGoAWopAwA3AgAgEyABQdQAaigCAEEAIBJBAUYbQQAgAEECRhsgEWo2AhRBAgs2AhAgBUHQBGokAAvPHQILfyp9IwBB4AFrIggkAAJAAn0CQAJAAkACQAJAAkAgA0EFTwRAIAhBADYCaCAIQgA3A2AgA0ECdCEMQwAAgD8gA7OVIRQDQCACIApqKAIAIgsgBU8NAiAIIBQgC0EYbCAEaiILKgIAIAsqAgySQwAAAD+UIhaUICGSIiE4AmAgCCAUIAsqAgggC0EUaioCAJJDAAAAP5QiFZQgHZIiHTgCaCAIIBQgCyoCBCALQRBqKgIAkkMAAAA/lCITlCAekiIeOAJkIBsgFCAWIBaUlJIhGyAXIBQgFSAVlJSSIRcgGCAUIBMgE5SUkiEYIAwgCkEEaiIKRw0ACyAIIAIgAyAEIAUgCEHgAGoiC0ECIBggHiAelJMiFSAbICEgIZSTIhNdIgIgFyAdIB2UkyAVIBMgAhtdGyICQQFqQQNwELAEIAhBDGoiDCgCACEKIAgoAgghAyAIIAgoAgAgCCgCBCAEIAUgCyACQQJqQQNwIgIQsAQgDCgCACEOIAgoAgghDyAIKAIEIRAgCCgCACERIAggAyAKIAQgBSALIAIQsAQgDCgCACESIAgoAgghCyAIKAIEIQwgCCgCACEKIAFBIGoiDSgCACEDIAhCADcDACAIQgA3AwggAyICIAFBHGooAgBGBEAgAUEYaiADEMMFIA0oAgAhAgsgASgCGCACQQd0aiIJQv////v///+/fzcDMCAJQv////v3//+//wA3AyAgCUL////79///v/8ANwMQIAlC////+/f//7//ADcDCCAJQv////v3//+//wA3AwAgCSAIKQMANwNgIAkgBjYCcCAJQdgAakL////7////v383AwAgCUHQAGpC////+////79/NwMAIAlByABqQv////v///+/fzcDACAJQUBrQv////v///+/fzcDACAJQThqQv////v///+/fzcDACAJQShqQv////v3//+//wA3AwAgCUEYakL////79///v/8ANwMAIAlB6ABqIAgpAwg3AwAgCUH0AGogBzoAACAJQQA7AXggCSAIKAGwATYBeiAJQfcAaiAIQZABaiIGQQJqLQAAOgAAIAkgCC8AkAE7AHUgCUH+AGogCEG0AWovAQA7AQAgDSACQQFqNgIAIAhB8ABqIAEgESAQIAQgBSADQQAQXCAGIAEgDyAOIAQgBSADQQEQXCAIQbABaiABIAogDCAEIAUgA0ECEFwgCCABIAsgEiAEIAUgA0EDEFwgDSgCACICIANNDQMgCCgCACEFIAgoArABIQQgCCgCkAEhAiABKAIYIANBB3RqIgYgCCgCcDYCYCAGQewAaiAFNgIAIAZB6ABqIAQ2AgAgBkHkAGogAjYCACABQSBqIgUoAgAiAiADTQ0EIAhBGGoqAgAhJSAIQRRqKgIAISYgCEEQaioCACEnIAhBDGoqAgAhKCAIQQhqKgIAISkgCEGwAWoiAkEYaioCACEqIAJBFGoqAgAhKyACQRBqKgIAISwgAkEMaioCACEtIAJBCGoqAgAhGyAIQZABaiICQRhqKgIAIR8gAkEUaioCACEgIAJBEGoqAgAhIiACQQxqKgIAISMgAkEIaioCACEkIAhB8ABqIgJBGGoqAgAhEyACQRRqKgIAIRcgAkEMaioCACEYIAJBCGoqAgAhHCAIKgIEIRkgCCoCtAEhGiAIKgKUASEUIAgqAnQhFiADQQd0IgQgASgCGGoiBiACQRBqKgIAIhU4AjAgBiAYOAIgIAYgHDgCECAGIBk4AgwgBiAaOAIIIAYgFDgCBCAGIBY4AgAgBkHcAGogJTgCACAGQdgAaiAqOAIAIAZB1ABqIB84AgAgBkHQAGogEzgCACAGQcwAaiAmOAIAIAZByABqICs4AgAgBkHEAGogIDgCACAGQUBrIBc4AgAgBkE8aiAnOAIAIAZBOGogLDgCACAGQTRqICI4AgAgBkEsaiAoOAIAIAZBKGogLTgCACAGQSRqICM4AgAgBkEcaiApOAIAIAZBGGogGzgCACAGQRRqICQ4AgAgBSgCACICIANNDQUgASgCGCAIQgA3A9gBIAhCADcD0AEgBGogCEHQAWoQpQIgACADNgIAIABBGGogEyAfIBMgH2AbIhMgKiATICpgGyITICUgEyAlYBs4AgAgAEEUaiAXICAgFyAgYBsiEyArIBMgK2AbIhMgJiATICZgGzgCACAAQRBqIBUgIiAVICJgGyITICwgEyAsYBsiEyAnIBMgJ2AbOAIAIABBDGogGCAjIBggI18bIhMgLSATIC1fGyITICggEyAoXxs4AgAgAEEIaiAcICQgHCAkXxsiEyAbIBMgG18bIhMgKSATIClfGzgCACAAIBYgFCAWIBRfGyITIBogEyAaXxsiEyAZIBMgGV8bOAIEDAgLIAFBIGoiESgCACEPIAhB2ABqQv////v///+/fzcDACAIQdAAakL////79///v383AwAgCEFAa0L////7////v383AwAgCEE4akL////79///v383AwAgCEEoakL////7////v383AwAgCEEgakL////79///v383AwAgCEEQakL////7////v383AwAgCEL////79///v/8ANwNIIAhC////+/f//7//ADcDMCAIQv////v3//+//wA3AxggCEL////79///v383AwggCEL////79///v/8ANwMAIAhBmAFqIhJCfzcDACAIQn83A5ABIANFBEBD//9/fyEhQ///f/8hF0P//3//IRhD//9//yEbQ///f38hMkP//39/ITND//9//yEcQ///f/8hGUP//3//IR9D//9/fyE0Q///f38hNUP//39/ITZD//9//yEaQ///f/8hFEP//3//ISBD//9/fyE3Q///f38hOEP//39/ITlD//9//yEWQ///f/8hFUP//39/ITpD//9/fyE7Q///f38hPEP//3//IS5D//9//yEvQ///f/8hMEP//39/ITFD//9/fyEdQ///f38hHkP//3//DAcLIANBAnQhEEEAIQND//9//yEwQ///f38hHiAIIQogCEGQAWohDkP//39/IR1D//9/fyExQ///f/8hL0P//3//IS4DQCACKAIAIgkgBU8EQCAJIAVBvMjBABDPCAALIANBBEcEQCAJQRhsIARqIg0qAgAhGSANQRRqKgIAIRogDUEQaiILKgIAIRQgDUEMaioCACEWIA1BCGoiDCoCACEVIA1BBGoqAgAhEyAOIAk2AgAgCiANKQIANwIAIApBEGogCykCADcCACAKQQhqIAwpAgA3AgAgASgCPCIMIAlNDQMgAkEEaiECIB4gGSAeIBlfGyEeIC4gGiAuIBpgGyEuIC8gFCAvIBRgGyEvIDAgFiAwIBZgGyEwIDEg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CEEEaioCACIhICaUkyIkICSSIiqUICAgJSAlkiIllCAhICEgIpQgHyAnlJMiJCAkkiIklJOSkpI4AgAgBUEUaiAIQRRqKgIAICcgIyAllCAfICSUICAgKpSTkpKSOAIAIAQgIyABKgIMIiiUICAgASoCACIplJMgISABKgIEIiKUkyAfIAEqAggiJ5STOALMASAEIB8gKJQgICAilCAjICeUkiAhICmUk5I4AsgBIAQgHyAplCAhICiUICMgIpQgICAnlJOSkjgCxAEgBCAhICeUICMgKZQgICAolJKSIB8gIpSTOALAASAEIAgqAhAgJiAkICOUICEgKpQgHyAllJOSkpI4AtABDAELIARBwAFqIgFBGGogCEEYaigCADYCACABQRBqIAhBEGopAgA3AwAgAUEIaiAIQQhqKQIANwMAIAQgCCkCADcDwAELIA0gBEHAAWogACgCJEGcysAAIAIgAyAAKAIoKgIAIAsgDygCMBEYABoMAQsgACgCICgCACEIAkAgAQRAIAFBCGoqAgAiHyAIQRRqKgIAIAEqAhSTIiaUIAFBBGoqAgAiICAIQRhqKgIAIAEqAhiTIiKUkyElIARBwAFqIgVBGGogIiABKgIMIiMgICAIKgIQIAEqAhCTIieUIAEqAgAiISAmlJMiJCAkkiIqlCAgICUgJZIiJZQgISAhICKUIB8gJ5STIiQgJJIiJJSTkpI4AgAgBUEUaiAmICMgJJQgISAqlCAfICWUk5KSOAIAIAQgHyAIKgIIIiiUICAgCCoCBCIplCAhIAgqAgAiJpQgIyAIKgIMIiKUkpKSOALMASAEICAgJpQgIyAolCAhICmUk5IgHyAilJM4AsgBIAQgIyAplCAhICiUkiAgICKUkyAfICaUkzgCxAEgBCAfICmUICMgJpQgISAilJMgICAolJOSOALAASAEICcgIyAllCAfICSUICAgKpSTkpI4AtABDAELIARBwAFqIgFBGGogCEEYaigCADYCACABQRBqIAhBEGopAgA3AwAgAUEIaiAIQQhqKQIANwMAIAQgCCkCADcDwAELIA0gBEHAAWogAiADIAAoAiRBnMrAACAAKAIoKgIAIAsgDygCMBEYABoLIARB8ANqJAAPCyAMIAVB5N3AABDPCAALIA8gBUHo0MAAEM8IAAv1GQIHfwF+IwBB0ABrIgQkAAJA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ADcDcCADQgA3A1ggA0IANwNAIAMgA0FAazYCPARAA0AgASABQQFqIAFBB09BACABQQpLGxshASAALQA8IABBAToAPA0ACwsgA0GwAWogAEEgahCKAwJAAkAgAygCuAEEQCADIAMpA7ABNwOIASADKAI8QUBrIgEgAygCjAE2AgAgA0GQAWogA0G4AWooAgA2AgAgAEEAOgA8IANB0AFqIgIgA0EYaikDADcDACADIAMpAxA3A8gBAkAgASgCACIABEAgACAJNgIAIABBAToAFSAAIAMpA8gBNwIEIABBDGogAikDADcCAAwBCyAJQQJHDQMLIAMoApABIgEoAgAhACABIABBf2o2AgAgA0ECNgLoASAAQQFHDQEgA0GQAWoQlgkMAQsgAEE4ai0AAEUEQCADQaABaiACNgIAIANBmAFqIANBGGopAwA3AwAgAyAJNgKMASADIAMpAxA3A5ABIANBqAFqIANBOGo2AgAgA0GkAWogA0EgajYCAEG4mMMAKAIAIQAgAyADQTxqNgKIAQJAIABBAUYNABDoByECQbiYwwAoAgAhAUG4mMMAQQE2AgBBvJjDACgCACEAQbyYwwAgAjYCACADIAA2AuwBIAMgATYC6AEgAUUNACAARQ0AIAAgACgCACIAQX9qNgIAIABBAUcNACADQegBakEEchCWCQtBvJjDACgCACEAQbyYwwBBADYCAAJAIABFBEAgAxDoByIANgLoASADQcgBaiADQYgBaiADQegBahDTASAAIAAoAgAiAEF/ajYCACAAQQFHDQEgA0HoAWoQlgkMAQsgAEIANwIQIAMgADYC5AEgA0HoAWogA0GIAWogA0HkAWoQ0wFBvJjDACgCACEAQbyYwwAgAygC5AE2AgAgAyAANgKwAQJAIABFDQAgACAAKAIAIgBBf2o2AgAgAEEBRw0AIANBsAFqEJYJCyADQcgBaiIAQQhqIANB6AFqIgFBCGopAwA3AwAgAEEQaiABQRBqKQMANwMAIAMgAykD6AE3A8gBCyADQbgBaiIAIANByAFqIgFBDGopAgA3AwAgA0HAAWoiAiABQRRqKAIANgIAIAMgAykCzAE3A7ABAkAgAygCyAEiAUEDRwRAIANB6AFqIgdBDGogACkDADcCACAHQRRqIAIoAgA2AgAgAyABNgLoASADIAMpA7ABNwLsAQwBCyAD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kzgCzAEgBCAdICaUIB4gIJQgISAllJIgHyAnlJOSOALIASAEIB0gJ5QgHyAmlCAhICCUIB4gJZSTkpI4AsQBIAQgHyAllCAhICeUIB4gJpSSkiAdICCUkzgCwAEgBCAFKgIQICQgIiAhlCAfICiUIB0gI5STkpKSOALQAQwBCyAEQcABaiIBQRhqIAVBGGooAgA2AgAgAUEQaiAFQRBqKQIANwMAIAFBCGogBUEIaikCADcDACAEIAUpAgA3A8ABCyALIARBwAFqIAAoAiAiASgCACABKAIEIAIgAyAAKAIkKgIAIAggDigCMBEYABoLIARB8ANqJAAPCyAGIAtB5N3AABDPCAALIA4gBkH4zsAAEM8IAAuwGgMcfwJ+Bn0jAEGQBGsiAyQAIAMgAjYCNCADQSxqIAIqAggiITgCACADQShqICE4AgAgA0EkaiAhOAIAIANBHGogAioCBCIiOAIAIANBGGogIjgCACADQRRqICI4AgAgAyABNgIwIANBADoAOCADICE4AiAgAyAiOAIQIAMgAioCACIhOAIMIAMgITgCCCADICE4AgQgAyAhOAIAAkAgAUEgaigCACIPBEAgA0IANwJMIANB0LnBACgCADYCSCADQcgAaiICQQAQwgUgAygCSCADKAJQIgRBA3RqQoCAgIDw////fjcCACADIARBAWo2AlAgA0HwAGogAhCZAwJAIAMoAnBBAUcEQEEEIQgMAQsgAUE8aigCACESIANB0AJqIgJBGGohGiACQQNqIQwgAkHUAGohFCADQYgDaiEVIAJBHGohFiABKAI0IRMgASgCGCEbIANBwANqIgJBDGohFyACQRhqIRhD//9/fyEhQQQhCANAICEgAyoCeIxfQQFzRQ0BAkACQAJAAkACQCAPIAMoAnQiAksEQCADQYABaiACQQd0IBtqQYABEJ4KGiADLQD4ASIHBEAgAygC7AEiAkEMbCATakEAIAIgEkkbIgJBCGpBACACGyEcIAMoAugBIgJBDGwgE2pBACACIBJJGyICQQhqQQAgAhshHSADKALkASICQQxsIBNqQQAgAiASSRsiAkEIakEAIAIbIR4gAygC4AEiAkEMbCATakEAIAIgEkkbIgJBCGpBACACGyEZCyADQaACaiADQYABaiADEJECIAMqAqACIiUgIV0hAiADKgKsAiEiIAMqAqgC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AQsgCEEERw0BC0HIt8EAQStBmOzBABDbCQALIANB2AJqIgFBD2ogA0GAAWoiAkEPaigAADYAACABQQhqIAJBCGopAwA3AwAgAyADKQOAATcD2AIgAEEIaiADQeMCaikAADcAACAAIAMpANsCNwAAIABBFGogDDYCACAAQQE2AhAgA0GABGokAAuJGQIRfw19IwBB0AFrIgIkACABKgIAIhO8Qf////8Hcb4iFCABQQRqIgMqAgAiFbxB/////wdxviIWIBYgFF8bIhQgAUEIaiIGKgIAIhe8Qf////8Hcb4iFiAWIBRfGyIUIAFBDGoiBCoCACIYvEH/////B3G+IhYgFiAUXxsiFCABQRBqIgoqAgAiGbxB/////wdxviIWIBYgFF8bIhQgAUEUaiIIKgIAIhq8Qf////8Hcb4iFiAWIBRfGyIUIAFBGGoiBSoCACIbvEH/////B3G+IhYgFiAUXxsiFCABQRxqIgcqAgAiHLxB/////wdxviIWIBYgFF8bIhQgAUEgaiIJKgIAIh28Qf////8Hcb4iFiAWIBRfGyIWQwAAAABcBEAgCSAdIBaVOAIAIAcgHCAWlTgCACAFIBsgFpU4AgAgCCAaIBaVOAIAIAogGSAWlTgCACAEIBggFpU4AgAgBiAXIBaVOAIAIAMgFSAWlTgCACABIBMgFpU4AgALIAJBkAFqIgNBIGoiBiABQSBqKAIANgIAIANBGGogAUEYaikCADcDACADQRBqIgQgAUEQaikCADcDACADQQhqIAFBCGopAgA3AwAgAiABKQIANwOQASACQdgAaiIBIAMQrgEgAUEQaioCACEXIAFBIGoqAgAhGCACKgJYIRkgAkGcAWpCADcCACADQRRqIgpCADcCACACQawBakKAgICAgICAwD83AgAgBEGAgID8AzYCACACQgA3ApQBIAJBgICA/AM2ApABIAJCATcCvAEgAiABQRRqNgK4ASACQYABaioCACETIAJBATYCzAEgAiAKNgLIAUMAAMB/QwAAgD8gE5ggEyATXBsiE0MAAADAlCIUIAJBuAFqIAJByAFqEN4ClCEVIANBBHIhAQJAIBNDAAAAAFwEQCACIBUgAioCbJQgEyACKgKkAZSSOAKkASACQQE2AswBIAIgBjYCyAEgBiAUIAJBuAFqIAJByAFqEN4ClCACKgJslCATIAYq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QbgBaiIGKAIAIgEEQCABQQxsIQIgBSgCAEEIaiEBA0AgASgCACIHKAIQIQQgByAEQQIgBBs2AhAgBEUEQCABKAIAKAIYQRhqEMwFCyABQQxqIQEgAkF0aiICDQALCyAFEMIDIANBADoAyAEgA0HMAWogA0HEAWooAgAgBigCAHJFOgAACyAAKAIMIgEtAIgCIAFBAToAiAJFDQIgACgCDCIAKAKEAUEYbARAIAAoAoABENoBCyAAQZABahC9BSAAQbABahC9BSAAENoBDwsgAEEMaigCACICKALAASEBIAIgAUF/ajYCwAEgAUEBRw0BIAAoAgwiASgCQCECIAEgAkEBcjYCQCACQQFxRQRAIAFBmAFqIgItAAAgAkEBOgAABEBBACEDA0AgAyADQQFqIANBB09BACADQQpLGxshAyABLQCYASABQQE6AJgBDQALCyABQYABaiEFIAFBiAFqIgYoAgAiAgRAIAJBDGwhAiAFKAIAQQhqIQMDQCADKAIAIgcoAhAhBCAHIARBAiAEGzYCECAERQRAIAMoAgAoAhhBGGoQzAULIANBDGohAyACQXRqIgINAAsLIAUQwgMgAUEAOgCYASABQZwBaiABQZQBaigCACAGKAIAckU6AAALIAAoAgwiAS0AyAEgAUEBOgDIAUUNASAAKAIMIgIoAgQhACACKAIAQX5xIgMgAigCQEF+cSIERwRAA0AgA0E+cUE+RgRAIAAoAgAgABDaASEACyAEIANBAmoiA0cNAAsLIAAEQCAAENoBCyACQYABahC9BSACENoBDwsgAEEMaigCACICKAIAIQEgAiABQX9qNgIAIAFBAUcNACAAKAIMIgFBPGoiAi0AACACQQE6AAAEQEEAIQMDQCADIANBAWogA0EHT0EAIANBCksbGyEDIAEtADwgAUEBOgA8DQALCyABQThqLQAARQRAIAFBCGogAUEBOgA4IAFBEGooAgAiAgRAIAJBDGwhAiABKAIIQQhqIQMDQCADKAIAIgYoAhAhBCAGIARBAiAEGzYCECAERQRAIAMoAgAoAhhBGGoQzAULIANBDGohAyACQXRqIgINAAsLEMIDIAFBIGohBSABQShqKAIAIgIEQCACQQxsIQIgBSgCAEEIaiEDA0AgAygCACIGKAIQIQQgBiAEQQIgBBs2AhAgBEUEQCADKAIAKAIYQRhqEMwFCyADQQxqIQMgAkF0aiICDQALCyAFEMIDCyABQQA6ADwgACgCDCIBLQBAIAFBAToAQEUNACAAKAIMIgBBCGoQvQUgAEEgahC9BSAAENoBCwvBFgMWfwN+BH0jAEGwBWsiCCQAIAhBgAJqIgtBCGogA0EIaigCADYCACAIIAMpAgA3A4ACIAhBsARqIgNBCGoiCiAEQQhqKAIANgIAIAggBCkCADcDsAQgCEEQaiIEIAsgAxCkCiAIQQhqIgsgB0H//wNxNgIEIAsgB0EQdjYCACAIKQMIIR4gCEEANgJYIAggHjcDUCAIIAI2AkwgCCABNgJIIANBEGogBEEQaikDADcDACAKIARBCGopAwA3AwAgCCAIKQMQNwOwBCAIQeAAaiADEPkFIAggBjoAzAEgCCAFOALIASAIIAQ2AsQBIAggCEHIAGo2AsABAn9BBCABQShqKAIAIhJFDQAaIAhCADcC1AEgCEHcmsAAKAIANgLQASAIQdABaiICQQAQwgUgCCgC0AEgCCgC2AEiA0EDdGpCgICAgPD///9+NwIAIAggA0EBajYC2AEgCEHwAWogAhCZAwJAIAgoAvABQQFHBEBBBCELDAELIAhBjAVqIQogCEHsBGohDCAIQbAEaiICQSBqIRAgCEGgA2pBBHIhEyAIQYADakEEciEUIAJBBHIhFUP//39/ISFBBCELAkACQANAICEgCCoC+AGMX0EBc0UNAyASIAgoAvQBIgJLBEAgCEGAAmogASgCICACQQd0akGAARCeChogCC0A+AIiBARAIAEoAjwiAiAIKALsAiIDQQR0akEAIAMgASgCRCIDSRsiBkEIakEAIAYbIRcgCCgC6AIiBkEEdCACakEAIAYgA0kbIgZBCGpBACAGGyEYIAgoAuQCIgZBBHQgAmpBACAGIANJGyIGQQhqQQAgBhshGSACIAgoAuACIgJBBHRqQQAgAiADSRsiAkEIakEAIAIbIRYLIAggCCoCyAEiBTgCrAMgCCAFOAKoAyAIIAU4AqQDIAggBTgCoAMgCEGwBGogCEGAAmogCEHgAGogCEGgA2oQgAIgCEGABGoiAiAVQQhqKAIANgIAIAggFSkCADcD+AMgCCgCsAQhByAIKgLABCEFIAgqAsQEISIgCCoCyAQhIyAIKgLMBCEkAn8gBEUEQEEEIQRBBCEGQQQhAkEEDAELIAggFzYClAQgCCAYNgKQBCAIIBk2AowEIAggFjYCiARCACEeIAhBmARqIgNBCGpCADcDACAIQgA3A5gEIAhBADYCrAQgCEEENgKoBSAIQQQ2AogFIAhBBDYC6AQgCEEENgLIBCAIIAc2AoADIBQgCCkD+AM3AgAgFEEIaiACKAIANgIAIAggJCAhXToAowMgCCAjICFdOgCiAyAIICIgIV06AKEDIAggBSAhXToAoAMgCEHgA2ogCEGAA2ogCEGgA2oQhQkgCC0A4AMgCC0A4QNBAXRyIAgtAOIDQQJ0ciAILQDjA0EDdHKtQv8BgyEfIAhBrARqIQYgCEGwBGohBCAIQYgEaiEHA0ACQCAfIB6IQgGDUA0AIAcoAgAiEUUNACAIKALAASICKAIEIg0gESgCACIPIBEoAgQiCRCvCSIORQ0AIAIoAgggDigCBHFFDQAgAkEMaigCACAOKAIAcUUNACACKAIQIg4EQCAOIA8gCSACQRRqKAIAKAIUEQUARQ0BCyANIA8gCRCuCSIORQ0FIA0gDyAJEK0JIgJFDQYgCCACQQRqKAIAIg82AgQgCCACKAIAIA8oAghBB2pBeHFqNgIAIAhBoANqIAgoAgAgDiAIKALEASAIKgLIASAILQDMASAIKAIEKAIcEQkAIAgoArADQQRGDQAgBkEBOgAAIAMgCCoCoAMiBTgCACAEQQhqIAU4AgAgBCARKQIANwIAIARBDGogEykCADcCACAEQRRqIBNBCGopAgA3AgAgBEEcaiATQRBqKAIANgIACyAHQQRqIQcgBEEgaiEEIAZBAWohBiADQQRqIQMgHkIBfCIeQgRSDQALIAhB4ANqIgJBCGogCEGwBGoiA0EIaikDADcDACACQRBqIANBEGopAwA3AwAgCEHIA2oiAkEIaiAQQQhqKQIANwMAIAJBEGogEEEQaikCADcDACAIIAgpA7AENwPgAyAIIBApAgA3A8gDIAgoAqwEIQcgCCoCpAQhJCAIKgKgBCEjIAgqApwEISIgCCoCmAQhBSAIKALIBCECIAgoAswEIREgCEGgA2oiA0EYaiAMQRhqKAIANgIAIANBEGogDEEQaikCADcDACAIQYADaiIDQRhqIApBGGooAgA2AgAgA0EQaiAKQRBqKQIANwMAIAggDEEIaikCADcDqAMgCCAMKQIANwOgAyAIIApBCGopAgA3A4gDIAggCikCADcDgAMgCCgC6AQhBiAIKAKsBSEPIAgoAqgFIQQgCCgCiAULIQMgECAIKQPIAzcCACAMIAgpA6ADNwIAIAxBCGogCCkDqAM3AgAgCEGwBGoiCUEQaiAIQeADaiINQRBqKQMANwMAIAlBCGogDUEIaikDADcDACAQQQhqIAhByANqIglBCGopAwA3AgAgEEEQaiAJQRBqKQMANwIAIAxBEGogCEGgA2oiCUEQaikDADcCACAMQRhqIAlBGGooAgA2AgAgCCAIKQPgAzcDsAQgCCARNgLMBCAIIAI2AsgEIAggBjYC6AQgCkEYaiAIQYADaiICQRhqKAIANgIAIApBEGogAkEQaikDADcCACAKQQhqIAgpA4gDNwIAIAogCCkDgAM3AgAgCCADNgKIBSAIIA82AqwFIAggBDYCqAUgCCAkOAKkBCAIICM4AqAEIAggIjgCnAQgCCAFOAKYBCAHQRV2QfgBcSAHQQ52QfwBcSAHQQd2Qf4BcSAHQf8BcXJycq0hICABKAJEIQlBACEDQgAhHgNAIB4iH0IBfCEeAkAgICAfiEIBg1ANACAILQD4AgRAIANBAnQiBiAIQZgEamoqAgAiBSAhXUEBcw0BIAhBsARqIANBBXRqIgRBGGooAgAiAkEERg0BIAYgCGpB4AJqKAIAIAlPDQEgCEHoAWogBEEQaikAADcDACAIIAQpAAg3A+ABIAQoAgQhGiAEKAIAIRsgBCgCHCEcIAIhCyAFISEMAQsgA0ECdCICIAhqQeACaigCACINIBJPDQAgCEGYBGogAmoqAgCMIQUgCCgC2AEiByEEIAgoAtQBIAdGBEAgCEHQAWogBxDCBSAIKALYASEECyAIKALQASIGIARBA3RqIgIgBTgCBCACIA02AgAgCCAEQQFqNgLYASAHQQN0IAZqIgIqAgQhBSACKAIAIQ1BACECAkAgB0UNAANAQQBBfyAFIAdBf2pBAXYiBEEDdCAGaiIOQQRqKgIAIiJgIh0bQQFBAiAdGyAFICJfG0F/akH/AXFBAUsEQCAHIQIMAgsgB0EDdCAGaiAOKQIANwIAIAQiBw0ACwsgAkEDdCAGaiICIAU4AgQgAiANNgIACyADQQFqIQMgHkIEUg0ACyAIQfABaiAIQdABahCZAyAIKALwAUEBRg0BDAQLCyACIBJBoJzAABDPCAALQfSYwABBK0GAoMAAENsJAAtB9JjAAEErQYCgwAAQ2wkACyAIQbgEaiAIQegBaikDADcDACAIIAgpA+ABNwOwBAJAIAgoAtQBIgFFDQAgCCgC0AEiAkUNACABQQN0RQ0AIAIQ2gELQQQgC0EERg0AGiAIQUBrIAhBuARqKQMANwMAIAggCCkDsAQ3AzggCwsiAkEERwRAIAhBMGogCEFAaykDACIeNwMAIAggCCkDOCIfNwMoIAhBuARqIB43AwAgCCAfNwOwBCAAIBo2AgQgACAbNgIAIAAgHzcCCCAAQRBqIB43AgAgACAcNgIcCyAAIAI2AhggCEGwBWokAAu8FAIIfwJ+IwBB8ABrIgIkAAJAAkACQAJAAkACQAJAAkAgASgCAEEBaw4FAQUEAwIACyABKAIEIgQoAgAhAQNAAkAgBCgCgAEgBCgCjAFBf2ogAXEiCUEYbGoiBigCACIHIAFBAWpHBEAgASAHRg0BIAUgBUEBaiAFQQdPQQAgBUEKSxsbIQUgBCgCACEBDAILIAQoAgAiAyABRiEIIAQgByAEKAKIAUEAIAQoAogBayABcWogCUEBaiAEKAKEAUkbIAMgCBs2AgAgCARAIAQoAogBIAFqIQEMCAsgBUEGIAVBBkkbQR9xIQZBACEBA0AgASAGdiABQQFqIQFFDQALIAVBB0kgBWohBSADIQEMAQsgBCgCQCIDIAQoAowBIgdBf3NxIAFHBEAgBUEGIAVBBkkbQR9xIQNBACEBA0AgASADdiABQQFqIQFFDQALIAVBB0kgBWohBSAEKAIAIQEMAQsLQQAhAUEAIQYgAyAHcQ0FIABBATsBAAwGCyABKAIEIggoAgQhBSAIKAIAIQEDQAJAAkACQAJAAkACQAJAIAFBAXYiA0EfcSIGQR9HBEAgAUECaiEEIAFBAXFFBEAgAyAIKAJAIgNBAXZGDQQgASADc0E/SyAEciEECyAFRQ0BIAgoAgAiAyABRiEBIAggBCADIAEbNgIAIAFFDQIgBkEeRw0EIAUoAgAiA0UEQEEAIQEDQCABIAFBAWogAUEHT0EAIAFBCksbGyEBIAUoAgAiA0UNAAsLIAMoAgAhASAIIAM2AgQgCCAEQQJqQX5xIAFBAEdyNgIADAQLIAdBB0kNBSAHQQpLDQYMBQsgB0EHSQ0EIAdBCk0NBAwFCyAHQQYgB0EGSRtBH3EhBCAIKAIEIQVBACEBA0AgASAEdiABQQFqIQFFDQALIAdBB0kgB2ohByADIQEMBQtBACEFQQAhBiADQQFxRQ0BCwJAIAVFDQAgBkEYbCAFaiIHQQRqIQMgB0EYaiIELQAAQQFxRQRAQQAhAQNAIAEgAUEBaiABQQdPQQAgAUEKSxsbIQEgBC0AAEEBcUUNAAsLIAJBGGogA0EIaikCADcDACACIAMpAgA3AxAgB0EUai0AACEHIAJBLmogA0ETai0AADoAACACIAMvABE7ASwCQCAGQR5GBEBBGCEBA0AgASAFaiIDLQAAQQJxRQRAIAMgAygCACIDQQRyNgIAIANBAnFFDQMLIAFBGGoiAUHoBUcNAAsgBRDaAQwBCyAEIAQoAgAiAUECcjYCACABQQRxRQ0AIAZBHE0EQCAGQRhsIQEgBUEwaiEEA0AgASAEaiIDLQAAQQJxRQRAIAMgAygCACIDQQRyNgIAIANBAnFFDQMLIAFBGGoiAUG4BUcNAAsLIAUQ2gELIAJB6ABqIgEgAkEYaikDADcDACACQSpqIgMgAkEuai0AADoAACACIAIpAxA3A2AgAiACLwEsOwEoIAdB/wFxQQJGDQAgAEEEaiACKQNgNwIAIABBFGogBzoAACAAQRVqIAIvASg7AAAgAEEMaiABKQMANwIAIABBF2ogAy0AADoAACAAQQA6AAAMCgsgAEEBOgABIABBAToAAAwJCyAAQQE7AQAMCAsgB0EBaiEHCyAIKAIEIQUgCCgCACEBDAALAAsgAEEBOwEADAQLIAJBEGoiAyABKAIEQQhqEJ4DIABBEGogA0EQaikDADcCACAAQQhqIANBCGopAwA3AgAgACACKQMQNwIADAMLQQEhBAJAIAEoAgQiAS0AGA0AELUMQX8gAikDACIKIAEpAwgiC1IgCiALVBsiA0F/IAIoAggiBSABQRBqKAIAIgZHIAUgBkkbIAMbQX9GDQAgAS0AGCEDIAFBAToAGCADDQAgAUEQaigCACEDIAEpAwghCkEAIQQLIABBADoAASAAIAQ6AAAgAEECaiACKAEQNgEAIABBEGogAzYCACAAQQhqIAo3AgAgAEEGaiACQRRqLwEAOwEADAILIAEoAgQiA0E8aiIBLQAAIAFBAToAACADQQhqIQQEQEEAIQEDQCABIAFBAWogAUEHT0EAIAFBCksbGyEBIAMtADwgA0EBOgA8DQALCyACQTBqIAQQiQMCQAJAIAIoAjgEQCADQQA6ADwgAkHIAGogAkE4aigCADYCACACIAIpAzA3A0AgAAJ/IAIoAkQiAQRAAkAgAS0AFEUEQCABLQAVRQRAQQAhBANAIAQgBEEBaiAEQQdPQQAgBEEKSxsbIQQgAS0AFUUNAAsLIAEtABAhBCABQQI6ABAgASkCACEKIAJB6ABqIgMgAUEIaikCADcDACACIAo3A2AgBEECRg0FIAJB2ABqIAMpAwA3AwAgAkEqaiABQRNqLQAAOgAAIAIgAikDYDcDUCACIAEvABE7ASggARDaAQwBCyABLQAQIQQgAUECOgAQIAEpAgAhCiACQRhqIgMgAUEIaikCADcDACACIAo3AxAgBEECRg0FIAJB6ABqIAMpAwAiCjcDACACQS5qIAFBE2otAAAiAzoAACACQSpqIAM6AAAgAkHYAGogCjcDACACIAIpAxAiCjcDYCACIAEvABEiAzsBLCABQQE6ABUgAiAKNwNQIAIgAzsBKAsgAEEEaiACKQNQNwIAIABBFGogBDoAACAAQRVqIAIvASg7AAAgAEEMaiACQdgAaikDADcCACAAQRdqIAJBKmotAAA6AABBAAwBCyAAQQE6AAFBAQs6AAAgAigCSCIBKAIAIQAgASAAQX9qNgIAIABBAUcNBCACQcgAahCWCQwECyAAQQE6AAAgA0EAOgA8IAAgA0E4ai0AADoAASACKAI4IgBFDQMgACAAKAIAIgBBf2o2AgAgAEEBRw0DIAJBOGoQlgkMAwtB9JjAAEErQdyIwAAQ2wkAC0H0mMAAQStBzIjAABDbCQALAkAgBkUNACAGIAE2AgAgAkEYaiIFIAZBDGopAgA3AwAgAkEuaiIHIAZBF2otAAA6AAAgAiAGKQIENwMQIAIgBi8AFTsBLCAGLQAUIQMgBEGsAWotAABFBEAgBEGoAWoiAS0AACABQQE6AAAEQEEAIQEDQCABIAFBAWogAUEHT0EAIAFBCksbGyEBIAQtAKgBIARBAToAqAENAAsLIAQtAKwBRQRAIAJB0ABqIARBkAFqIgYQiQMCQCACKAJYIgFFDQAgASABKAIAIgFBf2o2AgAgAUEBRw0AIAJB2ABqEJYJCyAGEMIDIAQgBEGkAWooAgAgBEGYAWooAgByRToArAELIARBADoAqAELIAJB6ABqIAUpAwA3AwAgAkEqaiAHLQAAOgAAIAIgAikDEDcDYCACIAIvASw7ASggA0H/AXFBAkYNACAAQQRqIAIpA2A3AgAgAEEUaiADOgAAIABBFWogAi8BKDsAACAAQQxqIAJB6ABqKQMANwIAIABBF2ogAkEqai0AADoAACAAQQA6AAAMAQsgAEEBOgABIABBAToAAAsgAkHwAGokAAukFgIMfxd9IwBBoARrIgkkAAJAAkACQAJAAkACQAJAAkAgA0EFTwRAIAlBuAJqQQA2AgAgCUIANwOwAiADQQJ0IQtDAACAPyADs5UhFQNAIAIgDGooAgAiCiAFTw0CIAkgFSAKQRhsIARqIgoqAgAgCioCDJJDAAAAP5QiHZQgFpIiFjgCsAIgCSAVIAoqAgggCkEUaioCAJJDAAAAP5QiHpQgF5IiFzgCuAIgCSAVIAoqAgQgCkEQaioCAJJDAAAAP5QiG5QgGJIiGDgCtAIgGiAVIB0gHZSUkiEaIBwgFSAeIB6UlJIhHCAZIBUgGyAblJSSIRkgCyAMQQRqIgxHDQALIAlBsAFqIgogAiADIAQgBSAJQbACaiICQQIgGSAYIBiUkyIYIBogFiAWlJMiFl0iAyAcIBcgF5STIBggFiADG10bIgxBAWpBA3AQsAQgCUG8AWoiAygCACELIAkoArgBIQ0gCiAJKAKwASAJKAK0ASAEIAUgAiAMQQJqQQNwIgwQsAQgAygCACEOIAkoArgBIQ8gCSgCtAEhECAJKAKwASERIAogDSALIAQgBSACIAwQsAQgAygCACELIAkoArgBIQ0gCSgCtAEhEiAJKAKwASETIAlBMGoiAxDDCCAJQZgBakIANwMAIAlCADcDkAEgAUEgaiIMKAIAIQIgCiADQfAAEJ4KGiACIQogAUEcaigCACACRgRAIAFBGGogAhDDBSAMKAIAIQoLIAEoAhggCkEHdGogCUGwAWpB8AAQngoiAyAJLwCgAzsAdSADQfcAaiAJQaADaiIUQQJqLQAAOgAAIAMgCSgBwAM2AXogA0H+AGogCUHEA2ovAQA7AQAgA0H0AGogBzoAACADIAY2AnAgA0EAOwF4IAwgCkEBajYCACAJQShqIgNBADoABCADIAI2AgAgCUHAAmogASARIBAgBCAFIAkoAiggCS0ALCAIEHIgCUEgaiIDQQE6AAQgAyACNgIAIAlB4AJqIAEgDyAOIAQgBSAJKAIgIAktACQgCBByIAlBGGoiA0ECOgAEIAMgAjYCACAJQYADaiABIBMgEiAEIAUgCSgCGCAJLQAcIAgQciAJQRBqIgNBAzoABCADIAI2AgAgFCABIA0gCyAEIAUgCSgCECAJLQAUIAgQciAMKAIAIgMgAk0NBCAJKAKgAyEEIAkoAoADIQUgCSgC4AIhBiABKAIYIAJBB3RqIgMgCSgCwAI2AmAgA0HsAGogBDYCACADQegAaiAFNgIAIANB5ABqIAY2AgAgCUHAAWogCUHAAmoiA0EUaikCADcDACAJQbgBaiADQQxqKQIANwMAIAlBsAFqIgNBIGogCUHgAmoiBEEMaikCADcDACAJQdgBaiAEQRRqKQIANwMAIAkgCSkCxAI3A7ABIAkgCSkC5AI3A8gBIAlB6AFqIAlBgANqIgRBDGopAgA3AwAgCUHwAWogBEEUaikCADcDACAJIAkpAoQDNwPgASAJQYgCaiAJQaADaiIEQRRqKQIANwMAIAlBgAJqIARBDGopAgA3AwAgCSAJKQKkAzcD+AEgCUHAA2ogAxCaBCABQSBqIgMoAgAiBCACTQ0FIAJBB3QiBCABKAIYaiAJQcADakHgABCeChogAygCACIDIAJNDQYgASgCGCAJIAg4ArwBIAkgCDgCuAEgCSAIOAK0ASAJIAg4ArABIARqIAlBsAFqEKUCIAlBoANqIgFBCGoqAgAhCCAJQYADaiIDQQhqKgIAIRYgCUHAAmoiBEEIaioCACEXIAlB4AJqIgVBCGoqAgAhGCABQQxqKgIAIRogA0EMaioCACEZIARBDGoqAgAhFSAFQQxqKgIAIR0gAUEQaioCACEeIANBEGoqAgAhGyAEQRBqKgIAIRwgBUEQaioCACEfIAFBFGoqAgAhICADQRRqKgIAISEgBEEUaioCACEiIAVBFGoqAgAhJSABQRhqKgIAISYgA0EYaioCACEjIARBGGoqAgAhJCAFQRhqKgIAIScgCSoCpAMhKCAJKgKEAyEpIAkqAsQCISogCSoC5AIhKyAAIAI2AgAgAEEYaiAkICcgJCAnYBsiJCAjICQgI2AbIiMgJiAjICZgGzgCACAAQRRqICIgJSAiICVgGyIiICEgIiAhYBsiISAgICEgIGAbOAIAIABBEGogHCAfIBwgH2AbIhwgGyAcIBtgGyIbIB4gGyAeYBs4AgAgAEEMaiAVIB0gFSAdXxsiFSAZIBUgGV8bIhkgGiAZIBpfGzgCACAAQQhqIBcgGCAXIBhfGyIXIBYgFyAWXxsiFiAIIBYgCF8bOAIAIAAgKiArICogK18bIgggKSAIIClfGyIIICggCCAoXxs4AgQMCAsgAUEgaiIQKAIAIQ4gCUGYBGpC////+////79/NwMAIAlBkARqQv////v3//+/fzcDACAJQYAEakL////7////v383AwAgCUH4A2pC////+/f//79/NwMAIAlB6ANqQv////v///+/fzcDACAJQcADaiIKQSBqQv////v3//+/fzcDACAKQRBqQv////v///+/fzcDACAJQv////v3//+//wA3A4gEIAlC////+/f//7//ADcD8AMgCUL////79///v/8ANwPYAyAJQv////v3//+/fzcDyAMgCUL////79///v/8ANwPAAyAJQagDaiIRQn83AwAgCUJ/NwOgAyADRQRAQ///f38hFUP//3//IRZD//9//yEaQ///f/8hGUP//39/IRdD//9/fyEYDAcLIANBAnQhD0EAIQpD//9//yEZQ///f38hGCAJQcADaiEMIAlBoANqIQND//9/fyEXQ///f38hFUP//3//IRpD//9//yEWA0AgAigCACINIAVPDQIgCkEERwRAIA1BGGwgBGoiCyoCACEdIAtBFGoqAgAhHiALQRBqIhIqAgAhGyALQQxqKgIAIRwgC0EIaiITKgIAIR8gC0EEaioCACEgIAMgDTYCACAMIAspAgA3AgAgDEEQaiASKQIANwIAIAxBCGogEykCADcCACAJQQhqIgsgCjoABCALIA42AgAgASgCPCINIAIoAgAiC00NBCAKQQFqIQogAkEEaiECIBggHSAYIB1fGyEYIBYgHiAWIB5gGyEWIBogGyAaIBtgGyEaIBkgHCAZIBxgGyEZIBUgHyAVIB9fGyEVIBcgICAXICBfGyEXIAkoAgghDSABKAI0IAtBBHRqIgsgCS0ADDoABCALIA02AgAgA0EEaiEDIAxBGGohDCAPQXxqIg9FDQgMAQsLQQRBBEGQxcAAEM8IAAsgCiAFQbDFwAAQzwgACyANIAVBgMXAABDPCAALIAsgDUGgxcAAEM8IAAsgAiADQcDFwAAQzwgACyACIARB0MXAABDPCAALIAIgA0HgxcAAEM8IAAsgCUGwAWoiAiAJQcADakHgABCeChogCUEwaiIDIAIQmgQgCUGkAWogBzoAACAJQZgBaiARKQMANwMAIAlBATsBqAEgCSAGNgKgASAJIAkpA6ADNwOQASAJIAg4ArwBIAkgCDgCuAEgCSAIOAK0ASAJIAg4ArABIAMgAhClAiACIANBgAEQngoaIBAoAgAiAiABQRxqKAIARgRAIAFBGGogAhDDBSABQSBqKAIAIQILIAEoAhggAkEHdGogCUGwAWpBgAEQngoaIAFBIGogAkEBajYCACAAQRhqIBY4AgAgAEEUaiAaOAIAIABBEGogGTgCACAAQQxqIBU4AgAgAEEIaiAXOAIAIAAgGDgCBCAAIA42AgALIAlBoARqJAALlRQCEH8SfSMAQcADayISJAACQAJAIA8gEF9BAXNFBEACfwJAAkACQCAJKAIAIhRFBEAgCigCAEUNAQsgCSgCBCEWIA1BAUchFyAKKAIEIRUgFAR9IBYqAgQhJiAWKgIAIScgFioCCAVDAAAAAAtDAACAP0MAAAAAIAtBAUcbIiKUISsgJiAilCEsICcgIpQhLSAKKAIAIhMEfSAVKgIEISQgFSoCACElIBUqAggFQwAAAAALQwAAgD9DAAAAACAXGyIjlCEuICQgI5QhLyAlICOUIBQEfSAWKgIQITEgFioCDCEyIBYqAhQFQwAAAAALICKUISkgMSAilCEmIDIgIpQhJ0MAAAAAISVDAAAAACEkIBMEQCAVKgIUITMgFSoCECElIBUqAgwhJAsgCCgCECEYIAgoAgwhHCAIKAIIIRsgCCgCBCEdIAgoAgAhISAHKAIQIRcgBygCDCEIIAcoAgghGiAHKAIEIR4gBygCACEHIDMgI5QhKiAlICOUISUgJCAjlCEkIC2TIiIgIpQgLyAskyIiICKUkiAuICuTIiIgIpSSQwAAAACSEKsBICcgJ5QgJiAmlJIgKSAplJJDAAAAAJIQqwEgCUEMaigCACEfIBQEfSAfQQRqKgIABUMAAAAAC5SSICogKpQgJSAllCAkICSUkpJDAAAAAJIQqwEgCkEMaigCACEgIBMEQCAgQQRqKgIAISgLQwAAAABDAAAAACARIBFDAAAAAF0bIBEgEVwbIB4oAgAgHkEEaigCACIZKAIIQQdqQXhxaiAZKAKUAREKACAdKAIAIB1BBGooAgAiGSgCCEEHakF4cWogGSgClAERCgCSkiERICiUkiEiQQEhGQJAIActAAANACAhLQAADQAgHCgCCCAIQQxqKAIAcUUgHEEMaigCACAIKAIIcUVyIRkLIBAgD5MgIpQgEV0NBSASQRhqIgcQwwkgByAURQ0DGiAfLQAIDQEgEkHwAWogFEE0aigCADYCACASQegBaiAUQSxqKQIANwMAIBJB4AFqIBRBJGopAgA3AwAgEiAUKQIcNwPYASASQYADaiASQdgBahC5CAwCCyAAQQI2AgwMBQsgCSgCCCEJIBJB2AFqIghBGGogFEEYaigCADYCACAIQRBqIBRBEGopAgA3AwAgCEEIaiAUQQhqKQIANwMAIBIgFCkCADcD2AEgEkGYAmoiHEEIaiAJQQhqKAIANgIAIBIgCSkCADcDmAIgEkG4AmoiCUEIaiAWQQhqKAIANgIAIBIgFikCADcDuAIgEkGYAWoiH0EIaiAWQRRqKAIANgIAIBIgFikCDDcDmAEgEkGAA2ogCCAcIAkgHxDaBwsgEkHYAWoiCEE4aiASQYADaiIJQThqKQMANwMAIAhBMGogCUEwaikDADcDACAIQShqIAlBKGopAwA3AwAgCEEgaiAJQSBqKQMANwMAIAhBGGogCUEYaikDADcDACAIQRBqIAlBEGopAwA3AwAgCEEIaiAJQQhqKQMANwMAIBIgEikDgAM3A9gBIAggEkEYaiAUGwshCCASQdgAaiIJQThqIAhBOGopAgA3AwAgCUEwaiAIQTBqKQIANwMAIAlBKGogCEEoaikCADcDACAJQSBqIAhBIGopAgA3AwAgCUEYaiAIQRhqKQIANwMAIAlBEGogCEEQaikCADcDACAJQQhqIAhBCGopAgA3AwAgEiAIKQIANwNYIBMEQAJAICAtAAhFBEAgEkHwAWogE0E0aigCADYCACASQegBaiATQSxqKQIANwMAIBJB4AFqIBNBJGopAgA3AwAgEiATKQIcNwPYASASQYADaiASQdgBahC5CAwBCyAKKAIIIQggEkHYAWoiB0EYaiATQRhqKAIANgIAIAdBEGogE0EQaikCADcDACAHQQhqIBNBCGopAgA3AwAgEiATKQIANwPYASASQfACaiIJQQhqIAhBCGooAgA2AgAgEiAIKQIANwPwAiASQZgCaiIIQQhqIBVBCGooAgA2AgAgEiAVKQIANwOYAiASQbgCaiIKQQhqIBVBFGooAgA2AgAgEiAVKQIMNwO4AiASQYADaiAHIAkgCCAKENoHCyASQdgBaiIHQThqIBJBgANqIghBOGopAwA3AwAgB0EwaiAIQTBqKQMANwMAIAdBKGogCEEoaikDADcDACAHQSBqIAhBIGopAwA3AwAgB0EYaiAIQRhqKQMANwMAIAdBEGogCEEQaikDADcDACAHQQhqIAhBCGopAwA3AwAgEiASKQOAAzcD2AEgByASQRhqIBMbIQcLIBJBmAFqIghBOGogB0E4aikCADcDACAIQTBqIAdBMGopAgA3AwAgCEEoaiAHQShqKQIANwMAIAhBIGogB0EgaikCADcDACAIQRhqIAdBGGopAgA3AwAgCEEQaiAHQRBqKQIANwMAIAhBCGogB0EIaikCADcDACASIAcpAgA3A5gBIAtBAUYEQCASQdgAaiAMEKgICyANQQFGBEAgEkGYAWogDhCoCAsgFwRAIBJBgANqIhpBGGogF0EgaigCADYCACAaQRBqIBdBGGopAgA3AwAgEkGIA2ogF0EQaikCADcDACASIBcpAgg3A4ADCyASQbgCaiIHQRhqIgkgGkEYaigCADYCACAHQRBqIgogGkEQaikCADcDACAHQQhqIgggGkEIaikCADcDACASIBopAgA3A7gCIBJB2AFqIBJB2ABqIAcQjwIgGARAIAkgGEEgaigCADYCACAKIBhBGGopAgA3AwAgCCAYQRBqKQIANwMAIBIgGCkCCDcDuAIgEkG4AmohGwsgEkGYAmoiB0EYaiAbQRhqKAIANgIAIAdBEGogG0EQaikCADcDACAHQQhqIBtBCGopAgA3AwAgEiAbKQIANwOYAiASQYADaiIJIBJBmAFqIAcQjwIgEkEQaiIHIB5BBGooAgAiCjYCBCAHIB4oAgAgCigCCEEHakF4cWo2AgAgEigCFCEKIBIoAhAhByASQQhqIgsgHUEEaigCACINNgIEIAsgHSgCACANKAIIQQdqQXhxajYCACASQbgCaiABIBJB2AFqIAcgCiAJIBIoAgggEigCDCAPIBAgGSACKAIoESYAIBItAOwCQR10QR11QX1MBEAgAEEC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QAJAAkAgBCgCEEEBRwRAIAQoAhQiAUEYaigCACICIARBGGooAgBBfGooAgAiAE0NASABKAIQIABBFGxqKAIQIQUMCgsgBEEwaiAEQSRqKAIANgIAIAQgBEEcaikCADcDKCAAKgIAIg0gASgCCLKUIQ4gDSAOkiEPIA0gDSABKAIEspQiEJIhESANIA0gASgCALKUIg2SIRIgBEEYaigCACEJIAQoAhQhCCADKAIIIgFFBEAgBEEANgI4DAMLIAMgAUF/aiIBNgIIIAQgAygCACABQQJ0aigCACIBNgI4IAFFDQIgAUEQakEANgIAIAFBHGpBADYCACABQQxqIgMoAgAiBUUEQCABQQhqQQBBARDBBSABKAIQIQcgAygCACEFCyABIAdBAWoiAzYCECABKAIIIgYgB0EDdGpC////ezcCACADIAVGBEAgAUEIaiAFQQEQwQUgASgCCCEGIAEoAhAhAwsgA0EDdCAGakL////79/////8ANwIAIAEgA0EBajYCEEEAIQcgAUEwakEANgIAIAEgDTgCACABIBI4AgQgAUE8akEANgIAIAFBLGoiAygCACIFRQRAIAFBKGpBAEEBEMEFIAEoAjAhByADKAIAIQULIAEgB0EBaiIDNgIwIAEoAigiBiAHQQN0akL///97NwIAIAMgBUYEQCABQShqIAVBARDBBSABKAIoIQYgASgCMCEDCyADQQN0IAZqQv////v3/////wA3AgAgASADQQFqNgIwQQAhByABQdAAakEANgIAIAEgEDgCICABQSRqIBE4AgAgAUHcAGpBADYCACABQcwAaiIDKAIAIgVFBEAgAUHIAGpBAEEBEMEFIAEoAlAhByADKAIAIQULIAEgB0EBaiIDNgJQIAEoAkgiBiAHQQN0akL///97NwIAIAMgBUYEQCABQcgAaiAFQQEQwQUgASgCSCEGIAEoAlAhAwsgA0EDdCAGakL////79/////8ANwIAIAEgA0EBajYCUCABIA44AkAgAUHEAGogDzgCACABQQA6AJABQZjAwAAoAgAhAwJAIAFB5ABqIgUoAgAiBkUNACABQeAAaigCACIHRQ0AIAZBAnRFDQAgBxDaAQsgASADNgJgIAFBADoAkQEgAUHsAGpBADYCACAFQgA3AgAgAUGEAWpCgICAgHA3AgAgASgCjAENASABQfgAaigC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wARqJAAL3hQDFX8Efh59IwBBoANrIgckACAHQThqIANBCGooAgA2AgAgB0EgaiIJQQhqIARBCGopAgA3AwAgByADKQIANwMwIAcgBCkCADcDICAHQRhqIgMgBUEEaigCACIENgIEIAMgBSgCACAEKAIIQQdqQXhxajYCACAHKAIYIQwgBygCHCENIAdBEGoiAyAGQf//A3E2AgQgAyAGQRB2NgIAIAFBBGooAgAiEigCCCEDIAEoAgAhBCAHKAIUIRMgBygCECEUIAdB4ABqIAwgCSANKAKAAREBAAJ/AkAgAUEoaigCAEUNACAHQfQAaioCACEjIAcqAmghICAHQfAAaioCACElIAcqAmQhJiAHKgJgISEgByoCbCEiIAdCADcCRCAHQdyawAAoAgA2AkAgB0FAayIFQQAQwgUgBygCQCAHKAJIIgZBA3RqQoCAgIDw////fjcCACAHIAZBAWo2AkggB0HQAGogBRCZAwJAAkAgBygCUEEBRwRAQQIhCQwBCyADQQdqQXhxIARqIRUgIyAgk0MAAAA/lCEoICUgJpNDAAAAP5QhKSAiICGTQwAAAD+UISogICAjkkMAAAC/lCErICYgJZJDAAAAv5QhJSAhICKSQwAAAL+UISZD//9/fyEjIAFBKGohFiAHQfABaiIOQQhqIQ9BAiEJAkACQAJAA0AgIyAHKgJYjF9BAXNFDQQgFigCACIQIAcoAlQiA0sEQCAHQeAAaiABKAIgIANBB3RqQYABEJ4KGiAHLQDYASIFBEAgASgCPCIDIAcoAswBIgRBBHRqQQAgBCABKAJEIgRJGyIGQQhqQQAgBhshFyAHKALIASIGQQR0IANqQQAgBiAESRsiBkEIakEAIAYbIRggBygCxAEiBkEEdCADakEAIAYgBEkbIgZBCGpBACAGGyEZIAMgBygCwAEiA0EEdGpBACADIARJGyIDQQhqQQAgAxshEQsgByoCYCEgIAcqAmQhISAHKgJoISIgByoCbCEsIAcqAnAhLSAHKgJ0ISQgByoCeCEnIAcqAnwhLiAHKgKAASEvIAcqAoQBITAgByoCiAEhMSAHKgKMASEyIAcqApABITMgByoClAEhNCAHKgKYASE1IAcqApwBITYgByoCoAEhNyAHKgKkASE4IAcqAqgBITkgByoCrAEhOiAHKgKwASE7IAcqArQBITwg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IAcoArQDIgEgAksNACAHKALIAiIDIAcoAsQCRgRAIAdBwAJqIANBARDFBSAHKALIAiEDCyAHKALAAiADQQJ0aiABNgIAIAcgA0EBajYCyAIgBy0AyAMhAwsCQCASQgSDUA0AIANB/wFxDQBBACEDIAcoArgDIgEgAksNACAHKALIAiIDIAcoAsQCRgRAIAdBwAJqIANBARDFBSAHKALIAiEDCyAHKALAAiADQQJ0aiABNgIAIAcgA0EBajYCyAIgBy0AyAMhAwsCfwJAIBJCCINQDQAgA0H/AXENACAHKAK8AyIBIAJLDQAgBygCyAIiAyAHKALEAkYEQCAHQcACaiADQQEQxQUgBygCyAIhAwsgBygCwAIgA0ECdGogATYCACADQQFqDAELIAcoAsgCCyIBRQ0BIAcgAUF/aiIBNgLIAiACIAcoAsACIAFBAnRqKAIAIgNLDQALIAMgAkGwnMAAEM8IAAsCQCAHKALEAiIARQ0AIAcoAsACIgFFDQAgAEECdEUNACABENoBCyAHKAIsIgBBJE8EQCAAEAALIAdBoARqJAALrhQCDX8HfSMAQSBrIggkACAFKAIIIQYgBSgCACEKIAggBSgCBCIJQQRqKAIAIgU2AgQgCCAJKAIAIAUoAghBB2pBeHFqNgIAIAhBCGogCCgCACAKIAgoAgQoAoABEQEAAkACQAJAAkACQAJAIAFDAAAAP5QiE0MAAAAAYARAIBMgCCoCFJIiAUP//39+IAFD//9/fl0bQ///f/4gAUP//3/+XhshFCAIKgIQIBOTIgFD//9/fiABQ///f35dG0P//3/+IAFD//9//l4bIRcgCCoCDCATkyIBQ///f34gAUP//39+XRtD//9//iABQ///f/5eGyEYIAgqAgggE5MiAUP//39+IAFD//9/fl0bQ///f/4gAUP//3/+XhshFiATIAhBHGoqAgCSIgFD//9/fiABQ///f35dG0P//3/+IAFD//9//l4bIRUgEyAIQRhqKgIAkiIBQ///f34gAUP//39+XRtD//9//iABQ///f/5eGyETQQBB/wACfwJAIAAoAgggBCgCACIHSwRAIAAoAgAgB0EsbGoiBCAVOAIgIAQgEzgCHCAEIBQ4AhggBCAXOAIUIAQgGDgCECAEIBY4AgwgBC0AKCEFIAYtAABBEHFFDQlDAAAAw0MAAADD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Qv////v///+/fzcDACADQdgAakIANwMAIANBPGpCADcCAEEAIQIgA0HQucEAKAIANgJUIANB2LnBACgCADYCOCADQv////v3//+/fzcDKCADQv////v3//+//wA3AyACQAJAAkACQAJAAkACQCAFRQRAQQQhCQwBCyAFQQJ0IgRBBBDICyIJRQ0BCyADQQA2AmggAyAFNgJkIAMgCTYCYCADQYABaiIEQRBqQv////v///+/fzcDACADQv////v3//+/fzcDiAEgA0L////79///v/8ANwOAASADQfAAaiAEIAUQ7AMgA0F/NgKIASADQQA6AIQBIANBfzYCgAEgA0HUAGogBCAFEKAEQQAhBEEAIQYgBQRAIAVBA3RBeGpBA3YhCyADQdQAaiEMQQAhBQNAIAEoAggiAiAHKAIAIgRNDQMgAiAHKAIEIgZNDQQgBUEBaiEKIAEoAgAiCCAEQQxsaiICKgIIIRAgAioCBCERIAIqAgAhEiAGQQxsIAhqIgIqAgQhEyACKgIAIRQgAioCCCEVAkAgAygCXCIGIAVLBEAgBiEEDAELIAogBiIEayEIIAMoAlggBGsgCEkEQCAMIAYgCBCtBSADKAJcIQQLIAMoAlQgBEEMbGohAiAIQQJPBEADQCACQX82AgAgAkEIakF/NgIAIAJBBGpBADoAACACQQxqIQIgBkEBaiIGIAVHDQALIAQgCGpBf2ohBAsgCARAIAJBADoABCACQX82AgAgAiADLwCAATsABSACQX82AgggAkEHaiADQYIBai0AADoAACAEQQFqIQQLIAMgBDYCXCAFIAMoAngiBkkEQCADIAo2AngMAQsgCiAGIgRrIQggAygCdCAEayAISQRAIANB8ABqIAYgCBCxBSADKAJ4IQQLIAMoAnAgBEEYbGohAiAIQQJPBEADQCACQv////v3//+//wA3AgAgAkEQakL////7////v383AgAgAkEIakL////79///v383AgAgAkEYaiECIAZBAWoiBiAFRw0ACyAEIAhqQX9qIQQLIAgEQCACQv////v3//+/fzcCCCACQv////v3//+//wA3AgAgAkEQakL////7////v383AgAgBEEBaiEECyADIAQ2AnggAygCXCEECyAEIAVNDQUgAygCVCAFQQxsaiAFNgIIIAMoAngiAiAFTQ0GIAMoAnAgBUEYbGoiAiASIBQgEiARQwAAAACUIhiSIBBDAAAAAJQiFpIgFCATQwAAAACUIhmSIBVDAAAAAJQiF5JeGzgCDCACIBAgFSASQwAAAACUIhogGJIiHCAQkyAUQwAAAACUIhsgGZIiHSAVk14bOAIIIAIgESATIBogEZMgFpIgGyATkyAXkl4bOAIEIAIgEiAUIBggEpMgFpIgGSAUkyAXkl4bOAIAIAJBFGogECAVIBAgHJIgFSAdkl4bOAIAIAJBEGogESATIBogEZIgFpIgGyATkiAXkl4bOAIAIAMoAmgiAiADKAJkRgRAIANB4ABqIAJBARDFBSADKAJgIQkgAygCaCECCyAHQQhqIQcgAkECdCAJaiAFNgIAIAMgAkEBaiIGNgJoIAUgC0cgCiEFDQALIAMoAkAhBCADKAI8IQILIAIgBEYEQCADQThqIAIQwwUgAygCQCEECyADKAI4IARBB3RqIgJBATYCYCACQv////v///+/fzcDMCACQv////v3//+//wA3AyAgAkL////79///v/8ANwMQIAJC////+/f//7//ADcDCCACQv////v3//+//wA3AwAgAiADLwB9OwB1IAJB2ABqQv////v///+/fzcDACACQdAAakL////7////v383AwAgAkHIAGpC////+////79/NwMAIAJBQGtC////+////79/NwMAIAJBOGpC////+////79/NwMAIAJBKGpC////+/f//7//ADcDACACQRhqQv////v3//+//wA3AwAgAkHsAGpCfzcCACACQeQAakJ/NwIAIAJB9ABqQQA6AAAgAkH3AGogA0H/AGotAAA6AAAgAkEAOwF4IAIgAygBgAE2AXogAkH+AGogA0GEAWovAQA7AQAgAyAEQQFqNgJAIANBgAFqIgIgA0EgaiADKAJgIgQgBiADKAJwIgYgAygCeEEAQQAQXCADIAJBGGoqAgAiEjgCNCADIANBlAFqKgIAIhQ4AjAgAyADQZABaioCACIROAIsIAMgA0GMAWoqAgAiEDgCKCADIANBiAFqKgIAIhM4AiQgAyADKgKEASIVOAIgIAMoAkBFDQUgAygCOCICQf///3s2AlwgAkL////7////v383AlQgAiASOAJQIAJB////ezYCTCACQv////v///+/fzcCRCACIBQ4AkAgAkH///97NgI8IAJC////+////79/NwI0IAIgETgCMCACQf////sHNgIsIAJC////+/f//7//ADcCJCACIBA4AiAgAkH////7BzYCHCACQv////v3//+//wA3AhQgAiATOAIQIAJB////+wc2AgwgAkL////79///v/8ANwIEIAIgFTgCAAJAIAMoAnQiAkUNACACQRhsRQ0AIAYQ2gELAkAgAygCZCICRQ0AIAJBAnRFDQAgBBDaAQsgACADKQMgNwIAIAAgASkCADcCQCAAQThqIANBIGoiAkE4aikDADcCACAAQTBqIAJBMGopAwA3AgAgAEEoaiACQShqKQMANwIAIABBIGogAkEgaikDADcCACAAQRhqIAJBGGopAwA3AgAgAEEQaiACQRBqKQMANwIAIABBCGogAkEIaikDADcCACAAQcgAaiABQQhqKAIANgIAIABB1ABqIANBGGooAgA2AgAgACADKQMQNwJMIANBoAFqJAAPCyAEQQRB0J7DACgCACIAQb8GIAAbEQAAAAsgBCACQbTywQAQzwgACyAGIAJBxPLBABDPCAALIAUgBEGcyMEAEM8IAAsgBSACQazIwQAQzwgAC0EAQQBBjMjBABDPCAAL6RIDFX8DfgV9IwBBsARrIggkACAIQdAAaiIMQQhqIANBCGooAgA2AgAgCCADKQIANwNQIAhB4AFqIgNBCGoiDSAEQQhqKAIANgIAIAggBCkCADcD4AEgCEEgaiIEIAwgAxCkCiAIQRhqIg4gB0H//wNxNgIEIA4gB0EQdjYCACAIKQMYIR0gCEEANgJIIAggHTcDQCAIIAI2AjwgCCABNgI4IANBEGogBEEQaikDADcDACANIARBCGopAwA3AwAgCCAIKQMgNwPgASAMIAMQ+QUgCCAGOgC8ASAIIAU4ArgBIAFBKGooAgAhDCAIIAQ2ArQBIAggCEE4ajYCsAECQAJAIAxFDQAgCEIANwLEASAIQdyawAAoAgA2AsABIAhBwAFqIgJBABDCBSAIKALAASAIKALIASIDQQN0akKAgICA8P///343AgAgCCADQQFqNgLIASAIQdABaiACEJkDAkAgCCgC0AFBAUcNACAIQYQEaiENIAhB9ANqIQ4gCEHQA2oiAkEUaiEQIAJBBHIhESAIQaAEakEEciEUQ///f38hIAJAAkADQCAgIAgqAtgBjF9BAXNF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Ig4gDiAPXRsgDiAOXBs4AgAgA0EQaiAQIBAgFiAWIBMgBRsgEyATXBsiDiAOIBBdGyAOIA5cGzgCACAEKAJIIgUgBCgCREYEQCAEQUBrIAVBARDFBSAEKAJAIQsgBCgCSCEFCyAKQQxqIQogBUECdCALaiAHNgIAIAQgBUEBaiIGNgJIIAcgDUcgCSEHDQALIAQoAiAiByAEKAIcIgNGBEAgBEEYaiADEMMFIAQoAiAhBwsgBCgCGCAHQQd0aiIDQQE2AmAgA0L////7////v383AzAgA0L////79///v/8ANwMgIANC////+/f//7//ADcDECADQv////v3//+//wA3AwggA0L////79///v/8ANwMAIAMgBC8AXTsAdSADQdgAakL////7////v383AwAgA0HQAGpC////+////79/NwMAIANByABqQv////v///+/fzcDACADQUBrQv////v///+/fzcDACADQThqQv////v///+/fzcDACADQShqQv////v3//+//wA3AwAgA0EYakL////79///v/8ANwMAIANB7ABqQn83AgAgA0HkAGpCfzcCACADQfQAakEAOgAAIANB9wBqIARB3wBqLQAAOgAAIANBADsBeCADIAQoAWA2AXogA0H+AGogBEHkAGovAQA7AQAgBCAHQQFqNgIgIARB4ABqIgMgBCAEKAJAIgcgBiAEKAJQIgYgBCgCWEEAQQAQXCAEIANBGGoqAgAiDjgCFCAEIARB9ABqKgIAIg84AhAgBCAEQfAAaioCACIQOAIMIAQgBEHsAGoqAgAiFTgCCCAEIARB6ABqKgIAIhQ4AgQgBCAEKgJkIhM4AgAgBCgCIEUNByAEKAIYIgNB////ezYCXCADQv////v///+/fzcCVCADIA44AlAgA0H///97NgJMIANC////+////79/NwJEIAMgDzgCQCADQf///3s2AjwgA0L////7////v383AjQgAyAQOAIwIANB////+wc2AiwgA0L////79///v/8ANwIkIAMgFTgCICADQf////sHNgIcIANC////+/f//7//ADcCFCADIBQ4AhAgA0H////7BzYCDCADQv////v3//+//wA3AgQgAyATOAIAAkAgBCgCVCIDRQ0AIANBGGxFDQAgBhDaAQsCQCAEKAJEIgNFDQAgA0ECdEUNACAHENoBCyAAIAQpAwA3AgAgACABKQIANwJAIABBOGogBEE4aikDADcCACAAQTBqIARBMGopAwA3AgAgAEEoaiAEQShqKQMANwIAIABBIGogBEEgaikDADcCACAAQRhqIARBGGopAwA3AgAgAEEQaiAEQRBqKQMANwIAIABBCGogBEEIaikDADcCACAAQcgAaiABQQhqKAIANgIAIABB1ABqIAJBCGooAgA2AgAgACACKQIANwJMIARBgAFqJAAPC0HIosIAQTNB4KPCABD+CgALIAZBBEHQnsMAKAIAIgBBvwYgABsRAAAACyAGIANB8KPCABDPCAALIAUgA0GApMIAEM8IAAsgCCADQZCkwgAQzwgACyAHIANBnMjBABDPCAALIAcgA0GsyMEAEM8IAAtBAEEAQYzIwQAQzwgAC4cPAgl/HX4jAEEga0FgcSEGIAFBFGooAgAiAyACTQRAIABBBDYCGA8LIAEoAgAhCgJAIAEoAggiCyABQQxqKAIAIgcgAkHkAWxqIgQpAtwBIg2nIgVNDQAgBCkC1AEhDCANQiCIpyEIAkACfyACIAVBBHQgCmoiCSgCCCIFRgRAIAlBCGoMAQsDQCAFIANPDQIgBUHkAWwgB2oiCSgC1AEiBSACRw0ACyAJQdQBagsgDD4CAAsgCyAITQ0AIAxCIIinIQkgAiAIQQR0IApqIggoAgwiBUcEQANAIAUgA08NAiAFQeQBbCAHaiIIKALYASIFIAJHDQALIAhB2AFqIAk2AgAMAQsgCEEMaiAJNgIACyABQRRqIANBf2oiBTYCACAEQRhqIgMpAgAhDCAFQeQBbCAHaiIBKQIAIQ4gASkCCCEPIAEpAhAhECADIAFBGGopAgA3AgAgBCkCECENIAQgEDcCECAEKQIIIRAgBCAPNwIIIAQpAgAhDyAEIA43AgAgBEE4aiIDKQIAIQ4gAUEgaikCACERIAFBKGopAgAhEiABQTBqKQIAIRMgAyABQThqKQIANwIAIARBMGoiAykCACElIAMgEzcCACAEQShqIgMpAgAhEyADIBI3AgAgBEEgaiIDKQIAIRIgAyARNwIAIARB2ABqIgMpAgAhESABQUBrKQIAIRQgAUHIAGopAgAhFSABQdAAaikCACEWIAMgAUHYAGopAgA3AgAgBEHQAGoiAykCACEmIAMgFjcCACAEQcgAaiIDKQIAIRYgAyAVNwIAIARBQGsiAykCACEVIAMgFDcCACAEQfgAaiIDKQIAIRQgAUHgAGopAgAhFyABQegAaikCACEYIAFB8ABqKQIAIRkgAyABQfgAaikCADcCACAEQfAAaiIDKQIAIScgAyAZNwIAIARB6ABqIgMpAgAhGSADIBg3AgAgBEHgAGoiAykCACEYIAMgFzcCACAEQZgBaiIDKQIAIRcgAUGAAWopAgAhGiABQYgBaikCACEbIAFBkAFqKQIAIRwgAyABQZgBaikCADcCACAEQZABaiIDKQIAISggAyAcNwIAIARBiAFqIgMpAgAhHCADIBs3AgAgBEGAAWoiAykCACEbIAMgGjcCACABQcABaikCACEgIAFByAFqKQIAISEgAUHQAWopAgAhIiABQdgBaikCACEjIAFBoAFqKQIAISQgAUGoAWopAgAhHSABQbABaikCACEeIAFBuAFqKQIAIR8gBEHgAWogAUHgAWooAgA2AgAgBEG4AWoiASkCACEaIAEgHzcCACAEQbABaiIBKQIAIR8gASAeNwIAIARBqAFqIgEpAgAhHiABIB03AgAgBEGgAWoiASkCACEdIAEgJDcCACAEQdgBaiIBKQIAISQgASAjNwIAIARB0AFqIgEpAgAhIyABICI3AgAgBEHIAWoiASkCACEiIAEgITcCACAEQcABaiIBKQIAISEgASAgNwIAIAYgITcDACAGICI3AwggBiAjNwMQIAYgJDcDGCAFIAJNBEAgACAPNwIAIABBqAFqIB43AgAgAEGgAWogHTcCACAAQYgBaiAcNwIAIABBgAFqIBs3AgAgAEHoAGogGTcCACAAQeAAaiAYNwIAIABByABqIBY3AgAgAEFAayAVNwIAIABBKGogEzcCACAAQSBqIBI3AgAgACAQNwIIIABB0AFqIAYoAhA2AgAgAEHIAWogBikDCDcCACAAQcABaiAGKQMANwIAIABBsAFqIB83AgAgAEGQAWogKDcCACAAQfAAaiAnNwIAIABB0ABqICY3AgAgAEEwaiAlNwIAIAAgDTcCECAAQbgBaiAaNwIAIABBmAFqIBc3AgAgAEH4AGogFDcCACAAQdgAaiARNwIAIABBOGogDjcCACAAQRhqIAw3AgAPCwJAIAsgAkHkAWwgB2opAtwBIiCnIgFNDQAgIEIgiKchBAJAAn8g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AgAhDyAAQdAAaikCACEQIAFB2ABqIABB2ABqKQIANwIAIAFB0ABqIBA3AgAgAUHIAGogDzcCACABQUBrIA43AgAgAEEgaikCACEOIABBKGopAgAhDyAAQTBqKQIAIRAgAUE4aiAAQThqKQIANwIAIAFBMGogEDcCACABQShqIA83AgAgAUEgaiAONwIAIAApAgAhDiAAKQIIIQ8gACkCECEQIAFBGGogAEEYaikCADcCACABIBA3AhAgASAPNwIIIAEgDjcCACABQeABaiAAQeABaigCADYCACACIAVNDQACQCAIIAwpAgAiDqciAE0NACAOQiCIpyEBAkACfyAAQQR0IAdqIgMoAggiACACRgRAIANBCGoMAQsDQCAAIAJPDQIgAiAAQeQBbCAGaiIDKALUASIARw0ACyADQdQBagsgBTYCAAsgCCABTQ0AIAFBBHQgB2oiASgCDCIAIAJHBEADQCAAIAJPDQIgAiAAQeQBbCAGaiIBKALYASIARw0ACyABQdgBaiAFNgIADAELIAFBDGogBTYCAAsgDSAFQeQBbCAGaiIBKAIQIgBNDQEgAEEMbCAKaiICKAIAQQFHDQEgAigCBCABKAIURw0BIABBDGwgCmogBTYCCAsgCUEQaiQADwtBmYLAAEETQfSlwAAQnAkAC7cLAgh/BH4jAEGgAWsiAiQAIAJBAzYCBCACIAE2AgACQAJAAkACQCABKAIEIgNBB00EQBCMCyEDDAELIAEgA0F4ajYCBCABIAEoAgAiA0EIajYCACADKQAAEKcGIgtCIIinIQMgC6dFDQELIAIgAzYCTAwBCyACQcgAaiABIAMQ6wIgAigCSEEBRg0AIAIoAkwiCEUEQEEAQZyGwABB7ITAABDeBSEBIABBATYCACAAIAE2AgQMAgsgAkHQAGopAwAhCyACQcgAaiACEFgCQAJAAn8gAigCSEEBRwRAIAJB5ABqKAIAIgENAkEBQZyGwABB7ITAABDeBQwBCyACKAJMCyEBIABBATYCACAAIAE2AgQMAQsgAkEYaiACQdwAaikCADcDACACQRBqIAJB1ABqKQIANwMAIAJBJGogAkHoAGopAwA3AgAgAkEsaiACQfAAaikDADcCACACQTRqIAJB+ABqKQMANwIAIAJBPGogAkGAAWopAwA3AgAgAkHEAGogAkGIAWooAgA2AgAg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IRogBUL////39/////4ANwIAIABBFGoiBSoCACEcIABBGGoqAgAgBUL////39/////4ANwIAIABBEGoqAgAhHSAAKgIMIRggAEL////39/////4ANwIMAn8gGCACQQZ0IBVqIgQqAgAiGJWOIhmLQwAAAE9dBEAgGagMAQtBgICAgHgLIQAgGJWOIhdDAAAAz2AhAyAAQYCAgIB4IBlDAAAAz2AbIQAgGUP///9OXiEFAn8gF4tDAAAAT10EQCAXqAwBC0GAgICAeAtBgICAgHggAxshAiAXQ////05eIQMCfyAaIBiVjiIai0MAAABPXQRAIBqoDAELQYCAgIB4CyEKQf////8HIAAgBRshACAZIBlcIQVB/////wcgAiADGyECIBcgF1whDAJ/IBsgGJWOIhmLQwAAAE9dBEAgGagMAQtBgICAgHgLIQtBACAAIAUbIQNBACACIAwbIQYCfyAcIBiVjiIXi0MAAABPXQRAIBeoDAELQYCAgIB4CyEAIAMgBkoCfyAdIBiVjiIYi0MAAABPXQRAIBioDAELQYCAgIB4CyECDQMCQEEAQf////8HIAJBgICAgHggGEMAAADPYBsgGEP///9OXhsgGCAYXBsiBUEAQf////8HIAtBgICAgHggGUMAAADPYBsgGUP///9OXhsgGSAZXBsiCEwEQEEAQf////8HIABBgICAgHggF0MAAADPYBsgF0P///9OXhsgFyAXXBsiDEEAQf////8HIApBgICAgHggGkMAAADPYBsgGkP///9OXhsgGiAaXBsiDUwEQCAEQQRqIRYMAgsDQCAFIQADQCAAIAhIBEAgACAISCAAaiIAIAhMDQELCyADIAZODQYgAyAGSCADaiIDIAZMDQALDAULA0AgAyAGTg0FIAMgBkggA2oiAyAGTA0ACwwECwNAIAMiCiADIAZIaiEDIAUhAgNAIAIiCyACIAhIaiECIAwhAAJAA0ACQCAHIAs2AhQgByAKNgIQIAcgADYCGCAWIAdBEGoQpAIiBARAIAkgBCgCACIETQ0BAkAgBEEsbCAQaiIEKAIAQQFGBEAgBCgCBCIEDQFBgL7AAEErQeihwQAQ2wkAC0GkoMEAQRNB2KHBABD7CgALIAQgBC0AkAEiBEEBIARBAUsbOgCQAQsgACANTg0CIAAgDUggAGoiACANTA0BDAILCyAE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IQkgAioCACEFIAIqAgQhBCACKgIIIQYgA0EYaiACEJkCAn0gAioCDCIOQwAAAABbBEAgA0E4aioCACEGIANBNGoqAgAhDiADQSxqKgIAIQ8gA0EoaioCACEFIAMqAjAhGSADKgIkIRogAyoCICEQIAMqAhwhESADKgIYDAELIAsgBJMiByAMIAaTIgaUQwAAAACSQwAAgD8gDpUiBJQiDyADQTRqKgIAkiEOIAggBZMiBSAGlEMAAAAAkiAElCIQIAMqAjCSIRkgDyADQSxqKgIAkiEPIAUgB5RDAAAAAJIgBJQiESADKgIkkiEaIBAgAyoCIJIhECARIAMqAhySIREgBiAGlCIGIAUgBZQiGyAHIAeUIgWSkkMAAAAAkiEHIAQgBiAHkpQgA0E4aioCAJIhBiAEIAUgB5KUIANBKGoqAgCSIQUgBCAbIAeSlCADKgIYkgshBCADIAw4AhAgAyALOAIMIAMgCDgCCCADQThqIAkgBpI4AgAgA0E0aiANIA6SOAIAIANBLGogEyAPkjgCACADQShqIAogBZI4AgAgAyAUIBmSOAIwIAMgFSAakjgCJCADIBYgEJI4AiAgAyAXIBGSOAIcIAMgGCAEkjgCGCAAIANBCGogEiADQRhqEJwBDAILIAAgASkCADcCACAAQShqIAFBKGooAgA2AgAgAEEgaiABQSBqKQIANwIAIABBGGogAUEYaikCADcCACAAQRBqIAFBEGopAgA3AgAgAEEIaiABQQhqKQIANwIADAELIAAgAikCADcCACAAQShqIAJBKGooAgA2AgAgAEEgaiACQSBqKQIANwIAIABBGGogAkEYaikCADcCACAAQRBqIAJBEGopAgA3AgAgAEEIaiACQQhqKQIANwIACyADQUBrJAALkQoCAX8CfQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIAQQFrDggBAgMEBQYHEQALIABBDGooAgAiAyACTw0IIANB5AFsIAFqIgEoAhgNByABQTxqIABBJGooAgA2AgAgAUE0aiAAQRxqKQIANwIAIAFB6ABqIABB5ABqKQIANwIAIAFB8ABqIABB7ABqKAIANgIAIAFBkAFqIABBmAFqKgIAOAIADwsgAEEIaigCACIDIAJPDQggA0HkAWwgAWoiASgCGA0GIAFBPGogAEEs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KAIAIgBBvwYgABsRAAAACxCWDAALswoCB38FfiMAQeAIayIEJAACf0EEIAG9IgtC////////////AINQDQAaIAtC/////////weDIg9CgICAgICAgAiEIAtCAYZC/v///////w+DIAtCNIinQf8PcSIGGyIMQgGDIQ4CQCALQoCAgICAgID4/wCDIg1QRQRAIA1CgICAgICAgPj/AFINAUEDQQIgD1AbDAILIAZBzXdqIQZCASENIA6nQQFzDAELQoCAgICAgIAgIAxCAYYgDEKAgICAgICACFEiBxshDEICQgEgBxshDUHLd0HMdyAHGyAGaiEGIA6nQQFzCyEFIAQgBjsB2AggBCANNwPQCCAEQgE3A8gIIAQgDDcDwAggBCAFOgDaCAJ/IAVBAkYEQEGE+cIADAELIAtCOIhCgAGDIQsgAkUEQCALQgeIpyEIQYT5wgBB//jCACALUBsMAQtBASEIQYD5wgBB//jCACALUBsLIQICQAJAAkACQAJAAkACQAJAAkACQAJAIAVBfmoiBUEDIAVB/wFxQQNJG0H/AXFBAWsOAwEDAgALIARBAzYCiAggBEGI+cIANgKECAwICyAEQQM2AogIIARBhfnCADYChAgMBwsgBkEQdEEQdSIFQXRBBSAFQQBIG2wiBUG//QBLDQEgBEGACGogBEHACGogBCAFQQR2QRVqIgZBACADa0GAgH4gA0GAgAJJGyIFEOEBIAVBEHRBEHUhBQJAIAQoAoAIRQRAIARBsAhqIARBwAhqIAQgBiAFEFYMAQsgBEG4CGogBEGICGooAgA2AgAgBCAEKQOACDcDsAgLIAQvAbgIIgdBEHRBEHUiCSAFSgRAIAQoArQIIgZFDQMgBCgCsAgiCi0AAEExSQ0EAkAgCUEBTgRAIAQgCjYChAhBAiEFIARBAjsBgAggBiAHTQ0BIARBlAhqQQE2AgAgBEGQCGpB/vjCADYCACAEIAc2AogIIARBoAhqIAYgB2siBjYCACAEQZwIaiAHIApqNgIAIARBAjsBmAggBEECOwGMCEEDIQUgBiADTw0IIARBqAhqIAMgBms2AgAgBEEAOwGkCEEEIQUMCAsgBEGgCGogBjYCACAEQZwIaiAKNgIAIARBADsBjAggBEGQCGpBACAJayIHNgIAIARBAjsBmAggBEECNgKICCAEQfz4wgA2AoQI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AjAgA0KMgICAgAE3AiggA0KAgICAwAA3AiAgB0MAAADDYCECQQBB/wACfyAHi0MAAABPXQRAIAeoDAELQYCAgIB4C0GAfyACGyAHQwAA/kJeGyAHIAdcG0EYdEGAgIAIakEYdUECbSIBQRh0QRh1IQIgAUH/AXFBAk8NAiADQQhqIANBIGogAkEEdGoiBUEIaiIEKQIANwMAIAMgBSkCADcDACADQThqQv2BgICQHTcCACADQtmBgICwHzcCMCADQvSBgICAHDcCKCADQtCBgICgHjcCICADQRBqIgFBCGogBCkCADcDACADIAUpAgA3AxAgCowhCyADIQQgCCENIAkgB5QiCSEMIAiMIg4hBwwDCyADQQhqIANBIGogAkEEdGoiBUEIaiIEKQIANwMAIAMgBSkCADcDACADQThqQvuBgICgGzcCACADQvKBgIDgHzcCMCADQumBgICAGTcCKCADQuCBgIDAHTcCICADQRBqIgFBCGogBCkCADcDACADIAUpAgA3AxAgCYwhDCADIQQgCiAHlCILIQogCIwiDSEOIAghBwwCCyADQQhqIANBIGogAkEEdGoiBUEIaiIEKQIANwMAIAMgBSkCADcDACADQThqQv2BgIDAHTcCACADQvSBgIDgHzcCMCADQtmBgICAGTcCKCADQtCBgICgGzcCICADQRBqIgFBCGogBCkCADcDACADIAUpAgA3AxAgCowhCyAJjCEMIAMhBCAIIAeUIg0iCCEOIAghBwwBCyACQQJBkPHBABDPCAALIABBBDYCVCAAIAc4AiQgACAOOAIYIAAgDTgCDCAAIAk4AgggACAKOAIEIAAgCDgCACAAIAQpAgA3AjAgACABKQIANwJAIABBLGogDDgCACAAQShqIAo4AgAgAEEgaiAMOAIAIABBHGogCzgCACAAQRRqIAk4AgAgAEEQaiALOAIAIABBOGogBEEIaikCADcCACAAQcgAaiABQQhqKQIANwIAIAAgAkEDbCAGakEKajYCUCADQUBrJAALgQkCAX8RfSMAQZACayIFJAAgBUEgakEANgIAIAVBwAFqQQA2AgAgBUIANwMYIAVCADcDuAEgBUKCgICAMDcDECAFQoCAgIAQNwMIIAVBzABqQQBB7AAQ5AoaIAJBEGoqAgAiDIwiFCACQQxqKgIAIgsgC5QgDCAMlJIgAkEU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DfURPpKUQ6mqqj6SlJKUIQEgAwRAIAAgAZMPCyACQQJ0IgJBxMvCAGoqAgAgASACQdTLwgBqKgIAkyAAk5MiACAAjCAEQX9KGw8LIAcL6QcCBn8FfiMAQYABayIDJAACf0EEIAG9IglC////////////AINQDQAaIAlC/////////weDIg1CgICAgICAgAiEIAlCAYZC/v///////w+DIAlCNIinQf8PcSIFGyIKQgGDIQwCQCAJQoCAgICAgID4/wCDIgtQRQRAIAtCgICAgICAgPj/AFINAUEDQQIgDVAbDAILIAVBzXdqIQVCASELIAynQQFzDAELQoCAgICAgIAgIApCAYYgCkKAgICAgICACFEiBBshCkICQgEgBBshC0HLd0HMdyAEGyAFaiEFIAynQQFzCyEEIAMgBTsBeCADIAs3A3AgA0IBNwNoIAMgCjcDYCADIAQ6AHoCfyAEQQJGBEBBhPnCACEFQQAMAQsgCUI4iEKAAYMhCSACRQRAQYT5wgBB//jCACAJUBshBSAJQgeIpwwBC0GA+cIAQf/4wgAgCVAbIQVBAQshAgJAAkACQAJAAkACQAJAAkACQAJAIARBfmoiBEEDIARB/wFxQQNJG0H/AXFBAWsOAwEDAgALIANBAzYCKCADQYj5wgA2AiQMBwsgA0EDNgIoIANBhfnCADYCJAwGCyADQSBqIANB4ABqIANBD2oQiAECQCADKAIgRQRAIANB0ABqIANB4ABqIANBD2oQRQwBCyADQdgAaiADQShqKAIANgIAIAMgAykDIDcDUAsgAygCVCIERQ0BIAMoAlAiCC0AAEExSQ0CAkAgAy4BWCIGQQFOBEAgAyAINgIkQQIhByADQQI7ASAgBCAGQf//A3EiBk0NASADQTRqQQE2AgAgA0EwakH++MIANgIAIAMgBjYCKCADQUBrIAQgBmsiBDYCACADQTxqIAYgCGo2AgAgA0ECOwE4IANBAjsBLEEDIQcgBEEATw0GIANByABqQQAgBGs2AgAgA0EAOwFEQQQhBwwGCyADQUBrIAQ2AgAgA0E8aiAINgIAIANBADsBLCADQTBqQQAgBmsiCDYCACADQQI7ATggA0ECNgIoIANB/PjCADYCJCADQQI7ASBBAyEHQQAgBE0NBUEAIARrIgQgCE0NBSADQcgAaiAEIAZqNgIAIANBADsB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ESARlJMgB5UhGCAIIAyUIBQgFJSTIAeVIRYLIAAgASkCADcCCCAAIAMpAgA3AhQgACAFKQIANwJ8IAAgBSkCDDcCiAEgACAFKQIYNwKUASAAQRBqIAFBCGooAgA2AgAgAEEcaiADQQhqKAIANgIAIABBhAFqIAVBCGooAgA2AgAgAEGQAWogBUEUaigCADYCACAAQZwBaiAFQSBqKAIANgIAIABBqAFqIAVBLGooAgA2AgAgACAFKQIkNwKgASAAIAUpAjA3AqwBIABBtAFqIAVBOGopAgA3AgAgAEG8AWogBUFAaykCADcCACAAIAUpAkg3AsQBIABBzAFqIAVB0ABqKQIANwIAIABB1AFqIAVB2ABqKQIANwIAIAIoAgghASAEKAIIIQIgAEHsAGogFjgCACAAQegAaiAXOAIAIABB5ABqIBg4AgAgAEHgAGogGTgCACAAQdwAaiAaOAIAIAAgGzgCWCAAQdQAaiALOAIAIABB0ABqICM4AgAgAEHMAGogEzgCACAAQcgAaiAfOAIAIABBxABqICE4AgAgACAKOAJAIABBPGogDjgCACAAQThqICI4AgAgAEE0aiAkOAIAIABBMGogHjgCACAAQSxqICA4AgAgACANOAIoIAAgHDgCJCAAIB04AiAgACACNgIEIAAgATYCACAAIAUtALQBOgDcASAFKQJ0IQYgACAFKgKYATgCeCAAIAY3AnALgwkBAX8jAEEwayICJAACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAALQAAQQFrDhEBAgMEBQYHCAkKCwwNDg8QEQALIAIgAC0AAToACCACQSxqQQE2AgAgAkICNwIcIAJBqNHCADYCGCACQboGNgIUIAIgAkEQajYCKCACIAJBCGo2AhAgASACQRhqENQIDBELIAIgAEEIaikDADcDCCACQSxqQQE2AgAgAkICNwIcIAJBjNHCADYCGCACQSM2AhQgAiACQRBqNgIoIAIgAkEIajYCECABIAJBGGoQ1AgMEAsgAiAAQQhqKQMANwMIIAJBLGpBATYCACACQgI3AhwgAkGM0cIANgIYIAJBuwY2AhQgAiACQRBqNgIoIAIgAkEIajYCECABIAJBGGoQ1AgMDwsgAiAAQQhqKwMAOQMIIAJBLGpBATYCACACQgI3AhwgAkHw0MIA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QcivwAAQzwgAC8EHAQN/IwBBgA9rIgIkACACIAE2AhQgAkEYaiACQRRqEO8GIAIoAhghAyACQQhqIgEgAigCIDYCBCABIAM2AgAgAiACKQMINwOgCyACQagLaiACQaALahAcIAIoAqwLIQECQAJAIAIoAqgLQQFGBEAgAiABNgLMByACQQE2AsgHIAJByAdqQQRyEJ8HDAELIAJByAdqIgRBCGogAkGwC2pB0AMQngoaIAIgATYCzAcgAkEANgLIByACQYAFaiAEQQRyQcgCEJ4KGiACQZQKaigCACEBIAJB+ANqIARB0AJqQYgBEJ4KGiABQQJGDQAgAkGwAWoiAyACQYAFakHIAhCeChogAkEoaiIEIAJB+ANqQYgBEJ4KGiAAQQxqIANBCGooAgA2AgAgACACKQKwATcCBCAAQdQCaiACKQIoNwIAIABB3AJqIARBCGopAgA3AgAgAEHkAmogBEEQaigCADYCACAAQRBqQQE2AgAgAEEBNgIAIABBFGogA0EMakHEABCeChogAEGQAWogA0GIAWopAgA3AgAgAEGIAWogA0GAAWopAgA3AgAgAEGAAWogA0H4AGopAgA3AgAgAEH4AGogA0HwAGopAgA3AgAgAEHwAGogA0HoAGopAgA3AgAgAEHoAGogA0HgAGopAgA3AgAgAEHgAGogA0HYAGopAgA3AgAgAEHYAGogAikCgAI3AgAgAEGYAWogA0GQAWpB5AAQngoaIABB/AFqIAJBpANqQcQAEJ4KGiAAQdACaiABNgIAIABByAJqIANBwAJqKQIANwIAIABBwAJqIAIpAugDNwIAIABB6AJqIAIpAjw3AgAgAEHwAmogAkHEAGopAgA3AgAgAEH4AmogBEEkaikCADcCACAAQYADaiACQdQAaikCADcCACAAQYgDaiACQdwAaikCADcCACAAQZADaiACQeQAaikCADcCACAAQZgDaiAEQcQAaigCADYCACAAQdQDaiAEQYABaikCADcCACAAQcwDaiAEQfgAaikCADcCACAAQcQDaiAEQfAAaikCADcCACAAQbwDaiAEQegAaikCADcCACAAQbQDaiAEQeAAaikCADcCACAAQawDaiAEQdgAaikCADcCACAAQaQDaiACQfgAaikCADcCACAAQZwDaiACKQJwNwIAAkAgAigCGCIARQ0AIAIoAhxF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IgJBIGogAUEgaigCADYCACACQRhqIAFBGGopAgA3AwAgAkEQaiABQRBqKQIANwMAIAJBCGogAUEIaikCADcDACAEIAEpAgA3AwggAiADQQRJDQIaIANBBEHI4sEAEM8IAAtBASEDQQAgACoCICABKgIAkyIFIAWUIABBJGoqAgAgASoCBJMiBSAFlJIgAEEoaioCACABKgIIkyIFIAWUkkMAAAAAkkMAAKA1XQ0CGgsgACADNgK8ASAEQQhqIgJBIGogAUEgaigCADYCACACQRhqIAFBGGopAgA3AwAgAkEQaiABQRBqKQIANwMAIAJBCGogAUEIaikCADcDACAEIAEpAgA3AwggAgshASADQSRsIABqIgBBQGsgAUEgaigCADYCACAAQThqIAFBGGopAgA3AgAgAEEwaiABQRBqKQIANwIAIABBKGogAUEIaikCADcCACAAQSBqIAEpAgA3AgBBAQsgBEEwaiQAC4gHAgN/AX0gACgCACgCACICQQRqIgQoAgAgAkEIaiIDKAIAIgBrQQdNBEAgAiAAQQgQnwYgAygCACEACyACKAIAIABqQgM3AAAgAyAAQQhqIgA2AgAgASoCACEFIAQoAgAgAGtBA00EQCACIABBBBCfBiACQQhqKAIAIQALIAIoAgAgAGogBTgAACACQQhqIgMgAEEEaiIANgIAIAEqAgQhBSACQQRqIgQoAgAgAGtBA00EQCACIABBBBCfBiADKAIAIQALIAIoAgAgAGogBTgAACADIABBBGoiADYCACABKgIIIQUgBCgCACAAa0EDTQRAIAIgAEEEEJ8GIAJBCGooAgAhAAsgAigCACAAaiAFOAAAIAJBCGoiAyAAQQRqIgA2AgAgASoCDCEFIAJBBGoiBCgCACAAa0EDTQRAIAIgAEEEEJ8GIAMoAgAhAAsgAigCACAAaiAFOAAAIAMgAEEEaiIANgIAIAEqAhAhBSAEKAIAIABrQQNNBEAgAiAAQQQQnwYgAkEIaigCACEACyACKAIAIABqIAU4AAAgAkEIaiIDIABBBGoiADYCACABKgIUIQUgAkEEaiIEKAIAIABrQQNNBEAgAiAAQQQQnwYgAygCACEACyACKAIAIABqIAU4AAAgAyAAQQRqIgA2AgAgASoCGCEFIAQoAgAgAGtBA00EQCACIABBBBCfBiACQQhqKAIAIQAL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DQEMAgsgBCAJXQ0BIAQgCl4NAQsgEiALIBSUIAcgE5QgCCAQlJOSkiEFIA2MIQQCQCAXIAsgDJQgByAOlCAIIA+Uk5KSIgdDAAAAAFwEQCANIAWTQwAAgD8gB5UiCJQhByAEIAWTIAiUIgUgB14hACAHIAUgABsiCCAIIAYgBiAIXRsgBiAGXBsgAyADIAUgByAAGyIGIAMgBl0bIAYgBlwbXkUNAQwCCyAFIARdDQEgBSANXg0BC0EBIQELIAELgwYBCX8jAEEQayIJJAAgACgCACgCACIIQTxqIgUoAgAgAU0EQCAJQQA6AAQgCUF/NgIAAkAgAUEBaiIHIAUoAgAiBE0EQCAIQTxqIAc2AgAMAQsgCS0ABCELIAkoAgAhDCAEIQUgCEE4aigCACAEayAHIARrIgpJBEAgCEE0aiAEIAoQygUgCEE8aigCACEFCyAIKAI0IAVBBHRqIQYgCkECTwRAIAEgBGshBANAIAYgDDYCACAGQQhqQn83AgAgBkEEaiALOgAAIAZBEGohBiAEQX9qIgQNAAsgBSAKakF/aiEFCyAIQTxqIAoEQCAGIAs6AAQgBiAMNgIAIAYgCS8ADTsABSAGQn83AgggBkEHaiAJQQ9qLQAAOgAAIAVBAWohBQsgBTYCAAsCQCAHIAAoAgQiBEEIaiIKKAIAIgVNDQAgByAFayEIIARBBGooAgAgBSIHayAISQRAIAQgBSAIELEFIARBCGooAgAhBwsgBCgCACAHQRhsaiEGIAhBAk8EQCABIAVrIQQDQCAGQv////v3//+//wA3AgAgBkEQakL////7////v383AgAgBkEIakL////79///v383AgAgBkEYaiEGIARBf2oiBA0ACyAHIAhqQX9qIQcLIAhFDQAgBkL////79///v383AgggBkL////79///v/8ANwIAIAZBEGpC////+////79/NwIAIAdBAWohBwsgCiAHNgIACwJAIAAoAgAoAgAiBUE8aigCACIHIAFLBEAgBSgCNCABQQR0aiIFIAE2AgggBUEMaiACNgIAIAAoAgQiAigCCCIFIAFNDQEgAigCACABQRhsaiICIAMpAgA3AgAgAkEQaiADQRBqKQIANwIAIAJBCGogA0EIaikCADcCACAAKAIIIgAoAggiBCAAQQRqKAIARgRAIAAgBEEBEMUFIAAoAggh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AABcBEAgESAUlCASIAaUIA8gB5SSkiEGQQAhAiAKQwAAAABeQQFzDQEgBkMAAAAAXkUNAQwDCyAKQwAAAABeRQ0BQQAhAgwCCyAGIAaUIAogCJSTIgdDAAAAAF0NASAGjCAHEKsBkyAIlSILQwAAAABfIQFDAAAAACALIAEbIRAgAUEBcw0AIAUNACAHkSAGkyAIlSEQC0EBIQIgECAEXw0AQQAhAgsgACAQOAIEIAAgAjYCAAu2BQICfwN+IwBB4ABrIgMkACADQQhqIgIQggogA0HcAGpBADoAACADQdQAakIANwIAIAJBxABqQgA3AgAgAkE8akIANwIAIAJBNGpCADcCACAAQgA3AtwBIABB5AFqQQA7AQAgAEIANwPoASAAQfABakIANwMAIANCADcCNCAAQcgAaiACQdgAEJ4KGiAAQdABakIANwMAIABByAFqQgA3AwAgAEHAAWpCADcDACAAQR82ApACIABBjAJqQQA6AAAgAEKKro/ho+H1kT03AoQCIABB/AFqQgA3AgAgAEGYwMAAKAIANgL4ASAAQcQAaiABQShqKAIAIgI2AgAgAEE8aiABQSBqKQMAIgQ3AgAgAEE0aiABQRhqKQMAIgU3AgAgAEEsaiABKQMQIgY3AgAgACAGNwMQIABBGGogBTcDACAAQSBqIAQ3AwAgAEEoaiACNgIAIAAgASkCLDcCoAEgAEGoAWogAUE0aigCADYCACAAQbQBaiABQUBrKAIANgIAIABBrAFqIAEpAjg3AgAgACABLQB8OgCUAiAAIAEpAwA3AwAgACABQQhqKQMANwMIIAAgASkDUDcDSCAAQdAAaiABQdgAaikDADcDACAAQdgAaiABQeAAaikDADcDACAAQeAAaiABQegAaikDADcDACAAQegAaiABQfAAaikDADcDACAAQfAAaiABQfgAaigCADYCACAAQZwBaiABLQB9OgAAIAAgASkDSDcDuAEgAEHYAWogASoCRDgCACAAIAEtAIEBOgCVAiAAQeUBaiABLQCAAToAAAJAIAEtAH4iAkUNACABLQB/RQ0AIABBAToAjAIgAEEANgKIAiAAQaABaiIBQgA3AwAgAUEIakIANwMAIAFBEGpCADcDAAsgAkUEQCAAQYCAgPx7NgKEAgsgA0HgAGokAAuyBAIGfwh9IwBBQGoiAiQAIABBBGoo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ABDPCAALIAUgAkHQh8AAEM8IAAsgBkEQaiQADwsgBCECIANBf2oLIAJBsIfAABDPCAALlwQCCH8BfiMAQRBrIgYkACAAQQA2AggCfwJAAkAgAUEIaigCACICRQ0AQcCYwwApAwAiClAEQCAGEJgLNgIAIAYoAgApAwghCiAGKAIAIgQoAgAhAiAEIAJBf2o2AgAgAkEBRgRAIAYoAgAQqggLQcCYwwAgCjcDACABQQhqKAIAIgJFDQELQQAgAkUNAhogAEEIaiEJQQEhBwJAA0ACQAJAIAEoAgAgCGoiBEEIaigCACIDKQMIIApRDQAgAyADKAIQIgMgBCgCACADGzYCECADDQAgAUEIaigCACICIAdBf2oiBU0NASABKAIAIAhqIgNBBGooAgAiBARAIANBCGooAgBBFGogBDYCACABQQhqKAIAIQILIAIgBU0NAyABKAIAIAhqIgVBCGoiAygCACgCGEEYahDMBSAGQQhqIgQgAygCADYCACAGIAUpAgA3AwAgBSAFQQxqIAIgB2tBDGwQoAgaIAFBCGogAkF/ajYCAAJAIAkoAgAiAUUNACABIAEoAgAiAUF/ajYCACABQQFHDQAgCRCWCQsgACAGKQMANwIAIABBCGogBCgCADYCAAwECyACIAdGDQMgCEEMaiEIIAFBCGooAgAiBCAHSyAHQQFqIgMhBw0BDAQLCyAFIAJBmLbAABDPCAALIAUgAkGotsAAEM8IAAsgBkEQaiQADwsgBCECIANBf2oLIAJBiLbAABDPCAALjQQCA38MfSMAQTBrIgMkACADIAEqAgwgAioCDCIGXzoAEyADIAEqAgggAioCCCIHXzoAEiADIAEqAgQgAioCBCIIXzoAESADIAEqAgAgAioCACIJXzoAECADIAFBHGoqAgAgAkEcaioCACIKXzoAIyADIAFBGGoqAgAgAkEYaioCACILXzoAIiADIAFBFGoqAgAgAkEUaioCACIMXzoAISADIAEqAhAgAioCECINXzoAICADIANBEGoiBCADQSBqIgUQhQkgAyABQSxqKgIAIAJBLGoqAgAiDl86ACMgAyABQShqKgIAIAJBKGoqAgAiD186ACIgAyABQSRqKgIAIAJBJGoqAgAiEF86ACEgAyABKgIgIAIqAiAiEV86ACAgBCADIAUQhQkgAyABQTxqKgIAIAZgOgAjIAMgAUE4aioCACAHYDoAIiADIAFBNGoqAgAgCGA6ACEgAyABKgIwIAlgOgAgIAMgBCAFEIUJIAMgAUHMAGoqAgAgCmA6ACMgAyABQcgAaioCACALYDoAIiADIAFBxABqKgIAIAxgOgAhIAMgAUFAayoCACANYDoAICAEIAMgBRCFCSADIAFB3ABqKgIAIA5gOgAjIAMgAUHYAGoqAgAgD2A6ACIgAyABQdQAaioCACAQYDoAISADIAFB0ABqKgIAIBFgOgAgIAAgBCAFEIUJIANBMGokAAu2BAEFfyMAQfAAayIDJAAgAS0AHCEGIANB0ABqIAEQxgQgAygCXCADKAJYaiICQf////8AcSEFAkAgAiAFRgRAAkAgAkEEdCIEQQBOBEAgAiAFRkECdCECIARFBEAgAkUNAkEAIQQMBAsgBCACEMgLIgVFDQEgBEEEdkEAIAUbIQQgBSECDAMLIANBCGoiAEEANgIEIAAgATYCABCWDAALIAQgAkHQnsMAKAIAIgBBvwYgABsRAAAACxCWDAALIANBADYCaCADIAQ2AmQgAyACNgJgIAFBGGooAgAiBUUEQCADQQA2AmgLIAEoAhAhAQJAAkAgBCAFSQRAIANB4ABqQQAgBRDKBSADKAJgIQIgAygCaCEEDAELQQAhBCAFRQ0BCyAFQQR0IAFqIQUgBEEEdCACaiECA0AgAiABKQIANwIAIAJBCGogAUEIaigCADYCACACQQxqIAFBDGotAABBAEc6AAAgAkEQaiECIARBAWohBCAFIAFBEGoiAUcNAAsLIANBEGoiAUEQaiICIAMpA2A3AwAgAUEYaiIFIAQ2AgAgAUEIaiIEIANB2ABqKQMANwMAIAMgAykDUDcDEEEgQQQQyAsiAQRAIAEgAykDEDcCACABQRhqIAUoAgA2AgAgAUEQaiACKQMANwIAIAFBCGogBCkDADcCACABIAZBAEc6ABwgAEHM1cEANgIEIAAgATYCACADQfAAaiQADwtBIEEEQdCewwAoAgAiAEG/BiAAGxEAAAALtgQBBX8jAEHwAGsiAyQAIAEtABwhBiADQdAAaiABEMYEIAMoAlwgAygCWGoiAkH/////AHEhBQJAIAIgBUYEQAJAIAJBBHQiBEEATgRAIAIgBUZBAnQhAiAERQRAIAJFDQJBACEEDAQLIAQgAhDICyIFRQ0BIARBBHZBACAFGyEEIAUhAgwDCyADQQhqIgBBADYCBCAAIAE2AgAQlgwACyAEIAJB0J7DACgCACIAQb8GIAAbEQAAAAsQlgwACyADQQA2AmggAyAENgJkIAMgAjYCYCABQRhqKAIAIgVFBEAgA0EANgJoCyABKAIQIQECQAJAIAQgBUkEQCADQeAAakEAIAUQygUgAygCYCECIAMoAmghBAwBC0EAIQQgBUUNAQsgBUEEdCABaiEFIARBBHQgAmohAgNAIAIgASkCADcCACACQQhqIAFBCGooAgA2AgAgAkEMaiABQQxqLQAAQQBHOgAAIAJBEGohAiAEQQFqIQQgBSABQRBqIgFHDQALCyADQRBqIgFBEGoiAiADKQNgNwMAIAFBGGoiBSAENgIAIAFBCGoiBCADQdgAaikDADcDACADIAMpA1A3AxBBIEEEEMgLIgEEQCABIAMpAxA3AgAgAUEYaiAFKAIANgIAIAFBEGogAikDADcCACABQQhqIAQpAwA3AgAgASAGQQBHOgAcIABBzNbBADYCBCAAIAE2AgAgA0HwAGokAA8LQSBBBEHQnsMAKAIAIgBBvwYgABsRAAAAC7EEAQh/IwBBEGsiBCQAAkACfyABKAIEIgIEQEEBIAAoAhggASgCACACIABBHGooAgAoAgwRBQANARoLIAFBDGooAgAiAwRAIAEoAggiAiADQQxsaiEHIABBHGooAgAhBSAEQQhqIgFBf2ohCCAAKAIYIQYgAUEEaiEJA0ACQAJAAkACQAJAAkACQAJAAkACQCACLwEAQQFrDgIBAgALIAIoAgQiAUHBAEkNAiAFKAIMIQADQCAGQdT/wgBBwAAgABEFAA0IIAFBQGoiAUHAAEsNAAsMBgsgAi8BAiEBIAlBADoAACAEQQA2AghBASEAAkACQAJAIAIvAQBBAWsOAgABAgsgAi8BAiIAQegHTwRAQQRBBSAAQZDOAEkbIQMMBgtBASEDIABBCkkNBUECQQMgAEHkAEkbIQMMBQtBAiEACyAAQQJ0IAJqKAIAIgNBBk8NAiADDQNBACEDDAQLIAYgAigCBCACKAIIIAUoAgwRBQANBQwGCyABDQMMBQsgA0EFQcT/wgAQ0QgACyADIQADQCAAIAhqIAEgAUH//wNxQQpuIgFBCmxrQTByOgAAIABBf2oiAA0ACwsgBiAEQQhqIAMgBSgCDBEFAA0BDAILIAFBP00EQCABQdT/wgBqLAAAQb9/TA0GCyAGQdT/wgAgASAFKAIMEQUARQ0BC0EBDAMLIAcgAkEMaiICRw0ACwtBAAsgBEEQaiQADwtB1P/CAEHAAEEAIAFBlIDDABDSAQALhgQBCn0CQCAALQCUAg0AIAIqAgAgAEH0AGoqAgCTIgcgASoCBCIFlCACKgIEIABB+ABqKgIAkyIJIAEqAgAiBJSTIQYgAioCCCAAQfwAaioCAJMiCiAElCAHIAEqAggiCJSTIQcgCSAIlCAKIAWUkyEJIAAgBCAAQYABaioCACIElCAAKgKgAZI4AqABIABBpAFqIgEgBSAElCABKgIAkjgCACAAQagBaiIBIAggBJQgASoCAJI4AgAgAwRAIABBjAJqLQAABEAgACAAKAKQAkEEcjYCkAILIABBADoAjAIgAEGIAmogACoChAKLIgUgBZI4AgALIAkgAEGMAWoqAgAiBZQgByAAQZQBaioCACIElJIgBiAAQZgBaioCACIMlJIhCCAJIABBhAFqKgIAIg2UIAcgAEGIAWoqAgAiCpSSIAYgBZSSIQsgAEGsAWoiASABKgIAIAUgCJQgDSALlCAKIAkgCpQgByAAQZABaioCACIHlJIgBiAElJIiBpSSkpI4AgAgAEGwAWoiASABKgIAIAQgCJQgCiALlCAHIAaUkpKSOAIAIABBtAFqIgEgDCAIlCAFIAuUIAQgBpSSkiABKgIAkjgCACADRQ0AIABBjAJqLQAABEAgACAAKAKQAkEEcjYCkAILIABBADoAjAIgAEGIAmogACoChAKLIgYgBpI4AgALC+MDAgF/DH0jAEHQAGsiBSQAIAMqAgAgAioCECIPkyIKIAJBBGoqAgAiC5QgAyoCBCACQRRqKgIAIhCTIgwgAioCACINlJMiCCAIkiEJIAwgAkEIaioCACIIlCADKgIIIAJBGGoqAgAiEZMiByALlJMiDiAOkiEGIAUgByACQQxqKgIAIg4gCZQgCyAGlCANIAcgDZQgCiAIlJMiByAHkiIHlJOSkjgCECAFIAwgDiAHlCANIAmUIAggBpSTkpI4AgwgBSAKIA4gBpQgCCAHlCALIAmUk5KSOAIIIAFBCGoiAioCACEJIAEqAgAhBiABKgIEIQogBUEYaiIDQRRqIAIoAgA2AgAgBSAJjDgCICAFIAqMOAIcIAUgBow4AhggBSABKQIANwIkIAVBMGogAyAFQQhqIAQQqwIgBSoCMCEJIAUqAjghBiAFKgI0IQogACAFLQA8OgAMIAAgESAGIA4gDSAKlCALIAmUkyIMIAySIgyUIA0gCCAJlCANIAaUkyIHIAeSIgeUIAsgCyAGlCAIIAqUkyIGIAaSIgaUk5KSkjgCCCAAIBAgCiAOIAeUIAggBpQgDSAMlJOSkpI4AgQgACAPIAkgDiAGlCALIAyUIAggB5STkpKSOAIAIAVB0ABqJAALzAMBC30gAioCACIKIANBCGoqAgAiBJQgAkEIaioCACILIAMqAgAiCJSTIgkgCZIhByACQQRqKgIAIgkgCJQgCiADQQRqKgIAIgWUkyIMIAySIQYgBSACQQxqKgIAIgwgB5QgCiAGlCALIAsgBZQgCSAElJMiBSAFkiIFlJOSkiINIAQgDCAGlCAJIAWUIAogB5STkpIiBCAElCAIIAwgBZQgCyAHlCAJIAaUk5KSIgYgBpQgDSANlJKSQwAAAACSEKsBIgiVIQVDAAAAACENIAQgCJUiByAHlCAGIAiVIgYgBpRDAAAAAJKSQwAAAACSEKsBIgRDAAAAAFwEQCAHIASVIAEqAgQiCJQhDiAGIASVIAiUIQ0LIAAgDiAHIAEqAggiB5SSIgQgDCAKIAEqAgAgBZggBSAHlJIiCJQgCSANIAYgB5SSIgeUkyIGIAaSIgaUIAogCyAHlCAKIASUkyIFIAWSIgWUIAkgCSAElCALIAiUkyIEIASSIgSUk5KSIAJBGGoqAgCSOAIIIAAgAkEUaioCACAIIAwgBZQgCyAElCAKIAaUk5KSkjgCBCAAIAIqAhAgByAMIASUIAkgBpQgCyAFlJOSkpI4AgALnQQBAn8jAEFAaiIIJAACQAJAAkAgAEUNACAAKAIAIglBf0YNASAAIAlBAWo2AgAgAUUNACABKAIAIglBf0YNASABIAlBAWo2AgAgAkUNACACKAIAIglBf0YNASACIAlBAWo2AgAgA0UNACADKAIAIglBf0YNASADIAlBAWo2AgAgBEUNACAEKAIAIglBf0YNASAEIAlBAWo2AgAgBUUNACAFKAIAIglBf0YNASAFIAlBAWo2AgAgCCAAQQRqIAFBBGogAkEEaiADQQRqIARBBGogBUEEaiAGIAcQOCAFIAUoAgBBf2o2AgAgBCAEKAIAQX9qNgIAIAMgAygCAEF/ajYCACACIAIoAgBBf2o2AgAgASABKAIAQX9qNgIAIAAgACgCAEF/ajYCAEEAIQAgCC0APCIBQQRHBEBBxABBBBDICyIARQ0DIABBADYCACAAIAgpAwA3AgQgACABOgBAIABBDGogCEEIaikDADcCACAAQRRqIAhBEGopAwA3AgAgAEEcaiAIQRhqKQMANwIAIABBJGogCEEgaikDADcCACAAQSxqIAhBKGopAwA3AgAgAEE0aiAIQTBqKQMANwIAIABBPGogCEE4aigCADYCACAAQcMAaiAIQT1qIgFBAmotAAA6AAAgACABLwAAOwBBCyAIQUBrJAAgAA8LEKIMAAsQowwAC0HEAEEEQdCewwAoAgAiAEG/BiAAGxEAAAALogQCBn8CfiMAQUBqIgIkAAJAIAEoAgQiA0UEQCAAQQI2AgRBACEBDAELIAEgA0F/ajYCBAJAAkACQAJ+IAEoAgAiAygCBCIBRQRAEIwLrUIghkIBhAwBCyADIAFBf2o2AgQgAyADKAIAIgFBAWo2AgAgATEAAEIIhgsiCKdBAXFFBEBBACEBAkACQAJAIAhCCIinIgRB/wFxDgICAQALQRBBBBDICyIBRQ0DIAFBBDoAACABIARB/wFxNgIEDAULIAJBAjYCFCACIAM2AhAgAkEoaiACQRBqEIkEIAIoAihBAUYNAyACKAIsRQRAQQBBxJDAAEHshMAAEN4FIQEMBQsgAkEgaiACQTxqKAIANgIAIAIgAkE0aikCADcDGAJAIAIoAhQEQCACQShqIgNBCGooAgAhBSADIAIoAhAQsgRBASEGIAIoAihBAUcNASACKAIsIQEMBgtBAUHEkMAAQeyEwAAQ3gUhAQwFCyACQQhqIAJBIGooAgA2AgAgAiACKQMYNwMAIAJBMGopAwAhCSACKAIsIQcLIABBDGogAikDADcCACAAQRRqIAJBCGooAgA2AgAgAEEcaiAJNwIAIABBGGogBzYCACAAQQhqIAU2AgAgACAGNgIEDAQLIAhCIIinIQEMAgtBEEEEQdCewwAoAgAiAEG/BiAAGxEAAAALIAIoAiwhAQsgACABNgIEQQEhAQsgACABNgIAIAJBQGskAAu2BAEKfSAAIAEpAgA3AgAgACADKQIANwIMIAAgAikCADcCGCAAIAQpAgA3AiQgAEEIaiABQQhqKAIANgIAIABBFGogA0EIaigCADYCACAAQSBqIAJBCGoiASgCADYCACAAQSxqIARBCGoiAygCADYCACADKgIAIQUgASoCACEGIAQqAgAhByACKgIAIQggBCoCBCEJIAIqAgQhCiAAQfAAakEANgIAIABB6ABqQgA3AgAgAEIANwJgIABCADcCnAEgAEGkAWpBADYCACAAQcQAaiAKjDgCACAAQdwAaiAJjDgCACAAQQA6ALQBIAAgAikCADcCqAEgAEGwAWogASgCADYCACAAQThqIAggBrxBgICAgHhxQYCAgPwDcr4iC4yUOAIAIABB0ABqIAcgBbxBgICAgHhxQYCAgPwDcr4iDIyUOAIAIABBPGogCCAKlEMAAIC/IAYgC5KVIgaUIg04AgAgAEHUAGogByAJlEMAAIC/IAUgDJKVIgWUIg44AgAgACAIIAggC5SUIAaUQwAAgD+SOAIwIABBNGogDSALlDgCACAAQUBrIAogCpQgBpQgC5I4AgAgACAHIAcgDJSUIAWUQwAAgD+SOAJIIABBzABqIA4gDJQ4AgAgAEHYAGogCSAJlCAFlCAMkjgCACAAQYwBakEANgIAIABC////+////7//ADcCdCAAQYQBakIANwIAIABCADcCfCAAQQE6ALUBIABC////+wc3ApABIABBADYCmAEL+AMCB38JfSMAQdAAayIDJAAgAEEIaiIEKgIAIQsgACoCBCEPIAAqAgAhDCADQRxqIgUgBCgCADYCACADIAApAgA3AhQgAyALjCINOAIQIAEqAgghCyAFKgIAIQogAyAMjCIOOAIIIAEqAgAhDCADQRhqKgIAIRAgAyAPjCIROAIMIAEqAgQhDyADKgIUIRIgAyANIAuTIg0gCyAKkyIKIA0gCmAbIg1DAAAAACANQwAAAABgGyINOAIoIAMgESAPkyIKIA8gEJMiECAKIBBgGyIKQwAAAAAgCkMAAAAAYBsiCjgCJCADIA4gDJMiDiAMIBKTIhAgDiAQYBsiDkMAAAAAIA5DAAAAAGAbIg44AiACfQJAIAJFBEAgA0EgaiIEQQxqIQVBAyECIAQhAANAIAJFDQIgBEEQaiEIIAJBAUYhCSAEQQxqIgYgBCAAIAVGIgcbIQQgAEEMaiAFIAcbIQUgAkF/aiECIAYgACAHGyIGIAggAEEEaiAHGyAJGyEAIAYqAgBDAAAAAFsNAAsLIA4gDpQgCiAKlJIgDSANlJJDAAAAAJIQqwEMAQsgA0EwaiADQQhqIAFBABCrAiADKgIwIAyTIgwgDJQgAyoCNCAPkyIMIAyUkiADKgI4IAuTIgsgC5SSQwAAAACSEKsBjAsgA0HQAGokAAvaAwIEfwx9IwBBIGsiBCQAIAAoAgAgACgCBCgCACIFKAJgIAUoAmQhAAJAIAEEQCABQQRqKgIAIgsgACoCECABKgIQkyISlCABKgIAIgwgAEEUaioCACABKgIUkyINlJMiCCAIkiEOIAFBCGoqAgAiCCANlCALIABBGGoqAgAgASoCGJMiCZSTIgogCpIhDyAEQRhqIAkgASoCDCIKIA6UIAsgD5QgDCAMIAmUIAggEpSTIgkgCZIiE5STkpI4AgAgBEEUaiANIAogE5QgDCAOlCAIIA+Uk5KSOAIAIAQgCCAAKgIIIg2UIAsgACoCBCIJlCAMIAAqAgAiEJQgCiAAKgIMIhGUkpKSOAIMIAQgCyAQlCAKIA2UIAwgCZSTkiAIIBGUkzgCCCAEIAogCZQgDCANlJIgCyARlJMgCCAQlJM4AgQgBCAIIAmUIAogEJQgDCARlJMgCyANlJOSOAIAIAQgEiAKIA+UIAggE5QgCyAOlJOSkjgCEAwBCyAEQRhqIABBGGooAgA2AgAgBEEQaiAAQRBqKQIANwMAIARBCGogAEEIaikCADcDACAEIAApAgA3AwALIAQgAiADIAUoAnAgBUH0AGooAgAQakH9AXE6AAAgBEEgaiQAC8MDARJ9IAEqAgQiCiACKgIAIgOUIAEqAgAiESACQQRqKgIAIgSUkyIGIAaSIQkgESACQQhqKgIAIgaUIAEqAggiByADlJMiBSAFkiEOIAMgAUEQaioCACIMlCAEIAEqAgwiEpSTIgUgBZIhDyAGIBKUIAMgAUEUaioCACIIlJMiBSAFkiEQIABBFGogASoCGCIFIAJBGGoqAgAiDSAHIAJBDGoqAgAiCyAJlCADIA6UIAQgByAElCAKIAaUkyIHIAeSIhOUk5KSkiIHIA0gCCALIA+UIAMgEJQgBCAEIAiUIAYgDJSTIgggCJIiDZSTkpKSIgggByAIYBuSOAIAIABBEGogBSACQRRqKgIAIhQgCiALIA6UIAYgE5QgAyAJlJOSkpIiCiAUIAwgCyAQlCAGIA2UIAMgD5STkpKSIgMgCiADYBuSOAIAIAAgBSACKgIQIgwgESALIBOUIAQgCZQgBiAOlJOSkpIiCSAMIBIgCyANlCAEIA+UIAYgEJSTkpKSIgQgCSAEYBuSOAIMIAAgByAIIAcgCF8bIAWTOAIIIAAgCiADIAogA18bIAWTOAIEIAAgCSAEIAkgBF8bIAWTOAIAC78DARB9IAJBFGoqAgAhDiACKgIQIQ8gAkEEaioCACIKIAMqAgAiBpQgAioCACILIANBBGoqAgAiB5STIgggCJIhCSACQQhqKgIAIgggB5QgCiADQQhqKgIAIgSUkyIMIAySIQUgAUEIaioCACIQIAQgAkEMaioCACIMIAmUIAogBZQgCyALIASUIAggBpSTIgQgBJIiBJSTkpIiDZQgASoCACIRIAYgDCAFlCAIIASUIAogCZSTkpIiBpQgAUEEaioCACISIAcgDCAElCALIAmUIAggBZSTkpIiCZSSkiANIAFBFGoqAgAiBZQgAUEMaioCACIEIAaUIAFBEGoqAgAiEyAJlJKSXiEDIAAgECAFIAMbIA0gASoCGCIFlJIiByAMIAsgEiATIAMbIAkgBZSSIgmUIAogESAEIAMbIAYgBZSSIgWUkyIGIAaSIgaUIAsgCCAFlCALIAeUkyIEIASSIgSUIAogCiAHlCAIIAmUkyIHIAeSIgeUk5KSIAJBGGoqAgCSOAIIIAAgDiAJIAwgBJQgCCAHlCALIAaUk5KSkjgCBCAAIA8gBSAMIAeUIAogBpQgCCAElJOSkpI4AgAL6QMCB38EfSABQQhqIgIoAgAiBkUEQCAAQQA2AgAPCyACIAZBf2oiBDYCACABKAIAIARBA3RqIgIqAgQhCSACKAIAIQUCQCAERQRAIAkhCyAFIQcMAQsgASgCACIDKgIEIQsgAyAJOAIEIAMoAgAhByADIAU2AgBBACEBQQEhAiAEQQNPBEBBACAEQX5qIgEgASAESxshCEEAIQQDQCAEQQN0IANqQQBBfyACQQN0IANqIgFBBGoqAgAiCiABQQxqKgIAIgxgIgEbQQFBAiABGyAKIAxfG0F/akH/AXFBAUsgAmoiAUEDdCADaikCADcCACABIQQgAUEBdEEBciICIAhNDQALCwJAAkACQCACIAZBfmpGBEAgAUEDdCADaiACQQN0IANqIgEpAgA3AgAgASAJOAIEIAEgBTYCACACIQEMAQsgAUEDdCADaiICIAk4AgQgAiAFNgIAIAFFDQELA0BBAEF/IAFBf2pBAXYiAkEDdCADaiIEQQRqKgIAIgogCV8iBhtBAUECIAYbIAogCWAbQX9qQf8BcUEBSw0CIAFBA3QgA2ogBCkCADcCACACIgENAAsLQQAhAQsgAUEDdCADaiIBIAk4AgQgASAFNgIACyAAIAc2AgQgAEEIaiALOAIAIABBATYCAAvoAwIHfwF+IwBBIGsiBCQAIAEoAgAhCAJAAn9BACABKAIIIgVFDQAaIAVBA24gBUEDcEEAR2oLrUIMfiIKQiCIpyIDRQRAAkAgCqciCUEATgRAIANFQQJ0IQMgCUUEQCADRQ0CDAQLIAlBDG4gCSADEMgLIgZFDQFBACAGGyEHIAYhAwwDCyAEQQA2AgQgBCAINgIAEJYMAAsgCSADQdCewwAoAgAiAEG/BiAAGxEAAAALEJYMAAtBACEGIARBADYCGCAEIAc2AhQgBCADNgIQAkAgBEEIaiAFBEAgByAFQQNuIgcgBSAHQQNsa0EAR2oiB0kEQCAEQRBqQQAgBxCtBSAEKAIYIQYgBCgCECEDCyAGQQxsIANqIQMDQCAFQQJNDQIgAyAIKQIANwIAIANBCGogCEEIaioCADgCACADQQxqIQMgCEEMaiEIIAZBAWohBiAFQX1qIgUNAAsgBCgCECEDCyADIAYgAhClBiAEKAIIIQYgBCgCDCEFAkAgBCgCFCIIRQ0AIANFDQAgCEEMbEUNACADENoBCwJAIAFBBGooAgAiA0UNACABKAIAIgFFDQAgA0ECdEUNACABENoBCyAAIAY2AgAgACAFNgIEIARBIGokAA8LQbiewABBywBBhJ/AABD6CgALngQCBX8KfSMAQUBqIgUkACADKgIAIg0gAioCACIOkyIKIAqUIAMqAgQiDyACKgIEIhCTIgogCpSSIANBCGoiByoCACIRIAJBCGoiCCoCACISkyIKIAqUkkMAAAAAkhCrASAFQShqIgZBCGoiCSAIKAIANgIAIAZBFGogBygCADYCACAFIAMpAgA3AjQgBUEIaiIDQQhqIAkpAwA3AwAgA0EQaiAGQRBqKQMANwMAIAUgAikCADcDCCAFIAQ4AiAgAEEcaiADEI0EQwAAAD+UIgogCpIhCyAEIASUIgwgDJJDAACgQJUiEyAMQwAAQECUIAogCpRDAACAQJSSQwAAQEGVkiALIAuUQwAAAD+UIAsgBJRDAABAQJRDAAAAPpSSkiAEQ9sPSUCUIASUIASUQwAAgECUQwAAQECVIAogBJQgBJRD2w9JQJQiBCAEkpIgAZQiAZQiCxCrASEEIAxDAAAAP5QgE5IgAZQQqwEhCiALEKsBIQsgAEMAAAAAQwAAgD8gBJUgBEMAAAAAWxs4AhAgAEMAAAAAQwAAgD8gAZUgAUMAAAAAWxs4AgwgACARIBKSQwAAAD+UOAIIIAAgDyAQkkMAAAA/lDgCBCAAIA0gDpJDAAAAP5Q4AgAgAEEUakMAAAAAQwAAgD8gCpUgCkMAAAAAWxs4AgAgAEEYakMAAAAAQwAAgD8gC5UgC0MAAAAAWxs4AgAgBUFAayQAC80DAQ99IAAgASkCEDcCECAAQRhqIAFBGGooAgA2AgAgAkEYaioCACEPIAJBFGoqAgAhECABQQxqKgIAIQ0gAUEIaioCACEOIAJBDGoqAgAhCiACQQRqKgIAIQMgAUEkaioCACEEIAJBCGoqAgAhBSABQSBqKgIAIQYgAioCECERIAEqAgQhByABKgIcIQggAioCACEJIAAgASoCADgCACAAQTBqIAFBMGooAgA2AgAgACABKQIoNwIoIAAgAS0ANDoANCAAIAggCiADIASUIAUgBpSTIgsgC5IiC5QgAyAJIAaUIAMgCJSTIgwgDJIiDJQgBSAFIAiUIAkgBJSTIgggCJIiCJSTkpI4AhwgAEEgaiAGIAogCJQgBSALlCAJIAyUk5KSOAIAIABBJGogBCAKIAyUIAkgCJQgAyALlJOSkjgCACAAIBEgByAKIA0gA5QgDiAFlJMiBCAEkiIElCADIA4gCZQgByADlJMiBiAGkiIGlCAFIAcgBZQgDSAJlJMiByAHkiIHlJOSkpI4AgQgAEEIaiAQIA4gCiAHlCAFIASUIAkgBpSTkpKSOAIAIABBDGogDyANIAogBpQgCSAHlCADIASUk5KSkjgCAAvmAwIHfwF+IwBBIGsiAyQAIAEoAgAhBwJAAn9BACABKAIIIgRFDQAaIARBA24gBEEDcEEAR2oLrUIMfiIJQiCIpyICRQRAAkAgCaciCEEATgRAIAJFQQJ0IQIgCEUEQCACRQ0CDAQLIAhBDG4gCCACEMgLIgVFDQFBACAFGyEGIAUhAgwDCyADQQA2AgQgAyAHNgIAEJYMAAsgCCACQdCewwAoAgAiAEG/BiAAGxEAAAALEJYMAAtBACEFIANBADYCGCADIAY2AhQgAyACNgIQAkAgA0EIaiAEBEAgBiAEQQNuIgYgBCAGQQNsa0EAR2oiBkkEQCADQRBqQQAgBhCtBSADKAIYIQUgAygCECECCyAFQQxsIAJqIQIDQCAEQQJNDQIgAiAHKQIANwIAIAJBCGogB0EIaioCADgCACACQQxqIQIgB0EMaiEHIAVBAWohBSAEQX1qIgQNAAsgAygCECECCyACIAUQrAYgAygCCCEFIAMoAgwhBAJAIAMoAhQiB0UNACACRQ0AIAdBDGxFDQAgAhDaAQsCQCABQQRqKAIAIgJFDQAgASgCACIBRQ0AIAJBAnRFDQAgARDaAQsgACAFNgIAIAAgBDYCBCADQSBqJAAPC0G4nsAAQcsAQYSfwAAQ+goAC/UDAgl/An4jAEEgayIGJAAgAUHhAHBBA3QiBUHMmMMAaiECIAVByJjDAGohCCABQQhqIQoDQBC1DCAGKAIYIQkgBikDECELAkACQCACKAIAIgNBAUYNACAIKAIAIQUgASgCCCEHIAEpAwAhDCACKAIAIANHDQAgCCgCACAFRg0BCyACKAIAIQQgAkEBNgIAIARBAUYEQEEAIQMDQCADIANBAWogA0EHT0EAIANBCksbGyEDIAIoAgAhBCACQQE2AgAgBEEBRg0ACwsgCigCACEHIAEpAwAhDCACIAQ2AgALAkAgAAJ/QX8gCyAMUiALIAxUGyIFQX8gByAJRyAJIAdJGyAFG0F/RwRAIAYgCyAJIAEpAxAgASgCGBCPCSACKAIAIQQgBigCCCEFIAYpAwAhCyACQQE2AgAgBEEBRgRAQQAhAwNAIAMgA0EBaiADQQdPQQAgA0EKSxsbIQMgAigCACEEIAJBATYCACAEQQFGDQALCyABKQMAIAxSDQIgCigCACAHRw0CIAEgCzcDACABQQhqIAU2AgAgBEECaiIBRQRAIAggCCgCAEEBajYCAEEAIQELIAIgATYCACAAQRBqIAc2AgAgAEEIaiAMNwMAQQAMAQsgAEEAOgABQQELOgAAIAZBIGokAA8LIAIgBDYCAAwACwALyAMBCX0jAEHQAGsiBSQAIAMqAgAgAioCEJMiDSACQQRqKgIAIgeUIAMqAgQgAkEUaioCAJMiDiACKgIAIguUkyIIIAiSIQkgDiACQQhqKgIAIgiUIAMqAgggAkEYaioCAJMiBiAHlJMiDCAMkiEKIAUgBiACKgIMIgwgCZQgByAKlCALIAYgC5QgDSAIlJMiBiAGkiIGlJOSkjgCICAFIA4gDCAGlCALIAmUIAggCpSTkpI4AhwgBSANIAwgCpQgCCAGlCAHIAmUk5KSOAIYIAcgA0EMaioCACINlCALIANBEGoqAgAiDpSTIgkgCZIhCSAIIA6UIAcgA0EUaioCACIGlJMiCiAKkiEKIAUgBiAMIAmUIAcgCpQgCyALIAaUIAggDZSTIgYgBpIiBpSTkpI4AjAgBSAOIAwgBpQgCyAJlCAIIAqUk5KSOAIsIAUgDSAMIAqUIAggBpQgByAJlJOSkjgCKCAFIAVBGGogBUEoaiICEKQKIAIgASABQQxqIAFBGGogBRCdAgJ/IAUoAjhBBEcEQEEBIAUqAigiByAEX0EBc0UNARpBAAwBC0EACyECIAAgBzgCBCAAIAI2AgAgBUHQAGokAAu0AwEPfSADQRRqKgIAIQkgA0EQaioCACEPIANBDGoqAgAhECADKgIIIAJBGGoqAgCTIhIgAioCACIKlCADKgIAIAIqAhCTIg4gAkEIaioCACILlJMiByAHkiEGIA4gAkEEaioCACIHlCADKgIEIAJBFGoqAgCTIgwgCpSTIg0gDZIhEQJAAkAgAUEEaioCACITIAwgAioCDCINIAaUIAogEZQgCyAMIAuUIBIgB5STIgwgDJIiDJSTkpKMlCABKgIAIhQgDiANIAyUIAsgBpQgByARlJOSkpSTIAFBCGoqAgAiDiASIA0gEZQgByAMlCAKIAaUk5KSlJMiBkMAAAAAXkEBc0UEQCAFDQELQQAhAiAGIA4gCSANIAcgEJQgCiAPlJMiCCAIkiIIlCAHIAsgD5QgByAJlJMiBiAGkiIGlCAKIAogCZQgCyAQlJMiCSAJkiIJlJOSkpQgFCAQIA0gBpQgCyAJlCAHIAiUk5KSlCATIA8gDSAJlCAKIAiUIAsgBpSTkpKUkpKVIghDAAAAAGBBAXMNASAIIARfQQFzDQELQQEhAgsgACAIOAIEIAAgAjYCAAvDAwIBfwx9IwBBQGoiBCQAIAMqAgAgAioCECIOkyINIAJBBGoqAgAiCJQgAyoCBCACQRRqKgIAIg+TIgkgAioCACIKlJMiByAHkiELIAkgAkEIaioCACIHlCADKgIIIAJBGGoqAgAiEJMiBSAIlJMiDCAMkiEGIAQgBSACQQxqKgIAIgwgC5QgCCAGlCAKIAUgCpQgDSAHlJMiBSAFkiIFlJOSkjgCECAEIAkgDCAFlCAKIAuUIAcgBpSTkpI4AgwgBCANIAwgBpQgByAFlCAIIAuUk5KSOAIIIARBGGoiAiABIARBCGpBARBNIAQqAhghCyAEKgIgIQYgBCoCHCENIAQtACQhASAAQRRqIAJBFGooAgBBACAEKAIoIgJBA0kiAxs2AgAgACACQQIgAxs2AhAgACABOgAMIAAgECAGIAwgCiANlCAIIAuUkyIJIAmSIgmUIAogByALlCAKIAaUkyIFIAWSIgWUIAggCCAGlCAHIA2UkyIGIAaSIgaUk5KSkjgCCCAAIA8gDSAMIAWUIAcgBpQgCiAJlJOSkpI4AgQgACAOIAsgDCAGlCAIIAmUIAcgBZSTkpKSOAIAIARBQGskAAvDAwEKfSACQQRqKgIAIgogAyoCACIHlCACKgIAIgsgA0EEaioCACIIlJMiCSAJkiEFIAJBCGoqAgAiCSAIlCAKIANBCGoqAgAiBJSTIgwgDJIhBiAEIAJBDGoqAgAiDCAFlCAKIAaUIAsgCyAElCAJIAeUkyIEIASSIgSUk5KSIg0gDZQgByAMIAaUIAkgBJQgCiAFlJOSkiIHIAeUIAggDCAElCALIAWUIAkgBpSTkpIiBiAGlJKSQwAAAACSEKsBIQUgACACQRhqKgIAIAEqAgwiCCANIAWVIgSUIAS8QYCAgIB4cSABKAIIQf////8HcXK+kiIEIAwgCyAIIAYgBZUiBpQgBrxBgICAgHhxIAEoAgRB/////wdxcr6SIgaUIAogCCAHIAWVIgWUIAW8QYCAgIB4cSABKAIAQf////8HcXK+kiIFlJMiByAHkiIHlCALIAkgBZQgCyAElJMiCCAIkiIIlCAKIAogBJQgCSAGlJMiBCAEkiIElJOSkpI4AgggACACQRRqKgIAIAYgDCAIlCAJIASUIAsgB5STkpKSOAIEIAAgAioCECAFIAwgBJQgCiAHlCAJIAiUk5KSkjgCAAvZAwEKfSAAIAEqAgAiA0Orqqo+lCABKgIMIgVDq6qqPpSSIAEqAhgiBkOrqqo+lJIiCSAGkyIGIAaUIAEqAgQiB0Orqqo+lCABQRBqKgIAIgtDq6qqPpSSIAFBHGoqAgAiBEOrqqo+lJIiBiAEkyIEIASUkiABKgIIIgxDq6qqPpQgAUEUaioCACIIQ6uqqj6UkiABQSBqKgIAIgpDq6qqPpSSIgQgCpMiCiAKlJJDAAAAAJIiCiAJIAWTIgUgBZQgBiALkyIFIAWUkiAEIAiTIgUgBZSSQwAAAACSIgUgCSADkyIDIAOUIAYgB5MiAyADlJIgBCAMkyIDIAOUkkMAAAAAkiIDQwAAAAAgA0MAAAAAXhsiAyAFIANeGyIDIAogA14bEKsBOAIMIAAgAkEYaioCACAEIAJBDGoqAgAiCyAGIAIqAgAiA5QgCSACQQRqKgIAIgWUkyIHIAeSIgyUIAMgCSACQQhqKgIAIgeUIAQgA5STIgggCJIiCJQgBSAEIAWUIAYgB5STIgQgBJIiBJSTkpKSOAIIIAAgAkEUaioCACAGIAsgCJQgByAElCADIAyUk5KSkjgCBCAAIAIqAhAgCSALIASUIAUgDJQgByAIlJOSkpI4AgALvgMBCX0jAEFAaiIFJAAgAkEEaioCACIHIANBDGoqAgAiDZQgAioCACILIANBEGoqAgAiDpSTIgggCJIhCSACQQhqKgIAIgggDpQgByADQRRqKgIAIgaUkyIMIAySIQogBUEUaiAGIAIqAgwiDCAJlCAHIAqUIAsgCyAGlCAIIA2UkyIGIAaSIgaUk5KSOAIAIAVBEGogDiAMIAaUIAsgCZQgCCAKlJOSkjgCACAFIA0gDCAKlCAIIAaUIAcgCZSTkpI4AgwgByADKgIAIAIqAhCTIg2UIAsgAyoCBCACQRRqKgIAkyIOlJMiCSAJkiEJIA4gCJQgAyoCCCACQRhqKgIAkyIGIAeUkyIKIAqSIQogBSAGIAwgCZQgByAKlCALIAYgC5QgDSAIlJMiBiAGkiIGlJOSkjgCCCAFIA4gDCAGlCALIAmUIAggCpSTkpI4AgQgBSANIAwgCpQgCCAGlCAHIAmUk5KSOAIAIAVBGGogASABQQxqIAFBGGogBRCdAgJ/IAUoAihBBEcEQEEBIAUqAhgiByAEX0EBc0UNARpBAAwBC0EACyECIAAgBzgCBCAAIAI2AgAgBUFAayQAC7wDAQt9IAIqAgAiCSADQQhqKgIAIgSUIAJBCGoqAgAiCiADKgIAIguUkyIIIAiSIQUgAkEEaioCACIIIAuUIAkgA0EEaioCACIMlJMiDSANkiEGIAwgAkEMaioCACINIAWUIAkgBpQgCiAKIAyUIAggBJSTIgwgDJIiDJSTkpIhDgJAAkACQCAEIA0gBpQgCCAMlCAJIAWUk5KSIgQgBJQgCyANIAyUIAogBZQgCCAGlJOSkiIFIAWUQwAAAACSkkMAAAAAkhCrASIGQwAAAABcBEAgBCAEIAaVIAEqAgQiBJQiB5QgBSAFIAaVIASUIgaUIA4gASoCACIFlCIEk5IgBF0NASAFjCEFDAMLIAEqAgAgDpghBQwBC0MAAAAAIQcLQwAAAAAhBgsgACAHIA0gCSAFlCAIIAaUkyIEIASSIgSUIAkgCiAGlCAJIAeUkyILIAuSIguUIAggCCAHlCAKIAWUkyIHIAeSIgeUk5KSIAJBGGoqAgCSOAIIIAAgBSANIAuUIAogB5QgCSAElJOSkiACQRRqKgIAkjgCBCAAIAIqAhAgBiANIAeUIAggBJQgCiALlJOSkpI4AgAL8AMCCX8BfiMAQTBrIgMkACAAQQhqKAIAIgYgAWohBSAAQRRqKAIAIQggACgCECEJAn8CQAJAIABBBGooAgAiBCAGayIHIAFJBEAgBSAGSQ0CIAWtQqACfiILQiCIp0VBA3QhAiALpyEHAkAgBARAIANBKGpBCDYCACADIARBoAJsNgIkIAMgACgCADYCIAwBCyADQQA2AiALIANBEGogByACIANBIGoQgQYgAygCEEEBRg0BIAMoAhQhBCAAQQRqIANBGGooAgBBoAJuIgI2AgAgACAENgIAIAIgBmshBwsgBiEEIAdBACAFIAZrIgIgAiAFSxsiAkkEQCAAIAYgAhCiBSAAQQhqKAIAIQQLIAUgBksEQCAGQQFqIQcgACgCACAEQaACbGohAiABIQUDQCACQQA2AgAgAkEIaiAIIAcgBUEBRiIKGzYCACACQQRqIAlBASAKGzYCACACQaACaiECIAdBAWohByAFQX9qIgUNAAsgASAEaiEECyAAIAY2AhQgAEEBNgIQIABBCGogBDYCACADQTBqJAAPCyADQRhqKAIAIQIgAygCFAwBCyADQQhqIgBBADYCBCAAIAU2AgAgAygCDCECIAMoAggLIQAgAgRAIAAgAkHQnsMAKAIAIgBBvwYgABsRAAAACxCWDAAL8AMCCX8BfiMAQTBrIgMkACAAQQhqKAIAIgYgAWohBSAAQRRqKAIAIQggACgCECEJAn8CQAJAIABBBGooAgAiBCAGayIHIAFJBEAgBSAGSQ0CIAWtQqABfiILQiCIp0VBA3QhAiALpyEHAkAgBARAIANBKGpBCDYCACADIARBoAFsNgIkIAMgACgCADYCIAwBCyADQQA2AiALIANBEGogByACIANBIGoQgQYgAygCEEEBRg0BIAMoAhQhBCAAQQRqIANBGGooAgBBoAFuIgI2AgAgACAENgIAIAIgBmshBwsgBiEEIAdBACAFIAZrIgIgAiAFSxsiAkkEQCAAIAYgAhCjBSAAQQhqKAIAIQQLIAUgBksEQCAGQQFqIQcgACgCACAEQaABbGohAiABIQUDQCACQQA2AgAgAkEIaiAIIAcgBUEBRiIKGzYCACACQQRqIAlBASAKGzYCACACQaABaiECIAdBAWohByAFQX9qIgUNAAsgASAEaiEECyAAIAY2AhQgAEEBNgIQIABBCGogBDYCACADQTBqJAAPCyADQRhqKAIAIQIgAygCFAwBCyADQQhqIgBBADYCBCAAIAU2AgAgAygCDCECIAMoAggLIQAgAgRAIAAgAkHQnsMAKAIAIgBBvwYgABsRAAAACxCWDAALtwMCAX8JfSMAQdAAayIEJAAgAioCACABKgIQkyIMIAFBBGoqAgAiCZQgAioCBCABQRRqKgIAkyINIAEqAgAiCpSTIgYgBpIhByANIAFBCGoqAgAiBpQgAioCCCABQRhqKgIAkyIFIAmUkyILIAuSIQggBCAFIAEqAgwiCyAHlCAJIAiUIAogBSAKlCAMIAaUkyIFIAWSIgWUk5KSOAIgIAQgDSALIAWUIAogB5QgBiAIlJOSkjgCHCAEIAwgCyAIlCAGIAWUIAkgB5STkpI4AhggCSACQQxqKgIAIgyUIAogAkEQaioCACINlJMiByAHkiEHIAYgDZQgCSACQRRqKgIAIgWUkyIIIAiSIQggBCAFIAsgB5QgCSAIlCAKIAogBZQgBiAMlJMiBSAFkiIFlJOSkjgCMCAEIA0gCyAFlCAKIAeUIAYgCJSTkpI4AiwgBCAMIAsgCJQgBiAFlCAJIAeUk5KSOAIoIAQgBEEYaiAEQShqIgEQpAogASAAIABBDGogAEEYaiAEEJ0CAn8gBCgCOEEERwRAQQAgBCoCKCADX0EBcw0BGkEBDAELQQALIARB0ABqJAAL7wMCAX8FfSMAQSBrIgQkAAJAAkACQAJAAkAgASoCDCABKgIAkyIFIAWUIAFBEGoqAgAgASoCBJMiBiAGlJIgAUEUaioCACABKgIIkyIIIAiUkkMAAAAAkiIHQwAAgCheQQFzRQRAIAQgCCAHEKsBIgeVIgg4AgggBCAGIAeVIgY4AgQgBCAFIAeVIgU4AgAgAg4DBAIDAQsgAEIBNwIAIABBCGpCgICA/AM3AgAMBAsgAEEANgIADAMLIARBADYCGCAEQgA3AxBBAiAGiyIHIAWLIgldIgEgCIsgByAJIAEbXRtBAnQiASAEQRBqakGAgID8AzYCACAEKgIQIAUgASAEaioCACIFlJMiByAHlCAEKgIUIAYgBZSTIgkgCZSSIAQqAhggCCAFlJMiBSAFlJJDAAAAAJIQqwEhBiAAQQE2AgAgAEEMaiAFIAaVOAIAIABBCGogCSAGlTgCACAAIAcgBpU4AgQMAgsgAEEBNgIAIABBDGpBADYCACAAQQhqIAUgBYwgAxs4AgAgACAGjCAGIAMbOAIEDAELIAMEQCAAQQE2AgAgAEEMaiAIjDgCACAAQQhqIAaMOAIAIAAgBYw4AgQMAQsgACAEKQMANwIEIABBATYCACAAQQxqIARBCGooAgA2AgALIARBIGokAAvVAwIEfwJ+AkACQAJAAkAgAUEHcSIDBEAgACgCACICQSlPDQECQCACRQRAQQAhAgwBCyADQQJ0QcziwgBqNQIAIQcgAkECdCIFIQQgAEEEaiEDA0AgAyADNQIAIAd+IAZ8IgY+AgAgA0EEaiEDIAZCIIghBiAEQXxqIgQNAAsgBqciA0UNACACQSdLDQMgACAFakEEaiADNgIAIAJBAWohAgsgACACNgIACyABQQhxBEAgACgCACICQSlPDQMCQCACRQRAQQAhAgwBCyACQQJ0IgQgAGogAEEEaiEDQgAhBgNAIAMgAzUCAEKAwtcvfiAGfCIGPgIAIANBBGohAyAGQiCIIQYgBEF8aiIEDQALIAanIgNFDQAgAkEnSw0FQQRqIAM2AgAgAkEBaiECCyAAIAI2AgALIAFBEHEEQCAAQZzjwgBBAhCQAgsgAUEgcQRAIABBpOPCAEEEEJACCyABQcAAcQRAIABBtOPCAEEHEJACCyABQYABcQRAIABB0OPCAEEOEJACCyABQYACcQRAIABBiOTCAEEbEJACCw8LIAJBKEG0kMMAENEIAAsgAkEoQbSQwwAQzwgACyACQShBtJDDABDRCAALIAJBKEG0kMMAEM8IAAuUBAECfwJAAkACQAJAAkACQAJAAkAgASgCAEEBaw4FAQIDBAUAC0EwQQQQyAsiAkUNBSACIAEpAgQ3AgAgAkEoaiABQSxqKQIANwIAIAJBIGogAUEkaikCADcCACACQRhqIAFBHGopAgA3AgAgAkEQaiABQRRqKQIANwIAIAJBCGogAUEMaikCADcCAEGM18EAIQMMBAtBIEEEEMgLIgJFDQUgAiABKQIENwIAIAJBGGogAUEcaikCADcCACACQRBqIAFBFGopAgA3AgAgAkEIaiABQQxqKQIANwIAQczWwQAhAwwDC0EgQQQQyAsiAkUNBCACIAEpAgQ3AgAgAkEYaiABQRxqKQIANwIAIAJBEGogAUEUaikCADcCACACQQhqIAFBDGopAgA3AgBBjNbBACEDDAILQSBBBBDICyICRQ0DIAIgASkCBDcCACACQRhqIAFBHGopAgA3AgAgAkEQaiABQRRqKQIANwIAIAJBCGogAUEMaikCADcCAEGM1cEAIQMMAQtBIEEEEMgLIgJFDQIgAiABKQIENwIAIAJBGGogAUEcaikCADcCACACQRBqIAFBFGopAgA3AgAgAkEIaiABQQxqKQIANwIAQczVwQAhAwsgACADNgIEIAAgAjYCAA8LQTBBBEHQnsMAKAIAIgBBvwYgABsRAAAAC0EgQQRB0J7DACgCACIAQb8GIAAbEQAAAAutAwEQfSADKgIAIAIqAhAiD5MiCSACQQRqKgIAIgqUIAMqAgQgAkEUaioCACIQkyILIAIqAgAiDJSTIgcgB5IhCCALIAJBCGoqAgAiB5QgAyoCCCACQRhqKgIAIhGTIgUgCpSTIg0gDZIhBgJAAkAgAUEIaioCACISIAUgAkEMaioCACINIAiUIAogBpQgDCAFIAyUIAkgB5STIgUgBZIiDpSTkpIiBZQgASoCACITIAkgDSAGlCAHIA6UIAogCJSTkpIiCZQgAUEEaioCACIUIAsgDSAOlCAMIAiUIAcgBpSTkpIiCJSSkiIGQwAAAABfIgJBAXMNACAERQ0AQQEhAgwBCyAFIBIgBpSTIQUgCCAUIAaUkyEIIAkgEyAGlJMhCQsgACACOgAMIAAgESAFIA0gDCAIlCAKIAmUkyIGIAaSIgaUIAwgByAJlCAMIAWUkyILIAuSIguUIAogCiAFlCAHIAiUkyIFIAWSIgWUk5KSkjgCCCAAIBAgCCANIAuUIAcgBZQgDCAGlJOSkpI4AgQgACAPIAkgDSAFlCAKIAaUIAcgC5STkpKSOAIAC7gDAgF/DH0jAEEwayIEJAAgAyoCACACKgIQIg6TIg0gAkEEaioCACIIlCADKgIEIAJBFGoqAgAiD5MiCSACKgIAIgqUkyIHIAeSIQsgCSACQQhqKgIAIgeUIAMqAgggAkEYaioCACIQkyIFIAiUkyIMIAySIQYgBCAFIAJBDGoqAgAiDCALlCAIIAaUIAogBSAKlCANIAeUkyIFIAWSIgWUk5KSOAIIIAQgCSAMIAWUIAogC5QgByAGlJOSkjgCBCAEIA0gDCAGlCAHIAWUIAggC5STkpI4AgAgBEEQaiICIAEgBBDjAiAEKgIQIQsgBCoCGCEGIAQqAhQhDSAELQAcIQEgAEEUakEAIAJBFGooAgAgBCgCICICGzYCACAAIAJBAEc2AhAgACABOgAMIAAgECAGIAwgCiANlCAIIAuUkyIJIAmSIgmUIAogByALlCAKIAaUkyIFIAWSIgWUIAggCCAGlCAHIA2UkyIGIAaSIgaUk5KSkjgCCCAAIA8gDSAMIAWUIAcgBpQgCiAJlJOSkpI4AgQgACAOIAsgDCAGlCAIIAmUIAcgBZSTkpKSOAIAIARBMGokAAutBAIBfwR9AkACQAJAIAIqAgwiB0MAAAAAXARAQwAAgD8gB5UiCCABKgIMIAIqAgAiBpOUIQcgCCABKgIAIAaTlCIGIAdeIQVDAAAAAEMAAAAAIAcgBiAFGyIIIAhDAAAAAF0bIAggCFwbIgggAyADIAYgByAFGyIGIAMgBl0bIAYgBlwbIgNeRQ0BDAILIAIqAgAiBiABKgIAXQ0CIAYgASoCDF4NAgsCQCACQRBqKgIAIgdDAAAAAFwEQEMAAIA/IAeVIgYgAUEQaioCACACQQRqKgIAIgmTlCEHIAYgAUEEaioCACAJk5QiBiAHXiEFIAcgBiAFGyIJIAkgCCAIIAldGyAIIAhcGyIIIAMgAyAGIAcgBRsiBiADIAZdGyAGIAZcGyIDXg0CDAELQQAhBSACQQRqKgIAIgYgAUEEaioCAF0NAiAGIAFBEGoqAgBeDQILAkAgAkEUaioCACIHQwAAAABcBEBDAACAPyAHlSIGIAFBFGoqAgAgAkEIaioCACIJk5QhByAGIAFBCGoqAgAgCZOUIgYgB14hASAHIAYgARsiCSAJIAggCCAJXRsgCCAIXBsiCCADIAMgBiAHIAEbIgYgAyAGXRsgBiAGXBsiA14NAgwBC0EAIQUgAkEIaioCACIGIAFBCGoqAgBdDQIgBiABQRRqKgIAXg0CCyAIIAggAyAEGyAIQwAAAABcGyEHQQEhBQwBC0EAIQULIAAgBzgCBCAAIAU2AgALrQMCAX8JfSMAQUBqIgQkACABQQRqKgIAIgkgAkEMaioCACIMlCABKgIAIgogAkEQaioCACINlJMiBiAGkiEHIAFBCGoqAgAiBiANlCAJIAJBFGoqAgAiBZSTIgsgC5IhCCAEQRRqIAUgASoCDCILIAeUIAkgCJQgCiAKIAWUIAYgDJSTIgUgBZIiBZSTkpI4AgAgBEEQaiANIAsgBZQgCiAHlCAGIAiUk5KSOAIAIAQgDCALIAiUIAYgBZQgCSAHlJOSkjgCDCAJIAIqAgAgASoCEJMiDJQgCiACKgIEIAFBFGoqAgCTIg2UkyIHIAeSIQcgDSAGlCACKgIIIAFBGGoqAgCTIgUgCZSTIgggCJIhCCAEIAUgCyAHlCAJIAiUIAogBSAKlCAMIAaUkyIFIAWSIgWUk5KSOAIIIAQgDSALIAWUIAogB5QgBiAIlJOSkjgCBCAEIAwgCyAIlCAGIAWUIAkgB5STkpI4AgAgBEEYaiAAIABBDGogAEEYaiAEEJ0CAn8gBCgCKEEERwRAQQAgBCoCGCADX0EBcw0BGkEBDAELQQALIARBQGskAAuTBAMCfwF+B31CgICA/AMhBSABKgIAIgYgBpQgASoCCCIHIAeUkkMAAAAAkhCrASIIQwAAADRfRQRAIAYgCJW8rSAHIAiVvK1CIIaEIQULIAVCIIinviEGIAWnviEHAn8CQCABKgIEIgqLQwAAAD9dRQRAIAJBLGogACoCBCIIIAeMlCILOAIAIAJBKGogACoCACAKmCIJOAIAIAIgCCAGlCIMOAIkIAJBIGogCCAGjJQiBjgCACACQRxqIAk4AgAgAiALOAIYIAJBFGogCCAHlCIHOAIAIAJBEGogCTgCACACIAY4AgwgAiAMOAIIIAIgCTgCBCACIAc4AgAgCkMAAAAAXQ0BIAJCk4CAgMAANwJQIAJCjICAgOABNwJAIAJByABqQpCAgICgAjcCAEERIQFBDSEDQQshBEEPDAILIAJCADcCQCACQRBqIAAqAgAiCDgCACACQcgAakIANwIAIAJB0ABqQoCAgIAgNwIAIAJBFGogACoCBCIJIAaUIgY4AgAgAiAJIAeUIgc4AgwgAiAGOAIIIAIgCIw4AgQgAiAHOAIAQQshA0EBIQRBCyEBQQsMAQsgAkKJgICAwAA3AlAgAkKCgICAwAA3AkAgAkHIAGpChoCAgIABNwIAQQchAUEDIQNBASEEQQULIQAgAiAENgIwIAJBPGogATYCACACQThqIAA2AgAgAkE0aiADNgIAC7wEAgN/AX4jAEFAaiIBJAACQAJAAkACf0EAIAAoAgAiAkUNABogASAAKQIENwIsIAEgAjYCKCABQRhqIgAgAUEoaiICKQIANwIAIABBCGogAkEIaigCADYCACABKAIYIQMCfyABKAIgIgJBCE8EQCABQRBqQQAgAyACEOwEIAEoAhQhAiABKAIQDAELIAJFBEBBACECQQAMAQtBACEAAkADQCAAIANqLQAARQ0BIAIgAEEBaiIARw0AC0EADAELIAAhAkEBCw0BIAFBKGoiAEEIaiABQSBqKAIANgIAIAEgASkDGDcDKCABQQhqIAAQ2QYgASgCDCECIAEoAggLIQNB2KLDAC0AACEAQdiiwwBBAToAACABIAA6ABggAA0BAkBBiJjDACkDACIEQn9SBEBBiJjDACAEQgF8NwMAIARCAFINAUGg0sIAQStB0NTCABDbCQALQdiiwwBBADoAAEGI1MIAQTdBwNTCABCICwALQdiiwwBBADoAAEEgQQgQyAsiAEUNAiAAQgA3AxggACACNgIUIAAgAzYCECAAIAQ3AwggAEKBgICAEDcDACABQUBrJAAgAA8LIAFBMGogASkCHDcDACABIAM2AiwgASACNgIoQeDUwgBBLyABQShqQezSwgBBkNXCABCb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AzcCACACQRhqQoCAgIAQNwIAIAJBEGpCgYCAgCA3AgAgAkEIakIBNwIAIAFCATcDECABIANBBGo2AghBoAFBBBDICyICRQ0BQegRQQQQyAsiA0UNAiAAQgA3AgQgAEGYwMAAKAIANgIAIAAgASkDADcCDCAAIAI2AiggAEE4akIKNwIAIABBNGogAzYCACAAQSxqQgo3AgAgAEEUaiABQQhqKQMANwIAIABBHGogAUEQaikDADcCACAAQSRqIAFBGGooAgA2AgAgAUFAayQADwsQlgwAC0GgAUEEQdCewwAoAgAiAEG/BiAAGxEAAAALQegRQQRB0J7DACgCACIAQb8GIAAbEQAAAAvgAwIDfwZ+AkACQAJ+IAEoAiBBAUYEQEEsQQQQyAsiAkUNAiACQShqIAFBzABqKAIANgIAIAJBIGogAUHEAGopAgA3AgAgAkEYaiABQTxqKQIANwIAIAJBEGogAUE0aikCADcCACACQQhqIAFBLGopAgA3AgAgAiABQSRqKQIANwIAQgEMAQsgAUEcaigCAEGAgID8AyABKAIYGyECQgALIQUgASgCECIDKAIAIQQgAyAEQQFqNgIAIARBf0wNASAAQj83AyAgACADNgIQIAAgAS0AkAE6AJQBIAAgASkCWDcCTCAAQRRqIAFBFGooAgA2AgAgAEHUAGogAUHgAGopAgA3AgAgAEHcAGogAUHoAGopAgA3AgAgAEHkAGogAUHwAGooAgA2AgAgACACrUIghiAFhDcDGCABQQhqKQMAIQUgASkDACEGIAEpA1AhByABLwGOASECIAEpAnwhCCABKQKEASEJIAEpAnQhCiABLwGMASEBIABBfzYCkAEgAEGMAWogATsBACAAQYQBaiAKNwIAIABB/ABqIAk3AgAgACAINwJ0IABB8ABqIAI7AQAgACAHNwNoIAAgBjcDACAAIAU3AwgPC0EsQQRB0J7DACgCACIAQb8GIAAbEQAAAAsAC6oDAgN/AX0gACgCACgCACICQQRqIgQoAgAgAkEIaiIDKAIAIgBrQQdNBEAgAiAAQQgQnwYgAygCACEACyACKAIAIABqQgU3AAAgAyAAQQhqIgA2AgAgASoCACEFIAQoAgAgAGtBA00EQCACIABBBBCfBiACQQhqKAIAIQALIAIoAgAgAGogBTgAACACQQhqIgMgAEEEaiIA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AUEQaiAAQfAAaikCADcDACABQRhqIABB+ABqKQIANwMAIAFBIGogAEGAAWopAgA3AwAgAUEoaiAAQYgBaikCADcDACABQTBqIABBkAFqKQIANwMAIAFBOGogAEGYAWooAgA2AgAgAEHcAGoiBCgCACEDIARBADYCACABIABB4ABqKQIANwMAIABBADYCACADBEBBxABBBBDICyICRQ0DIAIgAzYCBCACQQA2AgAgAiABKQMANwIIIAJBEGogAUEIaikDADcCACACQRhqIAFBEGopAwA3AgAgAkEgaiABQRhqKQMANwIAIAJBKGogAUEgaikDADcCACACQTBqIAFBKGopAwA3AgAgAkE4aiABQTBqKQMANwIAIAJBQGsgAUE4aigCADYCAAsgAUFAayQAIAIPCxCiDAALEKMMAAtBxABBBEHQnsMAKAIAIgBBvwYgABsRAAAAC4QDAQR/IwBBQGoiASQAAkACQCAABEAgACgCAA0BIAFBCGogAEGMAmopAgA3AwAgAUEQaiAAQZQCaikCADcDACABQRhqIABBnAJqKQIANwMAIAFBIGogAEGkAmopAgA3AwAgAUEoaiAAQawCaikCADcDACABQTBqIABBtAJqKQIANwMAIAFBOGogAEG8AmopAgA3AwAgAEGAAmoiBCgCACEDIARBADYCACABIABBhAJqKQIANwMAIABBADYCACADBEBByABBBBDICyICRQ0DIAIgAzYCBCACQQA2AgAgAiABKQMANwIIIAJBEGogAUEIaikDADcCACACQRhqIAFBEGopAwA3AgAgAkEgaiABQRhqKQMANwIAIAJBKGogAUEgaikDADcCACACQTBqIAFBKGopAwA3AgAgAkE4aiABQTBqKQMANwIAIAJBQGsgAUE4aikDADcCAAsgAUFAayQAIAIPCxCiDAALEKMMAAtByABBBEHQnsMAKAIAIgBBvwYgABsRAAAAC/8CAQh/IwBBEGsiBiQAIAEgAUEIaiIDKAIAEKcDIAJBHGooAgAhByACQRRqKAIAIQggAigCGCEJIAIoAhAhBAJAAkAgASgCEEEBRgRAIAMoAgAiAyABQRRqKAIAIgVNDQIgASgCACAFQaABbGoiAygCAEEBRw0BQbDhwABBEUHE4cAAEPsKAAsgBCAEKAIAIgBBf2o2AgAgAEEBRgRAIAQgCBD3BwsgCQRAIAcQ2gELQdThwABBPiAGQQhqQay+wABBlOLAABCbCAALIAIoAgAhCiADQQE2AgAgASABKAIYQQFqNgIYIAEgAykCBDcCECADQQhqIAo2AgAgAyABKAIMIgE2AgQgA0EMaiACKQIENwIAIANBFGogAkEMaigCADYCACADQSRqIAc2AgAgA0EgaiAJNgIAIANBHGogCDYCACADQRhqIAQ2AgAgA0EoaiACQSBqQfgAEJ4KGiAAIAE2AgQgACAFNgIAIAZBEGokAA8LIAUgA0Gg4cAAEM8IAAvGAgENfwJAIAAEQCAAKAIADQEgAEEANgIAIAAoAgghDSAAKAIMIQIgACgCECEDIAAoAhghBCAAKAIcIQUgACgCICEGIAAoAiQhByAAKAIoIQggACgCMCEJIAAoAjQhCiAAKAI8IQsgACgCQCEMIAAoAgQhASAAENoBIAEgASgCACIAQX9qNgIAIABBAUYEQCABIA0Q9wcLAkAgA0UNACACRQ0AIANBBHRFDQAgAhDaAQsgBgRAIAZBOGwhASAEIQADQCAAEO0FIABBOGohACABQUhqIgENAAsLAkAgBUUNACAFQThsRQ0AIAQQ2gELAkAgCEUNACAHRQ0AIAhBBHRFDQAgBxDaAQsCQCAKRQ0AIAlFDQAgCkEUbEUNACAJENoBCwJAIAxFDQAgC0UNACAMQQxsRQ0AIAsQ2gELDwsQogwACxCjDAAL/AIBAX8CQAJAIABFDQAgACgCAA0BIABBfzYCACABRQ0AIAEoAgAiCkF/Rg0BIAEgCkEBajYCACACRQ0AIAIoAgAiCkF/Rg0BIAIgCkEBajYCACADRQ0AIAMoAgANASADQX82AgAgBEUNACAEKAIADQEgBEF/NgIAIAVFDQAgBSgCAA0BIAVBfzYCACAGRQ0AIAYoAgANASAGQX82AgAgB0UNACAHKAIADQEgB0F/NgIAIAhFDQAgCCgCAA0BIAhBfzYCACAJRQ0AIAkoAgANASAJQX82AgAgAEEIaiABQQRqIAJBBGogA0EEaiAEQQRqIAVBBGogBkEEaiAHQQRqIAhBBGogCUEEakGwmcAAQfivwABBsJnAAEGcsMAAENYEIAlBADYCACAIQQA2AgAgB0EANgIAIAZBADYCACAFQQA2AgAgBEEANgIAIANBADYCACACIAIoAgBBf2o2AgAgASABKAIAQX9qNgIAIABBADYCAA8LEKIMAAsQowwAC+gCAQt/IwBBEGsiCSQAAkACQAJAIAEoAgAiBwRAIAdBAWoiBSAFQf////8DcUcNAiAFQQJ0IgMgB0EFaiIGaiIEIANJDQIgBEEEEMgLIgINASAEQQRB0J7DACgCACIAQb8GIAAbEQAAAAtBACEHQcDLwgAhCAwCCyACIANqIgggAUEEaigCACIEIAYQngpBfGohCiAEQQRqIQMgBCAFaiELIAQoAgBBf3NBgIGChHhxIQIgASgCDCEMIAQhBQNAAkAgAkUEQANAIAMgC08NAiAFQXBqIQUgAygCACADQQRqIgYhA0GAgYKEeHEiAkGAgYKEeEYNAAsgAkGAgYKEeHMhAiAGIQMLIAogBCAFIAJoQQF2QRxxayIGa0F8cWsgBkF8aigCADYCACACQX9qIAJxIQIMAQsLIAEoAgghAwwBCxCmCwALIAAgDDYCDCAAIAM2AgggACAINgIEIAAgBzYCACAJQRBqJAAL7AICAn8DfSMAQeAAayIFJAAgAUEIaiIGKgIAIQcgASoCACEIIAEqAgQhCSAFQRxqIAYoAgA2AgAgBSAHjDgCECAFIAmMOAIMIAUgCIw4AgggBSABKQIANwIUIAVBMGogBUEIaiACIAJBDGoQwgEgAAJ/AkACQAJAIAUoAjBBAUcNACAFKgI0IgdDAAAAAF1FBEAgByADX0EBcw0BIAVBKGogBUFAaygCADYCACAFIAVBOGopAwA3AyAgBUHEAGooAgAhAgwDCyAFQdgAaigCACECIAQNASAFQcgAaioCACIHIANfQQFzDQAgBUEoaiAFQdQAaigCADYCACAFIAVBzABqKQIANwMgDAILQQQMAgsgBUEoakEANgIAIAVCADcDIEMAAAAAIQcLIAAgBSkDIDcCBCAAIAc4AgAgAEEMaiAFQShqKAIANgIAIABBAiACayACQX9qIAJBAEgbNgIUQQILNgIQIAVB4ABqJAALtgIBEn0gAEEUaiACQRhqKgIAIgkgASoCACIKIAIqAgAiAyACKgIIIgSUIgUgBZIiDSACKgIEIgUgAioCDCIGlCIIIAiSIg6Ti5QgASoCBCIIIAUgBJQiByAHkiIPIAMgBpQiByAHkiIQkouUkiABKgIIIgcgBCAElCILIAYgBpQiESADIAOUIhKTIhMgBSAFlCIMk5KLlJIiFJI4AgAgACAJIBSTOAIIIABBEGogAkEUaioCACIJIAcgDyAQk4uUIAogAyAFlCIDIAOSIgMgBCAGlCIEIASSIgSSi5QgCCAMIBOSIAuTi5SSkiIFkjgCACAAIAIqAhAiBiAHIA0gDpKLlCAIIAMgBJOLlCAKIBIgEZIgDJMgC5OLlJKSIgOSOAIMIAAgCSAFkzgCBCAAIAYgA5M4AgAL4wIBBX8gAEELdCEEQR8hAkEfIQMCQANAAkACQCACQQF2IAFqIgJBAnRBnJHDAGooAgBBC3QiBSAETwRAIAQgBUYNAiACIQMMAQsgAkEBaiEBCyADIAFrIQIgAyABSw0BDAILCyACQQFqIQELAkACQCABQR5NBEAgAUECdCEEQbEFIQMgAUEeRwRAIARBoJHDAGooAgBBFXYhAwtBACEFIAFBf2oiAiABTQRAIAJBH08NAiACQQJ0QZyRwwBqKAIAQf///wBxIQULAkAgBEGckcMAaigCAEEVdiIBQQFqIANGDQAgACAFayEEIAFBsQUgAUGxBUsbIQIgA0F/aiEAQQAhAwNAIAEgAkYNBCABQZiSwwBqLQAAIANqIgMgBEsNASAAIAFBAWoiAUcNAAsgACEBCyABQQFxDwsgAUEfQeSPwwAQzwgACyACQR9BhJDDABDPCAALIAJBsQVB9I/DABDPCAAL3wIBA38jAEEQayICJAAgACgCACEAAkACfwJAIAFBgAFPBEAgAkEANgIMIAFBgBBPDQEgAiABQT9xQYABcjoADSACIAFBBnZBwAFyOgAMQQIMAgsgACgCCCIDIABBBGooAgBGBEAgACADQQEQnwYgACgCCCEDCyAAIANBAWo2AgggACgCACADaiABOgAADAILIAFBgIAETwRAIAIgAUE/cUGAAXI6AA8gAiABQRJ2QfABcjoADCACIAFBBnZBP3FBgAFyOgAOIAIgAUEMdkE/cUGAAXI6AA1BBAwBCyACIAFBP3FBgAFyOgAOIAIgAUEMdkHgAXI6AAwgAiABQQZ2QT9xQYABcjoADUEDCyEBIABBBGooAgAgAEEIaiIEKAIAIgNrIAFJBEAgACADIAEQnwYgBCgCACEDCyAAKAIAIANqIAJBDGogARCeChogBCABIANqNgIACyACQRBqJABBAAvaAgEDfyMAQRBrIgIkAAJAAn8CQAJAIAFBgAFPBEAgAkEANgIMIAFBgBBJDQEgAUGAgARPDQIgAiABQT9xQYABcjoADiACIAFBDHZB4AFyOgAMIAIgAUEGdkE/cUGAAXI6AA1BAwwDCyAAKAIIIgMgAEEEaigCAEYEQCAAIANBARCfBiAAKAIIIQMLIAAgA0EBajYCCCAAKAIAIANqIAE6AAAMAwsgAiABQT9xQYABcjoADSACIAFBBnZBwAFyOgAMQQIMAQsgAiABQT9xQYABcjoADyACIAFBEnZB8AFyOgAMIAIgAUEGdkE/cUGAAXI6AA4gAiABQQx2QT9xQYABcjoADUEECyEBIABBBGooAgAgAEEIaiIEKAIAIgNrIAFJBEAgACADIAEQnwYgBCgCACEDCyAAKAIAIANqIAJBDGogARCeChogBCABIANqNgIACyACQRBqJABBAAvkAgIDfwF9IAAoAgAoAgAiAkEEaiIEKAIAIAJBCGoiAygCACIAa0EHTQRAIAIgAEEIEJ8GIAMoAgAhAAsgAigCACAAakIENwAAIAMgAEEIaiIANgIAIAEqAgAhBSAEKAIAIABrQQNNBEAgAiAAQQQQnwYgAkEIaigCACEACyACKAIAIABqIAU4AAAgAkEIaiIDIABBBGoiADYCACABKgIEIQUgAkEEaiIEKAIAIABrQQNNBEAgAiAAQQQQnwYgAygCACEACyACKAIAIABqIAU4AAAgAyAAQQRqIgA2AgAgASoCCCEFIAQoAgAgAGtBA00EQCACIABBBBCfBiACQQhqKAIAIQALIAIoAgAgAGogBTgAACACQQhqIgMgAEEEaiIANgIAIAEqAgwhBSACQQRqKAIAIABrQQNNBEAgAiAAQQQQnwYgAygCACEACyADIABBBGo2AgAgAigCACAAaiAFOAAAQQAL2AIBA38jAEEQayICJAACQAJ/AkACQCABQYABTwRAIAJBADYCDCABQYAQSQ0BIAFBgIAETw0CIAIgAUE/cUGAAXI6AA4gAiABQQx2QeABcjoADCACIAFBBnZBP3FBgAFyOgANQQMMAwsgACgCCCIDIABBBGooAgBGBEAgACADQQEQ6wYgACgCCCEDCyAAIANBAWo2AgggACgCACADaiABOgAADAMLIAIgAUE/cUGAAXI6AA0gAiABQQZ2QcABcjoADEECDAELIAIgAUE/cUGAAXI6AA8gAiABQRJ2QfABcjoADCACIAFBBnZBP3FBgAFyOgAOIAIgAUEMdkE/cUGAAXI6AA1BBAshASAAQQRqKAIAIABBCGoiBCgCACIDayABSQRAIAAgAyABEOsGIAQoAgAhAwsgACgCACADaiACQQxqIAEQngoaIAQgASADajYCAAsgAkEQaiQAC+8CAQZ/IwBB0ABrIgIkACACQSE2AiQgAkEoaiAAQRhqIgYQcQJAIAItACgNAANAIAItADwhACACKAI4IQMgAigCNCEHIAIoAiwhBCACQRhqIgUgAigCMDYCBCAFIAQ2AgAgAigCGCEEIAJBEGoiBSADNgIEIAUgBzYCACACKAIQIQMgAiAEuBABNgJEIAIgA7gQATYCSCACIAEgAkEkaiIDIAJBxABqIAJByABqELcLNgJAIAJBIkEjIABBAXEbNgJMIAJBCGogAkFAayADIAJBzABqEL8JIAIoAgwhAAJAAkAgAigCCEUEQCAAQSRPDQEMAgsgAEEkSQ0BCyAAEAALIAIoAkwiAEEkTwRAIAAQAAsgAigCQCIAQSRPBEAgABAACyACKAJIIgBBJE8EQCAAEAALIAIoAkQiAEEkTwRAIAAQAAsgAkEoaiAGEHEgAi0AKEUNAAsgAigCJCIAQSRJDQAgABAACyACQdAAaiQAC+YCAQp9IAEqAgAiAkOrqqo+lCABKgIMIgNDq6qqPpSSIAEqAhgiBEOrqqo+lJIiByAEkyIEIASUIAEqAgQiCEOrqqo+lCABQRBqKgIAIglDq6qqPpSSIAFBHGoqAgAiBUOrqqo+lJIiBCAFkyIFIAWUkiABKgIIIgpDq6qqPpQgAUEUaioCACILQ6uqqj6UkiABQSBqKgIAIgZDq6qqPpSSIgUgBpMiBiAGlJJDAAAAAJIiBiAHIAOTIgMgA5QgBCAJkyIDIAOUkiAFIAuTIgMgA5SSQwAAAACSIgMgByACkyICIAKUIAQgCJMiAiAClJIgBSAKkyICIAKUkkMAAAAAkiICQwAAAAAgAkMAAAAAXhsiAiADIAJeGyICIAYgAl4bEKsBIQIgASoCJCIDQwAAAABgRQRAQeHBwQBBJkHwxMEAEP4KAAsgACAFOAIIIAAgBDgCBCAAIAc4AgAgACACIAOSOAIMC+ICAQZ/IwBBIGsiBCQAIAEoAgAhByABKAIEIgZBA3QiAwRAIAdBBGohAgNAIAIoAgAgBWohBSACQQhqIQIgA0F4aiIDDQALCwJAAkACQAJAAkAgAUEUaigCAEUEQCAFIQMMAQsgBkUNAkEAIQJBASEGIAVBD00EQCAHQQRqKAIARQ0CCyAFIAVqIgMgBUkNAQtBACECAkAgA0EATgRAIAMNAUEBIQYMAgsQlgwACyADIgJBARDICyIGRQ0DCyAAQQA2AgggACAGNgIAIAAgAjYCBCAEIAA2AgQgBEEIaiIAQRBqIAFBEGopAgA3AwAgAEEIaiABQQhqKQIANwMAIAQgASkCADcDCCAEQQRqQazewgAgABDYAg0BIARBIGokAA8LQQBBAEGQ38IAEM8IAAtBsN/CAEEzIARBCGpBoN/CAEH838IAEJsIAAsgAkEBQdCewwAoAgAiAEG/BiAAGxEAAAAL5AIBAn8jAEEgayIIJAACQAJAAkAgAEUNACAAKAIAIgdBf0YNASAAIAdBAWo2AgAgAUUNACABKAIAIgdBf0YNASABIAdBAWo2AgAgAkUNACACKAIAIgdBf0YNASACIAdBAWo2AgAgA0UNACADKAIAIgdBf0YNASADIAdBAWo2AgBBACEHIAggAEEEaiABQQRqIAJBBGogA0EEaiAEIAVBAEcgBhBwIAMgAygCAEF/ajYCACACIAIoAgBBf2o2AgAgASABKAIAQX9qNgIAIAAgACgCAEF/ajYCACAIKAIYIgBBBEcEQCAIKAIcIQFBJEEEEMgLIgdFDQMgB0EANgIAIAcgCCkDADcCBCAHIAE2AiAgByAANgIcIAdBDGogCEEIaikDADcCACAHQRRqIAhBEGopAwA3AgALIAhBIGokACAHDwsQogwACxCjDAALQSRBBEHQnsMAKAIAIgBBvwYgABsRAAAAC7oCAgF/CX0jAEFAaiIEJAAgAioCACABKgIQkyILIAFBBGoqAgAiBZQgAioCBCABQRRqKgIAkyIMIAEqAgAiCZSTIgcgB5IhByAMIAFBCGoqAgAiCpQgAioCCCABQRhqKgIAkyIGIAWUkyIIIAiSIQggBCAGIAEqAgwiDSAHlCAFIAiUIAkgBiAJlCALIAqUkyIGIAaSIgaUk5KSOAIQIAQgDCANIAaUIAkgB5QgCiAIlJOSkjgCDCAEIAsgDSAIlCAKIAaUIAUgB5STkpI4AgggBEEYaiAAIARBCGogAxBHIAQtACQhACAEKgIYIAQqAgiTIgUgBZQgBCoCHCAEKgIMkyIFIAWUkiAEKgIgIAQqAhCTIgUgBZSSQwAAAACSEKsBIQUgBEFAayQAIAUgBSAFjCADGyAAQQFHGwvDAgIBfwp9IAIqAgAiCSAJlCACQQhqKgIAIgggCJSSQwAAAACSEKsBIQQgASoCBCIGQwAAAAAgCCAElSAEQwAAADRfIgMblCEKIAZDAACAPyAJIASVIAMblCEMAkACfQJAAkACQAJAAkAgAioCBCIFIAEqAgAiB4wiC2BBAXMNACAEIAZfQQFzDQAgBSAHXw0BCyAFIAdeDQJBACECIAUgC11FDQUgBCAGX0EBc0UNASALIQUMBQtBASECIAYgBJMhDSAHIAWTIgQgBSAHkiIGXUEBc0VBACAEIA1dGw0CIAYgBF1BAXMNBCAGIA1dQQFzDQQLIAghCiALDAILQQAhAiAEIAZfQQFzRQ0AIAchBQwCCyAIIQogBwshBSAJIQwLIABBAzYCECAAIAI6AAwgACAKOAIIIAAgBTgCBCAAIAw4AgALugICAX8JfSMAQUBqIgQkACACKgIAIAEqAhCTIgsgAUEEaioCACIFlCACKgIEIAFBFGoqAgCTIgwgASoCACIJlJMiByAHkiEHIAwgAUEIaioCACIKlCACKgIIIAFBGGoqAgCTIgYgBZSTIgggCJIhCCAEIAYgASoCDCINIAeUIAUgCJQgCSAGIAmUIAsgCpSTIgYgBpIiBpSTkpI4AhAgBCAMIA0gBpQgCSAHlCAKIAiUk5KSOAIMIAQgCyANIAiUIAogBpQgBSAHlJOSkjgCCCAEQRhqIAAgBEEIaiADEE0gBC0AJCEAIAQqAhggBCoCCJMiBSAFlCAEKgIcIAQqAgyTIgUgBZSSIAQqAiAgBCoCEJMiBSAFlJJDAAAAAJIQqwEhBSAEQUBrJAAgBSAFIAWMIAMbIABBAUcbC9QCAgJ/AX4jAEGAAWsiAyQAIAAoAgAhAAJAAkACfwJAIAEoAgAiAkEQcUUEQCACQSBxDQEgACkDAEEBIAEQ7QQMAgsgACkDACEEQYABIQACQANAIABFBEBBACEADAILIAAgA2pBf2ogBKdBD3EiAkEwciACQdcAaiACQQpJGzoAACAAQX9qIQAgBEIEiCIEQgBSDQALIABBgQFPDQMLIAFBAUHE/cIAQQIgACADakGAASAAaxCaAgwBCyAAKQMAIQRBgAEhAAJAA0AgAEUEQEEAIQAMAgsgACADakF/aiAEp0EPcSICQTByIAJBN2ogAkEKSRs6AAAgAEF/aiEAIARCBIgiBEIAUg0ACyAAQYEBTw0DCyABQQFBxP3CAEECIAAgA2pBgAEgAGsQmgILIANBgAFqJAAPCyAAQYABQbT9wgAQ0AgACyAAQYABQbT9wgAQ0AgAC8UCAgR/AX4jAEEwayIOJAAgBikCHCESIAZBmMDAACgCACIPNgIcIA5BCGogBkEkaigCADYCACAGQSBqQgA3AgAgDiASNwMAIA5BEGoiEEEIaiAHQSRqKAIANgIAIAcpAhwhEiAHQSBqQgA3AgAgByAPNgIcIA4gEjcDECAOQSBqIhFBCGogB0EwaigCADYCACAHKQIoIRIgB0EsakIANwIAIAcgDzYCKCAOIBI3AyAgACABIAIgAyAEIAUgBiAHIA4gECARIAggCSAKIAsgDCANECQCQCAOKAIkIgBFDQAgDigCICIBRQ0AIABBA3RFDQAgARDaAQsCQCAOKAIUIgBFDQAgDigCECIBRQ0AIABBA3RFDQAgARDaAQsCQCAOKAIEIgBFDQAgDigCACIBRQ0AIABBA3RFDQAgARDaAQsgDkEwaiQAC+QCAgN/An4gASgCBCICRQRAIABBAjYCBCAAQQA2AgAPCyABIAJBf2o2AgQCQAJAAkACfiABKAIAIgEoAgQiAkUEQEEAIQIQjAutQiCGQgGEDAELIAEgAkF/aiICNgIEIAEgASgCACIDQQFqNgIAIAMxAABCCIYLIgWnQQFxRQRAQQAhAwJAAkACQCAFQgiIpyIEQf8BcQ4CAgEAC0EQQQQQyAsiAUUNAyABQQQ6AAAgASAEQf8BcTYCBAwFCyACQQRJDQMgASACQXxqIgQ2AgQgASABKAIAIgNBBGo2AgAgBEEESQ0DIAM1AAAhBSABIAJBeGo2AgQgASADQQhqNgIAIAM1AARCIIYgBYQhBkEBIQMLIAAgAzYCBCAAQQhqIAY3AgAgAEEANgIADwsgBUIgiKchAQwCC0EQQQRB0J7DACgCACIAQb8GIAAbEQAAAAsQjAshAQsgACABNgIEIABBATYCAAveAgEEfyMAQUBqIgQkAAJAAkACQCAARQ0AIAAoAgAiBUF/Rg0BIAAgBUEBajYCACABRQ0AIAEoAgAiBUF/Rg0BIAEgBUEBajYCACACRQ0AIAIoAgAiBUF/Rg0BIAIgBUEBajYCACAEQRBqIgVBCGogAEEEaiIGQQhqKAIANgIAIAQgBikCADcDECAEQSBqIgZBCGogAUEEaiIHQQhqKAIANgIAIAQgBykCADcDICAEQTBqIgdBCGogAkEMaigCADYCACAEIAIpAgQ3AzAgBEEIaiAFIAYgByADEIYGIAQoAgwhBSAEKAIIIQYgAiACKAIAQX9qNgIAIAEgASgCAEF/ajYCACAAIAAoAgBBf2o2AgBBDEEEEMgLIgBFDQIgACAFNgIIIAAgBjYCBCAAQQA2AgAgBEFAayQAIAAPCxCiDAALEKMMAAtBDEEEQdCewwAoAgAiAEG/BiAAGxEAAAAL6QIBBn8jAEEQayIHJAAgASABQQhqIgMoAgAQpgMgAkH8AWooAgAhBCACKAL4ASEFAkACQCABKAIQQQFGBEAgAygCACIDIAFBFGooAgAiBk0NAiABKAIAIAZBoAJsaiIDKAIAQQFHDQFBsOHAAEERQcThwAAQ+woACwJAIARFDQAgBUUNACAEQQN0RQ0AIAUQ2gELQdThwABBPiAHQQhqQay+wABBlOLAABCbCAALIAIoAgAhCCADQQE2AgAgASABKAIYQQFqNgIYIAEgAykCBDcCECADQQhqIAg2AgAgAyABKAIMIgE2AgQgA0EMaiACQQRqQfQBEJ4KGiADQYQCaiAENgIAIANBgAJqIAU2AgAgA0GIAmogAkGAAmopAwA3AwAgA0GQAmogAkGIAmopAwA3AwAgA0GYAmogAkGQAmopAwA3AwAgACABNgIEIAAgBjYCACAHQRBqJAAPCyAGIANBoOHAABDPCAALtAICAX8KfSMAQSBrIgQkACACKgIEIAFBFGoqAgCTIgsgAUEIaioCACIFlCACKgIIIAFBGGoqAgCTIgwgAUEEaioCACIIlJMiBiAGkiEGIAwgASoCACIKlCACKgIAIAEqAhCTIgcgBZSTIgkgCZIhCSAEIAcgASoCDCINIAaUIAUgCZQgCCAHIAiUIAsgCpSTIgcgB5IiB5STkpIiDjgCACAEIAwgDSAHlCAIIAaUIAogCZSTkpIiCDgCCCAEIAsgDSAJlCAKIAeUIAUgBpSTkpIiBTgCBCAEQRBqIAAgBCADECggBCoCECAOkyIGIAaUIAQqAhQgBZMiBSAFlJIgBCoCGCAIkyIFIAWUkkMAAAAAkhCrASEFIAQtABwhACAEQSBqJAAgBSAFIAWMIAMbIABBAUcbC7QCAgF/Cn0jAEEgayIEJAAgAioCBCABQRRqKgIAkyILIAFBCGoqAgAiBZQgAioCCCABQRhqKgIAkyIMIAFBBGoqAgAiCJSTIgYgBpIhBiAMIAEqAgAiCpQgAioCACABKgIQkyIHIAWUkyIJIAmSIQkgBCAHIAEqAgwiDSAGlCAFIAmUIAggByAIlCALIAqUkyIHIAeSIgeUk5KSIg44AgAgBCAMIA0gB5QgCCAGlCAKIAmUk5KSIgg4AgggBCALIA0gCZQgCiAHlCAFIAaUk5KSIgU4AgQgBEEQaiAAIAQgAxAqIAQqAhAgDpMiBiAGlCAEKgIUIAWTIgUgBZSSIAQqAhggCJMiBSAFlJJDAAAAAJIQqwEhBSAELQAcIQAgBEEgaiQAIAUgBSAFjCADGyAAQQFHGwu4AgIBfwl9IwBBIGsiBCQAIAIqAgAgASoCEJMiCyABQQRqKgIAIgWUIAIqAgQgAUEUaioCAJMiDCABKgIAIgmUkyIHIAeSIQcgDCABQQhqKgIAIgqUIAIqAgggAUEYaioCAJMiBiAFlJMiCCAIkiEIIAQgBiABKgIMIg0gB5QgBSAIlCAJIAYgCZQgCyAKlJMiBiAGkiIGlJOSkjgCCCAEIAwgDSAGlCAJIAeUIAogCJSTkpI4AgQgBCALIA0gCJQgCiAGlCAFIAeUk5KSOAIAIARBEGogACAEIAMQpgIgBCoCECAEKgIAkyIFIAWUIAQqAhQgBCoCBJMiBSAFlJIgBCoCGCAEKgIIkyIFIAWUkkMAAAAAkhCrASEFIAQtABwhACAEQSBqJAAgBSAFIAWMIAMbIABBAUcbC7cCAgF/CX0jAEEgayIEJAAgAioCACABKgIQkyILIAFBBGoqAgAiBZQgAioCBCABQRRqKgIAkyIMIAEqAgAiCZSTIgcgB5IhByAMIAFBCGoqAgAiCpQgAioCCCABQRhqKgIAkyIGIAWUkyIIIAiSIQggBCAGIAEqAgwiDSAHlCAFIAiUIAkgBiAJlCALIAqUkyIGIAaSIgaUk5KSOAIIIAQgDCANIAaUIAkgB5QgCiAIlJOSkjgCBCAEIAsgDSAIlCAKIAaUIAUgB5STkpI4AgAgBEEQaiAAIAQgAxBJIAQqAhAgBCoCAJMiBSAFlCAEKgIUIAQqAgSTIgUgBZSSIAQqAhggBCoCCJMiBSAFlJJDAAAAAJIQqwEhBSAELQAcIQAgBEEgaiQAIAUgBSAFjCADGyAAQQFHGwu0AgIBfwp9IwBBIGsiBCQAIAIqAgQgAUEUaioCAJMiCyABQQhqKgIAIgWUIAIqAgggAUEYaioCAJMiDCABQQRqKgIAIgiUkyIGIAaSIQYgDCABKgIAIgqUIAIqAgAgASoCEJMiByAFlJMiCSAJkiEJIAQgByABKgIMIg0gBpQgBSAJlCAIIAcgCJQgCyAKlJMiByAHkiIHlJOSkiIOOAIAIAQgDCANIAeUIAggBpQgCiAJlJOSkiIIOAIIIAQgCyANIAmUIAogB5QgBSAGlJOSkiIFOAIEIARBEGogACAEIAMQKSAEKgIQIA6TIgYgBpQgBCoCFCAFkyIFIAWUkiAEKgIYIAiTIgUgBZSSQwAAAACSEKsBIQUgBC0AHCEAIARBIGokACAFIAUgBYwgAxsgAEEBRxsLtwICAX8JfSMAQSBrIgQkACACKgIAIAEqAhCTIgsgAUEEaioCACIFlCACKgIEIAFBFGoqAgCTIgwgASoCACIJlJMiByAHkiEHIAwgAUEIaioCACIKlCACKgIIIAFBGGoqAgCTIgYgBZSTIgggCJIhCCAEIAYgASoCDCINIAeUIAUgCJQgCSAGIAmUIAsgCpSTIgYgBpIiBpSTkpI4AgggBCAMIA0gBpQgCSAHlCAKIAiUk5KSOAIEIAQgCyANIAiUIAogBpQgBSAHlJOSkjgCACAEQRBqIAAgBCADEGMgBCoCECAEKgIAkyIFIAWUIAQqAhQgBCoCBJMiBSAFlJIgBCoCGCAEKgIIkyIFIAWUkkMAAAAAkhCrASEFIAQtABwhACAEQSBqJAAgBSAFIAWMIAMbIABBAUcbC7UCAgF/Cn0jAEEgayIEJAAgAioCBCABQRRqKgIAkyILIAFBCGoqAgAiBZQgAioCCCABQRhqKgIAkyIMIAFBBGoqAgAiCJSTIgYgBpIhBiAMIAEqAgAiCpQgAioCACABKgIQkyIHIAWUkyIJIAmSIQkgBCAHIAEqAgwiDSAGlCAFIAmUIAggByAIlCALIAqUkyIHIAeSIgeUk5KSIg44AgAgBCAMIA0gB5QgCCAGlCAKIAmUk5KSIgg4AgggBCALIA0gCZQgCiAHlCAFIAaUk5KSIgU4AgQgBEEQaiAAIAQgAxDEAiAEKgIQIA6TIgYgBpQgBCoCFCAFkyIFIAWUkiAEKgIYIAiTIgUgBZSSQwAAAACSEKsBIQUgBC0AHCEAIARBIGokACAFIAUgBYwgAxsgAEEBRxsLtAICAX8KfSMAQSBrIgQkACACKgIEIAFBFGoqAgCTIgsgAUEIaioCACIFlCACKgIIIAFBGGoqAgCTIgwgAUEEaioCACIIlJMiBiAGkiEGIAwgASoCACIKlCACKgIAIAEqAhCTIgcgBZSTIgkgCZIhCSAEIAcgASoCDCINIAaUIAUgCZQgCCAHIAiUIAsgCpSTIgcgB5IiB5STkpIiDjgCACAEIAwgDSAHlCAIIAaUIAogCZSTkpIiCDgCCCAEIAsgDSAJlCAKIAeUIAUgBpSTkpIiBTgCBCAEQRBqIAAgBCADECsgBCoCECAOkyIGIAaUIAQqAhQgBZMiBSAFlJIgBCoCGCAIkyIFIAWUkkMAAAAAkhCrASEFIAQtABwhACAEQSBqJAAgBSAFIAWMIAMbIABBAUcbC7cCAgF/CX0jAEEgayIEJAAgAioCACABKgIQkyILIAFBBGoqAgAiBZQgAioCBCABQRRqKgIAkyIMIAEqAgAiCZSTIgcgB5IhByAMIAFBCGoqAgAiCpQgAioCCCABQRhqKgIAkyIGIAWUkyIIIAiSIQggBCAGIAEqAgwiDSAHlCAFIAiUIAkgBiAJlCALIAqUkyIGIAaSIgaUk5KSOAIIIAQgDCANIAaUIAkgB5QgCiAIlJOSkjgCBCAEIAsgDSAIlCAKIAaUIAUgB5STkpI4AgAgBEEQaiAAIAQgAxBQIAQqAhAgBCoCAJMiBSAFlCAEKgIUIAQqAgSTIgUgBZSSIAQqAhggBCoCCJMiBSAFlJJDAAAAAJIQqwEhBSAELQAcIQAgBEEgaiQAIAUgBSAFjCADGyAAQQFHGwu1AgIBfwp9IwBBIGsiBCQAIAIqAgQgAUEUaioCAJMiCyABQQhqKgIAIgWUIAIqAgggAUEYaioCAJMiDCABQQRqKgIAIgiUkyIGIAaSIQYgDCABKgIAIgqUIAIqAgAgASoCEJMiByAFlJMiCSAJkiEJIAQgByABKgIMIg0gBpQgBSAJlCAIIAcgCJQgCyAKlJMiByAHkiIHlJOSkiIOOAIAIAQgDCANIAeUIAggBpQgCiAJlJOSkiIIOAIIIAQgCyANIAmUIAogB5QgBSAGlJOSkiIFOAIEIARBEGogACAEIAMQ9AIgBCoCECAOkyIGIAaUIAQqAhQgBZMiBSAFlJIgBCoCGCAIkyIFIAWUkkMAAAAAkhCrASEFIAQtABwhACAEQSBqJAAgBSAFIAWMIAMbIABBAUcbC7QCAgF/Cn0jAEEgayIEJAAgAioCBCABQRRqKgIAkyILIAFBCGoqAgAiBZQgAioCCCABQRhqKgIAkyIMIAFBBGoqAgAiCJSTIgYgBpIhBiAMIAEqAgAiCpQgAioCACABKgIQkyIHIAWUkyIJIAmSIQkgBCAHIAEqAgwiDSAGlCAFIAmUIAggByAIlCALIAqUkyIHIAeSIgeUk5KSIg44AgAgBCAMIA0gB5QgCCAGlCAKIAmUk5KSIgg4AgggBCALIA0gCZQgCiAHlCAFIAaUk5KSIgU4AgQgBEEQaiAAIAQgAxAsIAQqAhAgDpMiBiAGlCAEKgIUIAWTIgUgBZSSIAQqAhggCJMiBSAFlJJDAAAAAJIQqwEhBSAELQAcIQAgBEEgaiQAIAUgBSAFjCADGyAAQQFHGwu0AgIBfwp9IwBBIGsiBCQAIAIqAgQgAUEUaioCAJMiCyABQQhqKgIAIgWUIAIqAgggAUEYaioCAJMiDCABQQRqKgIAIgiUkyIGIAaSIQYgDCABKgIAIgqUIAIqAgAgASoCEJMiByAFlJMiCSAJkiEJIAQgByABKgIMIg0gBpQgBSAJlCAIIAcgCJQgCyAKlJMiByAHkiIHlJOSkiIOOAIAIAQgDCANIAeUIAggBpQgCiAJlJOSkiIIOAIIIAQgCyANIAmUIAogB5QgBSAGlJOSkiIFOAIEIARBEGogACAEIAMQJyAEKgIQIA6TIgYgBpQgBCoCFCAFkyIFIAWUkiAEKgIYIAiTIgUgBZSSQwAAAACSEKsBIQUgBC0AHCEAIARBIGokACAFIAUgBYwgAxsgAEEBRxsLxwICA38NfSMAQSBrIgQkACAEQQhqIAEgAhDWAiABKgJgIgdDAAAAAGBFBEBB4cHBAEEmQYjCwQAQ/goACyAEQQhqIgJBEGoiBSoCACEIIAJBFGoiBioCACEJIAQqAgghCiAEKgIMIQsgBCoCECEMIAQqAhQhDSACIAEgAxDWAiAFKgIAIQ4gBCoCCCEPIAQqAgwhECAEKgIQIREgBCoCFCESIABBFGogByAJkiIJIAcgBioCAJIiEyAJIBNgGzgCACAAQRBqIAcgCJIiCCAHIA6SIgkgCCAJYBs4AgAgACAHIA2SIgggByASkiIJIAggCWAbOAIMIAAgDCAHkyIIIBEgB5MiCSAIIAlfGzgCCCAAIAsgB5MiCCAQIAeTIgkgCCAJXxs4AgQgACAKIAeTIgggDyAHkyIHIAggB18bOAIAIARBIGokAAvHAgIDfw19IwBBIGsiBCQAIARBCGogASACEMUCIAEqAiQiB0MAAAAAYEUEQEHhwcEAQSZBiMLBABD+CgALIARBCGoiAkEQaiIFKgIAIQggAkEUaiIGKgIAIQkgBCoCCCEKIAQqAgwhCyAEKgIQIQwgBCoCFCENIAIgASADEMUCIAUqAgAhDiAEKgIIIQ8gBCoCDCEQIAQqAhAhESAEKgIUIRIgAEEUaiAHIAmSIgkgByAGKgIAkiITIAkgE2AbOAIAIABBEGogByAIkiIIIAcgDpIiCSAIIAlgGzgCACAAIAcgDZIiCCAHIBKSIgkgCCAJYBs4AgwgACAMIAeTIgggESAHkyIJIAggCV8bOAIIIAAgCyAHkyIIIBAgB5MiCSAIIAlfGzgCBCAAIAogB5MiCCAPIAeTIgcgCCAHXxs4AgAgBEEgaiQAC9wCAQR/IwBBQGoiAyQAAkACQAJAIABFDQAgACgCACIEQX9GDQEgACAEQQFqNgIAIAFFDQAgASgCACIEQX9GDQEgASAEQQFqNgIAIAJFDQAgAigCACIEQX9GDQEgAiAEQQFqNgIAIANBEGoiBEEIaiAAQQRqIgVBCGooAgA2AgAgAyAFKQIANwMQIANBIGoiBUEIaiABQQRqIgZBCGooAgA2AgAgAyAGKQIANwMgIANBMGoiBkEIaiACQQxqKAIANgIAIAMgAikCBDcDMCADQQhqIAQgBSAGELwGIAMoAgwhBCADKAIIIQUgAiACKAIAQX9qNgIAIAEgASgCAEF/ajYCACAAIAAoAgBBf2o2AgBBDEEEEMgLIgBFDQIgACAENgIIIAAgBTYCBCAAQQA2AgAgA0FAayQAIAAPCxCiDAALEKMMAAtBDEEEQdCewwAoAgAiAEG/BiAAGxEAAAALswICAX8KfSMAQTBrIgQkACACKgIEIAFBFGoqAgCTIgsgAUEIaioCACIFlCACKgIIIAFBGGoqAgCTIgwgAUEEaioCACIIlJMiBiAGkiEGIAwgASoCACIKlCACKgIAIAEqAhCTIgcgBZSTIgkgCZIhCSAEIAcgASoCDCINIAaUIAUgCZQgCCAHIAiUIAsgCpSTIgcgB5IiB5STkpIiDjgCACAEIAwgDSAHlCAIIAaUIAogCZSTkpIiCDgCCCAEIAsgDSAJlCAKIAeUIAUgBpSTkpIiBTgCBCAEQRBqIAAgBBDjAiAELQAcIQAgBCoCECAOkyIGIAaUIAQqAhQgBZMiBSAFlJIgBCoCGCAIkyIFIAWUkkMAAAAAkhCrASEFIARBMGokACAFIAUgBYwgAxsgAEEBRxsLuQIBCX0gACABQeQAaioCACIHIAEqAlgiBZMiBiAGlCABQegAaioCACIGIAFB3ABqKgIAIgiTIgMgA5SSIAFB7ABqKgIAIgMgAUHgAGoqAgAiBJMiCSAJlJJDAAAAAJIQqwE4AgwgCCAGkkMAAAA/lCIJIAIqAgAiBpQgBSAHkkMAAAA/lCIKIAJBBGoqAgAiB5STIgUgBZIhBSAKIAJBCGoqAgAiCJQgBCADkkMAAAA/lCIEIAaUkyIDIAOSIQMgACACQRhqKgIAIAQgAkEMaioCACILIAWUIAYgA5QgByAEIAeUIAkgCJSTIgQgBJIiBJSTkpKSOAIIIAAgAkEUaioCACAJIAsgA5QgCCAElCAGIAWUk5KSkjgCBCAAIAIqAhAgCiALIASUIAcgBZQgCCADlJOSkpI4AgALtAIBCX0gACABQSxqKgIAIgcgASoCICIFkyIGIAaUIAFBMGoqAgAiBiABQSRqKgIAIgiTIgMgA5SSIAFBNGoqAgAiAyABQShqKgIAIgSTIgkgCZSSQwAAAACSEKsBOAIMIAggBpJDAAAAP5QiCSACKgIAIgaUIAUgB5JDAAAAP5QiCiACQQRqKgIAIgeUkyIFIAWSIQUgCiACQQhqKgIAIgiUIAQgA5JDAAAAP5QiBCAGlJMiAyADkiEDIAAgAkEYaioCACAEIAJBDGoqAgAiCyAFlCAGIAOUIAcgBCAHlCAJIAiUkyIEIASSIgSUk5KSkjgCCCAAIAJBFGoqAgAgCSALIAOUIAggBJQgBiAFlJOSkpI4AgQgACACKgIQIAogCyAElCAHIAWUIAggA5STkpKSOAIAC74CAQV/An8CQAJAAkACQCACQQNqQXxxIAJrIgRFDQAgAyAEIAQgA0sbIgRFDQAgAUH/AXEhBgNAIAIgBWotAAAgBkYNBCAFQQFqIgUgBEcNAAsgBCADQXhqIgZLDQIMAQsgA0F4aiEGQQAhBAsgAUH/AXFBgYKECGwhBQNAIAIgBGoiB0EEaigCACAFcyIIQX9zIAhB//37d2pxIAcoAgAgBXMiB0F/cyAHQf/9+3dqcXJBgIGChHhxRQRAIARBCGoiBCAGTQ0BCwsgBCADTQ0AIAQgA0HwgMMAENAIAAsCQCADIARHBEAgAyAEayEDIAIgBGohAkEAIQUgAUH/AXEhAQNAIAIgBWotAAAgAUYNAiADIAVBAWoiBUcNAAsLQQAMAgsgBCAFaiEFC0EBCyEEIAAgBTYCBCAAIAQ2AgALwwICBX8BfiMAQTBrIgUkAEEnIQMCQCAAQpDOAFQEQCAAIQgMAQsDQCAFQQlqIANqIgRBfGogACAAQpDOAIAiCEKQzgB+faciBkH//wNxQeQAbiIHQQF0Qcb9wgBqLwAAOwAAIARBfmogBiAHQeQAbGtB//8DcUEBdEHG/cIAai8AADsAACADQXxqIQMgAEL/wdcvViAIIQANAAsLIAinIgRB4wBKBEAgCKciBkH//wNxQeQAbiEEIANBfmoiAyAFQQlqaiAGIARB5ABsa0H//wNxQQF0Qcb9wgBqLwAAOwAACwJAIARBCk4EQCADQX5qIgMgBUEJamogBEEBdEHG/cIAai8AADsAAAwBCyADQX9qIgMgBUEJamogBEEwajoAAAsgAiABQYT5wgBBACAFQQlqIANqQScgA2sQmgIgBUEwaiQAC7cCAQl9IAAgASoCGCABKgIMIgcgASoCACIFkyIGIAaUIAFBEGoqAgAiBiABKgIEIgiTIgMgA5SSIAFBFGoqAgAiAyABKgIIIgSTIgkgCZSSQwAAAACSEKsBQwAAAD+UkjgCDCAGIAiSQwAAAD+UIgkgAioCACIGlCAHIAWSQwAAAD+UIgogAkEEaioCACIHlJMiBSAFkiEFIAogAkEIaioCACIIlCADIASSQwAAAD+UIgQgBpSTIgMgA5IhAyAAIAJBGGoqAgAgBCACQQxqKgIAIgsgBZQgBiADlCAHIAQgB5QgCSAIlJMiBCAEkiIElJOSkpI4AgggACACQRRqKgIAIAkgCyADlCAIIASUIAYgBZSTkpKSOAIEIAAgAioCECAKIAsgBJQgByAFlCAIIAOUk5KSkjgCAAveAgEEfyMAQaABayIEJAAgAkI/NwMgIAJBfzYCkAEgAkEEaiEGIAIoAgAhBQJAAkACQCABKAIQQQFGBEAgASgCCCIDIAFBFGooAgAiAk0NAiABKAIAIAJBoAFsaiIDKAIAQQFGDQMgA0EBNgIAIAEgASgCGEEBajYCGCABIAMpAgQ3AhAgA0EIaiAFNgIAIAMgASgCDCIFNgIEIANBDGogBkGUARCeChoMAQsgBCAFNgIIIARBCGoiAkEEciAGQZQBEJ4KGiAEIAEgAhDDBCAEKAIEIQUgBCgCACECCyABQSRqKAIAIgMgAUEgaigCAEYEQCABQRxqIANBARDBBSABKAIkIQMLIAEgA0EBajYCJCABKAIcIANBA3RqIgEgBTYCBCABIAI2AgAgACAFNgIEIAAgAjYCACAEQaABaiQADwsgAiADQaDhwAAQzwgAC0Gw4cAAQRFBxOHAABD7CgALwQICAX8FfSMAQRBrIgYkAAJAIAIgApQgBCAElJIgAyADlCAFIAWUkpJDAAAAAJIiB0MAAAAAXkEBc0UEQCAHEKsBIQcgBiAAIAEQ8gYgBigCACIARQ0BAkAgBCAHlSIIIAiMIAUgB5UiBEMAAAAAYCIBGyIKIAqUIAMgB5UiCSAJjCABGyILIAuUIAIgB5UiByAHjCABGyIFIAWUkpJDAAAAAJIiAkMAAAAAXkEBc0UEQCAGIAogAhCrASIDlSAIIAiUIAkgCZQgByAHlJKSQwAAAACSEKsBIAS8Qf////8Hcb4Q7QEiAiACkiIClDgCCCAGIAsgA5UgApQ4AgQgBiAFIAOVIAKUOAIADAELIAZBCGpBADYCACAGQgA3AwALIAAgBhDaBgsgBkEQaiQADwtBkKrAAEHNAEGYq8AAEJwJAAvBAgIBfwV9IwBBEGsiBiQAAkAgAiAClCAEIASUkiADIAOUIAUgBZSSkkMAAAAAkiIHQwAAAABeQQFzRQRAIAcQqwEhByAGIAAgARDuBiAGKAIAIgBFDQECQCAEIAeVIgggCIwgBSAHlSIEQwAAAABgIgEbIgogCpQgAyAHlSIJIAmMIAEbIgsgC5QgAiAHlSIHIAeMIAEbIgUgBZSSkkMAAAAAkiICQwAAAABeQQFzRQRAIAYgCiACEKsBIgOVIAggCJQgCSAJlCAHIAeUkpJDAAAAAJIQqwEgBLxB/////wdxvhDtASICIAKSIgKUOAIIIAYgCyADlSAClDgCBCAGIAUgA5UgApQ4AgAMAQsgBkEIakEANgIAIAZCADcDAAsgACAGEOcGCyAGQRBqJAAPC0Goq8AAQcwAQayswAAQnAkAC8ECAgF/BX0jAEEQayIGJAACQCACIAKUIAQgBJSSIAMgA5QgBSAFlJKSQwAAAACSIgdDAAAAAF5BAXNFBEAgBxCrASEHIAYgACABEO4GIAYoAgAiAEUNAQJAIAQgB5UiCCAIjCAFIAeVIgRDAAAAAGAiARsiCiAKlCADIAeVIgkgCYwgARsiCyALlCACIAeVIgcgB4wgARsiBSAFlJKSQwAAAACSIgJDAAAAAF5BAXNFBEAgBiAKIAIQqwEiA5UgCCAIlCAJIAmUIAcgB5SSkkMAAAAAkhCrASAEvEH/////B3G+EO0BIgIgApIiApQ4AgggBiALIAOVIAKUOAIEIAYgBSADlSAClDgCAAwBCyAGQQhqQQA2AgAgBkIANwMACyAAIAYQ0gYLIAZBEGokAA8LQairwABBzABBrKzAABCcCQALvQIBC38gAUEEaigCACIGIAEoAgAiByACcSIFaigAACIEIAJBGXZBgYKECGwiCXMiAkF/cyACQf/9+3dqcUGAgYKEeHEhAiAGQXxqIQogA0EEaigCACELIAFBGGooAgAhCCADKAIAIQwgASgCECENQQAhAQJAAn8DQCACRQRAA0BBACAEQQF0IARxQYCBgoR4cQ0DGiABIAVqIQIgAUEEaiEBIAkgAkEEaiAHcSIFIAZqKAAAIgRzIgJBf3MgAkH//ft3anFBgIGChHhxIgJFDQALCyAIIAogAmhBA3YgBWogB3FBAnRrKAIAIgNNDQIgAkF/aiACcSECIANBBHQgDWoiDkEEaigCACAMRw0AIA5BCGooAgAgC0cNAAtBAQshBCAAIAM2AgQgACAENgIADwsgAyAIQbTdwAAQzwgAC8ECAgN/AX4jAEFAaiIEJAACQAJAIABFDQAgACgCACIFQX9GDQEgACAFQQFqNgIAIAFFDQAgASgCAA0BIAFBADYCACAEQThqIAFBCGopAgA3AwAgASkCACEHIARBCGogBEE8aigCADYCACAEIAc3AzAgBCAEKQI0NwMAIAEQ2gEgAkUNACACKAIADQEgAkEANgIAIARBMGoiAUEIaiIFIAJBCGopAgA3AwAgAikCACEHIARBGGoiBiAEQTxqKAIANgIAIAQgBzcDMCAEIAQpAjQ3AxAgAhDaASAEIAM2AhwgBEEgaiICQQhqIARBCGooAgA2AgAgBCAEKQMANwMgIAUgBigCADYCACAEIAQpAxA3AzAgAEEEaiACIAEgBEEcahCOASAAIAAoAgBBf2o2AgAgBEFAayQADwsQogwACxCjDAALwwICAn8IfQJAIAEoAggiAwRAIAEoAgAiAioCCCEFIAIqAgQhBiACKgIAIQcCQCADQQFGBEAgBSEIIAYhCSAHIQoMAQsgA0EMbCACaiEDIAJBDGohAiAHIQogBiEJIAUhCANAIAggAkEIaioCACILIAggC2AbIQggCSACQQRqKgIAIgQgCSAEYBshCSAFIAsgBSALXxshBSAGIAQgBiAEXxshBiAKIAIqAgAiBCAKIARgGyEKIAcgBCAHIARfGyEHIAMgAkEMaiICRw0ACwsgASoCYCIEQwAAAABgRQ0BIABBFGogCCAEkjgCACAAQRBqIAkgBJI4AgAgACAKIASSOAIMIAAgBSAEkzgCCCAAIAYgBJM4AgQgACAHIASTOAIADwtBh8PBAEHSAEHsw8EAEJwJAAtB4cHBAEEmQYjCwQAQ/goAC2IBBH9BvKLDACgCACIARQRAQcyiwwBB/x82AgBBAA8LA0AgACIBKAIIIQAgASgCBBogASgCABogAUEMaigCABogAkEBaiECIAANAAtBzKLDACACQf8fIAJB/x9LGzYCAEEAC8cCAgN/BX0CQCABKAIIIgIEQCABKAIAIgMgAkEMbGohBCADKgIIRAAAAAAAAPA/IAK4o7YiBZQhByADKgIEIAWUIQggAyoCACAFlCEJIAJBAUcEQCADQQxqIQIDQCAJIAIqAgAgBZSSIQkgByACQQhqKgIAIAWUkiEHIAggAkEEaioCACAFlJIhCCAEIAJBDGoiAkcNAAsLQwAAAAAhBQNAIAkgAyoCAJMiBiAGlCAIIANBBGoqAgCTIgYgBpSSIAcgA0EIaioCAJMiBiAGlJJDAAAAAJIiBiAFIAYgBV4bIQUgBCADQQxqIgNHDQALIAUQqwEhBSABKgJgIgZDAAAAAGBFDQEgACAHOAIIIAAgCDgCBCAAIAk4AgAgACAFIAaSOAIMDwtBgMXCAEEvQZDGwgAQ/goAC0HhwcEAQSZB8MTBABD+CgALqwIBCX0gACABKgIMIgcgASoCACIFkyIGIAaUIAFBEGoqAgAiBiABKgIEIgiTIgMgA5SSIAFBFGoqAgAiAyABKgIIIgSTIgkgCZSSQwAAAACSEKsBOAIMIAggBpJDAAAAP5QiCSACKgIAIgaUIAUgB5JDAAAAP5QiCiACQQRqKgIAIgeUkyIFIAWSIQUgCiACQQhqKgIAIgiUIAQgA5JDAAAAP5QiBCAGlJMiAyADkiEDIAAgAkEYaioCACAEIAJBDGoqAgAiCyAFlCAGIAOUIAcgBCAHlCAJIAiUkyIEIASSIgSUk5KSkjgCCCAAIAJBFGoqAgAgCSALIAOUIAggBJQgBiAFlJOSkpI4AgQgACACKgIQIAogCyAElCAHIAWUIAggA5STkpKSOAIAC+oCAgJ/An0CQAJ9AkACQCAAvCICQf////8HcSIBQf////sDTQRAIAFBgICA+ANJDQEgAkF/TA0CQwAAgD8gAJNDAAAAP5QiABCrASIEvEGAYHG+IQMgACAAIABDa9MNvJRDuhMvvZKUQ3WqKj6SlCAAQ67lNL+UQwAAgD+SlSAElCAAIAMgA5STIAQgA5KVkiADkiIAIACSDwsgAUGAgID8A0YNA0MAAAAAIAAgAJOVDwtD2g/JPyABQYGAgJQDSQ0BGkNoIaIzIAAgAJQiAyADIANDa9MNvJRDuhMvvZKUQ3WqKj6SlCADQ67lNL+UQwAAgD+SlSAAlJMgAJND2g/JP5IPC0PaD8k/IABDAACAP5JDAAAAP5QiABCrASIDIAMgACAAIABDa9MNvJRDuhMvvZKUQ3WqKj6SlCAAQ67lNL+UQwAAgD+SlZRDaCGis5KSkyIAIACSCw8LQwAAAABD2g9JQCACQX9KGwvFAgEEfyAAQgA3AhAgAAJ/QQAgAUEIdiICRQ0AGkEfIAFB////B0sNABogAUEGIAJnIgNrQR9xdkEBcSADQQF0a0E+agsiAzYCHCADQQJ0QZyhwwBqIQQgACECAkACQAJAAkBBkJ/DACgCACIAQQEgA0EfcXQiBXEEQEEAQRkgA0EBdmsgA0EfRhshACAEKAIAIgMoAgRBeHEgAUcNASADIQAMAgtBkJ/DACAAIAVyNgIAIAQgAjYCACACIAQ2AhgMAwsgASAAQR9xdCEEA0AgBEEddkEEcSADakEQaiIFKAIAIgBFDQIgBEEBdCEEIAAiAygCBEF4cSABRw0ACwsgACgCCCIBIAI2AgwgACACNgIIIAIgADYCDCACIAE2AgggAkEANgIYDwsgBSACNgIAIAIgAzYCGAsgAiACNgIIIAIgAjYCDAvJAgECfyMAQSBrIgYkAAJAAkACQCAARQ0AIAAoAgAiBUF/Rg0BIAAgBUEBajYCACABRQ0AIAEoAgAiBUF/Rg0BIAEgBUEBajYCACACRQ0AIAIoAgAiBUF/Rg0BIAIgBUEBajYCAEEAIQUgBkEIaiAAQQRqIAFBBGogAkEEaiADQQBHIAQQeCACIAIoAgBBf2o2AgAgASABKAIAQX9qNgIAIAAgACgCAEF/ajYCACAGLQAcIgBBAkcEQEEcQQQQyAsiBUUNAyAFQQA2AgAgBSAGKQMINwIEIAUgADoAGCAFIAZBHWoiAC8AADsAGSAFQQxqIAZBEGopAwA3AgAgBUEUaiAGQRhqKAIANgIAIAVBG2ogAEECai0AADoAAAsgBkEgaiQAIAUPCxCiDAALEKMMAAtBHEEEQdCewwAoAgAiAEG/BiAAGxEAAAALvgIBCn0gACABKgIAIgJDq6qqPpQgASoCDCIDQ6uqqj6UkiABKgIYIgRDq6qqPpSSIgcgBJMiBCAElCABKgIEIghDq6qqPpQgAUEQaioCACIJQ6uqqj6UkiABQRxqKgIAIgVDq6qqPpSSIgQgBZMiBSAFlJIgASoCCCIKQ6uqqj6UIAFBFGoqAgAiC0Orqqo+lJIgAUEgaioCACIGQ6uqqj6UkiIFIAaTIgYgBpSSQwAAAACSIgYgByADkyIDIAOUIAQgCZMiAyADlJIgBSALkyIDIAOUkkMAAAAAkiIDIAcgApMiAiAClCAEIAiTIgIgApSSIAUgCpMiAiAClJJDAAAAAJIiAkMAAAAAIAJDAAAAAF4bIgIgAyACXhsiAiAGIAJeGxCrATgCDCAAIAU4AgggACAEOAIEIAAgBzgCAAvnAgEEfwJAAkAgASABXCAAIABcckUEQCABvCICQYCAgPwDRw0BIAAQuwQPCyAAIAGSIQEMAQsgAkEedkECcSIFIAC8IgNBH3ZyIQQCQAJAAkACQAJAIANB/////wdxIgNFBEBD2w9JwCEBIAQOAwEBAgYLIAJB/////wdxIgJBgICA/AdHBEAgAkUNBCADQYCAgPwHRg0DIAJBgICA6ABqIANJDQMCfSADQYCAgOgAaiACSQRAQwAAAAAgBQ0BGgsgACABlYsQuwQLIQECQAJAAkAgBA4DCQECAAsgAUMuvbszkkPbD0nAkg8LIAGMDwtD2w9JQCABQy69uzOSkw8LIANBgICA/AdGDQRD2w9JwCEBIARBA0YNBSAEQQJ0QdiXwwBqKgIADwsgAA8LQ9sPSUAPC0PbD8k/IACYDwtD2w/JPyAAmA8LQ+TLFsAhASAEQQNGDQAgBEECdEHMl8MAaioCAA8LIAELwAIBA38jAEGAAWsiAyQAAkACQAJAAkAgASgCACICQRBxRQRAIAJBIHENASAANQIAQQEgARDtBCEADAQLIAAoAgAhAkEAIQADQCAAIANqQf8AaiACQQ9xIgRBMHIgBEHXAGogBEEKSRs6AAAgAEF/aiEAIAJBBHYiAg0ACyAAQYABaiICQYEBTw0BIAFBAUHE/cIAQQIgACADakGAAWpBACAAaxCaAiEADAMLIAAoAgAhAkEAIQADQCAAIANqQf8AaiACQQ9xIgRBMHIgBEE3aiAEQQpJGzoAACAAQX9qIQAgAkEEdiICDQALIABBgAFqIgJBgQFPDQEgAUEBQcT9wgBBAiAAIANqQYABakEAIABrEJoCIQAMAgsgAkGAAUG0/cIAENAIAAsgAkGAAUG0/cIAENAIAAsgA0GAAWokACAAC9MCAgF/AX0jAEFAaiIDJAAgA0EwaiABIAIQuAkgAygCMCIBBEAgA0EoaiABEKEKQQAhAgJAAn0CQAJAAkACQAJAIAMoAiggAygCLCgCjAERBwBB/wFxDhAABgEGBgYGBgYGBgIDBgYEBgsgAyABEKEKIAMoAgAgAygCBBDiCSIBRQ0FIAEqAgAMBAsgA0EIaiABEKEKIAMoAgggAygCDBDlCSIBRQ0EIAFBGGoqAgAMAwsgA0EQaiABEKEKIAMoAhAgAygCFBDrCSIBRQ0DIAFBBGoqAgAMAgsgA0EYaiABEKEKIAMoAhggAygCHBDsCSIBRQ0CIAFBBGoqAgAMAQsgA0EgaiABEKEKIAMoAiAgAygCJBDtCSIBRQ0BIAFBBGoqAgALIQRBASECCyAAIAQ4AgQgACACNgIAIANBQGskAA8LQairwABBzABBnKzAABCcCQAL2AIBBH8jAEEwayIDJAAgA0EgaiABIAIQuAkCQAJAAkAgAygCICIBBEAgA0EYaiABEKEKIAMoAhggAygCHCgCjAERBwBB/wFxQQhGBEAgA0EQaiABEKEKIAMoAhAgAygCFBDpCSIBRQRAIABBADYCAAwFCyABKAIIIgVB/////wNxIQIgAiAFRw0CAkAgBUECdCIEQQBOBEAgAiAFRkECdCECIAEoAgAhBiAERQRAIAJFDQJBACEEDAYLIAQgAhDICyIBRQ0BIARBAnZBACABGyEEIAEhAgwFCyADQQhqIgBBADYCBCAAIAM2AgAQlgwACyAEIAJB0J7DACgCACIAQb8GIAAbEQAAAAsgAEEANgIADAMLQairwABBzABBnKzAABCcCQALEJYMAAsgAiAGIAVBAnQQngohASAAQQhqIAU2AgAgACAENgIEIAAgATYCAAsgA0EwaiQAC8MCAQJ/IwBBEGsiCCQAAkACQAJAIABFDQAgACgCACIHQX9GDQEgACAHQQFqNgIAIAFFDQAgASgCACIHQX9GDQEgASAHQQFqNgIAIAJFDQAgAigCACIHQX9GDQEgAiAHQQFqNgIAIANFDQAgAygCACIHQX9GDQEgAyAHQQFqNgIAQQAhByAIIABBBGogAUEEaiACQQRqIANBBGogBCAFQQBHIAYQggEgAyADKAIAQX9qNgIAIAIgAigCAEF/ajYCACABIAEoAgBBf2o2AgAgACAAKAIAQX9qNgIAIAgoAgBBAUYEQEEQQQQQyAsiB0UNAyAHQQA2AgAgByAIQQRyIgApAgA3AgQgB0EMaiAAQQhqKAIANgIACyAIQRBqJAAgBw8LEKIMAAsQowwAC0EQQQRB0J7DACgCACIAQb8GIAAbEQAAAAuxAgECfyMAQRBrIggkAAJAAkAgAUUNACABKAIAIgdBf0YNASABIAdBAWo2AgAgAkUNACACKAIAIgdBf0YNASACIAdBAWo2AgAgA0UNACADKAIAIgdBf0YNASADIAdBAWo2AgAgBEUNACAEKAIAIgdBf0YNASAEIAdBAWo2AgAgBUUNACAFKAIAIgdBf0YNASAFIAdBAWo2AgAgCEEIaiABQQRqIAJBBGogA0EEaiAEQQRqIAVBBGogBhB5IAgoAgwhByAIKAIIIQYgBSAFKAIAQX9qNgIAIAQgBCgCAEF/ajYCACADIAMoAgBBf2o2AgAgAiACKAIAQX9qNgIAIAEgASgCAEF/ajYCACAAIAdBACAGGzYCBCAAIAZBAEc2AgAgCEEQaiQADwsQogwACxCjDAALrgIBCn0CQCAALQCUAg0AIABBjAFqKgIAIgMgASoCACIElCAAQZQBaioCACIFIAEqAgQiCpSSIABBmAFqKgIAIgwgASoCCCILlJIhBiAAQYQBaioCACIHIASUIABBiAFqKgIAIgggCpSSIAMgC5SSIQkgAEGsAWoiASABKgIAIAMgBpQgByAJlCAIIAggBJQgAEGQAWoqAgAiByAKlJIgBSALlJIiBJSSkpI4AgAgAEGwAWoiASABKgIAIAUgBpQgCCAJlCAHIASUkpKSOAIAIABBtAFqIgEgDCAGlCADIAmUIAUgBJSSkiABKgIAkjgCACACRQ0AIABBjAJqLQAABEAgACAAKAKQAkEEcjYCkAILIABBADoAjAIgAEGIAmogACoChAKLIgMgA5I4AgALC58CAgF/DH0gAioCACIHIAeUIAIqAgQiBSAFlJIgAioCCCIEIASUkkMAAAAAkhCrASEGIAcgBpUiCCABQRhqIgIqAgCUIAUgBpUiCSABQRxqKgIAIgWUkiAEIAaVIgogAUEgaioCACIElJIhCwJAIAggASoCAJQgCSABQQRqKgIAIgyUkiAKIAFBCGoqAgAiDZSSIg4gCCABQQxqIgMqAgCUIAkgAUEQaioCACIGlJIgCiABQRRqKgIAIgeUkiIPXkUEQCAPIAteRQ0BIAchBCAGIQUgAyECDAELIA4gC15BAXMNACANIQQgDCEFIAEhAgsgACAEIAogASoCJCIElJI4AgggACAFIAkgBJSSOAIEIAAgAioCACAIIASUkjgCAAuEAgECfwJAIABBDGooAgAiAUUNACAAQQhqKAIAIgJFDQAgAUEDdEUNACACENoBCwJAIABBGGooAgAiAUUNACAAQRRqKAIAIgJFDQAgAUEMbEUNACACENoBCwJAIABBLGooAgAiAUUNACAAQShqKAIAIgJFDQAgAUEDdEUNACACENoBCwJAIABBOGooAgAiAUUNACAAQTRqKAIAIgJFDQAgAUEMbEUNACACENoBCwJAIABBzABqKAIAIgFFDQAgAEHIAGooAgAiAkUNACABQQN0RQ0AIAIQ2gELAkAgAEHYAGooAgAiAUUNACAAQdQAaigCACIARQ0AIAFBDGxFDQAgABDaAQsLpAICAn8BfiMAQfAAayIBJAACQCAABEAgACgCAA0BIABBADYCACABQThqIgJBEGogAEEQaikCADcDACACQQhqIABBCGopAgA3AwAgAkEYaiAAQRhqKQIANwMAIAJBIGogAEEgaikCADcDACACQShqIABBKGopAgA3AwAgAkEwaiAAQTBqKQIANwMAIAApAgAhAyABQQhqIAFBxABqKQIANwMAIAFBEGogAUHMAGopAgA3AwAgAUEYaiABQdQAaikCADcDACABQSBqIAFB3ABqKQIANwMAIAFBKGogAUHkAGopAgA3AwAgAUEwaiABQewAaigCADYCACABIAM3AzggASABKQI8NwMAIAAQ2gEgARCcBSABQfAAaiQADwsQogwACxCjDAALtgIBBX8gACgCGCEEAkACQCAAKAIMIABGBEBBFEEQIABBFGoiASgCACIDGyAAaigCACICDQFBACEBDAILIAAoAggiAiAAKAIMIgE2AgwgASACNgIIDAELIAEgAEEQaiADGyEDA0AgAyEFIAIiAUEUaiIDKAIAIgJFBEAgAUEQaiEDIAEoAhAhAgsgAg0ACyAFQQA2AgALAkAgBEUNAAJAIAAoAhxBAnRBnKHDAGoiAigCACAARwRAQRBBFCAEKAIQIABGGyAEaiABNgIAIAENAQwCCyACIAE2AgAgAQ0AQZCfwwBBkJ/DACgCAEF+IAAoAhx3cTYCAA8LIAEgBDYCGCAAKAIQIgIEQCABIAI2AhAgAiABNgIYCyAAQRRqKAIAIgBFDQAgAUEUaiAANgIAIAAgATYCGAsLpgIBCX0gAioCACIFIAWUIAIqAgQiCSAJlJIgAioCCCIKIAqUkkMAAAAAkiABKgIAIgYgBpSTIQYCQAJAAkAgAkEMaioCACILIAuUIAJBEGoqAgAiDCAMlJIgAkEUaioCACINIA2UkkMAAAAAkiIIQwAAAABcBEAgBSALlCAJIAyUkiAKIA2UkiEFQQAhAiAGQwAAAABeQQFzDQEgBUMAAAAAXkUNAQwDCyAGQwAAAABeRQ0BQQAhAgwCCyAFIAWUIAYgCJSTIgZDAAAAAF0NASAFjCAGEKsBkyAIlSIHQwAAAABfIQFDAAAAACAHIAEbIQcgAUEBcw0AIAQNACAGkSAFkyAIlSEHC0EBIQIgByADXw0AQQAhAgsgACAHOAIEIAAgAjYCAAvGAgIDfwJ+IwBBQGoiAyQAIAACfyAALQAIBEAgACgCBCEFQQEMAQsgACgCBCEFIAAoAgAiBC0AAEEEcUUEQEEBIAQoAhhB+vzCAEGR/cIAIAUbQQJBASAFGyAEQRxqKAIAKAIMEQUADQEaIAEgBCACKAIMEQMADAELAkAgBQ0AIAQoAhhBj/3CAEECIARBHGooAgAoAgwRBQBFDQBBACEFQQEMAQsgA0EBOgAXIANBNGpBnPzCADYCACADIAQpAhg3AwggAyADQRdqNgIQIAQpAgghBiAEKQIQIQcgAyAELQAgOgA4IAMgBzcDKCADIAY3AyAgAyAEKQIANwMYIAMgA0EIajYCMEEBIAEgA0EYaiACKAIMEQMADQAaIAMoAjBB+PzCAEECIAMoAjQoAgwRBQALOgAIIAAgBUEBajYCBCADQUBrJAALvgIBA38jAEEwayIBJAACQAJAIAAEQCAAKAIADQEgAUEoaiAAQfQCaikCADcDACABQQhqIABBiANqKQIANwMAIAFBEGogAEGQA2opAgA3AwAgAUEYaiAAQZgDaikCADcDACAAQfwCaiICKAIAIQMgAkECNgIAIAEgAEGAA2opAgA3AwAgASAAQewCaikCADcDIEEAIQIgAEEANgIAIANBAkcEQEE4QQQQyAsiAkUNAyACQQA2AgAgAiABKQMgNwIEIAIgAzYCFCACIAEpAwA3AhggAkEMaiABQShqKQMANwIAIAJBIGogAUEIaikDADcCACACQShqIAFBEGopAwA3AgAgAkEwaiABQRhqKQMANwIACyABQTBqJAAgAg8LEKIMAAsQowwAC0E4QQRB0J7DACgCACIAQb8GIAAbEQAAAAucAgICfwl9IwBBEGsiBCQAIAAoAgAiBSgCACgCBCEAAkAgAQRAIAAqAgAgASoCEJMiDCABQQRqKgIAIgmUIAAqAgQgASoCFJMiDSABKgIAIgqUkyIHIAeSIQcgDSABQQhqKgIAIguUIAAqAgggASoCGJMiBiAJlJMiCCAIkiEIIAQgBiABKgIMIg4gB5QgCSAIlCAKIAYgCpQgDCALlJMiBiAGkiIGlJOSkjgCCCAEIA0gDiAGlCAKIAeUIAsgCJSTkpI4AgQgBCAMIA4gCJQgCyAGlCAJIAeUk5KSOAIADAELIARBCGogAEEIaigCADYCACAEIAApAgA3AwALIAIgBCADKAIwEQMABEAgBSgCAEEBOgAICyAEQRBqJAALoAIBAX8jAEEQayICJAACfwJAIAEoAghBAUcEQCABKAIQQQFHDQELIAAoAgAhACACQQA2AgwgASACQQxqAn8CQAJAIABBgAFPBEAgAEGAEEkNASAAQYCABE8NAiACIABBP3FBgAFyOgAOIAIgAEEMdkHgAXI6AAwgAiAAQQZ2QT9xQYABcjoADUEDDAMLIAIgADoADEEBDAILIAIgAEE/cUGAAXI6AA0gAiAAQQZ2QcABcjoADEECDAELIAIgAEE/cUGAAXI6AA8gAiAAQRJ2QfABcjoADCACIABBBnZBP3FBgAFyOgAOIAIgAEEMdkE/cUGAAXI6AA1BBAsQ3gEMAQsgASgCGCAAKAIAIAFBHGooAgAoAhARAwALIAJBEGokAAu5AgECfyMAQcABayIFJAACQAJAAkAgAEUNACAAKAIAIgRBf0YNASAAIARBAWo2AgAgAUUNACABKAIAIgRBf0YNASABIARBAWo2AgAgAkUNACACKAIAIgRBf0YNASACIARBAWo2AgAgA0UNACADKAIAIgRBf0YNASADIARBAWo2AgAgBSAAQQRqIAFBBGogAkEEaiADQQRqEJUFIAMgAygCAEF/ajYCACACIAIoAgBBf2o2AgAgASABKAIAQX9qNgIAIAAgACgCAEF/ajYCAEEAIQAgBSgCACIBQQRHBEBBwAFBBBDICyIARQ0DIAAgATYCBCAAQQA2AgAgAEEIaiAFQQRyQbgBEJ4KGgsgBUHAAWokACAADwsQogwACxCjDAALQcABQQRB0J7DACgCACIAQb8GIAAbEQAAAAuSAgIBfwl9IwBB0ABrIgUkACADKgIAIAIqAhCTIgwgAkEEaioCACIJlCADKgIEIAJBFGoqAgCTIg0gAioCACIKlJMiByAHkiEHIA0gAkEIaioCACILlCADKgIIIAJBGGoqAgCTIgYgCZSTIgggCJIhCCAFIAYgAioCDCIOIAeUIAkgCJQgCiAGIAqUIAwgC5STIgYgBpIiBpSTkpI4AiAgBSANIA4gBpQgCiAHlCALIAiUk5KSOAIcIAUgDCAOIAiUIAsgBpQgCSAHlJOSkjgCGCAFQShqIgMgASAFQRhqIAQQRyAFQQhqIgFBCGogA0EIaikDADcDACAFIAUpAyg3AwggACABIAIQogYgBUHQAGokAAuZAgICfwl9IwBBEGsiBCQAIAAoAgAoAgAiBSgCBCEAAkAgAQRAIAAqAgAgASoCEJMiDCABQQRqKgIAIgmUIAAqAgQgASoCFJMiDSABKgIAIgqUkyIHIAeSIQcgDSABQQhqKgIAIguUIAAqAgggASoCGJMiBiAJlJMiCCAIkiEIIAQgBiABKgIMIg4gB5QgCSAIlCAKIAYgCpQgDCALlJMiBiAGkiIGlJOSkjgCCCAEIA0gDiAGlCAKIAeUIAsgCJSTkpI4AgQgBCAMIA4gCJQgCyAGlCAJIAeUk5KSOAIADAELIARBCGogAEEIaigCADYCACAEIAApAgA3AwALIAIgBCADKAIwEQMABEAgBUEBOgAICyAEQRBqJAALxAICB38DfSADQQJ0IQQgAkF8aiECIAFBfGohASADQX9qQQJJIQggAyEFAkACQANAIAUiBkUNASAIRQ0CIAZBf2ohBSABIARqIQcgAiAEaiACQXxqIQIgAUF8aiEBKgIAvEH/////B3G+IAdBBGoqAgC8Qf////8Hcb4gByoCACILvEH/////B3G+kkMAAAA0lF5BAXMNAAsgAiADQQJ0IgJqIQMgASACaiEBQX8hBANAIAMhAiAFIARBAWoiBEYNASACKgIAIgxDAAAAAFwEQCACQXxqIQMgC7xB/////wdxviENIAEqAgAhCyABQXxqIQEgDLxB/////wdxviANIAu8Qf////8Hcb6SQwAAADSUX0EBcw0BCwsgAkEANgIAQQEhCgsgACAGNgIEIAAgCjYCAA8LQZy7wQBBG0HAv8EAEP4KAAuYAgIFfwV9AkAgASgCCCIFBEAgASgCACEEIAJBCGoqAgAhCCACQQRqKgIAIQkgAioCACEKIAVBAUcEQCAKIAQqAgCUIAkgBEEEaioCAJSSIAggBEEIaioCAJSSIQsgBEEUaiECQQEhBgNAIAogAkF4aioCAJQgCSACQXxqKgIAlJIgCCACKgIAlJIiDCALXiEHIAwgCyAHGyELIAYgAyAHGyEDIAJBDGohAiAGQQFqIgYgBUcNAAsLIAMgBU8NASAAIANBDGwgBGoiAioCCCAIIAEqAmAiCJSSOAIIIAAgAioCBCAJIAiUkjgCBCAAIAIqAgAgCiAIlJI4AgAPC0EAQQBBiMnCABDPCAALIAMgBUGYycIAEM8IAAu0AgECfyMAQSBrIgIkAAJAAkACQCAABEAgACgCACIDQX9GDQEgACADQQFqNgIAIAJBEGogAEEEaiABELgJIAIoAhAiAUUNAiACQQhqIAEQoQoCQCACKAIIIAIoAgwoAowBEQcAQf8BcUEIRgRAAkAgAiABEKEKIAIoAgAgAigCBBDpCSIBRQ0AIAJBGGoiAyABQRRqIgFBCGooAgA2AgAgAiABKQIANwMQIAAgACgCAEF/ajYCAEEQQQQQyAsiAEUNBiAAQQA2AgAgACACKQMQNwIEIABBDGogAygCADYCAAwCCwsgACAAKAIAQX9qNgIAQQAhAAsgAkEgaiQAIAAPCxCiDAALEKMMAAtBqKvAAEHMAEGcrMAAEJwJAAtBEEEEQdCewwAoAgAiAEG/BiAAGxEAAAALiwICBH8CfiMAQSBrIgMkAAJAAkADQCAAKAIAKAIQIgIEQCACQX9qQQJJDQMMAgsgBEELRwRAIARBAWohBAwBCwsDQCAAKAIAKAIQIgIEQCACQX9qDgIDAwILIAEpAwBCAVIEQBCYBAwBCyABKQMIIQYgASgCECECELUMQX8gAykDECIHIAZSIAcgBlQbIgVBfyADKAIYIgQgAkcgBCACSRsgBRtBf0cEQEEBIQIgACgCACIBKAIQIQAgASAAQQEgABs2AhAgAEUNAyADQSBqJAAgAEEDIABBA0kbDwUgAyAGIAIgByAEEJUJIAMpAwAgAygCCBCSBAwBCwALAAtBAyECCyADQSBqJAAgAguiAgECfyAAKAIAIQAgAUEBRwRAIAAoAgAiAEEIaiICKAIAIgEgAEEEaigCAEYEQCAAIAFBARCfBiAAQQhqKAIAIQELIAAoAgAgAWpBADoAACACIAFBAWo2AgAPCyAAKAIAIgBBBGohBCAAQQhqIgUoAgAiASAEKAIARgRAIAAgAUEBEJ8GIABBCGooAgAhAQsgACgCACABakEBOgAAIABBCGogAUEBaiIBNgIAIAQoAgAgAWtBA00EQCAAIAFBBBCfBiAAQQhqKAIAIQELIAAoAgAgAWogAjYAACAAQQhqIgIgAUEEaiIBNgIAIABBBGooAgAgAWtBA00EQCAAIAFBBBCfBiACKAIAIQELIAAoAgAgAWogAzYAACAFIAFBBGo2AgALpwICAn8IfSMAQUBqIgUkAEEEIQYCQCACKgIAIgkgCZQgAioCBCIKIAqUkiACKgIIIgsgC5SSQwAAAACSIgdDAAAAAF5BAXMNACAHEKsBIQcgBCoCACIMIAyUIAQqAgQiDSANlJIgBCoCCCIOIA6UkkMAAAAAkiIIQwAAAABeQQFzDQAgCBCrASEIIAVBCGogAUEIaigCADYCACAFIAEpAgA3AwAgBSALIAeVOAIYIAUgCiAHlTgCFCAFIAkgB5U4AhAgBUEgaiIBQQhqIANBCGooAgA2AgAgBSADKQIANwMgIAUgDiAIlTgCOCAFIA0gCJU4AjQgBSAMIAiVOAIwIABBBGogBSAFQRBqIAEgBUEwahCUA0EDIQYLIAAgBjYCACAFQUBrJAALmQICAn8IfSAAKAIIIgIEQCAAKAIAIgEqAgghByABKgIEIQggASoCACEEAkAgAkEBRgRAIAchCSAIIQUgBCEDDAELIAJBDGwgAWohAiABQQxqIQEgBCEDIAghBSAHIQkDQCAJIAFBCGoqAgAiCiAJIApgGyEJIAUgAUEEaioCACIGIAUgBmAbIQUgByAKIAcgCl8bIQcgCCAGIAggBl8bIQggAyABKgIAIgYgAyAGYBshAyAEIAYgBCAGXxshBCACIAFBDGoiAUcNAAsLIAAqAmAgAyAEk0MAAAA/lCIEIAUgCJNDAAAAP5QiAyAEIANfGyIFIAkgB5NDAAAAP5QiAyAFIANfG5IPC0GHw8EAQdIAQezDwQAQnAkAC74CAgZ/AX4jAEEwayICJAAgAUEEaiEEAkAgASgCBARAQdjTwgAoAgAhBQwBCyABKAIAIQMgAkIANwIMIAJB2NPCACgCACIFNgIIIAIgAkEIaiIHNgIUIAJBGGoiBkEQaiADQRBqKQIANwMAIAZBCGogA0EIaikCADcDACACIAMpAgA3AxggAkEUakHA0cIAIAYQ2AIaIARBCGogB0EIaigCADYCACAEIAIpAwg3AgALIAJBIGoiAyAEQQhqKAIANgIAIAFBDGpBADYCACAEKQIAIQggAUEIakEANgIAIAEgBTYCBCACIAg3AxhBDEEEEMgLIgFFBEBBDEEEQdCewwAoAgAiAEG/BiAAGxEAAAALIAEgAikDGDcCACABQQhqIAMoAgA2AgAgAEH418IANgIEIAAgATYCACACQTBqJAALnwIBCH0gASoCACIDIAOUIAFBBGoqAgAiAyADlJIgAUEIaioCACIDIAOUkkMAAAAAkhCrASEDIAEqAgwiBkMAAAAAYEUEQEHhwcEAQSZB8MTBABD+CgALIAAgAyAGkjgCDCAAIAJBGGoqAgAgAkEMaioCACIDIAIqAgAiBkMAAAAAlCIEIAJBBGoqAgAiCEMAAAAAlCIFkyIHIAeSIgeUIAYgAkEIaioCACIJQwAAAACUIgogBJMiBCAEkiIElCAIIAUgCpMiBSAFkiIFlJOSQwAAAACSkjgCCCAAIAJBFGoqAgAgAyAElCAJIAWUIAYgB5STkkMAAAAAkpI4AgQgACACKgIQIAMgBZQgCCAHlCAJIASUk5JDAAAAAJKSOAIAC50CAgJ/BX0gASgCCCICBEAgASgCACIBIAJBDGxqIQMgASoCCEQAAAAAAADwPyACuKO2IgSUIQYgASoCBCAElCEHIAEqAgAgBJQhCCACQQFHBEAgAUEMaiECA0AgCCACKgIAIASUkiEIIAYgAkEIaioCACAElJIhBiAHIAJBBGoqAgAgBJSSIQcgAyACQQxqIgJHDQALC0MAAAAAIQQDQCAIIAEqAgCTIgUgBZQgByABQQRqKgIAkyIFIAWUkiAGIAFBCGoqAgCTIgUgBZSSQwAAAACSIgUgBCAFIAReGyEEIAMgAUEMaiIBRw0ACyAAIAQQqwE4AgwgACAGOAIIIAAgBzgCBCAAIAg4AgAPC0GAxcIAQS9BkMbCABD+CgALjQIBBX9BAiEGAkAgACgCOCIDIAFBDGxqQQAgAEFAaygCACIEIAFLGyIBRQ0AIAQgAk0NACAAQShqKAIAIgQgASgCCCIBTQ0AIAJBDGwgA2ooAgghAyAAQSxqKAIAIQICQCAAKAIgIAFBBHRqIgUoAggiASAAQTRqKAIAIgBJBEADQCABQRRsIAJqIgcoAgwgA0YNAiAHKAIAIgEgAEkNAAsLIAUoAgwiASAATw0BA0AgAUEUbCACaiIFKAIIIANGDQEgBSgCBCIBIABJDQALDAELIAAgAU0NACAEIAFBFGwgAmoiAEEIaigCAE0NACAEIABBDGooAgBNDQAgAUEUbCACai0AEEEARyEGCyAGC8ACAQJ/IwBBIGsiAiQAIAJBHGoiA0EANgIAIAJB9LfBADYCGCACQgE3AgwgAkHkucEANgIIAn9BASABIAJBCGoQ1AgNABogA0EBNgIAIAJCATcCDCACQey5wQA2AgggAkHxADYCBCACIAA2AgAgAiACNgIYQQEgASACQQhqENQIDQAaIAJBHGpBATYCACACQgE3AgwgAkH4ucEANgIIIAJB8QA2AgQgAiAAQQRqNgIAIAIgAjYCGAJAIAEgAkEIahDUCEUEQCACQQE2AhwgAkIBNwIMIAJB+LnBADYCCCACQfEANgIEIAIgAEEIajYCACACIAI2AhggASACQQhqENQIRQ0BC0EBDAELIAJBHGpBADYCACACQfS3wQA2AhggAkIBNwIMIAJBhLrBADYCCCABIAJBCGoQ1AgLIAJBIGokAAuEAgEFfyAAKAIAIQEgACgCCCICBEAgAkGgAWwhAgNAAkAgASgCAEUNACABQRhqIgQoAgAiBSgCACEDIAUgA0F/ajYCACADQQFGBEAgBCgCACABQRxqKAIAEPcHCyABQSBqKAIARQ0AIAFBJGooAgAQ2gELIAFBoAFqIQEgAkHgfmoiAg0ACyAAKAIAIQELAkAgAEEEaigCACICRQ0AIAFFDQAgAkGgAWxFDQAgARDaAQsCQCAAQSBqKAIAIgFFDQAgAEEcaigCACICRQ0AIAFBA3RFDQAgAhDaAQsCQCAAQSxqKAIAIgFFDQAgAEEoaigCACIARQ0AIAFBA3RFDQAgABDaAQsLnQICA38BfiMAQTBrIgIkAAJ/IAFBAWoiAyABTwRAIABBBGooAgAiAUEBdCIEIAMgBCADSxsiA0EEIANBBEsbrUKgAX4iBUIgiKdFQQN0IQMgBachBAJAIAEEQCACQShqQQg2AgAgAiABQaABbDYCJCACIAAoAgA2AiAMAQsgAkEANgIgCyACQRBqIAQgAyACQSBqEIEGIAIoAhBBAUYEQCACKAIUIQEgAkEYaigCAAwCCyACKAIUIQEgAEEEaiACQRhqKAIAQaABbjYCACAAIAE2AgAgAkEwaiQADwsgAkEIaiIAQQA2AgQgACADNgIAIAIoAgghASACKAIMCyIABEAgASAAQdCewwAoAgAiAEG/BiAAGxEAAAALEJYMAAudAgIDfwF+IwBBMGsiAiQAAn8gAUEBaiIDIAFPBEAgAEEEaigCACIBQQF0IgQgAyAEIANLGyIDQQQgA0EESxutQqACfiIFQiCIp0VBA3QhAyAFpyEEAkAgAQRAIAJBKGpBCDYCACACIAFBoAJsNgIkIAIgACgCADYCIAwBCyACQQA2AiALIAJBEGogBCADIAJBIGoQgQYgAigCEEEBRgRAIAIoAhQhASACQRhqKAIADAILIAIoAhQhASAAQQRqIAJBGGooAgBBoAJuNgIAIAAgATYCACACQTBqJAAPCyACQQhqIgBBADYCBCAAIAM2AgAgAigCCCEBIAIoAgwLIgAEQCABIABB0J7DACgCACIAQb8GIAAbEQAAAAsQlgwAC54CAgN/AX0gASgCACICQQRqIgQoAgAgAkEIaiIDKAIAIgFrQQdNBEAgAiABQQgQnwYgAygCACEBCyACKAIAIAFqQgM3AAAgAyABQQhqIgE2AgAgACoCACEFIAQoAgAgAWtBA00EQCACIAFBBBCfBiACQQhqKAIAIQELIAIoAgAgAWogBTgAACACQQhqIgMgAUEEaiIBNgIAIAAqAgQhBSACQQRqIgQoAgAgAWtBA00EQCACIAFBBBCfBiADKAIAIQELIAIoAgAgAWogBTgAACADIAFBBGoiATYCACAAKgIIIQUgBCgCACABa0EDTQRAIAIgAUEEEJ8GIAJBCGooAgAhAQsgAkEIaiABQQRqNgIAIAIoAgAgAWogBTgAAEEAC/EBAgN/AX4gASAAELwIIgIEfyACBSABKQMAIQUCfiAFQjB8IABBLGooAgAiAkUNABogAkEHdEGAf2pBB3atQocBfiAFfEK3AXwLQgh8IQUgAEEwaigCACICIABBNGooAgAiA0cEQCAAQTxqKAIAQX9qIQQDQCAFQgR8IQUgAyACQQFqIARxIgJHDQALCwJ+IAVCCHwgAEHIAGooAgAiAkUNABogAkEMbEF0akEMbq1CCX4gBXxCEXwLIQUgAQJ+IAVCCHwgAEHUAGooAgAiAEUNABogAEEYbEFoakEYbq1CKH4gBXxCMHwLQih8NwMAQQALC5QCAQJ/IwBBEGsiCCQAAkACQCAARQ0AIAAoAgAiB0F/Rg0BIAAgB0EBajYCACABRQ0AIAEoAgAiB0F/Rg0BIAEgB0EBajYCACACRQ0AIAIoAgAiB0F/Rg0BIAIgB0EBajYCACADRQ0AIAMoAgAiB0F/Rg0BIAMgB0EBajYCACAERQ0AIAQoAgAiB0F/Rg0BIAQgB0EBajYCACAIIAY2AgwgAEEEaiABQQRqIAJBBGogA0EEaiAEQQRqIAUgCEEMahB8IAQgBCgCAEF/ajYCACADIAMoAgBBf2o2AgAgAiACKAIAQX9qNgIAIAEgASgCAEF/ajYCACAAIAAoAgBBf2o2AgAgCEEQaiQADwsQogwACxCjDAALnQICAn8BfiMAQTBrIgMkAAJ/IAEgAmoiAiABTwRAIABBBGooAgAiAUEBdCIEIAIgBCACSxsiAkEEIAJBBEsbrUKgAn4iBUIgiKdFQQN0IQIgBachBAJAIAEEQCADQShqQQg2AgAgAyABQaACbDYCJCADIAAoAgA2AiAMAQsgA0EANgIgCyADQRBqIAQgAiADQSBqEIEGIAMoAhBBAUYEQCADKAIUIQEgA0EYaigCAAwCCyADKAIUIQEgAEEEaiADQRhqKAIAQaACbjYCACAAIAE2AgAgA0EwaiQADwsgA0EIaiIAQQA2AgQgACACNgIAIAMoAgghASADKAIMCyIABEAgASAAQdCewwAoAgAiAEG/BiAAGxEAAAALEJYMAAudAgICfwF+IwBBMGsiAyQAAn8gASACaiICIAFPBEAgAEEEaigCACIBQQF0IgQgAiAEIAJLGyICQQQgAkEESxutQqABfiIFQiCIp0VBA3QhAiAFpyEEAkAgAQRAIANBKGpBCDYCACADIAFBoAFsNgIkIAMgACgCADYCIAwBCyADQQA2AiALIANBEGogBCACIANBIGoQgQYgAygCEEEBRgRAIAMoAhQhASADQRhqKAIADAILIAMoAhQhASAAQQRqIANBGGooAgBBoAFuNgIAIAAgATYCACADQTBqJAAPCyADQQhqIgBBADYCBCAAIAI2AgAgAygCCCEBIAMoAgwLIgAEQCABIABB0J7DACgCACIAQb8GIAAbEQAAAAsQlgwAC5UCAgJ/BH0jAEEwayIDJAAgA0EQaiABIAJBABAoAkAgAioCCCADKgIYkyIFjCAFIAMtABwiBBsiBSAFlCACKgIAIAMqAhCTIgaMIAYgBBsiBiAGlCACKgIEIAMqAhSTIgeMIAcgBBsiByAHlJKSQwAAAACSIghDAACAKF5BAXNFBEAgAyAFIAgQqwEiBZU4AiggAyAHIAWVOAIkIAMgBiAFlTgCICADQQhqIAEgA0EgahC8AiADKAIIIQIgAygCDCEBIABBCGogA0EYaikDADcCACAAIAMpAxA3AgAgAEEUaiABNgIADAELIAAgAykDEDcCACAAQQhqIANBGGopAwA3AgBBAyECCyAAIAI2AhAgA0EwaiQAC5MCAgF/CH0gACgCCCIBBEAgACgCACIAKgIIIQYgACoCBCEHIAAqAgAhAwJAIAFBAUYEQCAGIQggByEEIAMhAgwBCyABQQxsIABqIQEgAEEMaiEAIAMhAiAHIQQgBiEIA0AgCCAAQQhqKgIAIgkgCCAJYBshCCAEIABBBGoqAgAiBSAEIAVgGyEEIAYgCSAGIAlfGyEGIAcgBSAHIAVfGyEHIAIgACoCACIFIAIgBWAbIQIgAyAFIAMgBV8bIQMgASAAQQxqIgBHDQALCyACIAOTQwAAAD+UIgMgBCAHk0MAAAA/lCICIAMgAl8bIgQgCCAGk0MAAAA/lCICIAQgAl8bDwtBh8PBAEHSAEHsw8EAEJwJAAuHAgEOfSAAQRRqIAFBCGoqAgAiAiABQRRqKgIAIgMgAiABKgIAIgRDAAAAAJQiCiABQQRqKgIAIgVDAAAAAJQiC5IiDpIgAyABQQxqKgIAIgZDAAAAAJQiDCABQRBqKgIAIgdDAAAAAJQiDZIiD5JeGzgCACAAQRBqIAUgByAKIAWSIAJDAAAAAJQiCJIgDCAHkiADQwAAAACUIgmSXhs4AgAgACAEIAYgBCALkiAIkiAGIA2SIAmSXhs4AgwgACACIAMgDiACkyAPIAOTXhs4AgggACAFIAcgCiAFkyAIkiAMIAeTIAmSXhs4AgQgACAEIAYgCyAEkyAIkiANIAaTIAmSXhs4AgALmgICA38BfiMAQTBrIgIkAAJ/IAFBAWoiAyABTwRAIABBBGooAgAiAUEBdCIEIAMgBCADSxsiA0EEIANBBEsbrUIkfiIFQiCIp0VBAnQhAyAFpyEEAkAgAQRAIAJBKGpBBDYCACACIAFBJGw2AiQgAiAAKAIANgIgDAELIAJBADYCIAsgAkEQaiAEIAMgAkEgahCBBiACKAIQQQFGBEAgAigCFCEBIAJBGGooAgAMAgsgAigCFCEBIABBBGogAkEYaigCAEEkbjYCACAAIAE2AgAgAkEwaiQADwsgAkEIaiIAQQA2AgQgACADNgIAIAIoAgghASACKAIMCyIABEAgASAAQdCewwAoAgAiAEG/BiAAGxEAAAALEJYMAAuaAgIDfwF+IwBBMGsiAiQAAn8gAUEBaiIDIAFPBEAgAEEEaigCACIBQQF0IgQgAyAEIANLGyIDQQQgA0EESxutQhh+IgVCIIinRUECdCEDIAWnIQQCQCABBEAgAkEoakEENgIAIAIgAUEYbDYCJCACIAAoAgA2AiAMAQsgAkEANgIgCyACQRBqIAQgAyACQSBqEIEGIAIoAhBBAUYEQCACKAIUIQEgAkEYaigCAAwCCyACKAIUIQEgAEEEaiACQRhqKAIAQRhuNgIAIAAgATYCACACQTBqJAAPCyACQQhqIgBBADYCBCAAIAM2AgAgAigCCCEBIAIoAgwLIgAEQCABIABB0J7DACgCACIAQb8GIAAbEQAAAAsQlgwAC5oCAgN/AX4jAEEwayICJAACfyABQQFqIgMgAU8EQCAAQQRqKAIAIgFBAXQiBCADIAQgA0sbIgNBBCADQQRLG61CNH4iBUIgiKdFQQJ0IQMgBachBAJAIAEEQCACQShqQQQ2AgAgAiABQTRsNgIkIAIgACgCADYCIAwBCyACQQA2AiALIAJBEGogBCADIAJBIGoQgQYgAigCEEEBRgRAIAIoAhQhASACQRhqKAIADAILIAIoAhQhASAAQQRqIAJBGGooAgBBNG42AgAgACABNgIAIAJBMGokAA8LIAJBCGoiAEEANgIEIAAgAzYCACACKAIIIQEgAigCDAsiAARAIAEgAEHQnsMAKAIAIgBBvwYgABsRAAAACxCWDAALmgICA38BfiMAQTBrIgIkAAJ/IAFBAWoiAyABTwRAIABBBGooAgAiAUEBdCIEIAMgBCADSxsiA0EEIANBBEsbrUI4fiIFQiCIp0VBAnQhAyAFpyEEAkAgAQRAIAJBKGpBBDYCACACIAFBOGw2AiQgAiAAKAIANgIgDAELIAJBADYCIAsgAkEQaiAEIAMgAkEgahCBBiACKAIQQQFGBEAgAigCFCEBIAJBGGooAgAMAgsgAigCFCEBIABBBGogAkEYaigCAEE4bjYCACAAIAE2AgAgAkEwaiQADwsgAkEIaiIAQQA2AgQgACADNgIAIAIoAgghASACKAIMCyIABEAgASAAQdCewwAoAgAiAEG/BiAAGxEAAAALEJYMAAudAgIDfwF+IwBBMGsiAiQAAn8gAUEBaiIDIAFPBEAgAEEEaigCACIBQQF0IgQgAyAEIANLGyIDQQQgA0EESxutQrQBfiIFQiCIp0VBAnQhAyAFpyEEAkAgAQRAIAJBKGpBBDYCACACIAFBtAFsNgIkIAIgACgCADYCIAwBCyACQQA2AiALIAJBEGogBCADIAJBIGoQgQYgAigCEEEBRgRAIAIoAhQhASACQRhqKAIADAILIAIoAhQhASAAQQRqIAJBGGooAgBBtAFuNgIAIAAgATYCACACQTBqJAAPCyACQQhqIgBBADYCBCAAIAM2AgAgAigCCCEBIAIoAgwLIgAEQCABIABB0J7DACgCACIAQb8GIAAbEQAAAAsQlgwAC5oCAgN/AX4jAEEwayICJAACfyABQQFqIgMgAU8EQCAAQQRqKAIAIgFBAXQiBCADIAQgA0sbIgNBBCADQQRLG61CFH4iBUIgiKdFQQJ0IQMgBachBAJAIAEEQCACQShqQQQ2AgAgAiABQRRsNgIkIAIgACgCADYCIAwBCyACQQA2AiALIAJBEGogBCADIAJBIGoQgQYgAigCEEEBRgRAIAIoAhQhASACQRhqKAIADAILIAIoAhQhASAAQQRqIAJBGGooAgBBFG42AgAgACABNgIAIAJBMGokAA8LIAJBCGoiAEEANgIEIAAgAzYCACACKAIIIQEgAigCDAsiAARAIAEgAEHQnsMAKAIAIgBBvwYgABsRAAAACxCWDAALmgICAn8BfiMAQTBrIgMkAAJ/IAEgAmoiAiABTwRAIABBBGooAgAiAUEBdCIEIAIgBCACSxsiAkEEIAJBBEsbrUIMfiIFQiCIp0VBAnQhAiAFpyEEAkAgAQRAIANBKGpBBDYCACADIAFBDGw2AiQgAyAAKAIANgIgDAELIANBADYCIAsgA0EQaiAEIAIgA0EgahCBBiADKAIQQQFGBEAgAygCFCEBIANBGGooAgAMAgsgAygCFCEBIABBBGogA0EYaigCAEEMbjYCACAAIAE2AgAgA0EwaiQADwsgA0EIaiIAQQA2AgQgACACNgIAIAMoAgghASADKAIMCyIABEAgASAAQdCewwAoAgAiAEG/BiAAGxEAAAALEJYMAAudAgIDfwF+IwBBMGsiAiQAAn8gAUEBaiIDIAFPBEAgAEEEaigCACIBQQF0IgQgAyAEIANLGyIDQQQgA0EESxutQuQBfiIFQiCIp0VBAnQhAyAFpyEEAkAgAQRAIAJBKGpBBDYCACACIAFB5AFsNgIkIAIgACgCADYCIAwBCyACQQA2AiALIAJBEGogBCADIAJBIGoQgQYgAigCEEEBRgRAIAIoAhQhASACQRhqKAIADAILIAIoAhQhASAAQQRqIAJBGGooAgBB5AFuNgIAIAAgATYCACACQTBqJAAPCyACQQhqIgBBADYCBCAAIAM2AgAgAigCCCEBIAIoAgwLIgAEQCABIABB0J7DACgCACIAQb8GIAAbEQAAAAsQlgwAC5oCAgN/AX4jAEEwayICJAACfyABQQFqIgMgAU8EQCAAQQRqKAIAIgFBAXQiBCADIAQgA0sbIgNBBCADQQRLG61CLH4iBUIgiKdFQQJ0IQMgBachBAJAIAEEQCACQShqQQQ2AgAgAiABQSxsNgIkIAIgACgCADYCIAwBCyACQQA2AiALIAJBEGogBCADIAJBIGoQgQYgAigCEEEBRgRAIAIoAhQhASACQRhqKAIADAILIAIoAhQhASAAQQRqIAJBGGooAgBBLG42AgAgACABNgIAIAJBMGokAA8LIAJBCGoiAEEANgIEIAAgAzYCACACKAIIIQEgAigCDAsiAARAIAEgAEHQnsMAKAIAIgBBvwYgABsRAAAACxCWDAALmgICA38BfiMAQTBrIgIkAAJ/IAFBAWoiAyABTwRAIABBBGooAgAiAUEBdCIEIAMgBCADSxsiA0EEIANBBEsbrUIMfiIFQiCIp0VBAnQhAyAFpyEEAkAgAQRAIAJBKGpBBDYCACACIAFBDGw2AiQgAiAAKAIANgIgDAELIAJBADYCIAsgAkEQaiAEIAMgAkEgahCBBiACKAIQQQFGBEAgAigCFCEBIAJBGGooAgAMAgsgAigCFCEBIABBBGogAkEYaigCAEEMbjYCACAAIAE2AgAgAkEwaiQADwsgAkEIaiIAQQA2AgQgACADNgIAIAIoAgghASACKAIMCyIABEAgASAAQdCewwAoAgAiAEG/BiAAGxEAAAALEJYMAAuaAgICfwF+IwBBMGsiAyQAAn8gASACaiICIAFPBEAgAEEEaigCACIBQQF0IgQgAiAEIAJLGyICQQQgAkEESxutQhh+IgVCIIinRUECdCECIAWnIQQCQCABBEAgA0EoakEENgIAIAMgAUEYbDYCJCADIAAoAgA2AiAMAQsgA0EANgIgCyADQRBqIAQgAiADQSBqEIEGIAMoAhBBAUYEQCADKAIUIQEgA0EYaigCAAwCCyADKAIUIQEgAEEEaiADQRhqKAIAQRhuNgIAIAAgATYCACADQTBqJAAPCyADQQhqIgBBADYCBCAAIAI2AgAgAygCCCEBIAMoAgwLIgAEQCABIABB0J7DACgCACIAQb8GIAAbEQAAAAsQlgwAC50CAgJ/AX4jAEEwayIDJAACfyABIAJqIgIgAU8EQCAAQQRqKAIAIgFBAXQiBCACIAQgAksbIgJBBCACQQRLG61CqAF+IgVCIIinRUECdCECIAWnIQQCQCABBEAgA0EoakEENgIAIAMgAUGoAWw2AiQgAyAAKAIANgIgDAELIANBADYCIAsgA0EQaiAEIAIgA0EgahCBBiADKAIQQQFGBEAgAygCFCEBIANBGGooAgAMAgsgAygCFCEBIABBBGogA0EYaigCAEGoAW42AgAgACABNgIAIANBMGokAA8LIANBCGoiAEEANgIEIAAgAjYCACADKAIIIQEgAygCDAsiAARAIAEgAEHQnsMAKAIAIgBBvwYgABsRAAAACxCWDAALnQICA38BfiMAQTBrIgIkAAJ/IAFBAWoiAyABTwRAIABBBGooAgAiAUEBdCIEIAMgBCADSxsiA0EEIANBBEsbrULMAX4iBUIgiKdFQQJ0IQMgBachBAJAIAEEQCACQShqQQQ2AgAgAiABQcwBbDYCJCACIAAoAgA2AiAMAQsgAkEANgIgCyACQRBqIAQgAyACQSBqEIEGIAIoAhBBAUYEQCACKAIUIQEgAkEYaigCAAwCCyACKAIUIQEgAEEEaiACQRhqKAIAQcwBbjYCACAAIAE2AgAgAkEwaiQADwsgAkEIaiIAQQA2AgQgACADNgIAIAIoAgghASACKAIMCyIABEAgASAAQdCewwAoAgAiAEG/BiAAGxEAAAALEJYMAAudAgIDfwF+IwBBMGsiAiQAAn8gAUEBaiIDIAFPBEAgAEEEaigCACIBQQF0IgQgAyAEIANLGyIDQQQgA0EESxutQvQDfiIFQiCIp0VBAnQhAyAFpyEEAkAgAQRAIAJBKGpBBDYCACACIAFB9ANsNgIkIAIgACgCADYCIAwBCyACQQA2AiALIAJBEGogBCADIAJBIGoQgQYgAigCEEEBRgRAIAIoAhQhASACQRhqKAIADAILIAIoAhQhASAAQQRqIAJBGGooAgBB9ANuNgIAIAAgATYCACACQTBqJAAPCyACQQhqIgBBADYCBCAAIAM2AgAgAigCCCEBIAIoAgwLIgAEQCABIABB0J7DACgCACIAQb8GIAAbEQAAAAsQlgwAC50CAgN/AX4jAEEwayICJAACfyABQQFqIgMgAU8EQCAAQQRqKAIAIgFBAXQiBCADIAQgA0sbIgNBBCADQQRLG61C4AJ+IgVCIIinRUECdCEDIAWnIQQCQCABBEAgAkEoakEENgIAIAIgAUHgAmw2AiQgAiAAKAIANgIgDAELIAJBADYCIAsgAkEQaiAEIAMgAkEgahCBBiACKAIQQQFGBEAgAigCFCEBIAJBGGooAgAMAgsgAigCFCEBIABBBGogAkEYaigCAEHgAm42AgAgACABNgIAIAJBMGokAA8LIAJBCGoiAEEANgIEIAAgAzYCACACKAIIIQEgAigCDAsiAARAIAEgAEHQnsMAKAIAIgBBvwYgABsRAAAACxCWDAALlQICA38BfiMAQTBrIgIkAAJ/IAFBAE8EQCAAQQRqKAIAIgRBAXQiAyABIAMgAUsbIgFBBCABQQRLG61CHH4iBUIgiKdFQQJ0IQEgBachAwJAIAQEQCACQShqQQQ2AgAgAiAEQRxsNgIkIAIgACgCADYCIAwBCyACQQA2AiALIAJBEGogAyABIAJBIGoQgQYgAigCEEEBRgRAIAIoAhQhASACQRhqKAIADAILIAIoAhQhASAAQQRqIAJBGGooAgBBHG42AgAgACABNgIAIAJBMGokAA8LIAJBCGoiAEEANgIEIAAgATYCACACKAIIIQEgAigCDAsiAARAIAEgAEHQnsMAKAIAIgBBvwYgABsRAAAACxCWDAALlQICA38BfiMAQTBrIgIkAAJ/IAFBAE8EQCAAQQRqKAIAIgRBAXQiAyABIAMgAUsbIgFBBCABQQRLG61CFH4iBUIgiKdFQQJ0IQEgBachAwJAIAQEQCACQShqQQQ2AgAgAiAEQRRsNgIkIAIgACgCADYCIAwBCyACQQA2AiALIAJBEGogAyABIAJBIGoQgQYgAigCEEEBRgRAIAIoAhQhASACQRhqKAIADAILIAIoAhQhASAAQQRqIAJBGGooAgBBFG42AgAgACABNgIAIAJBMGokAA8LIAJBCGoiAEEANgIEIAAgATYCACACKAIIIQEgAigCDAsiAARAIAEgAEHQnsMAKAIAIgBBvwYgABsRAAAACxCWDAALmgICA38BfiMAQTBrIgIkAAJ/IAFBAWoiAyABTwRAIABBBGooAgAiAUEBdCIEIAMgBCADSxsiA0EEIANBBEsbrUIofiIFQiCIp0VBAnQhAyAFpyEEAkAgAQRAIAJBKGpBBDYCACACIAFBKGw2AiQgAiAAKAIANgIgDAELIAJBADYCIAsgAkEQaiAEIAMgAkEgahCBBiACKAIQQQFGBEAgAigCFCEBIAJBGGooAgAMAgsgAigCFCEBIABBBGogAkEYaigCAEEobjYCACAAIAE2AgAgAkEwaiQADwsgAkEIaiIAQQA2AgQgACADNgIAIAIoAgghASACKAIMCyIABEAgASAAQdCewwAoAgAiAEG/BiAAGxEAAAALEJYMAAuaAgIDfwF+IwBBMGsiAiQAAn8gAUEBaiIDIAFPBEAgAEEEaigCACIBQQF0IgQgAyAEIANLGyIDQQQgA0EESxutQjB+IgVCIIinRUECdCEDIAWnIQQCQCABBEAgAkEoakEENgIAIAIgAUEwbDYCJCACIAAoAgA2AiAMAQsgAkEANgIgCyACQRBqIAQgAyACQSBqEIEGIAIoAhBBAUYEQCACKAIUIQEgAkEYaigCAAwCCyACKAIUIQEgAEEEaiACQRhqKAIAQTBuNgIAIAAgATYCACACQTBqJAAPCyACQQhqIgBBADYCBCAAIAM2AgAgAigCCCEBIAIoAgwLIgAEQCABIABB0J7DACgCACIAQb8GIAAbEQAAAAsQlgwAC50CAgJ/AX4jAEEwayIDJAACfyABIAJqIgIgAU8EQCAAQQRqKAIAIgFBAXQiBCACIAQgAksbIgJBBCACQQRLG61CyAB+IgVCIIinRUECdCECIAWnIQQCQCABBEAgA0EoakEENgIAIAMgAUHIAGw2AiQgAyAAKAIANgIgDAELIANBADYCIAsgA0EQaiAEIAIgA0EgahCBBiADKAIQQQFGBEAgAygCFCEBIANBGGooAgAMAgsgAygCFCEBIABBBGogA0EYaigCAEHIAG42AgAgACABNgIAIANBMGokAA8LIANBCGoiAEEANgIEIAAgAjYCACADKAIIIQEgAygCDAsiAARAIAEgAEHQnsMAKAIAIgBBvwYgABsRAAAACxCWDAAL+gECAX8FfSACKgIAIgQgAUEYaiIDKgIAlCACQQRqKgIAIgUgAUEcaioCAJSSIAJBCGoqAgAiBiABQSBqKgIAlJIhBwJAAkAgASoCACAElCABQQRqKgIAIAWUkiABQQhqKgIAIAaUkiIIIAQgAUEMaiICKgIAlCAFIAFBEGoqAgCUkiAGIAFBFGoqAgCUkiIEXkUEQCAEIAdeDQEMAgsgCCAHXkUEQAwCCyAAIAEpAgA3AgAgAEEIaiABQQhqKAIANgIADwsgACACKQIANwIAIABBCGogAkEIaigCADYCAA8LIAAgAykCADcCACAAQQhqIANBCGooAgA2AgALvQICA38CfiMAQUBqIgIkAAJ/QQEgAC0ABA0AGiAALQAFIQQgACgCACIDLQAAQQRxRQRAIARB/wFxBEBBASADKAIYQfr8wgBBAiADQRxqKAIAKAIMEQUADQIaCyABIANB5NHCACgCABEDAAwBCyAEQf8BcUUEQEEBIAMoAhhBlP3CAEEBIANBHGooAgAoAgwRBQANARoLIAJBAToAFyACQTRqQZz8wgA2AgAgAiADKQIYNwMIIAIgAkEXajYCECADKQIIIQUgAykCECEGIAIgAy0AIDoAOCACIAY3AyggAiAFNwMgIAIgAykCADcDGCACIAJBCGo2AjBBASABIAJBGGpB5NHCACgCABEDAA0AGiACKAIwQfj8wgBBAiACKAI0KAIMEQUACyEEIABBAToABSAAIAQ6AAQgAkFAayQAC4MCAQR/IAAoAgAhASAAKAIIIgIEQCACQQxsIQIgAUEIaiEBA0AgASgCACIEKAIAIQMgBCADQX9qNgIAIANBAUYEQCABEJYJCyABQQxqIQEgAkF0aiICDQALIAAoAgAhAQsCQCAAQQRqKAIAIgJFDQAgAUUNACACQQxsRQ0AIAEQ2gELIAAoAgwhASAAQRRqKAIAIgIEQCACQQxsIQIgAUEIaiEBA0AgASgCACIEKAIAIQMgBCADQX9qNgIAIANBAUYEQCABEJYJCyABQQxqIQEgAkF0aiICDQALIAAoAgwhAQsCQCAAQRBqKAIAIgBFDQAgAUUNACAAQQxsRQ0AIAEQ2gELC7sCAgJ/B30jAEEgayIDJAAgA0EANgIIIANCgICA/AM3AwAgA0EQaiIEIAEgAiADEPwDIANBgICA/Hs2AgAgAyoCECEGIAQgASACIAMQ/AMgA0KAgICAgICAwD83AwAgAyoCECEHIAQgASACIAMQ/AMgA0GAgID8ezYCBCADKgIUIQggBCABIAIgAxD8AyADQoCAgICAgIDAPzcCBCADKgIUIQkgBCABIAIgAxD8AyADQYCAgPx7NgIIIAMqAhghCiAEIAEgAiADEPwDIAEqAggiBUMAAAAAYEUEQEHhwcEAQSZBiMLBABD+CgALIAMqAhghCyAAQRRqIAogBZI4AgAgAEEQaiAIIAWSOAIAIAAgBiAFkjgCDCAAIAsgBZM4AgggACAJIAWTOAIEIAAgByAFkzgCACADQSBqJAALuwICAn8HfSMAQSBrIgMkACADQQA2AgggA0KAgID8AzcDACADQRBqIgQgASACIAMQpQMgA0GAgID8ezYCACADKgIQIQYgBCABIAIgAxClAyADQoCAgICAgIDAPzcDACADKgIQIQcgBCABIAIgAxClAyADQYCAgPx7NgIEIAMqAhQhCCAEIAEgAiADEKUDIANCgICAgICAgMA/NwIEIAMqAhQhCSAEIAEgAiADEKUDIANBgICA/Hs2AgggAyoCGCEKIAQgASACIAMQpQMgASoCCCIFQwAAAABgRQRAQeHBwQBBJkGIwsEAEP4KAAsgAyoCGCELIABBFGogCiAFkjgCACAAQRBqIAggBZI4AgAgACAGIAWSOAIMIAAgCyAFkzgCCCAAIAkgBZM4AgQgACAHIAWTOAIAIANBIGokAAubAgEDfyMAQTBrIgIkAAJ/IAFBAWoiAyABTwRAIABBBGooAgAiAUEBdCIEIAMgBCADSxsiA0EEIANBBEsbIgMgA0H/////AHFGQQJ0IQQgA0EEdCEDAkAgAQRAIAJBKGpBBDYCACACIAFBBHQ2AiQgAiAAKAIANgIgDAELIAJBADYCIAsgAkEQaiADIAQgAkEgahCBBiACKAIQQQFGBEAgAigCFCEBIAJBGGooAgAMAgsgAigCFCEBIABBBGogAkEYaigCAEEEdjYCACAAIAE2AgAgAkEwaiQADwsgAkEIaiIAQQA2AgQgACADNgIAIAIoAgghASACKAIMCyIABEAgASAAQdCewwAoAgAiAEG/BiAAGxEAAAALEJYMAAubAgECfyMAQTBrIgMkAAJ/IAEgAmoiAiABTwRAIABBBGooAgAiAUEBdCIEIAIgBCACSxsiAkEEIAJBBEsbIgIgAkH/////AXFGQQJ0IQQgAkEDdCECAkAgAQRAIANBKGpBBDYCACADIAFBA3Q2AiQgAyAAKAIANgIgDAELIANBADYCIAsgA0EQaiACIAQgA0EgahCBBiADKAIQQQFGBEAgAygCFCEBIANBGGooAgAMAgsgAygCFCEBIABBBGogA0EYaigCAEEDdjYCACAAIAE2AgAgA0EwaiQADwsgA0EIaiIAQQA2AgQgACACNgIAIAMoAgghASADKAIMCyIABEAgASAAQdCewwAoAgAiAEG/BiAAGxEAAAALEJYMAAubAgEDfyMAQTBrIgIkAAJ/IAFBAWoiAyABTwRAIABBBGooAgAiAUEBdCIEIAMgBCADSxsiA0EEIANBBEsbIgMgA0H/////AXFGQQJ0IQQgA0EDdCEDAkAgAQRAIAJBKGpBBDYCACACIAFBA3Q2AiQgAiAAKAIANgIgDAELIAJBADYCIAsgAkEQaiADIAQgAkEgahCBBiACKAIQQQFGBEAgAigCFCEBIAJBGGooAgAMAgsgAigCFCEBIABBBGogAkEYaigCAEEDdjYCACAAIAE2AgAgAkEwaiQADwsgAkEIaiIAQQA2AgQgACADNgIAIAIoAgghASACKAIMCyIABEAgASAAQdCewwAoAgAiAEG/BiAAGxEAAAALEJYMAAuaAgEDfyMAQTBrIgIkAAJ/IAFBAWoiAyABTwRAIABBBGooAgAiAUEBdCIEIAMgBCADSxsiA0EEIANBBEsbIgMgA0H///8PcUZBBHQhBCADQQd0IQMCQCABBEAgAkEoakEQNgIAIAIgAUEHdDYCJCACIAAoAgA2AiAMAQsgAkEANgIgCyACQRBqIAMgBCACQSBqEIEGIAIoAhBBAUYEQCACKAIUIQEgAkEYaigCAAwCCyACKAIUIQEgAEEEaiACQRhqKAIAQQd2NgIAIAAgATYCACACQTBqJAAPCyACQQhqIgBBADYCBCAAIAM2AgAgAigCCCEBIAIoAgwLIgAEQCABIABB0J7DACgCACIAQb8GIAAbEQAAAAsQlgwAC5oCAQN/IwBBMGsiAiQAAn8gAUEBaiIDIAFPBEAgAEEEaigCACIBQQF0IgQgAyAEIANLGyIDQQQgA0EESxsiAyADQf///x9xRkECdCEEIANBBnQhAwJAIAEEQCACQShqQQQ2AgAgAiABQQZ0NgIkIAIgACgCADYCIAwBCyACQQA2AiALIAJBEGogAyAEIAJBIGoQgQYgAigCEEEBRgRAIAIoAhQhASACQRhqKAIADAILIAIoAhQhASAAQQRqIAJBGGooAgBBBnY2AgAgACABNgIAIAJBMGokAA8LIAJBCGoiAEEANgIEIAAgAzYCACACKAIIIQEgAigCDAsiAARAIAEgAEHQnsMAKAIAIgBBvwYgABsRAAAACxCWDAALmwIBAn8jAEEwayIDJAACfyABIAJqIgIgAU8EQCAAQQRqKAIAIgFBAXQiBCACIAQgAksbIgJBBCACQQRLGyICIAJB/////wNxRkECdCEEIAJBAnQhAgJAIAEEQCADQShqQQQ2AgAgAyABQQJ0NgIkIAMgACgCADYCIAwBCyADQQA2AiALIANBEGogAiAEIANBIGoQgQYgAygCEEEBRgRAIAMoAhQhASADQRhqKAIADAILIAMoAhQhASAAQQRqIANBGGooAgBBAnY2AgAgACABNgIAIANBMGokAA8LIANBCGoiAEEANgIEIAAgAjYCACADKAIIIQEgAygCDAsiAARAIAEgAEHQnsMAKAIAIgBBvwYgABsRAAAACxCWDAALmgIBA38jAEEwayICJAACfyABQQFqIgMgAU8EQCAAQQRqKAIAIgFBAXQiBCADIAQgA0sbIgNBBCADQQRLGyIDIANB////P3FGQQJ0IQQgA0EFdCEDAkAgAQRAIAJBKGpBBDYCACACIAFBBXQ2AiQgAiAAKAIANgIgDAELIAJBADYCIAsgAkEQaiADIAQgAkEgahCBBiACKAIQQQFGBEAgAigCFCEBIAJBGGooAgAMAgsgAigCFCEBIABBBGogAkEYaigCAEEFdjYCACAAIAE2AgAgAkEwaiQADwsgAkEIaiIAQQA2AgQgACADNgIAIAIoAgghASACKAIMCyIABEAgASAAQdCewwAoAgAiAEG/BiAAGxEAAAALEJYMAAubAgEDfyMAQTBrIgIkAAJ/IAFBAWoiAyABTwRAIABBBGooAgAiAUEBdCIEIAMgBCADSxsiA0EEIANBBEsbIgMgA0H/////A3FGQQJ0IQQgA0ECdCEDAkAgAQRAIAJBKGpBBDYCACACIAFBAnQ2AiQgAiAAKAIANgIgDAELIAJBADYCIAsgAkEQaiADIAQgAkEgahCBBiACKAIQQQFGBEAgAigCFCEBIAJBGGooAgAMAgsgAigCFCEBIABBBGogAkEYaigCAEECdjYCACAAIAE2AgAgAkEwaiQADwsgAkEIaiIAQQA2AgQgACADNgIAIAIoAgghASACKAIMCyIABEAgASAAQdCewwAoAgAiAEG/BiAAGxEAAAALEJYMAAvwAQEKfwJAIAAEQCAAKAIADQEgAEEANgIAIAAoAgQhASAAKAIIIQIgACgCECEDIAAoAhQhBCAAKAIcIQUgACgCICEGIAAoAiwhByAAKAIwIQggACgCOCEJIAAoAjwhCiAAENoBAkAgAkUNACABRQ0AIAJBA3RFDQAgARDaAQsCQCAERQ0AIANFDQAgBEEDdEUNACADENoBCwJAIAZFDQAgBUUNACAGQQJ0RQ0AIAUQ2gELAkAgCEUNACAHRQ0AIAhBA3RFDQAgBxDaAQsCQCAKRQ0AIAlFDQAgCkEDdEUNACAJENoBCw8LEKIMAAsQowwAC50CAQN/IwBBMGsiASQAAkACQCAABEAgACgCAA0BIAFBKGogAEHMAmopAgA3AwAgAUEQaiAAQeACaikCADcDACABQRhqIABB6AJqKAIANgIAIABB1AJqIgIoAgAhAyACQQI2AgAgASAAQdgCaikCADcDCCABIABBxAJqKQIANwMgQQAhAiAAQQA2AgAgA0ECRwRAQSxBBBDICyICRQ0DIAJBADYCACACIAEpAyA3AgQgAiADNgIUIAIgASkDCDcCGCACQQxqIAFBKGopAwA3AgAgAkEgaiABQRBqKQMANwIAIAJBKGogAUEYaigCADYCAAsgAUEwaiQAIAIPCxCiDAALEKMMAAtBLEEEQdCewwAoAgAiAEG/BiAAGxEAAAALmwIBAn8jAEEwayIDJAACfyABIAJqIgIgAU8EQCAAQQRqKAIAIgFBAXQiBCACIAQgAksbIgJBBCACQQRLGyICIAJB/////wBxRkECdCEEIAJBBHQhAgJAIAEEQCADQShqQQQ2AgAgAyABQQR0NgIkIAMgACgCADYCIAwBCyADQQA2AiALIANBEGogAiAEIANBIGoQgQYgAygCEEEBRgRAIAMoAhQhASADQRhqKAIADAILIAMoAhQhASAAQQRqIANBGGooAgBBBHY2AgAgACABNgIAIANBMGokAA8LIANBCGoiAEEANgIEIAAgAjYCACADKAIIIQEgAygCDAsiAARAIAEgAEHQnsMAKAIAIgBBvwYgABsRAAAACxCWDAALmgIBAn8jAEEwayIDJAACfyABIAJqIgIgAU8EQCAAQQRqKAIAIgFBAXQiBCACIAQgAksbIgJBBCACQQRLGyICIAJB////P3FGQQJ0IQQgAkEFdCECAkAgAQRAIANBKGpBBDYCACADIAFBBXQ2AiQgAyAAKAIANgIgDAELIANBADYCIAsgA0EQaiACIAQgA0EgahCBBiADKAIQQQFGBEAgAygCFCEBIANBGGooAgAMAgsgAygCFCEBIABBBGogA0EYaigCAEEFdjYCACAAIAE2AgAgA0EwaiQADwsgA0EIaiIAQQA2AgQgACACNgIAIAMoAgghASADKAIMCyIABEAgASAAQdCewwAoAgAiAEG/BiAAGxEAAAALEJYMAAuDAwEDfyMAQSBrIgEkACAAKAIAIQIgAEECNgIAAkACQAJAAkAgAg4DAgECAAtBuNrCAEEcQdTawgAQiAsACyAALQAEIQIgAEEBOgAEIAEgAkEBcSICOgAHIAINASAAQQRqIQICQAJAAkACQEHgnsMAKAIAQf////8HcQRAAn9B0KLDACgCAEEBRgRAQdSiwwAoAgBFDAELQdCiwwBCATcDAEEBCyEDIABBBWotAABFDQIgA0EBcyEDDAELIABBBWotAABFDQILIAEgAzoADCABIAI2AghB/NLCAEErIAFBCGpBqNPCAEHk2sIAEJsIAAsgA0UNAQtB4J7DACgCAEH/////B3FFDQACf0HQosMAKAIAQQFGBEBB1KLDACgCAEUMAQtB0KLDAEIBNwMAQQELDQAgAEEFakEBOgAACyACQQA6AAALIAFBIGokAA8LIAFBHGpBADYCACABQRhqQejRwgA2AgAgAUIBNwIMIAFB5NzCADYCCCABQQdqIAFBCGoQ5QgAC54CAQR/IwBBMGsiBSQAAkACQAJAIABB1ABqKAIAIgQgAUsEQCAAQcgAaigCACIEIAAoAkwgAUEMbGoiASgCACIGTQ0B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IQYgAyAEIAEqAgwiDCAFlCAHIAaUIAggBCAIlCAKIAmUkyIEIASSIgSUk5KSOAIIIAMgCyAMIASUIAggBZQgCSAGlJOSkjgCBCADIAogDCAGlCAJIASUIAcgBZSTkpI4AgAgACADEJIBIANBEGokAAuZAgEFfyMAQdAAayIFJAAgBUEoaiIGQQhqIgcgAUEIaigCADYCACAFQTxqIAJBCGooAgA2AgAgBUEYaiIIIAMpAgA3AwAgBUEgaiIJIANBCGooAgA2AgAgBSACKQIANwI0IAVBCGoiAiAHKQMANwMAIAVBEGoiAyAGQRBqKQMANwMAIAUgASkCADcDAEEwQQQQyAsiAUUEQEEwQQRB0J7DACgCACIAQb8GIAAbEQAAAAsgASAFKQMANwIIIAEgBDgCLCABQoGAgIAQNwIAIAFBKGogCSgCADYCACABQSBqIAgpAwA3AgAgAUEYaiADKQMANwIAIAFBEGogAikDADcCACAAQZyowgA2AgQgACABNgIAIAVB0ABqJAALigIBAn8jAEEgayICJAACQAJAAkAgAARAIAAoAgAiA0F/Rg0BIAAgA0EBajYCACACQRBqIABBBGogARC4CSACKAIQIgFFDQIgAkEIaiABEKEKAkAgAigCCCACKAIMEOMJIgEEQCACQRhqIgMgAUEIaigCADYCACACIAEpAgA3AxAgACAAKAIAQX9qNgIAQRBBBBDICyIARQ0FIABBADYCACAAIAIpAxA3AgQgAEEMaiADKAIANgIADAELIAAgACgCAEF/ajYCAEEAIQALIAJBIGokACAADwsQogwACxCjDAALQairwABBzABBnKzAABCcCQALQRBBBEHQnsMAKAIAIgBBvwYgABsRAAAAC4cCAQN/IwBBIGsiAyQAAkACQAJAIAEEQCABKAIAIgRBf0YNASABIARBAWo2AgAgA0EQaiABQQRqIAIQwQEgASABKAIAQX9qNgIAIAMoAhAiAUUEQEEAIQJBACEBDAQLIAMoAhQiBCADQRhqKAIAIgJNDQMgBEECdCEEIAJBAnQiBUUEQCAERQRAQQQhAQwFCyABENoBQQQhAQwECyABIARBBCAFELgLIgENAyADQQhqIgBBBDYCBCAAIAU2AgAgAygCDCIARQ0CIAMoAgggAEHQnsMAKAIAIgBBvwYgABsRAAAACxCiDAALEKMM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pMIAEM8IAAsgBSADQcCkwgAQzwgACyACIANB0KTCABDPCAAL7wECAX8BfSMAQSBrIgskAAJAAkAgAARAIAAoAgANASAAQX82AgAgCyAAQQRqIAEQ5wcgCygCACIBRQ0CAkAgASgCGA0AIAIgApQgBCAElJIgAyADlCAFIAWUkpJDAAAAAJIiDEP+5tsuXkEBcw0AIAsgAiAMEKsBIgKVOAIMIAsgBSAClTgCCCALIAQgApU4AgQgCyADIAKVOAIAIAsgCDgCGCALIAc4AhQgCyAGOAIQIAFBHGogCyALQRBqIAkgChDdCQsgAEEANgIAIAtBIGokAA8LEKIMAAsQowwAC0GAqcAAQckAQYCqwAAQnAkAC9gBAQJ/IwBB4ABrIgIkACACQShqIABBKGooAgA2AgAgAkEgaiAAQSBqKQIANwMAIAJBGGogAEEYaikCADcDACACQRBqIABBEGopAgA3AwAgAkEIaiAAQQhqKQIANwMAIAIgACkCADcDACACQTBqIgNBKGogAUEoaigCADYCACADQSBqIAFBIGopAgA3AwAgA0EYaiABQRhqKQIANwMAIANBEGogAUEQaikCADcDACADQQhqIAFBCGopAgA3AwAgAiABKQIANwMwIAAgAiADENkBIAJB4ABqJAAL2AEBAn8jAEHgAGsiAiQAIAJBKGogAEEoaigCADYCACACQSBqIABBIGopAgA3AwAgAkEYaiAAQRhqKQIANwMAIAJBEGogAEEQaikCADcDACACQQhqIABBCGopAgA3AwAgAiAAKQIANwMAIAJBMGoiA0EoaiABQShqKAIANgIAIANBIGogAUEgaikCADcDACADQRhqIAFBGGopAgA3AwAgA0EQaiABQRBqKQIANwMAIANBCGogAUEIaikCADcDACACIAEpAgA3AzAgACACIAMQxwEgAkHgAGokAAufAgEEfSABKgIEIgQgBJQiA0MAAEBAlCEFIAEqAgAiBCADQ9sPSUCUlCIDIAOSQwAAQECVIAKUIQIgBUMAAKBBlSAEIASUQwAAgECUQwAAQECUQwAAoECVkiAClCIGEKsBIQMgBUMAACBBlSAClBCrASEFIAYQqwEhBiAAQSRqQoCAgICAgIDAPzcCACAAQgA3AhwgAEEANgIIIAAgBEMAAAC/lDgCBCAAQQA2AgAgAEMAAAAAQwAAgD8g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CCAGIAhgGzgCACAAQRBqIAQgAkEUaioCACIGkiIIIAQgA0EUaioCACIJkiIKIAggCmAbOAIAIAAgBSAEkyIFIAcgBJMiByAFIAdfGzgCCCAAIAYgBJMiBSAJIASTIgQgBSAEXxs4AgQLhQIBBX0gAEEANgIIIABCADcCACABKgIEIgQgBJRDAABAQJUiBiABKgIIIgUgBZRDAABAQJUiB5IgASoCACIDIASUIAWUQwAAAEGUIAKUIgKUEKsBIQQgAyADlEMAAEBAlSIDIAeSIAKUEKsBIQUgAyAGkiAClBCrASEDIABBJGpCgICAgICAgMA/NwIAIABCADcCHCAAQwAAAABDAACAPyAElSAEQwAAAABbGzgCECAAQwAAAABDAACAPyAClSACQwAAAABbGzgCDCAAQRRqQwAAAABDAACAPyAFlSAFQwAAAABbGzgCACAAQRhqQwAAAABDAACAPyADlSADQwAAAABbGzgCAAuCAgIDfwJ+IwBBMGsiAkEgaiIEIAFBIGooAgAiAzYCACACQSxqIAM2AgAgAkEUaiABQRRqKAIANgIAIAJBCGoiAyABQQhqKAIANgIAIAJBGGogASkCGCIFNwMAIABBGGogBTcCACAAIAEpAgAiBjcCACACIAU3AiQgAEEgaiAEKQMANwIAIABBKGogAkEoaikDADcCACACIAEpAgw3AgwgAEEQaiACQRBqKQMANwIAIABBCGogAykDADcCACACIAY3AwAgAEKAgICAMDcCUCAAQcgAakKFgICA0AA3AgAgAEKBgICAMDcCQCAAQThqQoSAgIDAADcCACAAQoCAgIAgNwIwC/YBAgR/AX4jAEGAAWsiAyQAIAMgASACECMgA0HoAGogA0EIaigCACIENgIAIAMgAykDACIHNwNgIANBEGooAgAhASADQRRqKAIAIQUgAygCDCECIANB8ABqIgZBCGogBDYCACADIAc3A3AgAyAGIAIgBRA6AkAgAUUNACABQQxsRQ0AIAIQ2gELAkACQCADKAIARQRAQQAhAQwBC0HoAEEEEMgLIgFFDQEgAUEIaiADQeAAEJ4KGiABQoGAgIAQNwIACyAAQYSLwgA2AgQgACABNgIAIANBgAFqJAAPC0HoAEEEQdCewwAoAgAiAEG/BiAAGxEAAAALywEBBH8CQCAAQRxqKAIAIgFFDQAgAEEY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AiQhAwsgASADQQFqNgIkIAEoAhwgA0EDdGoiASAENgIEIAEgAjYCAAsgACACNgIEIAAgBTYCACAAQQhqIAQ2AgAPCyAAQQA2AgALxQEBBH8jAEEQayIEJAACQAJAAkAgASgCACIFEBQiAUEATgRAIAENAUEBIQMMAgsgBEEIaiIAQQA2AgQgACABNgIAEJYMAAsgASECIAFBARDJCyIDRQ0BCyAAIAE2AgggACADNgIAIAAgAjYCBBAbIgEQDSICEBUhACACQSRPBEAgAhAACyAAIAUgAxAWIABBJE8EQCAAEAALIAFBJE8EQCABEAALIARBEGokAA8LIAFBAUHQnsMAKAIAIgBBvwYgABsRAAAAC9cBAQJ/IwBBIGsiAyQAAkACQAJAIAAEQCAAKAIAIgRBf0YNASAAIARBAWo2AgAgA0EQaiAAQQRqIAEQtwkgAygCECIBRQ0CIANBCGoiBCABQYACaigCADYCBCAEIAEoAvgBNgIAIAMoAgwiASACTQ0DIAMoAgggAkEDdGoiASgCACECIAMgASgCBDYCBCADIAI2AgAgAygCACAAIAAoAgBBf2o2AgAgA0EgaiQADwsQogwACxCjDAALQZCqwABBzQBBiKvAABCcCQALIAIgAUGkrcAAEM8IAAuEAgECfwJAQQhBBBDICyIBBEAgAUKBgICAEDcCAEEgQQQQyAsiAkUNASAAQQA6AEwgAEGKro/hAzYCSCAAQv////v3//+//wA3AgggAEH0ksEANgIEIAAgATYCACAAQSxqQgA3AgAgAEEkakIANwIAIABBQGtCADcCACAAQTxqQZjAwAAoAgA2AgAgAEE4akEINgIAIABBNGogAjYCACAAQSBqQaDAwAAoAgA2AgAgAEEYakL////7////v383AgAgAEEQakL////79///v383AgAPC0EIQQRB0J7DACgCACIAQb8GIAAbEQAAAAtBIEEEQdCewwAoAgAiAEG/BiAAGxEAAAALuAEBA38CQCABKAIIIAJNDQAgASgCACACQaACbGoiAygCAEEBRw0AIANBCGohBSADKAIEIQQgA0GYAmoiAy0AAEEBcUUEQCADQQE2AgAgAUEkaigCACIDIAFBIGooAgBGBEAgAUEcaiADEMIFIAEoAiQhAwsgASADQQFqNgIkIAEoAhwgA0EDdGoiASAENgIEIAEgAjYCAAsgACACNgIEIAAgBTYCACAAQQhqIAQ2AgAPCyAAQQA2AgALhAIBAn8CQEEIQQQQyAsiAQRAIAFCgYCAgBA3AgBBIEEEEMgLIgJFDQEgAEEAOgBMIABC////+/f//7//ADcCCCAAQfSSwQA2AgQgACABNgIAIABBiq6P4QM2AkggAEEsakIANwIAIABBJGpCADcCACAAQUBrQgA3AgAgAEE8akGYwMAAKAIANgIAIABBOGpBCDYCACAAQTRqIAI2AgAgAEEgakGgwMAAKAIANgIAIABBGGpC////+////79/NwIAIABBEGpC////+/f//79/NwIADwtBCEEEQdCewwAoAgAiAEG/BiAAGxEAAAALQSBBBEHQnsMAKAIAIgBBvwYgABsRAAAAC6YBAQl9IAIqAgAiBCABKgIAIgaUIAJBBGoqAgAiBSABQQRqKgIAIgeUkiABQQhqKgIAIgggAkEIaioCACIDlJIgBCABQQxqKgIAIgmUIAUgAUEQaioCACIKlJIgAyABQRRqKgIAIguUkl4hAiAAIAggCyACGyADIAEqAhgiA5SSOAIIIAAgByAKIAIbIAUgA5SSOAIEIAAgBiAJIAIbIAQgA5SSOAIAC6wBAQF/IwBBEGsiBiQAAkACQCAABEAgACgCAA0BIABBfzYCACAGIABBBGogARDyBiAGKAIAIgFFDQIgAS0AlAJFBEAgBQRAIAEQtgkLIAFBnAFqIgUgBS0AAEHxAXEgA0EAR0ECdCACQQBHQQF0ciAEQQBHQQN0cnI6AAAgARDRBQsgAEEANgIAIAZBEGokAA8LEKIMAAsQowwAC0GQqsAAQc0AQZirwAAQnAkAC7MBAQR9AkACQAJAIAIqAgAiAyADlEMAAAAAkiACQQhqKgIAIgQgBJSSQwAAAACSEKsBIgVDAAAAAFwEQCAEIAQgBZUgASoCBCIElCIGlCADIAMgBZUgBJQiBJQgASoCACIDIAJBBGoqAgCUIgWTkiAFXQ0BIAOMIQMMAwsgASoCACACQQRqKgIAmCEDDAELQwAAAAAhBgtDAAAAACEECyAAIAY4AgggACADOAIEIAAgBDgCAAvDAQECfyMAQUBqIgAkACAAEIwJQcQAQQQQyAsiAUUEQEHEAEEEQdCewwAoAgAiAEG/BiAAGxEAAAALIAFBADYCACABIAApAwA3AgQgAUEMaiAAQQhqKQMANwIAIAFBFGogAEEQaikDADcCACABQRxqIABBGGopAwA3AgAgAUEkaiAAQSBqKQMANwIAIAFBLGogAEEoaikDADcCACABQTRqIABBMGopAwA3AgAgAUE8aiAAQThqKQMANwIAIABBQGskACABC8MBAQJ/IwBBQGoiACQAIAAQnQRBxABBBBDICyIBRQRAQcQAQQRB0J7DACgCACIAQb8GIAAbEQAAAAsgAUEANgIAIAEgACkDADcCBCABQQxqIABBCGopAwA3AgAgAUEUaiAAQRBqKQMANwIAIAFBHGogAEEYaikDADcCACABQSRqIABBIGopAwA3AgAgAUEsaiAAQShqKQMANwIAIAFBNGogAEEwaikDADcCACABQTxqIABBOGopAwA3AgAgAEFAayQAIAELvwEBBH8jAEHwAGsiAiQAAkACQCAABEAgACgCAA0BIAJBDGogAEGcAWpB4gAQngoaIABBADYCACAAQf4BaiIELQAAIQMgBEECOgAAIANBAkcEQCAAQf8Bai0AACEAQegAQQQQyAsiAUUNAyABQQA2AgAgAUEEaiACQQxqQeIAEJ4KGiABIAA6AGcgASADOgBmCyACQfAAaiQAIAEPCxCiDAALEKMMAAtB6ABBBEHQnsMAKAIAIgBBvwYgABsRAAAAC58BAQV9AkAgAUEEaioCACIGIAIqAgSMlCACKgIAIAEqAgAiB5STIAIqAgggAUEIaioCACIIlJMiCUMAAAAAXkEBc0VBACAEG0UEQEEAIQEgCSAHIAJBDGoqAgCUIAYgAkEQaioCAJSSIAggAkEUaioCAJSSlSIFQwAAAABgQQFzDQEgBSADX0EBcw0BC0EBIQELIAAgBTgCBCAAIAE2AgALxgEBAn8jAEGAAWsiAyQAIANB2ABqIgRBEGogAUEQaigCADYCACAEQQhqIAFBCGopAgA3AwAgAyABKQIANwNYIANB8ABqIgFBCGogAkEIaigCADYCACADIAIpAgA3A3AgA0EIaiAEIAEQjAJB2ABBBBDICyIBRQRAQdgAQQRB0J7DACgCACIAQb8GIAAbEQAAAAsgAUEIaiADQQhqQdAAEJ4KGiABQoGAgIAQNwIAIABBzIjCADYCBCAAIAE2AgAgA0GAAWokAAu1AQEEfyMAQTBrIgIkACABQQRqIQMgASgCBEUEQCABKAIAIQEgAkIANwIMIAJB2NPCACgCADYCCCACIAJBCGoiBTYCFCACQRhqIgRBEGogAUEQaikCADcDACAEQQhqIAFBCGopAgA3AwAgAiABKQIANwMYIAJBFGpBwNHCACAEENgCGiADQQhqIAVBCGooAgA2AgAgAyACKQMINwIACyAAQfjXwgA2AgQgACADNgIAIAJBMGokAAvEAQEBfyMAQRBrIgEkACAAAn9BASAALQAEDQAaIAAtAAVFBEAgACgCACIAKAIYQYb9wgBBByAAQRxqKAIAKAIMEQUADAELIAAoAgAiAC0AAEEEcUUEQCAAKAIYQYD9wgBBBiAAQRxqKAIAKAIMEQUADAELIAFBAToADyABIAApAhg3AwAgASABQQ9qNgIIQQEgAUH8/MIAQQMQ+QMNABogACgCGEH//MIAQQEgACgCHCgCDBEFAAsiADoABCABQRBqJAAgAAuaAQEDfyAAKAIAIgEQhQUCQCABQeQAaigCACICRQ0AIAFB4ABqKAIAIgNFDQAgAkECdEUNACADENoBCwJAIAFB9ABqKAIAIgJFDQAgAUHwAGooAgAiA0UNACACQQJ0RQ0AIAMQ2gELAkAgAUGAAWooAgAiAkUNACABQfwAaigCACIBRQ0AIAJBAnRFDQAgARDaAQsgACgCABDaAQvTAQECfyMAQSBrIgIkAAJAAkAgAARAIAAoAgAiA0F/Rg0BIAAgA0EBajYCACACQRBqIABBBGogARC4CSACKAIQIgFFDQIgAkEQaiIDIAEoAiRBAUYEfyADIAFBKGopAwA3AgRBAQVBAAs2AgACfyACKAIQQQFGBEAgAigCFCEBIAJBCGoiAyACQRhqKAIANgIEIAMgATYCACACKAIIDAELQQALIAAgACgCAEF/ajYCACACQSBqJAAPCxCiDAALEKMMAAtBqKvAAEHMAEGcrMAAEJwJAAvOAQEDfSADKgIAEKsBIQUgA0EEaioCABCrASEGIANBCGoqAgAQqwEhByAAQRRqQwAAAABDAACAPyAGlSAGQwAAAABbGzgCACAAQwAAAABDAACAPyAFlSAFQwAAAABbGzgCECAAQwAAAABDAACAPyAClSACQwAAAABbGzgCDCAAQQhqIAFBCGooAgA2AgAgACABKQIANwIAIAAgBCkCADcCHCAAQSRqIARBCGopAgA3AgAgAEEYakMAAAAAQwAAgD8gB5UgB0MAAAAAWxs4AgALtQEBAn8jAEEQayIEJAACQAJAAkAgAEUNACAAKAIADQEgAEF/NgIAIAJFDQAgAigCACIFQX9GDQEgAiAFQQFqNgIAIAQgAEEEaiABEPIGIAQoAgAiAUUNAiAEQQhqIAJBDGooAgA2AgAgBCACKQIENwMAIAEgBCADQQBHEP8IIAIgAigCAEF/ajYCACAAQQA2AgAgBEEQaiQADwsQogwACxCjDAALQZCqwABBzQBBmKvAABCcCQALtQEBAn8jAEEQayIEJAACQAJAAkAgAEUNACAAKAIADQEgAEF/NgIAIAJFDQAgAigCACIFQX9GDQEgAiAFQQFqNgIAIAQgAEEEaiABEPIGIAQoAgAiAUUNAiAEQQhqIAJBDGooAgA2AgAgBCACKQIENwMAIAEgBCADQQBHEO0IIAIgAigCAEF/ajYCACAAQQA2AgAgBEEQaiQADwsQogwACxCjDAALQZCqwABBzQBBmKvAABCcCQALtQEBAn8jAEEQayIEJAACQAJAAkAgAEUNACAAKAIADQEgAEF/NgIAIAJFDQAgAigCACIFQX9GDQEgAiAFQQFqNgIAIAQgAEEEaiABEPIGIAQoAgAiAUUNAiAEQQhqIAJBDGooAgA2AgAgBCACKQIENwMAIAEgBCADQQBHEOsHIAIgAigCAEF/ajYCACAAQQA2AgAgBEEQaiQADwsQogwACxCjDAALQZCqwABBzQBBmKvAABCcCQALtQEBAn8jAEEQayIEJAACQAJAAkAgAEUNACAAKAIADQEgAEF/NgIAIAJFDQAgAigCACIFQX9GDQEgAiAFQQFqNgIAIAQgAEEEaiABEPIGIAQoAgAiAUUNAiAEQQhqIAJBDGooAgA2AgAgBCACKQIENwMAIAEgBCADQQBHELkHIAIgAigCAEF/ajYCACAAQQA2AgAgBEEQaiQADwsQogwACxCjDAALQZCqwABBzQBBmKvAABCcCQALtQEBAn8jAEEQayIEJAACQAJAAkAgAEUNACAAKAIADQEgAEF/NgIAIAJFDQAgAigCACIFQX9GDQEgAiAFQQFqNgIAIAQgAEEEaiABEPIGIAQoAgAiAUUNAiAEQQhqIAJBDGooAgA2AgAgBCACKQIENwMAIAEgBCADQQBHEN4HIAIgAigCAEF/ajYCACAAQQA2AgAgBEEQaiQADwsQogwACxCjDAALQZCqwABBzQBBmKvAABCcCQALtQEBAn8jAEEQayIEJAACQAJAAkAgAEUNACAAKAIADQEgAEF/NgIAIAJFDQAgAigCACIFQX9GDQEgAiAFQQFqNgIAIAQgAEEEaiABEPIGIAQoAgAiAUUNAiAEQQhqIAJBDGooAgA2AgAgBCACKQIENwMAIAEgBCADQQBHEIMFIAIgAigCAEF/ajYCACAAQQA2AgAgBEEQaiQADwsQogwACxCjDAALQZCqwABBzQBBmKvAABCcCQALqwECAX8BfSMAQUBqIgQkACAEQRhqIAEgAUEMaiABQRhqIAIQnQJBBCEBAkAgBCgCKCICQQRHBEAgBEEQaiIFIARBJGooAgA2AgAgBCAEKQIcNwMIIAAgBCoCGCIGIANfQQFzBH9BBAUgBCgCLCEBIAAgBjgCACAAIAQpAwg3AgQgACABNgIUIABBDGogBSgCADYCACACCzYCEAwBCyAAQQQ2AhALIARBQGskAAvQAQAgAEIANwIYIABCADcCTCAAQgA3AiQgAEEBOwF4IABCgICAgPD//7//ADcCRCAAIAEpAgA3AgAgACACKQIANwIMIABBIGpBADYCACAAQdQAakEANgIAIABBLGpCADcCACAAQTRqQgA3AgAgAEE8akKAgID8AzcCACAAQQhqIAFBCGooAgA2AgAgAEEUaiACQQhqKAIANgIAIABC////+wc3AnAgAEHoAGpCADcCACAAQYCAgPwDNgJkIABB3ABqQgA3AgAgAEGAgID8AzYCWAu5AQEBfyAAQQA6AGIgAEEAOwFgIABBFGpCADcCACAAQZjAwAAoAgAiATYCECAAQX82AgwgAEIANwIEIAAgATYCACAAQdgAakIANwIAIABB1ABqIAE2AgAgAEHMAGpCADcCACAAQcgAakHAy8IANgIAIABBADYCRCAAQTxqQgA3AgAgACABNgI4IABBMGpCADcCACAAQSxqIAE2AgAgAEEkakIANwIAIABBIGpBwMvCADYCACAAQQA2AhwLtAECAn8BfCMAQSBrIgAkACAAEI4KNgIUIABB7q3BAEELEAM2AhggAEEIaiAAQRRqIABBGGoQzAkgACgCDCEBIAAoAghFBEAgACABNgIcIABBHGooAgAQBCAAKAIcIgFBJE8EQCAB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NgIAIAIgAigCPCIANgIwIAIgADYCLCACIAIoAjg2AiggAkHwADYCJCACQgI3AgwgAkHAsMEANgIIIAIgAkEoajYCICACIAJBIGo2AhggASACQQhqENQIAkAgAigCKCIBRQ0AIAIoAixFDQAgARDaAQsgAkFAayQAC70BAgJ/AX0jAEEgayIDJAACQAJAIAEEQCABKAIAIgRBf0YNASABIARBAWo2AgAgA0EQaiABQQRqIAIQuAkgAygCECICRQ0CIANBCGoiBCACQRxqKgIAOAIEIAQgAigCGEEBRzYCACADKgIMIQUgAygCCCECIAEgASgCAEF/ajYCACAAIAVDAAAAACACGzgCBCAAIAJBAEc2AgAgA0EgaiQADwsQogwACxCjDAALQairwABBzABBnKzAABCcCQALogEBBH8jAEEgayIEJAAgACgCBCIGKAIAIgUoAmAgBSgCZCEFAkAgAQRAIAQgASAFELwEDAELIARBGGogBUEYaigCADYCACAEQRBqIAVBEGopAgA3AwAgBEEIaiAFQQhqKQIANwMAIAQgBSkCADcDAAsgBCACIAMgBigCACIBKAJwIAFB9ABqKAIAEGohASAAKAIAIAFB/QFxOgAAIARBIGokAAuwAQEDfyMAQRBrIgEkAAJAAkAgAARAIAAoAgAiAkF/Rg0BIAAgAkEBajYCACABQQhqIgIgACgCBCIDQRRqKAIANgIAIAEgAykCDDcDACAAIAAoAgBBf2o2AgBBEEEEEMgLIgBFDQIgAEEANgIAIAAgASkDADcCBCAAQQxqIAIoAgA2AgAgAUEQaiQAIAAPCxCiDAALEKMMAAtBEEEEQdCewwAoAgAiAEG/BiAAGxEAAAALrgEBAn8jAEEQayIBJAACQAJAIAAEQCAAKAIAIgJBf0YNASAAIAJBAWo2AgAgAUEIaiICIABBFGooAgA2AgAgASAAQQxqKQIANwMAIAAgACgCAEF/ajYCAEEQQQQQyAsiAEUNAiAAQQA2AgAgACABKQMANwIEIABBDGogAigCADYCACABQRBqJAAgAA8LEKIMAAsQowwAC0EQQQRB0J7DACgCACIAQb8GIAAbEQAAAAuuAQECfyMAQRBrIgEkAAJAAkAgAARAIAAoAgAiAkF/Rg0BIAAgAkEBajYCACABQQhqIgIgAEEYaigCADYCACABIABBEGop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EN8JIABBADYCACADQSBqJAAPCxCiDAALEKMMAAtBqKvAAEHMAEGsrMAAEJwJAAuZAQECfyMAQSBrIgMkAAJAAkAgAARAIAAoAgANASAAQX82AgAgA0EIaiIEIAJB//8DcTYCBCAEIAJBEHY2AgAgAygCDCECIAMoAgghBCADQRBqIABBBGogARDuBiADKAIQIgFFDQIgASAEIAIQ4AkgAEEANgIAIANBIGokAA8LEKIMAAsQowwAC0Goq8AAQcwAQayswAAQnAkAC8YBAQF/IwBBEGsiBSQAAkACQCAABEAgACgCAA0BIABBfzYCACAFIABBBGogARDnByAFKAIAIgFFDQICQAJAAkAgASgCGEECaw4CAAECCyABQRxqIgEgBDgCjAEgASADOAKIASABIAI4AoQBIAFBADYCgAEMAQsgAUEcaiIBIAQ4AowBIAEgAzgCiAEgASACOAKEASABQQA2AoABCyAAQQA2AgAgBUEQaiQADwsQogwACxCjDAALQYCpwABByQBBgKrAABCcCQALiwEBAn8jAEEQayICJAACQAJAIAAEQCAAKAIAIgNBf0YNASAAIANBAWo2AgAgAiAAQQRqIAEQtwkgAigCACIBRQ0CIAEtAJQCIAAgACgCAEF/ajYCACACQRBqJABB/wFxQQJzQQJ0QaSxwABqKAIADwsQogwACxCjDAALQZCqwABBzQBBiKvAABCcCQALmQEBAX8jAEEwayIBJAAgAUEIaiAAQQBHEJkGQShBBBDICyIARQRAQShBBEHQnsMAKAIAIgBBvwYgABsRAAAACyAAQQA2AgAgACABKQMINwIEIABBDGogAUEQaikDADcCACAAQRRqIAFBGGopAwA3AgAgAEEcaiABQSBqKQMANwIAIABBJGogAUEoaigCADYCACABQTBqJAAgAAumAQECfyMAQfAAayIEJAAgBEHgAGoiBUEIaiABQQhqKAIANgIAIAQgASkCADcDYCAEIAUgAiADEDoCQAJAIAQoAgBFBEBBACEBDAELQegAQQQQyAsiAUUNASABQQhqIARB4AAQngoaIAFCgYCAgBA3AgALIABBhIvCADYCBCAAIAE2AgAgBEHwAGokAA8LQegAQQRB0J7DACgCACIAQb8GIAAbEQAAAAukAQEDfyMAQRBrIgEkACAAKAIAIgJBFGooAgAhAwJAAn8CQAJAIAIoAgQOAgABAwsgAw0CQQAhAkHo0cIADAELIAMNASACKAIAIgMoAgQhAiADKAIACyEDIAEgAjYCBCABIAM2AgAgAUHk18IAIAAoAgQoAgggACgCCBDFBgALIAFBADYCBCABIAI2AgAgAUHQ18IAIAAoAgQoAgggACgCCBDFBgALhQEBAX8CQAJAIABFDQAgACgCAA0BIABBfzYCACABRQ0AIAEoAgANASABQX82AgAgAkUNACACKAIAIgVBf0YNASACIAVBAWo2AgAgAEEEaiABQQRqIAJBBGogAyAEEIsBIAIgAigCAEF/ajYCACABQQA2AgAgAEEANgIADwsQogwACxCjDAALkwEBAn8jAEEgayIBJAAgAUEYaiICQQA2AgAgAUEMakIANwIAIAFCADcCBCABQajAwAAoAgA2AgAgAUEEEKYDIABBIGpCADcCACAAQZjAwAAoAgA2AhwgAEEYaiACKAIANgIAIABBEGogAUEQaikDADcCACAAQQhqIAFBCGopAwA3AgAgACABKQMANwIAIAFBIGokAAuAAQIBfwN9IAAgASABQQxqIgMgASoCACACKgIAIgSUIAFBBGoqAgAgAkEEaioCACIFlJIgAUEIaioCACACQQhqKgIAIgaUkiAEIAMqAgCUIAUgAUEQaioCAJSSIAYgAUEUaioCAJSSXhsiASkCADcCACAAQQhqIAFBCGooAgA2AgALewEDfyMAQSBrIgMkACADQQhqIAEQgAMgA0EYaigCACEBIAMoAgwhBCAAIAIgAygCCCIAIAMoAhAgAygCFCIFIANBHGooAgAQkwICQCABRQ0AIAFBDGxFDQAgBRDaAQsCQCAERQ0AIARBDGxFDQAgABDaAQsgA0EgaiQAC68BAQF/IwBBEGsiBiQAAkACQCAABEAgACgCAA0BIABBfzYCACAGIABBBGogARDnByAGKAIAIgFFDQIgASgCGEUEQCAGIAQ4AgggBiADOAIEIAYgAjgCACABQRxqIgEgBTgCRCABQQA2AkAgASAGKQIANwIkIAFBLGogBkEIaigCADYCAAsgAEEANgIAIAZBEGokAA8LEKIMAAsQowwAC0GAqcAAQckAQYCqwAAQnAkAC7YBAQF/IwBBEGsiBCQAAkACQCAABEAgACgCAA0BIABBfzYCACAEIABBBGogARDnByAEKAIAIgFFDQICQAJAAkAgASgCGEECaw4CAAECCyABQRxqIgEgAzgCjAEgAUEANgKIASABIAI4AoABDAELIAFBHGoiASADOAKMASABQQA2AogBIAEgAjgCgAELIABBADYCACAEQRBqJAAPCxCiDAALEKMMAAtBgKnAAEHJAEGAqsAAEJwJAAuYAQECfyMAQSBrIgIkAAJAAkAgAARAIAAoAgAiA0F/Rg0BIAAgA0EBajYCACACQRBqIABBBGogARC3CSACKAIQIgFFDQIgAkEIaiIDIAFBgAJqKAIANgIEIAMgASgC+AE2AgAgAigCDCAAIAAoAgBBf2o2AgAgAkEgaiQADwsQogwACxCjDAALQZCqwABBzQBBiKvAABCcCQALigEAIAAgASkCADcCACAAIAIpAgA3AhwgACADKQIANwIoIAAgBCkCADcCNCAAQRhqIAFBGGooAgA2AgAgAEEQaiABQRBqKQIANwIAIABBCGogAUEIaikCADcCACAAQSRqIAJBCGooAgA2AgAgAEEwaiADQQhqKAIANgIAIABBPGogBEEIaigCADYCAAuUAQECfyMAQTBrIgAkACAAQQhqENQHQSxBBBDICyIBRQRAQSxBBEHQnsMAKAIAIgBBvwYgABsRAAAACyABQQA2AgAgASAAKQMINwIEIAFBDGogAEEQaikDADcCACABQRRqIABBGGopAwA3AgAgAUEcaiAAQSBqKQMANwIAIAFBJGogAEEoaikDADcCACAAQTBqJAAgAQuaAQEBfyMAQTBrIgQkACAEIAE2AhggBCABNgIUIAQgADYCECAEIAM2AiggBCADNgIkIAQgAjYCICAEQQhqIARBEGogBEEgahDnASAEKAIMIQEgBCgCCCECQQxBBBDICyIARQRAQQxBBEHQnsMAKAIAIgBBvwYgABsRAAAACyAAIAI2AgQgAEEANgIAIAAgATYCCCAEQTBqJAAgAAuaAQEBfyMAQTBrIgQkACAEIAE2AhggBCABNgIUIAQgADYCECAEIAM2AiggBCADNgIkIAQgAjYCICAEQQhqIARBEGogBEEgahD4ASAEKAIMIQEgBCgCCCECQQxBBBDICyIARQRAQQxBBEHQnsMAKAIAIgBBvwYgABsRAAAACyAAIAI2AgQgAEEANgIAIAAgATYCCCAEQTBqJAAgAAuQAQIBfwF9AkAgAC0A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ACAAIAAoAgBBf2o2AgAgAkEQaiQADwsQogwACxCjDAALQairwABBzABBnKzAABCcCQALlAECAX8BfSABKgIkIQNBKEEEEMgLIgJFBEBBKEEEQdCewwAoAgAiAEG/BiAAGxEAAAALIAIgAzgCJCACIAEpAgA3AgAgAkEgaiABQSBqKAIANgIAIAJBGGogAUEYaikCADcCACACQRBqIAFBEGopAgA3AgAgAkEIaiABQQhqKQIANwIAIABBnKjCADYCBCAAIAI2AgALdwEDfyMAQSBrIgIkAAJAIAAgARD+BEUEQCABQRxqKAIAIQMgASgCGCACQRxqQQA2AgAgAkGE+cIANgIYIAJCATcCDCACQcT5wgA2AgggAyACQQhqENgCRQ0BCyACQSBqJABBAQ8LIABBBGogARD+BCACQSBqJAALeAACQAJAIABFDQAgACgCAA0BIABBfzYCACACRQ0AIAIoAgANASACQX82AgAgA0UNACADKAIADQEgA0F/NgIAIABBBGogASACQQRqIANBBGogBEEARxCsASADQQA2AgAgAkEANgIAIABBADYCAA8LEKIMAAsQowwAC3sBAn8jAEEQayICJAACQAJAIAAEQCAAKAIAIgNBf0YNASAAIANBAWo2AgAgAiAAQQRqIAEQtwkgAigCACIBRQ0CIAFBjAJqLQAAIAAgACgCAEF/ajYCACACQRBqJAAPCxCiDAALEKMMAAtBkKrAAEHNAEGIq8AAEJwJAAt3AQJ/IwBBEGsiAiQAAkACQCAABEAgACgCACIDQX9GDQEgACADQQFqNgIAIAIgAEEEaiABELcJIAIoAgAiAUUNAiABEPcFIAAgACgCAEF/ajYCACACQRBqJAAPCxCiDAALEKMMAAtBkKrAAEHNAEGIq8AAEJwJAAujAQEBfyMAQRBrIgUkAAJAAkAgAARAIAAoAgANASAAQX82AgAgBSAAQQRqIAEQ8gYgBSgCACIBRQ0CIAUgBDgCCCAFIAM4AgQgBSACOAIAIAEtAJQCQQJxBEAgAUE8aiAFKQIANwIAIAFBxABqIAVBCGooAgA2AgALIABBADYCACAFQRBqJAAPCxCiDAALEKMMAAtBkKrAAEHNAEGYq8AAEJwJAAuTAQICfwF9IwBBEGsiAiQAAkACQCAABEAgACgCACIDQX9GDQEgACADQQFqNgIAIAIg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IGokACAEIAQgBIwgAhsgAEEBRxsLgwECAX8BfSAAIAEqAgwiBCACKAIIIgO+lCABKAIIQf////8HcSADQYCAgIB4cXK+kjgCCCAAIAQgAigCBCIDvpQgASgCBEH/////B3EgA0GAgICAeHFyvpI4AgQgACAEIAIoAgAiAL6UIAEoAgBB/////wdxIABBgICAgHhxcr6SOAIAC3kDAn8BfgF9IwBBEGsiASQAIAFCADcDCEEBIQICfSAAKAIAQQFHBEBDAACAPyAAKAIEIgJBAkkNARogAkECQaD2wQAQzwgACyABIAAqAgQ4AgggAEEIaioCAAshBCABQQhqIAJBAnRqIAQ4AgAgASkDCCABQRBqJAALfAEBfyAALQAEIQEgAC0ABQRAIAFB/wFxIQEgAAJ/QQEgAQ0AGiAAKAIAIgEtAABBBHFFBEAgASgCGEGN/cIAQQIgAUEcaigCACgCDBEFAAwBCyABKAIYQf/8wgBBASABQRxqKAIAKAIMEQUACyIBOgAECyABQf8BcUEARwttAQF/AkAgACABayACSQRAIAFBf2ohASAAQX9qIQMDQCACIANqIAEgAmotAAA6AAAgAkF/aiICDQALDAELIAJFDQAgACEDA0AgAyABLQAAOgAAIAFBAWohASADQQFqIQMgAkF/aiICDQALCyAAC4IBAQN9AkACQCAABEAgACgCAEF/Rg0BIABBDGoqAgAhASAAQQhqKgIAIQIgAEEEaioCACEDQRBBBBDICyIARQ0CIAAgATgCDCAAIAI4AgggACADOAIEIABBADYCACAADwsQogwACxCjDAALQRBBBEHQnsMAKAIAIgBBvwYgABsRAAAAC4IBAQN9AkACQCAABEAgACgCAEF/Rg0BIABBDGoqAgAhASAAQQRqKgIAIQIgAEEIaioCACEDQRBBBBDICyIARQ0CIAAgATgCDCAAIAI4AgggACADOAIEIABBADYCACAADwsQogwACxCjDAALQRBBBEHQnsMAKAIAIgBBvwYgABsRAAAAC4IBAQN9AkACQCAABEAgACgCAEF/Rg0BIABBCGoqAgAhASAAQQRqKgIAIQIgAEEMaioCACEDQRBBBBDICyIARQ0CIAAgATgCDCAAIAI4AgggACADOAIEIABBADYCACAADwsQogwACxCjDAALQRBBBEHQnsMAKAIAIgBBvwYgABsRAAAAC4IBAQN9AkACQCAABEAgACgCAEF/Rg0BIABBCGoqAgAhASAAQQxqKgIAIQIgAEEEaioCACEDQRBBBBDICyIARQ0CIAAgATgCDCAAIAI4AgggACADOAIEIABBADYCACAADwsQogwACxCjDAALQRBBBEHQnsMAKAIAIgBBvwYgABsRAAAAC4IBAQN9AkACQCAABEAgACgCAEF/Rg0BIABBBGoqAgAhASAAQQxqKgIAIQIgAEEIaioCACEDQRBBBBDICyIARQ0CIAAgATgCDCAAIAI4AgggACADOAIEIABBADYCACAADwsQogwACxCjDAALQRBBBEHQnsMAKAIAIgBBvwYgABsRAAAAC4IBAQN9AkACQCAABEAgACgCAEF/Rg0BIABBBGoqAgAhASAAQQhqKgIAIQIgAEEMaioCACEDQRBBBBDICyIARQ0CIAAgATgCDCAAIAI4AgggACADOAIEIABBADYCACAADwsQogwACxCjDAALQRBBBEHQnsMAKAIAIgBBvwYgABsRAAAAC3MAIAFBATYCICABQSRqIAIpAgA3AgAgAUHMAGogAkEoaigCADYCACABQcQAaiACQSBqKQIANwIAIAFBPGogAkEYaikCADcCACABQTRqIAJBEGopAgA3AgAgAUEsaiACQQhqKQIANwIAIAAgAUGYARCeChoLcgEBfyMAQSBrIgIkACACIAAgARCtAiAAQRhqIAJBGGooAgA2AgAgAEEQaiACQRBqKQMANwIAIABBCGogAkEIaikDADcCACAAIAIpAwA3AgAgAEE4akIANwIAIABBMGpCADcCACAAQgA3AiggAkEgaiQAC20BBX0gAioCACIFIAWUQwAAAACSIAIqAggiBiAGlJJDAAAAAJIQqwEiB0MAAAAAXARAIAYgB5UgASoCBCIDlCEEIAUgB5UgA5QhAwsgACAEOAIIIAAgAzgCACAAIAEqAgAgAkEEaioCAJg4AgQLVwECfyAAQQhqIQECQCAAKAIQIgJFDQAgAkEAOgAAIAFBDGooAgBFDQAgACgCEBDaAQsCQCAAQX9GDQAgACAAKAIEIgFBf2o2AgQgAUEBRw0AIAAQ2gELC3cBAX8jAEEQayIDJAACQAJAIAAEQCAAKAIADQEgAEF/NgIAIAMgAEEEaiABEO4GIAMoAgAiAUUNAiABQfAAaiACQQMgAkEDSRs6AAAgAEEANgIAIANBEGokAA8LEKIMAAsQowwAC0Goq8AAQcwAQayswAAQnAkAC3cBAX8jAEEQayIDJAACQAJAIAAEQCAAKAIADQEgAEF/NgIAIAMgAEEEaiABEO4GIAMoAgAiAUUNAiABQfEAaiACQQMgAkEDSRs6AAAgAEEANgIAIANBEGokAA8LEKIMAAsQowwAC0Goq8AAQcwAQayswAAQnAkAC3cBAX8jAEEQayIDJAACQAJAIAAEQCAAKAIADQEgAEF/NgIAIAMgAEEEaiABEO4GIAMoAgAiAUUNAiABQYQBakEAIAIgAkEHSxs2AgAgAEEANgIAIANBEGokAA8LEKIMAAsQowwAC0Goq8AAQcwAQayswAAQnAkAC3cBAX8jAEEQayIDJAACQAJAIAAEQCAAKAIADQEgAEF/NgIAIAMgAEEEaiABEO4GIAMoAgAiAUUNAiABQYgBakEAIAIgAkEDSxs2AgAgAEEANgIAIANBEGokAA8LEKIMAAsQowwAC0Goq8AAQcwAQayswAAQnAkAC3gBAX8jAEEQayIDJAACQAJAIAAEQCAAKAIADQEgAEF/NgIAIAMgAEEEaiABEO4GIAMoAgAiAUUNAiABQYwBakEAIAIgAkHQI3EbOwEAIABBADYCACADQRBqJAAPCxCiDAALEKMMAAtBqKvAAEHMAEGsrMAAEJwJAAtyAQR/IwBBEGsiAiQAAkAgAARAIAAoAgAiAUF/Rg0BIAAgAUEBajYCACAAKAIEIgEoAgghAyACQQhqIgQgAUEMaigCADYCBCAEIAM2AgAgAigCCCAAIAAoAgBBf2o2AgAgAkEQaiQADwsQogwACxCjDAALYAECfyAAEK4GAkAgAEHEAGooAgAiAUUNACAAQUBrKAIAIgJFDQAgAUEMbEUNACACENoBCwJAIABB0ABqKAIAIgFFDQAgAEHMAGooAgAiAEUNACABQQxsRQ0AIAAQ2gELC2ABAn8gABCuBgJAIABBxABqKAIAIgFFDQAgAEFAaygCACICRQ0AIAFBDGxFDQAgAhDaAQsCQCAAQdAAaigCACIBRQ0AIABBzABqKAIAIgBFDQAgAUEDdEUNACAAENoBCwtuAQR9IAQqAgAiBiAGlCAEKgIEIgcgB5SSIAQqAggiBSAFlJJDAAAAAJIiCEMAAIAoXkUEQCAAQQA2AgAPCyAAQQxqIAUgCBCrASIFlTgCACAAQQhqIAcgBZU4AgAgACAGIAWVOAIEIABBATYCAAuEAQEBf0EkQQQQyAsiAkUEQEEkQQRB0J7DACgCACIAQb8GIAAbEQAAAAsgAiABKQIANwIAIAJBIGogAUEgaigCADYCACACQRhqIAFBGGopAgA3AgAgAkEQaiABQRBqKQIANwIAIAJBCGogAUEIaikCADcCACAAQdj9wQA2AgQgACACNgIAC2MBA38jAEGwAWsiASQAAkAgAARAIAAoAgANASAAQQA2AgAgAUHYAGoiAiAAQdQAEJ4KGiABQQhqIgMgAkEEckHQABCeChogABDaASADENgFIAFBsAFqJAAPCxCiDAALEKMMAAtwAQF/IwBBEGsiBCQAAkACQCAABEAgACgCAA0BIABBfzYCACAEIABBBGogARDyBiAEKAIAIgFFDQIgASACIANBAEcQnwogAEEANgIAIARBEGokAA8LEKIMAAsQowwAC0GQqsAAQc0AQZirwAAQnAkAC2sCA38BfQJAAkAgAARAIAAoAgAiAkF/Rg0BIAAgAkEBajYCACAAKAIEIgNBqAFqKAIAIgQgAU0NAiADQaABaigCACABQThsaioCECAAIAI2AgAPCxCiDAALEKMMAAsgASAEQaSuwAAQzwgAC2sCA38BfQJAAkAgAARAIAAoAgAiAkF/Rg0BIAAgAkEBajYCACAAKAIEIgNBqAFqKAIAIgQgAU0NAiADQaABaigCACABQThsaioCFCAAIAI2AgAPCxCiDAALEKMMAAsgASAEQbSuwAAQzwgAC2sAIABCADcCHCAAIAEpAgA3AgAgAEEkakIANwIAIABBLGpCADcCACAAQTRqQgA3AgAgAEE8akEANgIAIABBGGogAUEYaigCADYCACAAQRBqIAFBEGopAgA3AgAgAEEIaiABQQhqKQIANwIAC4ABAgN/An0gACgCCCIBRQRAQ///f38PCyABQSRsIQEgACgCAEEgaiEAQ///f38hBANAIAAoAgAhAiAAQXxqIQMgAEEkaiEAIAQgBCADKAIAIAIoAghBB2pBeHFqIAIoApQBEQoAIgUgBCAFXRsgBSAFXBshBCABQVxqIgENAAsgBAt8AgN/An0gACgCCCIBRQRAQ///f38PCyABQSRsIQEgACgCAEEgaiEAQ///f38hBANAIAAoAgAhAiAAQXxqIABBJGohACgCACACKAIIQQdqQXhxaiACKAKYAREKACIFIAUgBCAEIAVdGyAEIARcGyEEIAFBXGoiAQ0ACyAEC2YBA38gACAAKQMAQgh8NwMAIAEoAghBJGwhAiABKAIAIQEDQCACRQRAQQAPCyAAIAApAwBCLHw3AwAgAkFcaiECIAFBIGohAyABKAIcIAFBJGohASADKAIAIAAQ5QEiA0UNAAsgAwtyAQF/IwBBEGsiAyQAAkACQCAABEAgACgCAA0BIABBfzYCACADIABBBGogARDyBiADKAIAIgFFDQIgAUHlAWogAkEARzoAACAAQQA2AgAgA0EQaiQADwsQogwACxCjDAALQZCqwABBzQBBmKvAABCcCQALbwEBfyMAQRBrIgMkAAJAAkAgAARAIAAoAgANASAAQX82AgAgAyAAQQRqIAEQ8gYgAygCACIBRQ0CIAFBvAFqIAI4AgAgAEEANgIAIANBEGokAA8LEKIMAAsQowwAC0GQqsAAQc0AQZirwAAQnAkAC40BAQF/IwBBEGsiAyQAAkACQCAABEAgACgCAA0BIABBfzYCACADIABBBGogARDuBiADKAIAIgFFDQIgAkEARyICIAEtAJQBQQBHRwRAIAEgAjoAlAEgASABKAIgQSByNgIgCyAAQQA2AgAgA0EQaiQADwsQogwACxCjDAALQairwABBzABBrKzAABCcCQALbwEEfyMAQRBrIgIkAAJAIAAEQCAAKAIAIgFBf0YNASAAIAFBAWo2AgAgACgCBCIBKAIAIQMgAkEIaiIEIAEoAgQ2AgQgBCADNgIAIAIoAgggACAAKAIAQX9qNgIAIAJBEGokAA8LEKIMAAsQowwAC20BA38jAEEQayICJAACQCAABEAgACgCACIBQX9GDQEgACABQQFqNgIAIAAoAgQhASACQQhqIgMgAEEIaigCADYCBCADIAE2AgAgAigCCCAAIAAoAgBBf2o2AgAgAkEQaiQADwsQogwACxCjDAALYQEBfSMAQTBrIgQkACAEQQhqIAEgAUEMaiABQRhqIAIQnQICfyAEKAIYQQRHBEBBASAEKgIIIgUgA19BAXNFDQEaQQAMAQtBAAshASAAIAU4AgQgACABNgIAIARBMGokAAvUAQAgAEL////7////v383AzAgAEL////79///v/8ANwMgIABC////+/f//7//ADcDECAAQv////v3//+//wA3AwggAEL////79///v/8ANwMAIABB2ABqQv////v///+/fzcDACAAQdAAakL////7////v383AwAgAEHIAGpC////+////79/NwMAIABBQGtC////+////79/NwMAIABBOGpC////+////79/NwMAIABBKGpC////+/f//7//ADcDACAAQRhqQv////v3//+//wA3AwALaQECfyMAQSBrIgIkACACIAE2AgRBASEDAkAgACgCACABRg0AQQIhAyAAKAIEIAFGDQBBACEDIAAoAgggAUYNACACQQA2AgggAEEIaiACQQRqIAJBCGpB3NvBABDiCAALIAJBIGokACADC3cBAX8jAEEQayIDJAAgAyAAIAEQ5wcgAygCACIABEACQAJAAkACQCAAKAIYQQFrDgMDAQIACyAAQRxqIAI6AHgMAgsgAEEcaiACOgCZAQwBCyAAQRxqIAI6ALUBCyADQRBqJAAPC0GAqcAAQckAQYCqwAAQnAkAC2ECAn8BfQJAIAAEQCAAKAIAIgJBf0YNASAAIAJBAWo2AgAgACgCBCIDQagBaigCACABSwRAIANBoAFqKAIAIAFBOGxqQQxqKgIAIQQLIAAgAjYCACAEDwsQogwACxCjDAALbAAgASACKQIANwJQIAFB+ABqIAJBKGooAgA2AgAgAUHwAGogAkEgaikCADcCACABQegAaiACQRhqKQIANwIAIAFB4ABqIAJBEGopAgA3AgAgAUHYAGogAkEIaikCADcCACAAIAFBiAEQngoaC2gCAX8EfSMAQRBrIgMkACACKgIAIgUgBZQgAioCBCIGIAaUkiACKgIIIgcgB5SSQwAAAACSEKsBIQQgAyAHIASVOAIIIAMgBiAElTgCBCADIAUgBJU4AgAgACABIAMQkQUgA0EQaiQAC2sBAXxBfwJ/IABDAAAAP5IgAZWOIgAgAkF/arMiASAAIAFdG0MAAAAAIABDAAAAAF4buyIDRAAAAAAAAAAAZiICIANEAAAAAAAA8EFjcQRAIAOrDAELQQALQQAgAhsgA0QAAOD////vQWQbC2kAIABCADcCACAAQgA3AjAgAEIANwJAIABBKGpCADcCACAAQSBqQgA3AgAgAEEYakIANwIAIABBEGpCADcCACAAQQhqQgA3AgAgAEE4akIANwIAIABByABqQgA3AgAgAEHQAGpCADcCAAumAQECfyMAQRBrIgIkACAAKAIAIgAoAgghAyAAKAIAIQAgAiABrUKAgICAEEIAIAEoAhhBlf3CAEEBIAFBHGooAgAoAgwRBQAbhDcDACADBEADQCACIAA2AgwgAiACQQxqELwFIABBAWohACADQX9qIgMNAAsLIAItAAQEf0EBBSACKAIAIgAoAhhBlv3CAEEBIABBHGooAgAoAgwRBQALIAJBEGokAAt4AQN/AkACQAJAIAEoAggiAkEATgRAIAEoAgAhASACDQFBASEDDAILEJYMAAsgAiEEIAJBARDICyIDRQ0BCyADIAEgAhCeCiEBIAAgAjYCCCAAIAQ2AgQgACABNgIADwsgAkEBQdCewwAoAgAiAEG/BiAAGxEAAAALcAEBfyMAQTBrIgIkACACIAE2AgQgAiAANgIAIAJBHGpBAjYCACACQSxqQQI2AgAgAkIDNwIMIAJB/ODCADYCCCACQQI2AiQgAiACQSBqNgIYIAIgAkEEajYCKCACIAI2AiAgAkEIakGw4cIAEOIKAAtwAQF/IwBBMGsiAiQAIAIgATYCBCACIAA2AgAgAkEcakECNgIAIAJBLGpBAjYCACACQgM3AgwgAkHU4cIANgIIIAJBAjYCJCACIAJBIGo2AhggAiACQQRqNgIoIAIgAjYCICACQQhqQbi2wAAQ4goAC20BAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakECNgIAIANCAjcCDCADQdz6wgA2AgggA0ECNgIkIAMgA0EgajYCGCADIAM2AiggAyADQQRqNgIgIANBCGogAhDiCgALbQEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQQI2AgAgA0ICNwIMIANBtIHDADYCCCADQQI2AiQgAyADQSBqNgIYIAMgA0EEajYCKCADIAM2AiAgA0EIaiACEOIKAAttAQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EcakECNgIAIANBLGpBAjYCACADQgI3AgwgA0HUgcMANgIIIANBAjYCJCADIANBIGo2AhggAyADQQRqNgIoIAMgAzYCICADQQhqIAIQ4goAC20BAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakECNgIAIANCAjcCDCADQYiCwwA2AgggA0ECNgIkIAMgA0EgajYCGCADIANBBGo2AiggAyADNgIgIANBCGogAhDiCgALWQEDfyMAQSBrIgIkACABQRxqKAIAIQMgASgCGCACQQhqIgFBEGogAEEQaikCADcDACABQQhqIABBCGopAgA3AwAgAiAAKQIANwMIIAMgARDYAiACQSBqJAALWQEDfyMAQSBrIgIkACAAQRxqKAIAIQMgACgCGCACQQhqIgBBEGogAUEQaikCADcDACAAQQhqIAFBCGopAgA3AwAgAiABKQIANwMIIAMgABDYAiACQSBqJAALXAECfyMAQRBrIgIkAAJAIAAEQCAAKAIAIgNBf0YNASAAIANBAWo2AgAgAiAAQQRqIAEQ5wcgAigCACAAIAAoAgBBf2o2AgAgAkEQaiQAQQBHDwsQogwACxCjDAALbAEBfyMAQRBrIgMkAAJAAkAgAARAIAAoAgANASAAQX82AgAgAyAAQQRqIAEQ8gYgAygCACIBRQ0CIAEgAjoAlQIgAEEANgIAIANBEGokAA8LEKIMAAsQowwAC0GQqsAAQc0AQZirwAAQnAkAC2kBAX8jAEEQayICJAACQAJAIAAEQCAAKAIADQEgAEF/NgIAIAIgAEEEaiABEPIGIAIoAgAiAUUNAiABELYJIABBADYCACACQRBqJAAPCxCiDAALEKMMAAtBkKrAAEHNAEGYq8AAEJwJAAtsAQF/IwBBEGsiAyQAAkACQCAABEAgACgCAA0BIABBfzYCACADIABBBGogARDyBiADKAIAIgFFDQIgASACOAK4ASAAQQA2AgAgA0EQaiQADwsQogwACxCjDAALQZCqwABBzQBBmKvAABCcCQALXAECfyMAQRBrIgIkAAJAIAAEQCAAKAIAIgNBf0YNASAAIANBAWo2AgAgAiAAQQRqIAEQtwkgAigCACAAIAAoAgBBf2o2AgAgAkEQaiQAQQBHDwsQogwACxCjDAALbwEBfyMAQRBrIgMkAAJAAkAgAARAIAAoAgANASAAQX82AgAgAyAAQQRqIAEQ7gYgAygCACIBRQ0CIAFB7ABqIAI4AgAgAEEANgIAIANBEGokAA8LEKIMAAsQowwAC0Goq8AAQcwAQayswAAQnAkAC2sBAX8jAEEQayIDJAACQAJAIAAEQCAAKAIADQEgAEF/NgIAIAMgAEEEaiABEO4GIAMoAgAiAUUNAiABIAI4AmggAEEANgIAIANBEGokAA8LEKIMAAsQowwAC0Goq8AAQcwAQayswAAQnAkAC1wBAn8jAEEQayICJAACQCAABEAgACgCACIDQX9GDQEgACADQQFqNgIAIAIgAEEEaiABELgJIAIoAgAgACAAKAIAQX9qNgIAIAJBEGokAEEARw8LEKIMAAsQowwAC2UBAX8jAEEgayIEJAAgBCABNgIEIAQgADYCACAEQQhqIgBBEGogAkEQaikCADcDACAAQQhqIAJBCGopAgA3AwAgBCACKQIANwMIQQAgBEG8vsAAIARBBGpBvL7AACAAIAMQugQAC2sBAX8jAEEgayICJAAgAkHMwcAANgIEIAIgADYCACACQQhqIgBBEGogAUEQaikCADcDACAAQQhqIAFBCGopAgA3AwAgAiABKQIANwMIQQEgAkHcvMAAIAJBBGpB3LzAACAAQcCVwQAQugQAC2sBAX8jAEEgayICJAAgAkHIjMEANgIEIAIgADYCACACQQhqIgBBEGogAUEQaikCADcDACAAQQhqIAFBCGopAgA3AwAgAiABKQIANwMIQQAgAkHMvsAAIAJBBGpBzL7AACAAQcyMwQAQugQAC2UBAX8jAEEgayIFJAAgBSACNgIEIAUgATYCACAFQQhqIgFBEGogA0EQaikCADcDACABQQhqIANBCGopAgA3AwAgBSADKQIANwMIIAAgBUHcvsAAIAVBBGpB3L7AACABIAQQugQAC1UBAn8CQCAAQQRqKAIAIgFFDQAgACgCACICRQ0AIAFBAnRFDQAgAhDaAQsCQCAAQShqKAIAIgFFDQAgAEEkaigCACIARQ0AIAFBAnRFDQAgABDaAQsLZQEBfyMAQSBrIgQkACAEIAE2AgQgBCAANgIAIARBCGoiAEEQaiACQRBqKQIANwMAIABBCGogAkEIaikCADcDACAEIAIpAgA3AwhBACAEQai2wQAgBEEEakGotsEAIAAgAxC6BAALWwECfyMAQSBrIgIkACACQQhqIgMgAUH0t8EAQQAQwgogAiAANgIYIAIgAEEEajYCHCADIAJBGGpBqLbBABCJBSADIAJBHGpBqLbBABCJBSADEMkHIAJBIGokAAtuAQJ9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IABBCGooAgAhAiAAKAIEIQEgABDaASABIAEoAgAiAEF/ajYCACAAQQFGBEAgASACEPcHCw8LEKIMAAsQowwAC24BBH8jAEEQayIEJAAgBEEIaiAAIAEgAiADENoJIAQoAgwhBiAEKAIIIQdBDEEEEMgLIgVFBEBBDEEEQdCewwAoAgAiBEG/BiAEGxEAAAALIAUgBjYCCCAFIAc2AgQgBUEANgIAIARBEGokACAFC04BAX8jAEEwayIDJAAgA0EIaiAAIABBDGogAEEYaiABEJ0CAn8gAygCGEEERwRAQQAgAyoCCCACX0EBcw0BGkEBDAELQQALIANBMGokAAtlAQF/IABBADYCJCAAQgA3AgQgAEE4akIANwIAIABBmMDAACgCACIBNgI0IABBLGpCADcCACAAIAE2AiggAEEcakIANwIAIAAgATYCGCAAQRBqQgA3AgAgACABNgIMIAAgATYCAAtXAQF/An9BACABQUBrKAIAIAJNDQAaIAEoAjggAkEMbGooAgQhA0EBCyECIAAgAzYCBCAAIAI2AgAgAEE8akECOgAAIABBIGpBAjoAACAAQQhqIAE2AgALWwEBfyMAQSBrIgMkACADIAEgAhDjAiAAQQhqIANBCGopAwA3AgAgACADKQMANwIAIABBFGpBACADQRRqKAIAIAMoAhAiARs2AgAgACABQQBHNgIQIANBIGokAAthAAJAIAEgA3wiAyABVA0AAkAgAiAEaiICQYCU69wDSQRAIAMhAQwBCyADQgF8IgEgA1QNASACQYDslKN8aiECCyAAIAI2AgggACABNwMADwtBgNbCAEEoQajWwgAQnAkAC2wBBH8jAEEQayIDJAAgA0EIaiAAIAEgAhCICiADKAIMIQUgAygCCCEGQQxBBBDICyIERQRAQQxBBEHQnsMAKAIAIgNBvwYgAxsRAAAACyAEIAU2AgggBCAGNgIEIARBADYCACADQRBqJAAgBAtsAQR/IwBBEGsiAyQAIANBCGogACABIAIQhAkgAygCDCEFIAMoAgghBkEMQQQQyAsiBEUEQEEMQQRB0J7DACgCACIDQb8GIAMbEQAAAAsgBCAFNgIIIAQgBjYCBCAEQQA2AgAgA0EQaiQAIAQLbAEEfyMAQRBrIgMkACADQQhqIAAgASACEIcKIAMoAgwhBSADKAIIIQZBDEEEEMgL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Gwt+AQF/IwBBEGsiBSQAIAEoAgAgAigCACADKAIAIAQoAgAQCiEBQZiYwwAoAgAhAkGcmMMAKAIAIQNBmJjDAEIANwIAIAVBCGoiBCADNgIEIAQgAkEBRjYCACAAIAUoAggiAkEARzYCACAAIAUoAgwgASACGzYCBCAFQRBqJAALSwECfyAAQQRqKAIAIABBCGoiBCgCACIDayACSQRAIAAgAyACEJ8GIAQoAgAhAwsgACgCACADaiABIAIQngoaIAQgAiADajYCAEEAC18BAn8jAEHQAGsiACQAIABBCGoQjQpByABBBBDICyIBRQRAQcgAQQRB0J7DACgCACIAQb8GIAAbEQAAAAsgAUEANgIAIAFBBGogAEEIakHEABCeChogAEHQAGokACABC18BAn8jAEHwAGsiACQAIABBCGoQiQdB6ABBBBDICyIBRQRAQegAQQRB0J7DACgCACIAQb8GIAAbEQAAAAsgAUEANgIAIAFBBGogAEEIakHkABCeChogAEHwAGokACABC0YBAX8CQCAABEAgACgCACICQX9GDQEgACACQQFqNgIAIABBBGogARCYBiAAIAAoAgBBf2o2AgBB/wFxDwsQogwACxCjDAALXwECfyMAQdAAayIAJAAgAEEIahCoBkHIAEEEEMgLIgFFBEBByABBBEHQnsMAKAIAIgBBvwYgABsRAAAACyABQQA2AgAgAUEEaiAAQQhqQcQAEJ4KGiAAQdAAaiQAIAELQwEBfSAAQYwCai0AAARAIAAgACgCkAJBBHI2ApACCyAAQQA6AIwCIABBiAJqKgIAGiAAIAAqAoQCiyIBIAGSOAKIAgtMAAJAIAEoAgggAksEQCABKAIAIAJBoAJsaiIBKAIAQQFGDQELIABBADYCAA8LIAAgAjYCBCAAQQhqIAEoAgQ2AgAgACABQQhqNgIAC0wAAkAgASgCCCACSwRAIAEoAgAgAkGgAWxqIgEoAgBBAUYNAQsgAEEANgIADwsgACACNgIEIABBCGogASgCBDYCACAAIAFBCGo2AgALUQEBfyMAQSBrIgEkACABQRRqQQE2AgAgAUICNwIEIAFBqMXBADYCACABQQI2AhwgAUG4xcEANgIYIAEgAUEYajYCECAAIAEQ1AggAUEgaiQAC04BAX1DAAAAACABKgIAIgMgA5QgAUEEaioCACIDIAOUkiABQQhqKgIAIgMgA5SSQwAAAACSEKsBIAAqAgCTIgMgAhsgAyADQwAAAABdGwtkAQF/QRhBBBDICyICRQRAQRhBBEHQnsMAKAIAIgBBvwYgABsRAAAACyACIAEpAgA3AgAgAkEQaiABQRBqKQIANwIAIAJBCGogAUEIaikCADcCACAAQYj0wQA2AgQgACACNgIAC1AAIAAgASoCFCAClDgCFCAAIAEqAhAgApQ4AhAgACABKgIMIAKUOAIMIAAgASoCCCAClDgCCCAAIAEqAgQgApQ4AgQgACABKgIAIAKUOAIAC2cBA30gAUEEaioCACECIAEqAgghAyABKgIAIQRBDEEEEMgLIgFFBEBBDEEEQdCewwAoAgAiAEG/BiAAGxEAAAALIAEgAzgCCCABIAI4AgQgASAEOAIAIABB1KrCADYCBCAAIAE2AgALZwEDfSABQQRqKgIAIQIgASoCCCEDIAEqAgAhBEEMQQQQyAsiAUUEQEEMQQRB0J7DACgCACIAQb8GIAAbEQAAAAsgASADOAIIIAEgAjgCBCABIAQ4AgAgAEHEr8IANgIEIAAgATYCAAt5AQJ/IwBBEGsiBCQAIAEoAgAgAigCACADKAIAEAkhAUGYmMMAKAIAIQJBnJjDACgCACEDQZiYwwBCADcCACAEQQhqIgUgAzYCBCAFIAJBAUY2AgAgACAEKAIIIgJBAEc2AgAgACAEKAIMIAEgAhs2AgQgBEEQaiQAC0sBAX0gACoCDCAAKgIAkyIBIAGUIABBEGoqAgAgACoCBJMiASABlJIgAEEUaioCACAAKgIIkyIBIAGUkkMAAAAAkhCrAUMAAAA/lAtLAAJAAn8gAUGAgMQARwRAQQEgACgCGCABIABBHGooAgAoAhARAwANARoLIAINAUEACw8LIAAoAhggAiADIABBHGooAgAoAgwRBQALSQACQAJAIAAEQCAAKAIADQEgAEF/NgIAIAJBBE8NAiAAQQRqIAEgAhDFCCAAQQA2AgAPCxCiDAALEKMMAAtBwazAAEEZEKEMAAtRACAAQgA3AhAgAEKAgICAgICAwD83AgggAEIANwIAIABBGGpCADcCACAAQSBqQgA3AgAgAEEoakIANwIAIABBMGpCADcCACAAQThqQgA3AgALSAEBfUMAAAAAIAAqAgAgASoCAJQgAEEEaioCACABQQRqKgIAlJIgAEEIaioCACABQQhqKgIAlJIiAyACGyADIANDAAAAAF0bC2QCAX8BfSABKgIMIQNBEEEEEMgLIgJFBEBBEEEEQdCewwAoAgAiAEG/BiAAGxEAAAALIAIgAzgCDCACIAEpAgA3AgAgAkEIaiABQQhqKAIANgIAIABB5KXCADYCBCAAIAI2AgALQAEBfwJAIAAEQCAAKAIAIgFBf0YNASAAIAFBAWo2AgAgAEFAaygCACAAIAAoAgBBf2o2AgAPCxCiDAALEKMMAAtAAQF/AkAgAARAIAAoAgAiAUF/Rg0BIAAgAUEBajYCACAAQRxqKAIAIAAgACgCAEF/ajYCAA8LEKIMAAsQowwAC0QBAX8CQCAABEAgACgCACIDQX9GDQEgACADQQFqNgIAIABBBGogASACEOsBIAAgACgCAEF/ajYCAA8LEKIMAAsQowwAC0QBAX8CQCAABEAgACgCACIDQX9GDQEgACADQQFqNgIAIABBBGogASACENYBIAAgACgCAEF/ajYCAA8LEKIMAAsQowwAC0cAIAEgAikCADcCECABQShqIAJBGGooAgA2AgAgAUEgaiACQRBqKQIANwIAIAFBGGogAkEIaikCADcCACAAIAFBiAEQngoaC0oAIAEgAikCADcCWCABQfAAaiACQRhqKAIANgIAIAFB6ABqIAJBEGopAgA3AgAgAUHgAGogAkEIaikCADcCACAAIAFBmAEQngoaC3QBA38jAEEQayIDJAAgASgCACACKAIAEAYhAUGYmMMAKAIAIQJBnJjDACgCACEEQZiYwwBCADcCACADQQhqIgUgBDYCBCAFIAJBAUY2AgAgACADKAIIIgJBAEc2AgAgACADKAIMIAEgAhs2AgQgA0EQaiQAC0gBAX0gACACQRhqKgIAIAMqAgggASoCACIElJI4AgggACACQRRqKgIAIAQgAyoCBJSSOAIEIAAgAioCECAEIAMqAgCUkjgCAAtcACAAIAEoAghB/////wdxIAIoAghBgICAgHhxcjYCCCAAIAEoAgRB/////wdxIAIoAgRBgICAgHhxcjYCBCAAIAEoAgBB/////wdxIAIoAgBBgICAgHhxcjYCAAthAQF/IwBB4ABrIgIkACACIAEQrwFB4ABBBBDICyIBRQRAQeAAQQRB0J7DACgCACIAQb8GIAAbEQAAAAsgASACQeAAEJ4KIQEgAEGEi8IANgIEIAAgATYCACACQeAAaiQAC1kBAn8jAEHQAGsiACQAIAAQ8QZB1ABBBBDICyIBRQRAQdQAQQRB0J7DACgCACIAQb8GIAAbEQAAAAsgAUEANgIAIAFBBGogAEHQABCeChogAEHQAGokACABC1kBAn8jAEHQAGsiACQAIAAQ8wZB1ABBBBDICyIBRQRAQdQAQQRB0J7DACgCACIAQb8GIAAbEQAAAAsgAUEANgIAIAFBBGogAEHQABCeChogAEHQAGokACABC00BAX8gAEIANwIEIABBKGpCADcCACAAQdC5wQAoAgAiATYCJCAAQRxqQgA3AgAgACABNgIYIABBEGpCADcCACAAIAE2AgwgACABNgIAC0YBAX0gACABKgIAIgIgApQgAUEEaioCACICIAKUkiABQQhqKgIAIgIgApSSQwAAAACSEKsBOAIMIABBADYCCCAAQgA3AgALPwACQCAABEAgACgCAA0BIABBfzYCACAAQQRqIAEgAiADIAQgBSAGQQBHEIIDIABBADYCAA8LEKIMAAsQowwACz0BAn8CQCAABEAgACgCACIBQX9GDQEgACABQQFqNgIAIAAoAgRBGGooAgAgACABNgIADwsQogwACxCjDAALPQECfwJAIAAEQCAAKAIAIgFBf0YNASAAIAFBAWo2AgAgACgCBEEIaigCACAAIAE2AgAPCxCiDAALEKMMAAs+AQJ/AkAgAARAIAAoAgAiAUF/Rg0BIAAgAUEBajYCACAAKAIEQagBaigCACAAIAE2AgAPCxCiDAALEKMMAAtBACAAKAIIIAFLBEAgACgCACABQSRsaiIAQSBqKAIAIQEgAiAAIAAoAhwgASgCCEEHakF4cWogASADKAIQEQIACwtGAQN9IABBFGogASoCCCICOAIAIABBEGogASoCBCIDOAIAIAAgASoCACIEOAIMIAAgAow4AgggACADjDgCBCAAIASMOAIAC2EBAX9BGEEEEMgLIgVFBEBBGEEEQdCewwAoAgAiAEG/BiAAGxEAAAALIAUgBDgCFCAFIAM4AhAgBSACOAIMIAUgATgCCCAFQoGAgIAQNwIAIABB5KXCADYCBCAAIAU2AgALSAEBfyMAQSBrIgMkACADQRRqQQA2AgAgA0GE+cIANgIQIANCATcCBCADIAE2AhwgAyAANgIYIAMgA0EYajYCACADIAIQ4goACz0BAn8jAEEwayIEJAAgBEEIaiIFIAEgAiADEEcgAEEIaiAFQQhqKQMANwIAIAAgBCkDCDcCACAEQTBqJAALRAAgACAEOAJEIAAgAzgCQCAAIAIpAgA3AiQgACABKQIANwIwIABBLGogAkEIaigCADYCACAAQThqIAFBCGopAgA3AgALOwEBfwJAIAAoAgggAU0NACAAKAIAIAFBoAJsaiIAKAIAQQFHDQAgAEEIakEAIAAoAgQgAkYbIQMLIAMLQwEBfyAAQfgAaiEDAkAgASAAQfQAaigCAEYEQCADKAIAIAJGDQELIAAgATYCdCADIAI2AgAgACAAKAIgQQhyNgIgCwtDAQF/IABBgAFqIQMCQCABIABB/ABqKAIARgRAIAMoAgAgAkYNAQsgACABNgJ8IAMgAjYCACAAIAAoAiBBCHI2AiALCz0BAn8jAEEwayIEJAAgBEEIaiIFIAEgAiADEE0gAEEIaiAFQQhqKQMANwIAIAAgBCkDCDcCACAEQTBqJAALSwIBfwF+IwBBEGsiAiQAIAJBCGogACABKAJYEQAAIAIoAggiACACKAIMKAIMEQQAIQMgAkEQaiQAIABBACADQs/jrOPb7N7WMVEbC0wCAX8BfiMAQRBrIgIkACACQQhqIAAgASgCWBEAACACKAIIIgAgAigCDCgCDBEEACEDIAJBEGokACAAQQAgA0KWmveL7r+BsqV/URsLTAIBfwF+IwBBEGsiAiQAIAJBCGogACABKAJYEQAAIAIoAggiACACKAIMKAIMEQQAIQMgAkEQaiQAIABBACADQvu0o92VhrKQvH9RGwtMAgF/AX4jAEEQayICJAAgAkEIaiAAIAEoAlgRAAAgAigCCCIAIAIoAgwoAgwRBAAhAyACQRBqJAAgAEEAIANCpJ/v1+f1v6SGf1EbC0sCAX8BfiMAQRBrIgIkACACQQhqIAAgASgCWBEAACACKAIIIgAgAigCDCgCDBEEACEDIAJBEGokACAAQQAgA0KnkoqKk5GFsRZRGwtLAgF/AX4jAEEQayICJAAgAkEIaiAAIAEoAlgRAAAgAigCCCIAIAIoAgwoAgwRBAAhAyACQRBqJAAgAEEAIANC+5WjmtKZ2rBpURsLSwIBfwF+IwBBEGsiAiQAIAJBCGogACABKAJYEQAAIAIoAggiACACKAIMKAIMEQQAIQMgAkEQaiQAIABBACADQvWrmYrDrtuUa1EbC0sCAX8BfiMAQRBrIgIkACACQQhqIAAgASgCWBEAACACKAIIIgAgAigCDCgCDBEEACEDIAJBEGokACAAQQAgA0KY25OxvdiSkBxRGwtMAgF/AX4jAEEQayICJAAgAkEIaiAAIAEoAlgRAAAgAigCCCIAIAIoAgwoAgwRBAAhAyACQRBqJAAgAEEAIANC58qLobLo4MOnf1EbC0sCAX8BfiMAQRBrIgIkACACQQhqIAAgASgCWBEAACACKAIIIgAgAigCDCgCDBEEACEDIAJBEGokACAAQQAgA0LPkvCjufCfqntRGwtMAgF/AX4jAEEQayICJAAgAkEIaiAAIAEoAlgRAAAgAigCCCIAIAIoAgwoAgwRBAAhAyACQRBqJAAgAEEAIANC8+iDy4Ph68epf1EbC0wCAX8BfiMAQRBrIgIkACACQQhqIAAgASgCWBEAACACKAIIIgAgAigCDCgCDBEEACEDIAJBEGokACAAQQAgA0Kc1bPn4dLYj/8AURsLSwIBfwF+IwBBEGsiAiQAIAJBCGogACABKAJYEQAAIAIoAggiACACKAIMKAIMEQQAIQMgAkEQaiQAIABBACADQpXB+qLnpp/zUFEbC1kBAn0gAUEEaioCACECIAEqAgAhA0EIQQQQyAsiAUUEQEEIQQRB0J7DACgCACIAQb8GIAAbEQAAAAsgASACOAIEIAEgAzgCACAAQfiNwgA2AgQgACABNgIAC1kBAn0gAUEEaioCACECIAEqAgAhA0EIQQQQyAsiAUUEQEEIQQRB0J7DACgCACIAQb8GIAAbEQAAAAsgASACOAIEIAEgAzgCACAAQeyQwgA2AgQgACABNgIACzoBAn8CQCAABEAgACgCACIBQX9GDQEgACABQQFqNgIAIAAoAgQoAiQgACABNgIADwsQogwACxCjDAALSgAgAEIANwIQIABCADcCsAEgAEKCgICAMDcCCCAAQoCAgIAQNwIAIABBGGpBADYCACAAQbgBakIANwIAIABBHGpBAEGUARDkChoLOwEBfSABKgIAIgIgApQgAUEEaioCACICIAKUkiABQQhqKgIAIgIgApSSQwAAAACSIAAqAgAiAiAClF8LPwEBfyMAQSBrIgUkACAFQQhqIAEgAiADIAQQ1wEgBSgCGCEBIAAgBSoCCDgCBCAAIAFBBEc2AgAgBUEgaiQACz8BAX8jAEEgayIFJAAgBUEIaiABIAIgAyAEEOYBIAUoAhghASAAIAUqAgg4AgQgACABQQRHNgIAIAVBIGokAAs/AQF/IwBBIGsiBSQAIAVBCGogASACIAMgBBCVASAFKAIYIQEgACAFKgIIOAIEIAAgAUEERzYCACAFQSBqJAALPwEBfyMAQSBrIgUkACAFQQhqIAEgAiADIAQQgQIgBSgCGCEBIAAgBSoCCDgCBCAAIAFBBEc2AgAgBUEgaiQACz8BAX8jAEEgayIFJAAgBUEIaiABIAIgAyAEEP8BIAUoAhghASAAIAUqAgg4AgQgACABQQRHNgIAIAVBIGokAAs/AQF/IwBBIGsiBSQAIAVBCGogASACIAMgBBDKASAFKAIYIQEgACAFKgIIOAIEIAAgAUEERzYCACAFQSBqJAALPwEBfyMAQSBrIgUkACAFQQhqIAEgAiADIAQQ9wEgBSgCGCEBIAAgBSoCCDgCBCAAIAFBBEc2AgAgBUEgaiQACz8BAX8jAEEgayIFJAAgBUEIaiABIAIgAyAEEMABIAUoAhghASAAIAUqAgg4AgQgACABQQRHNgIAIAVBIGokAAs/AQF/IwBBIGsiBSQAIAVBCGogASACIAMgBBDRASAFKAIYIQEgACAFKgIIOAIEIAAgAUEERzYCACAFQSBqJAALPwEBfyMAQSBrIgUkACAFQQhqIAEgAiADIAQQ6QEgBSgCGCEBIAAgBSoCCDgCBCAAIAFBBEc2AgAgBUEgaiQACz8BAX8jAEEgayIFJAAgBUEIaiABIAIgAyAEEIYCIAUoAhghASAAIAUqAgg4AgQgACABQQRHNgIAIAVBIGokAAs6AAJAIAAEQCAAKAIADQEgAEF/NgIAIABBBGogASACIAMgBCAFEPAEIABBADYCAA8LEKIMAAsQowwACzoAAkAgAARAIAAoAgANASAAQX82AgAgAEEEaiABIAIgAyAEIAUQ8QQgAEEANgIADwsQogwACxCjDAALOgACQCAABEAgACgCAA0BIABBfzYCACAAQQRqIAEgAiADIAQgBRDyBCAAQQA2AgAPCxCiDAALEKMMAAs/ACAAQgA3AgAgAEEgakIANwIAIABBGGpCADcCACAAQRBqQgA3AgAgAEEIakIANwIAIABBKGpBgICA/AM2AgALQAACQCAAKAK8ASABTwRAIAFBBEkNASABQQRB+OLBABDPCAALQYy9wQBBFEHo4sEAEP4KAAsgAUEkbCAAakEgagtUAQF/QQxBBBDICyICRQRAQQxBBEHQnsMAKAIAIgBBvwYgABsRAAAACyACIAEpAgA3AgAgAkEIaiABQQhqKAIANgIAIABB8PfBADYCBCAAIAI2AgALPwAgAEIANwIAIABBIGpCADcCACAAQRhqQgA3AgAgAEEQakIANwIAIABBCGpCADcCACAAQShqQYCAgPwDNgIAC1QBAX9BDEEEEMgLIgJFBEBBDEEEQdCewwAoAgAiAEG/BiAAGxEAAAALIAIgASkCADcCACACQQhqIAFBCGooAgA2AgAgAEH4lMIANgIEIAAgAjYCAAtaAQF/QRRBBBDICyIERQRAQRRBBEHQnsMAKAIAIgBBvwYgABsRAAAACyAEIAM4AhAgBCACOAIMIAQgATgCCCAEQoGAgIAQNwIAIABBxK/CADYCBCAAIAQ2AgALWgEBf0EUQQQQyAsiBEUEQEEUQQRB0J7DACgCACIAQb8GIAAbEQAAAAsgBCADOAIQIAQgAjgCDCAEIAE4AgggBEKBgICAEDcCACAAQfD3wQA2AgQgACAENgIAC1YBAn8gASgCBCECIAEoAgAhA0EIQQQQyAsiAUUEQEEIQQRB0J7DACgCACIAQb8GIAAbEQAAAAsgASACNgIEIAEgAzYCACAAQYjYwgA2AgQgACABNgIACz0CAX8BfSABKAIAQQFxIQIgACoCACEDIAEoAhBBAUYEQCABIAMgAiABQRRqKAIAEM4BDwsgASADIAIQ8AELPQIBfwF8IAEoAgBBAXEhAiAAKwMAIQMgASgCEEEBRgRAIAEgAyACIAFBFGooAgAQzAEPCyABIAMgAhDuAQs3AQF/IAAoAgAiAUEkTwRAIAEQAAsgACgCBCIBQSRPBEAgARAACyAAKAIIIgBBJE8EQCAAEAALC3gAIABBATYCQCAAQoGAgICAEDcCOCAAQs2Zs/LDADcCMCAAQu+kjNTTmbOmPjcCKCAAQoquj93zzcSBOzcCICAAQoCAgPwDNwIYIABCgICA/IOAgJDBADcCECAAQs2Zs/LTmbOmPjcCCCAAQomRouTz57CXOTcCAAs/AQJ/IwBBEGsiASQAEKsEIgBFBEBB6K7BAEHGACABQQhqQZCwwQBBgLDBABCbCAALIAAoAgAQCCABQRBqJAALNwAgACoCACABKgIAlCAAQQRqKgIAIAFBBGoqAgCUkiAAQQhqKgIAIAFBCGoqAgCUkkMAAAAAXws5AQF/IAFBEHZAACECIABBADYCCCAAQQAgAUGAgHxxIAJBf0YiARs2AgQgAEEAIAJBEHQgARs2AgALVAEBf0EFQQEQyAsiAUUEQEEFQQFB0J7DACgCACIAQb8GIAAbEQAAAAsgAUEEakHArMAALQAAOgAAIAFBvKzAACgAADYAACAAQQU2AgQgACABNgIAC04BAX9BFEEEEMgLIgRFBEBBFEEEQdCewwAoAgAiBEG/BiAEGxEAAAALIAQgAzgCECAEIAI4AgwgBCABOAIIIAQgADgCBCAEQQA2AgAgBAs7ACAAQgA3AiQgACADOAJEIAAgAjgCQCAAIAEpAgA3AjAgAEEsakEANgIAIABBOGogAUEIaikCADcCAAszACABIAEtAH1B8QFxQQBBBCADG0EAQQIgAhtyQQBBCCAEG3JyOgB9IAAgAUGIARCeChoLOAAgACgCJEEBRgRAIABBQGsgASkCADcCACAAIAAoAiBBAnI2AiAgAEHIAGogAUEIaigCADYCAAsLOQEBfyMAQRBrIgIkACACIAEoAgAQFyACKAIAIQEgACACKwMIOQMIIAAgAUEAR603AwAgAkEQaiQACzwBAX0gAEEUaiABKgIAIgI4AgAgAEEQaiACOAIAIAAgAjgCDCAAIAKMIgI4AgggACACOAIEIAAgAjgCAAteAQN/IwBBEGsiASQAIAAoAgwiAkUEQEGg0sIAQStBsNfCABDbCQALIAAoAggiA0UEQEGg0sIAQStBwNfCABDbCQALIAEgAjYCCCABIAA2AgQgASADNgIAIAEQ4QoACzUAIwBBIGsiAyQAIAMgASACEOMCIABBCGogA0EIaikDADcCACAAIAMpAwA3AgAgA0EgaiQACzcBAX8jAEEQayIDJAAgA0EIaiACQQhqKAIANgIAIAMgAikCADcDACAAIAEgAxDQASADQRBqJAALUAECfSAAKgIEIAAqAgAQsAwiAUMAAAAAYEEBc0UEQEPbD8k/IAGTIgIgAiABIAGSIgEgAiABXRsgASABXBsPC0GgksIAQShBqJPCABDbCQALNwEBfyMAQRBrIgMkACADQQhqIAFBCGooAgA2AgAgAyABKQIANwMAIAIgACADENABIANBEGokAAtTAQF/QRBBBBDICyIDRQRAQRBBBEHQnsMAKAIAIgBBvwYgABsRAAAACyADIAI4AgwgAyABOAIIIANCgYCAgBA3AgAgAEHskMIANgIEIAAgAzYCAAszAQF/IAIEQCAAIQMDQCADIAEtAAA6AAAgAUEBaiEBIANBAWohAyACQX9qIgINAAsLIAALOAACQCAAQYwCai0AAEUNACACRQ0AIABBADoAjAIgACAAKAKQAkEEcjYCkAILIABB2AFqIAE4AgALOAEBfyAAQQxqQQA2AgAgACABKAIAIgI2AgQgACABKAIYNgIAIABBCGogASgCCEGgAmwgAmo2AgALVwEDfyMAQRBrIgIkACACQQhqIgMgAUEQaiIBQQRqKAIAIgQ2AgQgAyABKAIAIAQoAghBB2pBeHFqNgIAIAAgAigCCDYCACAAIAIoAgw2AgQgAkEQaiQACzgBAX8gAEEMakEANgIAIAAgASgCACICNgIEIAAgASgCGDYCACAAQQhqIAEoAghBoAFsIAJqNgIACysAAkAgAEF8Sw0AIABFBEBBBA8LIAAgAEF9SUECdBDICyIARQ0AIAAPCwALNgAgACABKQIANwIAIAAgAikCADcCDCAAQQhqIAFBCGooAgA2AgAgAEEUaiACQQhqKAIANgIACzEBAX8gAC4BACIAQX9KIQIgAK1C//8DgyAAQX9zrUIwhkIwh0IBfCACGyACIAEQ7QQLRwEBf0EQQQQQyAsiA0UEQEEQQQRB0J7DACgCACIDQb8GIAMbEQAAAAsgAyACOAIMIAMgATgCCCADIAA4AgQgA0EANgIAIAMLNgAgAEIANwOgASAAQYwCakEBOgAAIABBiAJqQQA2AgAgAEGoAWpCADcDACAAQbABakIANwMACyoBAn8QGyICEA0iAyAAIAEQEyACQSRPBEAgAhAACyADQSRPBEAgAxAACwssAQF/IwBBIGsiAyQAIANBCGogACABIAJBARDAASADKAIYIANBIGokAEEERwsrAQF/IwBBEGsiAyQAIANBCGogACABIAJBARBlIAMoAgggA0EQaiQAQQFGCywBAX8jAEEgayIDJAAgA0EIaiAAIAEgAkEBEIYCIAMoAhggA0EgaiQAQQRHCysBAX8jAEEQayIDJAAgA0EIaiAAIAEgAkEBEFcgAygCCCADQRBqJABBAUYLLAEBfyMAQSBrIgMkACADQQhqIAAgASACQQEQ6QEgAygCGCADQSBqJABBBEcLKwEBfyMAQRBrIgMkACADQQhqIAAgASACQQEQbCADKAIIIANBEGokAEEBRgssAQF/IwBBIGsiAyQAIANBCGogACABIAJBARCVASADKAIYIANBIGokAEEERwssAQF/IwBBIGsiAyQAIANBCGogACABIAJBARDKASADKAIYIANBIGokAEEERwssAQF/IwBBIGsiAyQAIANBCGogACABIAJBARDmASADKAIYIANBIGokAEEERwssAQF/IwBBIGsiAyQAIANBCGogACABIAJBARDXASADKAIYIANBIGokAEEERwssAQF/IwBBIGsiAyQAIANBCGogACABIAJBARCBAiADKAIYIANBIGokAEEERwssAQF/IwBBIGsiAyQAIANBCGogACABIAJBARD/ASADKAIYIANBIGokAEEERwssAQF/IwBBIGsiAyQAIANBCGogACABIAJBARDRASADKAIYIANBIGokAEEERwssAQF/IwBBIGsiAyQAIANBCGogACABIAJBARD3ASADKAIYIANBIGokAEEERwtHAQF/QRRBBBDICyIARQRAQRRBBEHQnsMAKAIAIgBBvwYgABsRAAAACyAAQgA3AgAgAEGAgID8AzYCECAAQQhqQgA3AgAgAAs+ACAAKAIAIQAgAS0AAEEQcUEEdkUEQCABLQAAQSBxQQV2RQRAIAAgARCYDA8LIAAgARC2Bw8LIAAgARC1BwtDACAAKAIAIQAgAS0AAEEQcUEEdkUEQCABLQAAQSBxQQV2RQRAIAAxAABBASABEO0EDwsgACABEKsHDwsgACABEKoHCz4AIAAoAgAhACABLQAAQRBxQQR2RQRAIAEtAABBIHFBBXZFBEAgACABEKUKDwsgACABEKwHDwsgACABEKkHCykBAX8jAEEwayICJAAgAkEIaiAAIAFBARBHIAItABQgAkEwaiQAQQBHCykBAX8jAEEwayICJAAgAkEIaiAAIAFBARBNIAItABQgAkEwaiQAQQBHC0gBAX0gASoCACECQQRBBBDICyIBRQRAQQRBBEHQnsMAKAIAIgBBvwYgABsRAAAACyABIAI4AgAgAEHo58EANgIEIAAgATYCAAsyAQF9IAAgASoCACICIAKUIAFBBGoqAgAiAiAClJIQqwE4AgwgAEEANgIIIABCADcCAAtMAQF/QQxBBBDICyICRQRAQQxBBEHQnsMAKAIAIgBBvwYgABsRAAAACyACIAE4AgggAkKBgICAEDcCACAAQejnwQA2AgQgACACNgIAC0wBAn0gACoCBCAAKgIAELAMIgFDAAAAAGBFBEBBoJLCAEEoQaiTwgAQ2wkAC0PbD8k/IAGTIgIgAiABIAGSIgEgAiABXRsgASABXBsLKwACQCAAIAEQrgQiAUUNACABQXhqLQAEQQNxRQ0AIAFBACAAEOQKGgsgAQs0ACAAIAEoAhggAiADIAFBHGooAgAoAgwRBQA6AAggACABNgIAIAAgA0U6AAkgAEEANgIECysAAkAgAARAIAAoAgANASAAQQA2AgAgAEEMaiABOAIADwsQogwACxCjDAALKwACQCAABEAgACgCAA0BIABBADYCACAAQRBqIAE4AgAPCxCiDAALEKMMAAsrAAJAIAAEQCAAKAIADQEgAEEANgIAIABBFGogATgCAA8LEKIMAAsQowwACysAAkAgAARAIAAoAgANASAAQQA2AgAgAEEkaiABOAIADwsQogwACxCjDAALKwACQCAABEAgACgCAA0BIABBADYCACAAQShqIAE4AgAPCxCiDAALEKMMAAsrAAJAIAAEQCAAKAIADQEgAEEANgIAIABBLGogATgCAA8LEKIMAAsQowwACysAAkAgAARAIAAoAgANASAAQQA2AgAgAEEwaiABOAIADwsQogwACxCjDAALKwACQCAABEAgACgCAA0BIABBADYCACAAQTRqIAE4AgAPCxCiDAALEKMMAAsrAAJAIAAEQCAAKAIADQEgAEEANgIAIABBOGogATYCAA8LEKIMAAsQowwACysAAkAgAARAIAAoAgANASAAQQA2AgAgAEE8aiABNgIADwsQogwACxCjDAALKwACQCAABEAgACgCAA0BIABBADYCACAAQUBrIAE2AgAPCxCiDAALEKMMAAssAAJAIAAEQCAAKAIADQEgAEEANgIAIABBxABqIAE2AgAPCxCiDAALEKMMAAsrAAJAIAAEQCAAKAIADQEgAEEANgIAIABBCGogATgCAA8LEKIMAAsQowwACy0BAn0gACoCDCAAKgIAIgEgACoCBCICIAEgAl8bIgEgACoCCCICIAEgAl8bkgtfAQF/IAAoAgAhAQJAIAAtAAQNAEHgnsMAKAIAQf////8HcUUNAAJ/QdCiwwAoAgBBAUYEQEHUosMAKAIARQwBC0HQosMAQgE3AwBBAQsNACABQQE6AAELIAFBADoAAAtGACMAQRBrIgAkACAAIAGtQoCAgIAQQgAgASgCGEHg08IAQQsgAUEcaigCACgCDBEFABuENwMIIABBCGoQnwggAEEQaiQACzUBAX8jAEEQayICJAAgAiABNgIMIAIgADYCCCACQZDSwgA2AgQgAkHo0cIANgIAIAIQmAoAC0YAIwBBEGsiACQAIAAgAa1CgICAgBBCACABKAIYQajVwgBBCyABQRxqKAIAKAIMEQUAG4Q3AwggAEEIahD9BiAAQRBqJAALLQEBfyMAQRBrIgEkACABQQhqIABBCGooAgA2AgAgASAAKQIANwMAIAEQ+QoACykBAX8CQCAAQX9GDQAgACAAKAIEIgFBf2o2AgQgAUEBRw0AIAAQ2gELCyYAAkAgAARAIAAoAgANASAAQQA2AgAgABDaAQ8LEKIMAAsQowwACy0BAX8jAEEQayIBJAAgAUEIaiAAQQhqKAIANgIAIAEgACkCADcDACABEPwKAAsuACAAQdwAaiABKQIANwIAIAAgACgCIEEEcjYCICAAQeQAaiABQQhqKAIANgIACy0BAX8jAEEQayIBJAAgAUEIaiAAQQhqKAIANgIAIAEgACkCADcDACABEP0KAAssAQF/IwBBEGsiBCQAIAQgACkCADcDCCAEQQhqIAEgAiADEJoBIARBEGokAAswAQF9IAAgAioCCCABKgIAIgOUOAIIIAAgAyACKgIElDgCBCAAIAMgAioCAJQ4AgALLgAgACABKQJYNwIAIABBEGogAUHoAGopAgA3AgAgAEEIaiABQeAAaikCADcCAAssACAAIAEpAgA3AgAgAEEQaiABQRBqKQIANwIAIABBCGogAUEIaikCADcCAAssACAAIAEpAiA3AgAgAEEQaiABQTBqKQIANwIAIABBCGogAUEoaikCADcCAAstAQF/IwBBEGsiASQAIAFBCGogAEEIaigCADYCACABIAApAgA3AwAgARCJCwALLQEBfyMAQRBrIgEkACABQQhqIABBCGooAgA2AgAgASAAKQIANwMAIAEQ0gcACzUBAX8jAEEQayICJAAgAiABNgIMIAIgADYCCCACQZj6wgA2AgQgAkGE+cIANgIAIAIQmAoACzcAIABBAzoAICAAQoCAgICABDcCACAAIAE2AhggAEEANgIQIABBADYCCCAAQRxqQbCWwAA2AgALKQEBfyACBEAgACEDA0AgAyABOgAAIANBAWohAyACQX9qIgINAAsLIAALJQACQCAABEAgACgCAEF/Rg0BIABBDGoqAgAPCxCiDAALEKMMAAslAAJAIAAEQCAAKAIAQX9GDQEgAEEQaioCAA8LEKIMAAsQowwACyUAAkAgAARAIAAoAgBBf0YNASAAQRRqKgIADwsQogwACxCjDAALJQACQCAABEAgACgCAEF/Rg0BIABBJGoqAgAPCxCiDAALEKMMAAslAAJAIAAEQCAAKAIAQX9GDQEgAEEoaioCAA8LEKIMAAsQowwACyUAAkAgAARAIAAoAgBBf0YNASAAQSxqKgIADwsQogwACxCjDAALJQACQCAABEAgACgCAEF/Rg0BIABBMGoqAgAPCxCiDAALEKMMAAslAAJAIAAEQCAAKAIAQX9GDQEgAEE0aioCAA8LEKIMAAsQowwACyUAAkAgAARAIAAoAgBBf0YNASAAQThqKAIADwsQogwACxCjDAALJQACQCAABEAgACgCAEF/Rg0BIABBPGooAgAPCxCiDAALEKMMAAslAAJAIAAEQCAAKAIAQX9GDQEgAEFAaygCAA8LEKIMAAsQowwACyYAAkAgAARAIAAoAgBBf0YNASAAQcQAaigCAA8LEKIMAAsQowwACygAAkAgAARAIAAoAgANASAAQQA2AgAgACABOAIEDwsQogwACxCjDAALJQACQCAABEAgACgCAEF/Rg0BIABBGGotAAAPCxCiDAALEKMMAAslAAJAIAAEQCAAKAIAQX9GDQEgAEEIaioCAA8LEKIMAAsQowwACzwBAX9BEEEEEMgLIgBFBEBBEEEEQdCewwAoAgAiAEG/BiAAGxEAAAALIABCADcCACAAQQhqQgA3AgAgAAs4AAJAIAEtAABBEHFBBHZFBEAgAS0AAEEgcUEFdg0BIAAgARCYDA8LIAAgARC1Bw8LIAAgARC2BwtFAQF/QQhBBBDICyIBRQRAQQhBBEHQnsMAKAIAIgBBvwYgABsRAAAACyABQoGAgIAQNwIAIABBsLTAADYCBCAAIAE2AgALJQEBfyMAQSBrIgIkACACIAAgARDjAiACLQAMIAJBIGokAEEARwskAQF/AkAgAEEEaigCACIBRQ0AIABBCGooAgBFDQAgARDaAQsLLAEBfyMAQRBrIgEkACABIAApAgA3AwggAUEIakGclsAAQQAgACgCCBDFBgALKAEBfyMAQRBrIgMkACADIAI2AgggAyABNgIEIAMgADYCACADENUKAAsoAQF/IwBBEGsiAyQAIAMgAjYCCCADIAE2AgQgAyAANgIAIAMQ2AoACywBAX8jAEEQayIBJAAgASAAKQIANwMIIAFBCGpBtLzAAEEAIAAoAggQxQYACywBAX8jAEEQayIBJAAgASAAKQIANwMIIAFBCGpBpLPBAEEAIAAoAggQxQYACygBAX8jAEEQayIDJAAgAyACNgIIIAMgATYCBCADIAA2AgAgAxDaCgALKQEBfyAAKAIIIgIgAU0EQCABIAJBuLbCABDPCAALIAAoAgAgAUEMbGoLJAEBfyMAQRBrIgIkACACIAAgAUEBEMQCIAItAAwgAkEQaiQACyMBAX8jAEEQayICJAAgAiAAIAFBARAqIAItAAwgAkEQaiQACyMBAX8jAEEQayICJAAgAiAAIAFBARAsIAItAAwgAkEQaiQACyMBAX8jAEEQayICJAAgAiAAIAFBARApIAItAAwgAkEQaiQACyMBAX8jAEEQayICJAAgAiAAIAFBARArIAItAAwgAkEQaiQACyMBAX8jAEEQayICJAAgAiAAIAFBARAnIAItAAwgAkEQaiQACyMBAX8jAEEQayICJAAgAiAAIAFBARAoIAItAAwgAkEQaiQACycBAn0gACoCACIBIAAqAgQiAiABIAJfGyIBIAAqAggiAiABIAJfGwsoAQF/IwBBEGsiAyQAIAMgAjYCCCADIAE2AgQgAyAANgIAIAMQ4AoACywBAX8jAEEQayIBJAAgASAAKQIANwMIIAFBCGpBmNjCAEEAIAAoAggQxQYACyEBAX8CQCAAKAIAIgFFDQAgAEEEaigCAEUNACABENoBCwsiAAJAIAAEQCAAKAIAQX9GDQEgACoCBA8LEKIMAAsQowwACzsBAX9BEEEEEMgLIgBFBEBBEEEEQdCewwAoAgAiAEG/BiAAGxEAAAALIABCgcoANwIEIABBADoAACAACycAIAEgAikCADcCLCABQTRqIAJBCGooAgA2AgAgACABQYgBEJ4KGgsnACABIAIpAgA3AjggAUFAayACQQhqKAIANgIAIAAgAUGIARCeChoLIQEBfwJAIAAoAgQiAUUNACAAQQhqKAIARQ0AIAEQ2gELCx8AAkAgAUF8TQRAIAAgAUEEIAIQuAsiAA0BCwALIAALJQAgAEUEQEG4rsEAQTAQoQwACyAAIAIgAyAEIAUgASgCEBEcAAsgAQJ+IAApAwAiAkI/hyIDIAIgA3yFIAJCf1UgARDtBAsyAQF/QQRBBBDICyIARQRAQQRBBEHQnsMAKAIAIgBBvwYgABsRAAAACyAAQQA2AgAgAAsjACAARQRAQbiuwQBBMBChDAALIAAgAiADIAQgASgCEBECAAsjACAARQRAQbiuwQBBMBChDAALIAAgAiADIAQgASgCEBEWAAsjACAARQRAQbiuwQBBMBChDAALIAAgAiADIAQgASgCEBE4AAsjACAARQRAQbiuwQBBMBChDAALIAAgAiADIAQgASgCEBFaAAsnAEGAn8MAKAIAQQFHBEBBgJ/DAEIBNwIAQYifwwBBADYCAAsQ+gULIQAgAEUEQEG4rsEAQTAQoQwACyAAIAIgAyABKAIQEQEACyQAIAAtAABFBEAgAUGogMMAQQUQ3gEPCyABQaSAwwBBBBDeAQsdACABKAIARQRAAAsgAEGop8AANgIEIAAgATYCAAsdACABKAIARQRAAAsgAEGs4MAANgIEIAAgATYCAAsfACAARQRAQbiuwQBBMBChDAALIAAgAiABKAIQEQMACxgAQQFBAiAAKAIAEBgiAEEBRhtBACAAGwsdACABKAIARQRAAAsgAEHwv8EANgIEIAAgATYCAAsgACAAQbT8wQA2AgQgACABNgIAIABBCGogASoCGDgCAAsgACAAQcD5wQA2AgQgACABNgIAIABBCGogASoCDDgCAAsgACAAQaj/wQA2AgQgACABNgIAIABBCGogASoCJDgCAAsgACAAQciPwgA2AgQgACABNgIAIABBCGogASoCCDgCAAsgACAAQdSTwgA2AgQgACABNgIAIABBCGogASoCCDgCAAsgACAAQdSMwgA2AgQgACABNgIAIABBCGogASoCYDgCAAsSAEG0ysIAQRxBsMvCABDbCQALEgBBrN3CAEEcQZjewgAQ2wkACzQAIABC////9//////+ADcCCCAAQv////f/////fjcCACAAQRBqQv////f3/////gA3AgALHQAgAEHA+cEANgIEIAAgATYCACAAQQhqQQA2AgALHQAgAEGo/8EANgIEIAAgATYCACAAQQhqQQA2AgALHQAgAEG0/MEANgIEIAAgATYCACAAQQhqQQA2AgALHQAgAEHUjMIANgIEIAAgATYCACAAQQhqQQA2AgALHQAgAEHIj8IANgIEIAAgATYCACAAQQhqQQA2AgALHQAgAEHUk8IANgIEIAAgATYCACAAQQhqQQA2AgALNAAgAEL////3//////4ANwIIIABC////9/////9+NwIAIABBEGpC////9/f////+ADcCAAs0ACAAQv////f//////gA3AgggAEL////3/////343AgAgAEEQakL////39/////4ANwIACx0AIAEoAgBFBEAACyAAQYjYwgA2AgQgACABNgIACxoAIABBADYCCCAAQgA3AgAgACABKgIAOAIMCxwAIAEoAhhBzPnCAEELIAFBHGooAgAoAgwRBQALHAAgASgCGEHX+cIAQQ4gAUEcaigCACgCDBEFAAscACABKAIYQZaRwwBBBSABQRxqKAIAKAIMEQUACxMAIAAoAgAiAEEkTwRAIAAQAAsLGAAgACgCACABKAIAIAIoAgAgAygCABAMCw0AIAAgASACIAMQjQILDAAgAQRAIAAQ2gELCxQAIAAgASACQQAQ9AIgAEICNwIQCxMAIAAgASACQQAQUCAAQQM2AhALFAAgACABIAJBABDEAiAAQQM2AhALFAAgACABIAJBABCmAiAAQQM2AhALEwAgACABIAJBABAsIABBAzYCEAsTACAAIAEgAkEAECsgAEEDNgIQCxMAIAAgASACQQAQKSAAQQM2AhALEwAgACABIAJBABAnIABBAzYCEAsTACAAIAEgAkEAECogAEEDNgIQCxQAIAAgASoCACABQQRqKgIAEMYDCxMAIAAgAiABKAIAIAEoAggQnwELFAAgACgCACABIAAoAgQoAgwRAwALEAAgAEEBNgIEIABBATYCAAsPACAAKAIAIAEQywQaQQALCQAgACABEK4ECwkAIAAgARDBCgsTACAAQci8wAA2AgQgACABNgIACxEAIAAoAgAgACgCCCABEKoMCxYAQZyYwwAgADYCAEGYmMMAQQE2AgALEwAgAEG4s8EANgIEIAAgATYCAAsTACAAQcizwQA2AgQgACABNgIACxMAIABB2LPBADYCBCAAIAE2AgALEwAgAEHos8EANgIEIAAgATYCAAsTACAAQfizwQA2AgQgACABNgIACxMAIABBiLTBADYCBCAAIAE2AgALEwAgAEGYtMEANgIEIAAgATYCAAsTACAAQai0wQA2AgQgACABNgIACxMAIABBuLTBADYCBCAAIAE2AgALEwAgAEHItMEANgIEIAAgATYCAAsTACAAQdi0wQA2AgQgACABNgIACxMAIABB6LTBADYCBCAAIAE2AgALEwAgAEH4tMEANgIEIAAgATYCAAsTACAAQYi1wQA2AgQgACABNgIACxMAIABBmLXBADYCBCAAIAE2AgALEwAgAEGotcEANgIEIAAgATYCAAsTACAAQbi1wQA2AgQgACABNgIACxMAIABByLXBADYCBCAAIAE2AgALEwAgAEHYtcEANgIEIAAgATYCAAsTACAAQei1wQA2AgQgACABNgIACxMAIABB+LXBADYCBCAAIAE2AgALEwAgAEGItsEANgIEIAAgATYCAAsTACAAQZi2wQA2AgQgACABNgIACwsAIACtQiCGQgOECwsAIACtQiCGQgSECwsAIACtQiCGQgKECwsAIACtQiCGQgGECxMAIABB0PbBADYCBCAAIAE2AgALEwAgAEGk+cEANgIEIAAgATYCAAsTACAAQZj8wQA2AgQgACABNgIACxMAIABBjP/BADYCBCAAIAE2AgALEwAgAEHI/8EANgIEIAAgATYCAAsLACAArUIghkIJhAsTACAAQZyCwgA2AgQgACABNgIACwsAIACtQiCGQgaECxMAIABB6ITCADYCBCAAIAE2AgALCwAgAK1CIIZCBYQLEwAgAEG0h8IANgIEIAAgATYCAAsLACAArUIghkIIhAsLACAArUIghkIKhAsTACAAQbiMwgA2AgQgACABNgIACwsAIACtQiCGQguECxMAIABBrI/CADYCBCAAIAE2AgALCwAgAK1CIIZCDIQLEwAgAEG4k8IANgIEIAAgATYCAAsZACAAQoCAgIDw//+//wA3AgggAEIANwIACwsAIACtQiCGQgeECwsAIACtQiCGQg2ECxMAIABBqMnCADYCBCAAIAE2AgALCwAgAK1CIIZCDoQLEwAgAEHEycIANgIEIAAgATYCAAsLACAArUIghkIPhAsTACAAQeDJwgA2AgQgACABNgIACwsAIACtQiCGQhCECxMAIABB/MnCADYCBCAAIAE2AgALCwAgAK1CIIZCEYQLEwAgAEGYysIANgIEIAAgATYCAAsRACAAKAIAIAAoAgQgARDqAQsfACABKAIYIAAoAgAgACgCBCABQRxqKAIAKAIMEQUACxMAIABBiNjCADYCBCAAIAE2AgALEQAgASAAKAIAIAAoAgQQ3gELDQAgACABIAIgAxCGAQsMACAAIAEgAiADEFoLDAAgACABIAIgAxBhCwwAIAAgASACIAMQXgsNACAAIAEgAiADENsBCw0AIAAgASACIAMQvAELDQAgACABIAIgAxDGAQsLACAAIAIgAxCnBAsNACAAIAEgAiADEKkDCw0AIAAgASACIAMQwwILDQAgACoCBCAAKgIIkgsOACAAKAIAIAEQzQRBAAsSAEGo4MIAQRFBvODCABDbCQALDgAgACgCABoDQAwACwALDgAgADUCAEEBIAEQ7QQLDgAgACgCACABIAIQ+QMLDgAgACkDAEEBIAEQ7QQLCwAjACAAaiQAIwALHAAgASgCGEGAgMAAQQ4gAUEcaigCACgCDBEFAAscACABKAIYQciFwABBESABQRxqKAIAKAIMEQUACxwAIAEoAhhB/ITAAEERIAFBHGooAgAoAgwRBQALHAAgASgCGEHcqMAAQRQgAUEcaigCACgCDBEFAAsOACABQdi8wABBAhDeAQsJACAAIAEQGgALDQBB0LDBAEEbEKEMAAsOAEHrsMEAQc8AEKEMAAsIACAArUIghgsLACAAIAEgAhDFAgsLACAAIAEgAhDpAgsLACAAIAEgAhDWAgsNACAAKgIkQwAAAACSCwwAIAAoAgAgARCaCwsLACACIAAgARDeAQsHACABELkJCxwAIAEoAhhBuNHCAEEFIAFBHGooAgAoAgwRBQALCQAgAEEANgIACwcAIABBDGoLCQAgAEEANgIACwkAIAAgARD9BAsHACAAEK8ECwcAIAAqAgALBwAgACoCGAsHACAAKgIECxIAQfTawgBBJUHI28IAEIgLAAsEAEEBCw0AQvT5nubuo6r5/gALDABCp5KKipORhbEWCwQAIAALDQBC58qLobLo4MOnfwsMAEL1q5mKw67blGsLDQBCpr7s4+iL7daTfwsMAEKVwfqi56af81ALDQBCpJ/v1+f1v6SGfwsMAEKY25OxvdiSkBwLDQBC0LaY1svtmZXhAAsMAEKI1qqi5ISHtDkLDQBCnNWz5+HS2I//AAsMAELPkvCjufCfqnsLDABCpJbbxdfo8vlgCw0AQpaa94vuv4GypX8LDQBC+7Sj3ZWGspC8fwsMAELP46zj2+ze1jELDQBC34jW//HrpKL9AAsNAELz6IPLg+Hrx6l/CwwAQr77x8/wtJPBJgsMAEL7laOa0pnasGkLDABC6JrX74n4r+pjCwwAQpiRt9iHsILgKwsMAELJ0b7j8s7i83QLDABC0u/4/rjBtb0kCwQAQQALBABBAAsEAEEACwcAQ9sPSUALBABBAQsEAEECCwcAQ9sPyT8LBABBBAsHAEMAAAAACwQAQQMLBABBCQsEAEEGCwQAQQULBwBD2w9JPwsEAEEICwQAQQoLBABBCwsEAEEMCwcAQ///f38LBABBBwsEAEENCwQAQQ4LBABBDwsEAEEQCwQAQRELDABC+KbehOD3rN1xCwwAQrH0jeDdk6f3LQsDAAELAwABCwMAAQsL8ZcDCQBBgIDAAAulQmEgbWF0cml4IGFycmF5L2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL25hbGdlYnJhLTAuMjkuMC9zcmMvYmFzZS9hcnJheV9zdG9yYWdlLnJzAA4AEABpAAAABQEAADIAAAAEAAAAAAAAAAEAAAAFAAAABAAAAAAAAAABAAAABQAAAAQAAAAAAAAAAQAAAAUAAAAEAAAAAAAAAAEAAAAFAAAABAAAAAAAAAABAAAABQAAAAQAAAAAAAAAAQAAAAUAAAAEAAAAAAAAAAEAAAAFAAAABAAAAAAAAAABAAAABQAAAGNhcGFjaXR5IG92ZXJmbG93Tm8gZWxlbWVudCBhdCBpbmRleENhbm5vdCBkZXNlcmlhbGl6ZSBjdXN0b20gc2hhcGUuBAAAAAAAAAABAAAABgAAAAQAAAAAAAAAAQAAAAcAAABBbGxvY2F0aW9uIGZyb20gaXRlcmF0b3IgZXJyb3I6IHRoZSBpdGVyYXRvciBkaWQgbm90IHlpZWxkIHRoZSBjb3JyZWN0IG51bWJlciBvZiBlbGVtZW50cy4vaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvbmFsZ2VicmEtMC4yOS4wL3NyYy9iYXNlL2RlZmF1bHRfYWxsb2NhdG9yLnJzAMYBEABtAAAAfgAAAAkAAABzdHJ1Y3QgQml0VmVjIHdpdGggMiBlbGVtZW50cwAAAEQCEAAdAAAABAAAAAgAAAAEAAAACAAAAGEgdHVwbGUgb2Ygc2l6ZSAyAAAABAAAAAAAAAABAAAACQAAAHN0cnVjdCBUcmlNZXNoIHdpdGggMyBlbGVtZW50cwAAoAIQAB4AAABhIHR1cGxlIG9mIHNpemUgMwAAAAQAAAAAAAAAAQAAAAoAAAAEAAAAAAAAAAEAAAAKAAAAc3RydWN0IENvbXBvdW5kIHdpdGggNCBlbGVtZW50cwD8AhAAHwAAAHN0cnVjdCBQb2x5bGluZSB3aXRoIDMgZWxlbWVudHMAJAMQAB8AAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvY3Jvc3NiZWFtLWNoYW5uZWwtMC41LjEvc3JjL3dha2VyLnJzTAMQAGQAAABWAAAAFAAAAEwDEABkAAAAXQAAABkAAABMAxAAZAAAAF8AAAAZAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2Nyb3NzYmVhbS1jaGFubmVsLTAuNS4xL3NyYy9mbGF2b3JzL3plcm8ucnMA4AMQAGsAAACsAAAANgAAAOADEABrAAAAswAAADYAAAB2YXJpYW50IGluZGV4IDAgPD0gaSA8IDJsBBAAGAAAAHN0cnVjdCBFZGdlIHdpdGggMyBlbGVtZW50cwCMBBAAGwAAAHN0cnVjdCBDb2xsaWRlciB3aXRoIDEwIGVsZW1lbnRzsAQQACAAAABzdHJ1Y3QgQXJlbmEgd2l0aCA0IGVsZW1lbnRz2AQQABwAAABzdHJ1Y3QgUmlnaWRCb2R5IHdpdGggMTMgZWxlbWVudHMAAAD8BBAAIQAAAHN0cnVjdCBFZGdlIHdpdGggNCBlbGVtZW50cwAoBRAAGwAAAHZhcmlhbnQgaW5kZXggMCA8PSBpIDwgMTkAAABMBRAAGQAAAHN0cnVjdCBDb2FyZW5hIHdpdGggMSBlbGVtZW50AAAAcAUQAB0AAABzdHJ1Y3QgR3JhcGggd2l0aCAyIGVsZW1lbnRzmAUQABwAAABzdHJ1Y3QgQ29sbGlkZXJTZXQgd2l0aCAzIGVsZW1lbnRzAAC8BRAAIgAAAHN0cnVjdCBDb250YWN0RGF0YSB3aXRoIDMgZWxlbWVudHMAAOgFEAAiAAAAc3RydWN0IENvbnRhY3RQYWlyIHdpdGggNSBlbGVtZW50cwAAFAYQACIAAABzdHJ1Y3QgUUJWSCB3aXRoIDQgZWxlbWVudHMAQAYQABsAAABzdHJ1Y3QgU29sdmVyQ29udGFjdCB3aXRoIDkgZWxlbWVudHNkBhAAJAAAAHZhcmlhbnQgaW5kZXggMCA8PSBpIDwgNJAGEAAYAAAAc3RydWN0IFJpZ2lkQm9keVNldCB3aXRoIDIgZWxlbWVudHMAsAYQACMAAABzdHJ1Y3QgSXNsYW5kTWFuYWdlciB3aXRoIDQgZWxlbWVudHPcBhAAJAAAAHN0cnVjdCBDb252ZXhQb2x5aGVkcm9uIHdpdGggOCBlbGVtZW50cwAIBxAAJwAAAHN0cnVjdCBSb3VuZFNoYXBlIHdpdGggMiBlbGVtZW50cwAAADgHEAAhAAAAc3RydWN0IEJhbGxKb2ludCB3aXRoIDE1IGVsZW1lbnRzAAAAZAcQACEAAABzdHJ1Y3QgQ29udGFjdE1hbmlmb2xkRGF0YSB3aXRoIDggZWxlbWVudHMAAJAHEAAqAAAAc3RydWN0IFJldm9sdXRlSm9pbnQgd2l0aCAyMCBlbGVtZW50cwAAAMQHEAAlAAAAc3RydWN0IE1hc3NQcm9wZXJ0aWVzIHdpdGggNCBlbGVtZW50cwAAAPQHEAAlAAAAc3RydWN0IElzb21ldHJ5IHdpdGggMiBlbGVtZW50cwAkCBAAHwAAAHN0cnVjdCBQcmlzbWF0aWNKb2ludCB3aXRoIDE3IGVsZW1lbnRzAABMCBAAJgAAAHN0cnVjdCBTQVBBeGlzIHdpdGggMyBlbGVtZW50cwAAfAgQAB4AAABzdHJ1Y3QgU0FQTGF5ZXIgd2l0aCA2IGVsZW1lbnRzAKQIEAAfAAAAc3RydWN0IFNBUFByb3hpZXMgd2l0aCAyIGVsZW1lbnRzAAAAzAgQACEAAABzdHJ1Y3QgU0FQUmVnaW9uIHdpdGggNyBlbGVtZW50c/gIEAAgAAAAc3RydWN0IEJyb2FkUGhhc2Ugd2l0aCA3IGVsZW1lbnRzAAAAIAkQACEAAAB2YXJpYW50IGluZGV4IDAgPD0gaSA8IDZMCRAAGAAAAHN0cnVjdCBUcmlNZXNoU2hhcGVDb250YWN0TWFuaWZvbGRzV29ya3NwYWNlIHdpdGggMyBlbGVtZW50c2wJEAA8AAAAc3RydWN0IEhlaWdodEZpZWxkU2hhcGVDb250YWN0TWFuaWZvbGRzV29ya3NwYWNlIHdpdGggMiBlbGVtZW50c7AJEABAAAAAc3RydWN0IENvbnRhY3RNYW5pZm9sZCB3aXRoIDggZWxlbWVudHMAAPgJEAAmAAAAc3RydWN0IENvbXBvc2l0ZVNoYXBlU2hhcGVDb250YWN0TWFuaWZvbGRzV29ya3NwYWNlIHdpdGggMiBlbGVtZW50cwAoChAAQwAAAHN0cnVjdCBIZWlnaHRGaWVsZENvbXBvc2l0ZVNoYXBlQ29udGFjdE1hbmlmb2xkc1dvcmtzcGFjZSB3aXRoIDIgZWxlbWVudHMAAAB0ChAASQAAAHN0cnVjdCBDb21wb3NpdGVTaGFwZUNvbXBvc2l0ZVNoYXBlQ29udGFjdE1hbmlmb2xkc1dvcmtzcGFjZSB3aXRoIDIgZWxlbWVudHPIChAATAAAAAQAAAAIAAAABAAAAAsAAAAMAAAADQAAAAwAAAAEAAAADgAAAA8AAAAQAAAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseS9ydXN0Yy81NzRkMzc1NjgwMjlmNWM2Mzc1NTdhODc0MjZhZGU1NDc3MGQ5YTE0L2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAfwsQAEsAAABPCQAADgAAAAQAAAAEAAAABAAAABEAAAASAAAAEwAAAGFzc2VydGlvbiBmYWlsZWQ6IG1pZCA8PSBzZWxmLmxlbigpL3J1c3RjLzU3NGQzNzU2ODAyOWY1YzYzNzU1N2E4NzQyNmFkZTU0NzcwZDlhMTQvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9tb2QucnMXDBAATQAAAP8FAAAJAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZQAEAAAAAAAAAAEAAAAUAAAAL3J1c3RjLzU3NGQzNzU2ODAyOWY1YzYzNzU1N2E4NzQyNmFkZTU0NzcwZDlhMTQvbGlicmFyeS9hbGxvYy9zcmMvY29sbGVjdGlvbnMvdmVjX2RlcXVlL21vZC5ycwAAsAwQAF4AAAAOAgAACQAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuY2FwKCkgPT0gb2xkX2NhcCAqIDIAsAwQAF4AAABpCAAADQAAAAQAAAAAAAAAAQAAAAAAAABpbnZhbGlkIHZhbHVlOiAsIGV4cGVjdGVkIAAAbA0QAA8AAAB7DRAACwAAAGludmFsaWQgbGVuZ3RoIACYDRAADwAAAHsNEAALAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC43LjAvc3JjL3BhcnRpdGlvbmluZy9xYnZoLnJzAAC4DRAAZgAAAOkBAAAYAAAAuA0QAGYAAACvAQAAGAAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9pbmRleG1hcC0xLjcuMC9zcmMvbWFwL2NvcmUucnMAAEAOEABeAAAAKgAAACMAAABADhAAXgAAAO4AAAAuAAAAQA4QAF4AAAAiAAAADwAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9uYWxnZWJyYS0wLjI5LjAvc3JjL2Jhc2UvY29uc3RydWN0aW9uLnJzTWF0cml4IGluaXQuIGVycm9yOiB0aGUgc2xpY2UgZGlkIG5vdCBjb250YWluIHRoZSByaWdodCBudW1iZXIgb2YgZWxlbWVudHMuANAOEABoAAAAYAAAAAkAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4wL3NyYy9kYXRhL2NvbXBvbmVudF9zZXQucnMAAACUDxAAaQAAABsAAAAaAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMC9zcmMvZGF0YS9hcmVuYS5ycwAAABAQEABhAAAABwEAAB4AAABjb3JydXB0IGZyZWUgbGlzdAAAABAQEABhAAAACAEAACsAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4wL3NyYy9kYXRhL2dyYXBoLnJzAAAAqBAQAGEAAACSAAAAGAAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuZWRnZXMubGVuKCkgIT0gY3JhdGU6OklOVkFMSURfVVNJWkUAAKgQEABhAAAA3AAAAAkAAABHcmFwaDo6YWRkX2VkZ2U6IG5vZGUgaW5kaWNlcyBvdXQgb2YgYm91bmRzAKgQEABhAAAA5AAAABsAAABhc3NlcnRpb24gZmFpbGVkOiBzZWxmLm5vZGVzLmxlbigpICE9IGNyYXRlOjpJTlZBTElEX1VTSVpFAACoEBAAYQAAALMAAAAJAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMC9zcmMvZGF0YS9jb2FyZW5hLnJzAPAREABjAAAAUAAAABkAAADwERAAYwAAAEEAAAAJAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMC9zcmMvZHluYW1pY3Mvam9pbnQvam9pbnRfc2V0LnJzAHQSEABvAAAA1gAAAAkAAAB0EhAAbwAAACgBAAANAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMC9zcmMvZ2VvbWV0cnkvaW50ZXJhY3Rpb25fZ3JhcGgucnMAAAAEExAAcQAAAHwAAAA/AAAABBMQAHEAAAB9AAAADgAAAAQTEABxAAAAfQAAACcAAAAEAAAACAAAAAQAAAAVAAAAL3J1c3RjLzU3NGQzNzU2ODAyOWY1YzYzNzU1N2E4NzQyNmFkZTU0NzcwZDlhMTQvbGlicmFyeS9hbGxvYy9zcmMvY29sbGVjdGlvbnMvdmVjX2RlcXVlL3Jpbmdfc2xpY2VzLnJzAAC4ExAAZgAAACAAAAAOAAAARXhwZWN0ZWQgIGNvbXBvbmVudHMsIGZvdW5kIDAUEAAJAAAAORQQABMAAABhbiBhcnJheSBvZiBsZW5ndGggMwQAAAAAAAAAAQAAABYAAABJbnZhbGlkIEpvaW50IHJlZmVyZW5jZS4gSXQgbWF5IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBoeXNpY3MgV29ybGQucmFwaWVyM2QvLi4vc3JjL2R5bmFtaWNzL2pvaW50X3NldC5ycwAAyRQQACUAAAANAAAADgAAAMkUEAAlAAAAFQAAAA4AAABJbnZhbGlkIFJpZ2lkQm9keSByZWZlcmVuY2UuIEl0IG1heSBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwaHlzaWNzIFdvcmxkLnJhcGllcjNkLy4uL3NyYy9keW5hbWljcy9yaWdpZF9ib2R5X3NldC5ycwBdFRAAKgAAACoAAAA4AAAAXRUQACoAAAAxAAAAPAAAAEludmFsaWQgQ29sbGlkZXIgcmVmZXJlbmNlLiBJdCBtYXkgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGh5c2ljcyBXb3JsZC5yYXBpZXIzZC8uLi9zcmMvZ2VvbWV0cnkvY29sbGlkZXJfc2V0LnJz9BUQACgAAAAPAAAADgAAAPQVEAAoAAAAFwAAAA4AAAAwLjcuMmludmFsaWQgZW51bSB2YWx1ZSBwYXNzZWQAAMkUEAAlAAAAKQAAADkAAADJFBAAJQAAACoAAAA5AAAAcmFwaWVyM2QvLi4vc3JjL2R5bmFtaWNzL3JpZ2lkX2JvZHkucnMAAHwWEAAmAAAAJAEAAB8AAABOb3QgeWV0IGltcGxlbWVudGVkLnJhcGllcjNkLy4uL3NyYy9nZW9tZXRyeS9jb2xsaWRlci5yc8gWEAAkAAAAiwAAADkAAAByYXBpZXIzZC8uLi9zcmMvZ2VvbWV0cnkvbmFycm93X3BoYXNlLnJz/BYQACgAAADPAAAAEgAAAPwWEAAoAAAA0wAAABIAAAD8FhAAKAAAANcAAAASAAAAcmFwaWVyM2QvLi4vc3JjL2dlb21ldHJ5L3NoYXBlLnJzAAAAVBcQACEAAABvAAAAOgAAAFQXEAAhAAAAbwAAAEAAAABUFxAAIQAAAHkAAAA4AAAAVBcQACEAAAB5AAAAPgAAAFQXEAAhAAAAuAAAAEAAAABUFxAAIQAAALgAAABGAAAAVBcQACEAAADDAAAAQAAAAFQXEAAhAAAAwwAAAEYAAAAEAAAAAAAAAAEAAAAXAAAAGAAAABkAAAAEAAAAAAAAAAEAAAAEAAAAAAAAAAEAAAAQGBAAGgAAABsAAAAcAAAADAAAAAQAAAAdAAAAHgAAAB8AAAAgAAAAEAAAAAQAAAAgAAAAEAAAAAQAAABMGBAAIQAAACIAAABzdHJ1Y3QgRGVzZXJpYWxpemFibGVXb3JsZCB3aXRoIDggZWxlbWVudHMAAHAYEAAqAAAAAgAAAAMAAAAAAAAAAQAAAEludmFsaWQgc2l6ZSA6IHNpemVzIG11c3QgZml0IGluIGEgdXNpemUgKDAgdG8gKbQYEAANAAAAwRgQACIAAADjGBAAAQAAAP////9UaGUgbG9vc2VuaW5nIG1hcmdpbiBtdXN0IGJlIHBvc2l0aXZlLi9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuNy4wL3NyYy9ib3VuZGluZ192b2x1bWUvYWFiYi5ycwAmGRAAaQAAALABAAAJAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC43LjAvc3JjL3F1ZXJ5L2RlZmF1bHRfcXVlcnlfZGlzcGF0Y2hlci5ycwCgGRAAcwAAAOABAAAeAAAAJQAAAAAAAAABAAAAJQAAAAAAAAABAAAAJBoQACYAAAAnAAAAKAAAACkAAAAqAAAAAAAAACsAAAAsAAAALQAAAKAZEABzAAAAuQEAADEAAACgGRAAcwAAAKYBAAAxAAAAoBkQAHMAAAAQAgAALwAAAKAZEABzAAAAHwIAAC8AAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvY3Jvc3NiZWFtLWNoYW5uZWwtMC41LjEvc3JjL3dha2VyLnJzpBoQAGQAAABWAAAAFAAAAKQaEABkAAAAXQAAABkAAACkGhAAZAAAAF8AAAAZAAAApBoQAGQAAABFAAAAKAAAAGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGUvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvY3Jvc3NiZWFtLWNoYW5uZWwtMC41LjEvc3JjL2NoYW5uZWwucnMAAHAbEABmAAAAsAEAAC0AAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvY3Jvc3NiZWFtLWNoYW5uZWwtMC41LjEvc3JjL2NvbnRleHQucnMAAOgbEABmAAAAMQAAAB4AAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvY3Jvc3NiZWFtLWNoYW5uZWwtMC41LjEvc3JjL2ZsYXZvcnMvbGlzdC5ycwBgHBAAawAAAAMBAABDAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2Nyb3NzYmVhbS1jaGFubmVsLTAuNS4xL3NyYy9mbGF2b3JzL3plcm8ucnMA3BwQAGsAAADbAAAALQAAANwcEABrAAAA+QAAAEAAAADcHBAAawAAAPoAAABHAAAA3BwQAGsAAAD0AAAAQAAAANwcEABrAAAA9QAAAEcAAADcHBAAawAAAPIAAAAmAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2Nyb3NzYmVhbS1jaGFubmVsLTAuNS4xL3NyYy9mbGF2b3JzL2FycmF5LnJzqB0QAGwAAACAAQAANwAAAKgdEABsAAAAfgEAACoAAAAlAAAACAAAAAQAAAAuAAAALwAAACUAAAAkAAAABAAAADAAAAAoKQAAJQAAAAQAAAAEAAAAMQAAAGFzc2VydGlvbiBmYWlsZWQ6IG1pZCA8PSBzZWxmLmxlbigpL3J1c3RjLzU3NGQzNzU2ODAyOWY1YzYzNzU1N2E4NzQyNmFkZTU0NzcwZDlhMTQvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9tb2QucnOPHhAATQAAAP8FAAAJAAAAjx4QAE0AAAA1AgAAJAAAAAAAAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlACUAAAAAAAAAAQAAADIAAAAlAAAABAAAAAQAAAAzAAAAJQAAAAQAAAAEAAAANAAAACUAAAAEAAAABAAAADUAAABjYXBhY2l0eSBvdmVyZmxvdy9ydXN0Yy81NzRkMzc1NjgwMjlmNWM2Mzc1NTdhODc0MjZhZGU1NDc3MGQ5YTE0L2xpYnJhcnkvYWxsb2Mvc3JjL2NvbGxlY3Rpb25zL3ZlY19kZXF1ZS9tb2QucnNhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmNhcCgpID09IG9sZF9jYXAgKiAyAAB9HxAAXgAAAGkIAAANAAAABAAAAAAAAAAQAAAAAAAAAAgAAAAAAAAAL3J1c3RjLzU3NGQzNzU2ODAyOWY1YzYzNzU1N2E4NzQyNmFkZTU0NzcwZDlhMTQvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2UucnMAADAgEABKAAAAUQQAABUAAAAwIBAASgAAAF8EAAAeAAAAMCAQAEoAAABoBAAAGAAAADAgEABKAAAAaQQAABkAAAAwIBAASgAAAGwEAAAaAAAA/y9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9iaXQtdmVjLTAuNi4zL3NyYy9saWIucnMAQbDCwAAL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cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuNy4wL3NyYy9xdWVyeS9namsvZ2prLnJzAACcKxAAYgAAAIwAAAAJAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC43LjAvc3JjL3NoYXBlL2hlaWdodGZpZWxkMy5ycwAQLBAAZwAAAIYBAAAeAAAAECwQAGcAAACSAQAAGwAAABAsEABnAAAAkwEAABsAAAAQLBAAZwAAAJQBAAAbAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC43LjAvc3JjL3NoYXBlL3BvbHlnb25hbF9mZWF0dXJlM2QucnMAALgsEABuAAAAFgEAAB4AAAC4LBAAbgAAABgBAAA6AAAAuCwQAG4AAAAbAQAAKQAAALgsEABuAAAAQgEAAB4AAAC4LBAAbgAAAEQBAAA6AAAAuCwQAG4AAABHAQAAKQAAALgsEABuAAAAawEAABEAAAC4LBAAbgAAAGwBAAARAAAAuCwQAG4AAABxAQAAFQAAALgsEABuAAAAcgEAACUAAAC4LBAAbgAAAHIBAAAVAAAAaW5kZXggb3V0IG9mIGJvdW5kcy9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9pbmRleG1hcC0xLjcuMC9zcmMvbWFwLnJz6y0QAFkAAACGAQAAGgAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9pbmRleG1hcC0xLjcuMC9zcmMvbWFwL2NvcmUucnMAAFQuEABeAAAAKgAAACMAAABpbmRleCBub3QgZm91bmQAVC4QAF4AAAA2AAAACgAAAFQuEABeAAAAdwIAAA4AAABULhAAXgAAAJIBAAAiAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2luZGV4bWFwLTEuNy4wL3NyYy9tYXAvY29yZS9yYXcucnMAAAQvEABiAAAAdgAAAAoAAABULhAAXgAAACIAAAAPAAAATWF0cml4IGluZGV4IG91dCBvZiBib3VuZHMuSW5kZXggb3V0IG9mIGJvdW5kcy4vaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvbmFsZ2VicmEtMC4yOS4wL3NyYy9iYXNlL2luZGV4aW5nLnJzALcvEABkAAAAVwEAABoAAAAlAAAACAAAAAQAAABgAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMC9zcmMvZGF0YS9hcmVuYS5ycwAAADwwEABhAAAABwEAAB4AAABjb3JydXB0IGZyZWUgbGlzdAAAADwwEABhAAAACAEAACsAAABpbnNlcnRpbmcgd2lsbCBhbHdheXMgc3VjY2VlZCBhZnRlciByZXNlcnZpbmcgYWRkaXRpb25hbCBzcGFjZQAAPDAQAGEAAABJAQAADgAAAE5vIGVsZW1lbnQgYXQgaW5kZXgvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4wL3NyYy9kYXRhL2NvYXJlbmEucnMAADcxEABjAAAAQQAAAAkAAABDYW5ub3QgaW5kZXggdGhlIHNhbWUgb2JqZWN0IHR3aWNlLgCsMRAAIwAAADcxEABjAAAAYwAAAAkAAAA3MRAAYwAAAGwAAAATAAAANzEQAGMAAABsAAAAIgAAADcxEABjAAAAdQAAABMAAAA3MRAAYwAAAHUAAAArAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMC9zcmMvZGF0YS9jb21wb25lbnRfc2V0LnJzAAAAKDIQAGkAAAAbAAAAGgAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjExLjAvc3JjL2RhdGEvZ3JhcGgucnMAAACkMhAAYQAAAJIAAAAYAAAAYXNzZXJ0aW9uIGZhaWxlZDogc2VsZi5ub2Rlcy5sZW4oKSAhPSBjcmF0ZTo6SU5WQUxJRF9VU0laRQAApDIQAGEAAACzAAAACQAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuZWRnZXMubGVuKCkgIT0gY3JhdGU6OklOVkFMSURfVVNJWkUAAKQyEABhAAAA3AAAAAkAAABHcmFwaDo6YWRkX2VkZ2U6IG5vZGUgaW5kaWNlcyBvdXQgb2YgYm91bmRzAKQyEABhAAAA5AAAABsAAACkMhAAYQAAAA8BAAAcAAAAQ291bGQgbm90IGZpbmQgdGhlIENvbGxpZGVyUGFyZW50IGNvbXBvbmVudC4vaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4wL3NyYy9keW5hbWljcy9jY2QvY2NkX3NvbHZlci5ycwAAKDQQAG4AAACvAAAAGgAAACg0EABuAAAAQwEAABoAAAAoNBAAbgAAADACAABLAAAAKDQQAG4AAABCAgAASwAAAGFzc2VydGlvbiBmYWlsZWQ6IHRvaS50b2kgPD0gZHQAKDQQAG4AAACeAQAADQAAACg0EABuAAAAqAEAADEAAAAoNBAAbgAAAKsBAAAxAAAAKDQQAG4AAAC/AQAALgAAACg0EABuAAAAwAEAADsAAAAoNBAAbgAAAMQBAAAuAAAAKDQQAG4AAADFAQAAOwAAACg0EABuAAAAzQEAAEgAAABhc3NlcnRpb24gZmFpbGVkOiBzdGFydF90aW1lIDw9IGVuZF90aW1lL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMC9zcmMvZHluYW1pY3MvY2NkL3RvaV9lbnRyeS5ycwAAAKA1EABtAAAAUAAAAAkAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4wL3NyYy9keW5hbWljcy9pc2xhbmRfbWFuYWdlci5ycwAAIDYQAG4AAAB+AAAAHAAAACA2EABuAAAAfgAAADwAAAAgNhAAbgAAAH8AAAAKAAAAVGhlIG1pbmltdW0gaXNsYW5kIHNpemUgbXVzdCBiZSBhdCBsZWFzdCAxLgAgNhAAbgAAALwAAAAJAAAAIDYQAG4AAAAjAQAAUAAAACA2EABuAAAAPQEAACkAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4wL3NyYy9keW5hbWljcy9qb2ludC9qb2ludF9zZXQucnMAHDcQAG8AAADmAAAAIAAAABw3EABvAAAAAwEAABEAAAAcNxAAbwAAAFABAABXAAAAHDcQAG8AAABVAQAAGQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjExLjAvc3JjL2R5bmFtaWNzL3JpZ2lkX2JvZHlfY29tcG9uZW50cy5ycwAAAMw3EAB1AAAA0AIAABIAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4wL3NyYy9keW5hbWljcy9zb2x2ZXIvY2F0ZWdvcml6YXRpb24ucnMAAABUOBAAdQAAAA0AAAAZAAAAVDgQAHUAAAAfAAAAFgAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjExLjAvc3JjL2R5bmFtaWNzL3NvbHZlci9qb2ludF9jb25zdHJhaW50L2JhbGxfcG9zaXRpb25fY29uc3RyYWludC5yc+w4EACQAAAAQgAAAB0AAADsOBAAkAAAAEMAAAAdAAAA7DgQAJAAAACTAAAACQAAAOw4EACQAAAAlAAAAAkAAADsOBAAkAAAANIAAAAdAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMC9zcmMvZHluYW1pY3Mvc29sdmVyL2pvaW50X2NvbnN0cmFpbnQvYmFsbF92ZWxvY2l0eV9jb25zdHJhaW50LnJzzDkQAJAAAAD0AAAAHgAAAMw5EACQAAAA9QAAAB4AAADMORAAkAAAAE4BAAAeAAAAzDkQAJAAAABPAQAAHgAAAMw5EACQAAAAVQEAAAkAAADMORAAkAAAAFYBAAAJAAAAzDkQAJAAAABaAQAAGgAAAMw5EACQAAAAQQIAAB4AAADMORAAkAAAAIICAAAeAAAAzDkQAJAAAACIAgAACQAAAMw5EACQAAAAjQIAABoAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4wL3NyYy9keW5hbWljcy9zb2x2ZXIvam9pbnRfY29uc3RyYWludC9maXhlZF9wb3NpdGlvbl9jb25zdHJhaW50LnJzAAAADDsQAJEAAAA5AAAAHQAAAAw7EACRAAAAOgAAAB0AAAAMOxAAkQAAAFUAAAAJAAAADDsQAJEAAABWAAAACQAAAAw7EACRAAAAhgAAAB0AAABTaW5ndWxhciBzeXN0ZW0uL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMC9zcmMvZHluYW1pY3Mvc29sdmVyL2pvaW50X2NvbnN0cmFpbnQvZml4ZWRfdmVsb2NpdHlfY29uc3RyYWludC5ycwAAAAA8EACRAAAAcgAAACYAAAAAPBAAkQAAAKgAAAAeAAAAADwQAJEAAACpAAAAHgAAAAA8EACRAAAAwAAAAB4AAAAAPBAAkQAAAMEAAAAeAAAAADwQAJEAAADpAAAAGgAAAAA8EACRAAAATgEAACYAAAAAPBAAkQAAAH4BAAAeAAAAADwQAJEAAACPAQAAHgAAAAA8EACRAAAArwEAABoAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4wL3NyYy9keW5hbWljcy9zb2x2ZXIvam9pbnRfY29uc3RyYWludC9qb2ludF9jb25zdHJhaW50LnJzND0QAIgAAABeAQAAMgAAADQ9EACIAAAAhgEAADIAAAA0PRAAiAAAAMIBAAAyAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMC9zcmMvZHluYW1pY3Mvc29sdmVyL2pvaW50X2NvbnN0cmFpbnQvam9pbnRfcG9zaXRpb25fY29uc3RyYWludC5ycwAAAOw9EACRAAAAFQEAADIAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4wL3NyYy9keW5hbWljcy9zb2x2ZXIvam9pbnRfY29uc3RyYWludC9wcmlzbWF0aWNfcG9zaXRpb25fY29uc3RyYWludC5ycwAAAJA+EACVAAAAQQAAAB0AAACQPhAAlQAAAEIAAAAdAAAAkD4QAJUAAABnAAAACQAAAJA+EACVAAAAaAAAAAkAAACQPhAAlQAAAJwAAAAdAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMC9zcmMvZHluYW1pY3Mvc29sdmVyL2pvaW50X2NvbnN0cmFpbnQvcHJpc21hdGljX3ZlbG9jaXR5X2NvbnN0cmFpbnQucnMAAAB4PxAAlQAAADcBAAAeAAAAeD8QAJUAAAA4AQAAHgAAAHg/EACVAAAAwQEAAB4AAAB4PxAAlQAAAMIBAAAeAAAAeD8QAJUAAADNAQAAGgAAAHg/EACVAAAA+QIAAB4AAAB4PxAAlQAAAEkDAAAeAAAAeD8QAJUAAABUAwAAGgAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjExLjAvc3JjL2R5bmFtaWNzL3NvbHZlci9qb2ludF9jb25zdHJhaW50L3Jldm9sdXRlX3Bvc2l0aW9uX2NvbnN0cmFpbnQucnOQQBAAlAAAAEwAAAAdAAAAkEAQAJQAAABNAAAAHQAAAJBAEACUAAAAYwAAAC0AAACQQBAAlAAAAJsAAAAJAAAAkEAQAJQAAACcAAAACQAAAJBAEACUAAAA7QAAAB0AAACQQBAAlAAAAPwAAAAtAAAAkEAQAJQAAAAlAQAACQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjExLjAvc3JjL2R5bmFtaWNzL3NvbHZlci9qb2ludF9jb25zdHJhaW50L3Jldm9sdXRlX3ZlbG9jaXR5X2NvbnN0cmFpbnQucnOkQRAAlAAAAAsBAAAeAAAApEEQAJQAAAAMAQAAHgAAAKRBEACUAAAAgAEAAB4AAACkQRAAlAAAAIEBAAAeAAAApEEQAJQAAACMAQAAGgAAAKRBEACUAAAAiAIAAB4AAACkQRAAlAAAANsCAAAeAAAApEEQAJQAAADmAgAAGgAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjExLjAvc3JjL2R5bmFtaWNzL3NvbHZlci9wb3NpdGlvbl9jb25zdHJhaW50LnJzAAC4QhAAegAAACAAAAAtAAAAuEIQAHoAAABCAAAAMQAAALhCEAB6AAAAQwAAADEAAAC4QhAAegAAAH4AAAAYAAAAuEIQAHoAAAB/AAAAGAAAALhCEAB6AAAAgwAAACAAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4wL3NyYy9keW5hbWljcy9zb2x2ZXIvcG9zaXRpb25fZ3JvdW5kX2NvbnN0cmFpbnQucnMAAACUQxAAgQAAACcAAAAoAAAAlEMQAIEAAAApAAAAKAAAAJRDEACBAAAAWgAAABgAAACUQxAAgQAAAF4AAAAgAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMC9zcmMvZHluYW1pY3Mvc29sdmVyL3Bvc2l0aW9uX3NvbHZlci5ycwAAWEQQAHYAAAA1AAAAHQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9yYXBpZXIzZC0wLjExLjAvc3JjL2R5bmFtaWNzL3NvbHZlci9zb2x2ZXJfY29uc3RyYWludHMucnMAAADgRBAAeQAAALgAAAAdAAAA4EQQAHkAAAD8AAAAHQAAAOBEEAB5AAAAYAEAABoAAADgRBAAeQAAAJMBAAAaAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMC9zcmMvZHluYW1pY3Mvc29sdmVyL3ZlbG9jaXR5X2NvbnN0cmFpbnQucnMAAJxFEAB6AAAANAAAAC0AAACcRRAAegAAAEAAAAAtAAAAnEUQAHoAAABMAAAALQAAAAAAAACcRRAAegAAAHYAAAAJAAAAnEUQAHoAAAB7AAAAMQAAAJxFEAB6AAAAfAAAADEAAACcRRAAegAAALwAAAAWAAAAnEUQAHoAAAA3AQAADgAAAJxFEAB6AAAAQQEAAAkAAACcRRAAegAAAEIBAAAJAAAAnEUQAHoAAABGAQAAHgAAAJxFEAB6AAAARwEAAB4AAACcRRAAegAAAEoBAAASAAAAnEUQAHoAAABVAQAACQAAAJxFEAB6AAAAVgEAAAkAAACcRRAAegAAAFoBAAAdAAAAnEUQAHoAAABdAQAAHgAAAJxFEAB6AAAAXgEAACcAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4wL3NyYy9keW5hbWljcy9zb2x2ZXIvdmVsb2NpdHlfZ3JvdW5kX2NvbnN0cmFpbnQucnMAAAA8RxAAgQAAAEMAAAApAAAAPEcQAIEAAAB7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cmMvZ2VvbWV0cnkvYnJvYWRfcGhhc2VfbXVsdGlfc2FwL3NhcF91dGlscy5ycwAUUhAAfwAAAA0AAAAFAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMC9zcmMvZ2VvbWV0cnkvaW50ZXJhY3Rpb25fZ3JhcGgucnMAAACkUhAAcQAAAHwAAAA/AAAApFIQAHEAAAB9AAAADgAAAKRSEABxAAAAfQAAACcAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcmFwaWVyM2QtMC4xMS4wL3NyYy9nZW9tZXRyeS9uYXJyb3dfcGhhc2UucnNIUxAAbAAAAFMBAAARAAAASFMQAGwAAABfAQAAEQAAAEhTEABsAAAAvwIAABsAAABIUxAAbAAAAMACAAAbAAAAQSBjb250YWN0IG1hbmlmb2xkIGNhbm5vdCBjb250YWluIG1vcmUgdGhhbiAyNTUgY29udGFjdHMgY3VycmVudGx5LgBIUxAAbAAAALkDAAAVAAAASFMQAGwAAAAPBAAAIAAAAEhTEABsAAAAOAQAABkAAABQYXJlbnQgcmlnaWQgYm9keSBub3QgZm91bmQuL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMC9zcmMvZ2VvbWV0cnkvY29sbGlkZXJfc2V0LnJzhFQQAGwAAACmAAAADgAAAIRUEABsAAAAqgAAADUAAACEVBAAbAAAAK0AAAAlAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMC9zcmMvcGlwZWxpbmUvcGh5c2ljc19waXBlbGluZS5ycyBVEABwAAAAqwAAABEAAAAgVRAAcAAAABABAAASAAAAIFUQAHAAAAAiAQAAEQAAACBVEABwAAAAKQEAABYAAAAgVRAAcAAAACsBAAAWAAAAVW5hYmxlIHRvIGluZGV4IHRoZSBzYW1lIGVsZW1lbnQgdHdpY2UuL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3JhcGllcjNkLTAuMTEuMC9zcmMvdXRpbHMucnMAB1YQAFwAAADuAgAACQAAAAdWEABcAAAA7wIAAAkAAABhAAAABAAAAAQAAABiAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2luc3RhbnQtMC4xLjEwL3NyYy93YXNtLnJzcGVyZm9ybWFuY2VmYWlsZWQgdG8gZ2V0IHBlcmZvcm1hbmNlIGZyb20gZ2xvYmFsIG9iamVjdAAAAJRWEABaAAAAdgAAAA4AAABjbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgZGVzdHJveWVkIGFscmVhZHljYW5ub3QgYWNjZXNzIGEgVGhyZWFkIExvY2FsIFN0b3JhZ2UgdmFsdWUgZHVyaW5nIG9yIGFmdGVyIGRlc3RydWN0aW9uL3J1c3RjLzU3NGQzNzU2ODAyOWY1YzYzNzU1N2E4NzQyNmFkZTU0NzcwZDlhMTQvbGlicmFyeS9zdGQvc3JjL3RocmVhZC9sb2NhbC5ycwAAAK5XEABPAAAAdwEAABoAAABuAAAAAAAAAAEAAABvAAAAcmV0dXJuIHRoaXMABAAAAAAAAABKc1ZhbHVlKCkAAAA0WBAACAAAADxYEAABAAAAbnVsbCBwb2ludGVyIHBhc3NlZCB0byBydXN0cmVjdXJzaXZlIHVzZSBvZiBhbiBvYmplY3QgZGV0ZWN0ZWQgd2hpY2ggd291bGQgbGVhZCB0byB1bnNhZmUgYWxpYXNpbmcgaW4gcnVzdAEAY2FwYWNpdHkgb3ZlcmZsb3dBbGxvY2F0aW9uIGZyb20gaXRlcmF0b3IgZXJyb3I6IHRoZSBpdGVyYXRvciBkaWQgbm90IHlpZWxkIHRoZSBjb3JyZWN0IG51bWJlciBvZiBlbGVtZW50cy4vaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvbmFsZ2VicmEtMC4yOS4wL3NyYy9iYXNlL2RlZmF1bHRfYWxsb2NhdG9yLnJzJ1kQAG0AAAB+AAAACQAAAHQAAAAIAAAABAAAAHUAAAB2AAAAdAAAAAwAAAAEAAAAdwAAAHgAAAAgAAAABAAAAHkAAAB0AAAAHAAAAAQAAAB6AAAAewAAAFgAAAAEAAAAfAAAAHgAAAAgAAAABAAAAH0AAAB0AAAAKAAAAAQAAAB+AAAAfwAAAFAAAAAEAAAAgAAAAIEAAABkAAAABAAAAIIAAACDAAAAYAAAAAQAAACEAAAAdAAAAAgAAAAEAAAAhQAAAHQAAAAEAAAABAAAAIYAAAB0AAAADAAAAAQAAACHAAAAiAAAAHAAAAAEAAAAiQAAAIoAAAAgAAAABAAAAIsAAAB0AAAAGAAAAAQAAACMAAAAdAAAABAAAAAEAAAAjQAAAHQAAAAkAAAABAAAAI4AAACPAAAAWAAAAAQAAACQAAAAkQAAADAAAAAEAAAAkgAAAHQAAAAMAAAABAAAAJMAAAB0AAAADAAAAAQAAACUAAAAdAAAAAgAAAAEAAAAlQAAAIoAAAAgAAAABAAAAJYAAAB0AAAABAAAAAQAAACXAAAAYXNzZXJ0aW9uIGZhaWxlZDogbWlkIDw9IHNlbGYubGVuKCkvcnVzdGMvNTc0ZDM3NTY4MDI5ZjVjNjM3NTU3YTg3NDI2YWRlNTQ3NzBkOWExNC9saWJyYXJ5L2NvcmUvc3JjL3NsaWNlL21vZC5yc1tbEABNAAAA/wUAAAkAAABbWxAATQAAADYCAAAkAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZQAvcnVzdGMvNTc0ZDM3NTY4MDI5ZjVjNjM3NTU3YTg3NDI2YWRlNTQ3NzBkOWExNC9saWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwAA9FsQAEoAAADPAAAAEQAAAC9ydXN0Yy81NzRkMzc1NjgwMjlmNWM2Mzc1NTdhODc0MjZhZGU1NDc3MGQ5YTE0L2xpYnJhcnkvYWxsb2Mvc3JjL2NvbGxlY3Rpb25zL3ZlY19kZXF1ZS9tb2QucnMAAFBcEABeAAAADgIAAAkAAABQXBAAXgAAAKwCAAAOAAAABAAAAAAAAAAQAAAAAAAAAHsAAADgXBAAAQAAAPRbEAAAAAAALCAAAPRcEAACAAAAfQAAAABdEAABAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2luZGV4bWFwLTEuNy4wL3NyYy9tYXAvY29yZS5ycwAADF0QAF4AAAAqAAAAIwAAAAxdEABeAAAAdwIAAA4AAAAMXRAAXgAAACIAAAAPAAAATWF0cml4IGluZGV4IG91dCBvZiBib3VuZHMuL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL25hbGdlYnJhLTAuMjkuMC9zcmMvYmFzZS9ibGFzLnJzRG90IHByb2R1Y3QgZGltZW5zaW9ucyBtaXNtYXRjaCBmb3Igc2hhcGVzICBhbmQgOiBsZWZ0IHJvd3MgIT0gcmlnaHQgcm93cy4AAAAXXhAAKwAAAEJeEAAFAAAAR14QABoAAAC3XRAAYAAAACAAAAAJAAAASW5kZXggb3V0IG9mIGJvdW5kcy4vaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvbmFsZ2VicmEtMC4yOS4wL3NyYy9saW5hbGcvc3ltbWV0cmljX2VpZ2VuLnJzAAAAoF4QAG0AAACOAAAAFQAAAKBeEABtAAAAkAAAAB0AAACgXhAAbQAAAJEAAAAdAAAAoF4QAG0AAACSAAAAHQAAAKBeEABtAAAAlAAAABUAAACgXhAAbQAAAJ0AAAAdAAAAoF4QAG0AAAChAAAAIwAAAKBeEABtAAAAsAAAADAAAACgXhAAbQAAAMQAAAAVAAAAoF4QAG0AAADFAAAAFQAAAKBeEABtAAAAyQAAAC8AAACgXhAAbQAAAP4AAAAQAAAAoF4QAG0AAABAAAAAPgAAAKBeEABtAAAAVAAAACAAAAB0AAAACAAAAAQAAACYAAAAL3J1c3RjLzU3NGQzNzU2ODAyOWY1YzYzNzU1N2E4NzQyNmFkZTU0NzcwZDlhMTQvbGlicmFyeS9hbGxvYy9zcmMvY29sbGVjdGlvbnMvdmVjX2RlcXVlL3Jpbmdfc2xpY2VzLnJzAAAAYBAAZgAAACAAAAAOAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC43LjAvc3JjL2JvdW5kaW5nX3ZvbHVtZS9hYWJiLnJzVGhlIGxvb3NlbmluZyBtYXJnaW4gbXVzdCBiZSBwb3NpdGl2ZS4AeGAQAGkAAACwAQAACQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuNy4wL3NyYy9ib3VuZGluZ192b2x1bWUvYWFiYl91dGlscy5yc1BvaW50IGNsb3VkIEFBQkIgY29uc3RydWN0aW9uOiB0aGUgaW5wdXQgaXRlcmF0b3Igc2hvdWxkIHlpZWxkIGF0IGxlYXN0IG9uZSBwb2ludC4AAAAYYRAAbwAAAEAAAAAYAAAAGGEQAG8AAABXAAAAGAAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuNy4wL3NyYy9ib3VuZGluZ192b2x1bWUvYm91bmRpbmdfc3BoZXJlLnJz/GEQAHQAAABzAAAACQAAAHR3byBhcnJheXMgY29udGFpbmluZyBhdCBsZWFzdCAgZmxvYXRzAACAYhAAHwAAAJ9iEAAHAAAAGAAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuNy4wL3NyYy9tYXNzX3Byb3BlcnRpZXMvbWFzc19wcm9wZXJ0aWVzX2NvbnZleF9wb2x5aGVkcm9uLnJzAAC8YhAAhgAAABcAAAAXAAAAvGIQAIYAAAAYAAAAFwAAALxiEACGAAAAGQAAABcAAAC8YhAAhgAAAKUAAAASAAAAvGIQAIYAAACmAAAAEgAAALxiEACGAAAApwAAABIAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjcuMC9zcmMvcGFydGl0aW9uaW5nL3FidmgucnMAAKRjEABmAAAAyAAAAAkAAACkYxAAZgAAALYAAAANAAAApGMQAGYAAAC3AAAADQAAAKRjEABmAAAAEgEAACAAAACkYxAAZgAAABMBAAARAAAApGMQAGYAAAAVAQAAEQAAAKRjEABmAAAAMQEAABoAAACkYxAAZgAAAG0BAAAJAAAApGMQAGYAAABuAQAACQAAAKRjEABmAAAAbwEAAAkAAACkYxAAZgAAAK8BAAAYAAAApGMQAGYAAADpAQAAGAAAAKRjEABmAAAA2gIAABEAAACkYxAAZgAAANsCAAAWAAAApGMQAGYAAADdAgAADAAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuNy4wL3NyYy9xdWVyeS9jbGlwL2NsaXBfYWFiYl9saW5lLnJzAAD8ZBAAbgAAAI0AAAANAAAA/GQQAG4AAACbAAAADQAAAFRoZSBwcm94aW1pdHkgbWFyZ2luIG11c3QgYmUgcG9zaXRpdmUgb3IgbnVsbC4vaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjcuMC9zcmMvcXVlcnkvY2xvc2VzdF9wb2ludHMvY2xvc2VzdF9wb2ludHNfYmFsbF9iYWxsLnJzumUQAIIAAAAPAAAABQAAAFRoZSBjb21wb3NpdGUgc2hhcGUgbXVzdCBub3QgYmUgZW1wdHkuL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC43LjAvc3JjL3F1ZXJ5L2Nsb3Nlc3RfcG9pbnRzL2Nsb3Nlc3RfcG9pbnRzX2NvbXBvc2l0ZV9zaGFwZV9zaGFwZS5yc3JmEACOAAAAGwAAAAoAAAByZhAAjgAAAIEAAAAhAAAAcmYQAI4AAACCAAAAIQAAAHJmEACOAAAAgwAAACEAAABpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC43LjAvc3JjL3F1ZXJ5L2Nsb3Nlc3RfcG9pbnRzL2Nsb3Nlc3RfcG9pbnRzX2N1Ym9pZF9jdWJvaWQucnMAAGhnEACGAAAAUgAAAAUAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjcuMC9zcmMvcXVlcnkvY2xvc2VzdF9wb2ludHMvY2xvc2VzdF9wb2ludHNfY3Vib2lkX3RyaWFuZ2xlLnJzAGgQAIgAAABNAAAABQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuNy4wL3NyYy9xdWVyeS9jbG9zZXN0X3BvaW50cy9jbG9zZXN0X3BvaW50c19oYWxmc3BhY2Vfc3VwcG9ydF9tYXAucnMAAJhoEACOAAAADQAAAAUAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjcuMC9zcmMvcXVlcnkvY2xvc2VzdF9wb2ludHMvY2xvc2VzdF9wb2ludHNfc3VwcG9ydF9tYXBfc3VwcG9ydF9tYXAucnM4aRAAkAAAACAAAAAkAAAAdAAAABQAAAAEAAAAmQAAAJoAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjcuMC9zcmMvcXVlcnkvY29udGFjdC9jb250YWN0X3N1cHBvcnRfbWFwX3N1cHBvcnRfbWFwLnJzAADsaRAAggAAAB4AAAAkAAAAeAAAACAAAAAEAAAAeAAAACAAAAAEAAAAeQAAAJsAAACcAAAAnQAAAJ4AAACAahAAgGoQAJwAAACfAAAAoAAAAIoAAAAgAAAABAAAAIoAAAAgAAAABAAAAIsAAAChAAAAogAAAKMAAACkAAAAwGoQAMBqEACiAAAApQAAAKYAAAB4AAAAIAAAAAQAAAB4AAAAIAAAAAQAAAB9AAAApwAAAKgAAACpAAAAqgAAAABrEAAAaxAAqAAAAKsAAACsAAAAigAAACAAAAAEAAAAigAAACAAAAAEAAAAlgAAAK0AAACuAAAArwAAALAAAABAaxAAQGsQAK4AAACxAAAAsgAAAJEAAAAwAAAABAAAAJEAAAAwAAAABAAAAJIAAACzAAAAtAAAALUAAAC2AAAAgGsQAIBrEAC0AAAAtwAAALgAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjcuMC9zcmMvcXVlcnkvZGlzdGFuY2UvZGlzdGFuY2VfY29tcG9zaXRlX3NoYXBlX3NoYXBlLnJzAADAaxAAggAAABcAAAAKAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC43LjAvc3JjL3F1ZXJ5L2Rpc3RhbmNlL2Rpc3RhbmNlX3N1cHBvcnRfbWFwX3N1cHBvcnRfbWFwLnJzVGwQAIQAAAA0AAAAJAAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuNy4wL3NyYy9xdWVyeS9lcGEvZXBhMy5ycwDobBAAYwAAAEgAAAAOAAAA6GwQAGMAAABJAAAADgAAAOhsEABjAAAASgAAAA4AAADobBAAYwAAAGEAAAANAAAA6GwQAGMAAABiAAAADQAAAOhsEABjAAAAYwAAAA0AAADobBAAYwAAAHUAAAANAAAA6GwQAGMAAAB2AAAAEwAAAOhsEABjAAAAdwAAABMAAADobBAAYwAAAIgAAAANAAAA6GwQAGMAAACOAAAAHAAAAOhsEABjAAAAjgAAABMAAADobBAAYwAAAI8AAAATAAAA6GwQAGMAAACQAAAAEwAAAOhsEABjAAAAkQAAABMAAADobBAAYwAAACgBAAAbAAAA6GwQAGMAAAD3AAAAFwAAAOhsEABjAAAA+AAAABcAAADobBAAYwAAAPkAAAAXAAAA6GwQAGMAAAAUAQAAHQAAAOhsEABjAAAAFAEAADcAAADobBAAYwAAABkBAAAdAAAA6GwQAGMAAAAZAQAANwAAAOhsEABjAAAAHgEAAB0AAADobBAAYwAAAB4BAAA3AAAA6GwQAGMAAAAjAQAAHQAAAOhsEABjAAAAIwEAADcAAADobBAAYwAAAEQBAAAyAAAA6GwQAGMAAACqAQAAGgAAAOhsEABjAAAASwEAABgAAADobBAAYwAAAF8BAAAiAAAA6GwQAGMAAABkAQAADQAAAOhsEABjAAAAZgEAACIAAADobBAAYwAAAGcBAAAiAAAA6GwQAGMAAABoAQAAIgAAAOhsEABjAAAAdgEAABUAAADobBAAYwAAAIoBAAAwAAAA6GwQAGMAAACKAQAAIgAAAOhsEABjAAAAngEAAA0AAADobBAAYwAAAJ8BAAAjAAAA6GwQAGMAAACwAQAADQAAAOhsEABjAAAAuQEAABwAAADobBAAYwAAAL0BAAAVAAAA6GwQAGMAAAC/AQAAFQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuNy4wL3NyYy9xdWVyeS9namsvZ2prLnJzAAAMcBAAYgAAAEMAAAAOAAAAYXNzZXJ0aW9uIGZhaWxlZDogbWluX2JvdW5kID09IG1pbl9ib3VuZAxwEABiAAAAjAAAAAkAAAAMcBAAYgAAAE8BAAAJAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC43LjAvc3JjL3F1ZXJ5L2dqay92b3Jvbm9pX3NpbXBsZXgzLnJzAMhwEABvAAAATQAAABIAAADIcBAAbwAAAFEAAAAJAAAAyHAQAG8AAABYAAAACQAAAMhwEABvAAAAXQAAAAkAAADIcBAAbwAAAF4AAAAKAAAAyHAQAG8AAABkAAAACQAAAMhwEABvAAAAagAAAAoAAABhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmRpbSA9PSAzAMhwEABvAAAAuQAAAA0AAADIcBAAbwAAAA4BAAAeAAAAyHAQAG8AAADlAAAAHgAAAMhwEABvAAAAiwAAABYAAADIcBAAbwAAAFwBAAAUAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC43LjAvc3JjL3F1ZXJ5L2ludGVyc2VjdGlvbl90ZXN0L2ludGVyc2VjdGlvbl90ZXN0X3N1cHBvcnRfbWFwX3N1cHBvcnRfbWFwLnJzAAAYchAAlgAAADkAAAApAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC43LjAvc3JjL3F1ZXJ5L25vbmxpbmVhcl90aW1lX29mX2ltcGFjdC9ub25saW5lYXJfdGltZV9vZl9pbXBhY3RfY29tcG9zaXRlX3NoYXBlX3NoYXBlLnJzAAB0AAAABAAAAAQAAAC5AAAAugAAALsAAAC8AAAAvQAAAL4AAAC/AAAAwAAAAHQAAAAEAAAABAAAAIYAAADBAAAAwgAAAMMAAADEAAAAdAAAAAQAAAAEAAAAdAAAAAQAAAAEAAAAhgAAAMEAAADCAAAAwwAAAMQAAACwcxAAsHMQAMIAAAB0AAAABAAAAAQAAADFAAAAxgAAAMcAAADIAAAAyQAAAMoAAAC5AAAAugAAALsAAAC8AAAAvQAAAL4AAAC/AAAAwAAAAGRzEACGAAAAWFoQAMEAAADCAAAAwwAAAMQAAACQcxAAsHMQALBzEADCAAAAvHMQAMsAAADMAAAAzQAAAM4AAADPAAAA0AAAANEAAADSAAAA0wAAANQAAADVAAAA1gAAANcAAADYAAAA2QAAANoAAADAchAAogAAAMMAAAAVAAAAwHIQAKIAAACbAAAAKgAAAMByEACiAAAAvAAAACEAAADAchAAogAAAL0AAAAhAAAAwHIQAKIAAAC+AAAAIQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuNy4wL3NyYy9xdWVyeS9ub25saW5lYXJfdGltZV9vZl9pbXBhY3Qvbm9ubGluZWFyX3RpbWVfb2ZfaW1wYWN0X3N1cHBvcnRfbWFwX3N1cHBvcnRfbWFwLnJz7HQQAKQAAADHAAAAKAAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuNy4wL3NyYy9xdWVyeS9wb2ludC9wb2ludF9jb21wb3NpdGVfc2hhcGUucnMAAKB1EAB2AAAAHQAAAFMAAACgdRAAdgAAADoAAABUAAAAoHUQAHYAAABNAAAANwAAAKB1EAB2AAAAawAAADcAAACgdRAAdgAAAHoAAAA3AAAAYXNzZXJ0aW9uIGZhaWxlZDogc3FuYWIgIT0gMC4wL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC43LjAvc3JjL3F1ZXJ5L3BvaW50L3BvaW50X3NlZ21lbnQucnOGdhAAbgAAAEgAAAANAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL3BhcnJ5M2QtMC43LjAvc3JjL3F1ZXJ5L3BvaW50L3BvaW50X3RldHJhaGVkcm9uLnJzYXNzZXJ0aW9uIGZhaWxlZDogZGVub20gIT0gXzAABHcQAHIAAAAfAQAAFQAAAHQAAAAEAAAABAAAANsAAADcAAAAdAAAABwAAAAEAAAA3QAAAN4AAAB0AAAACAAAAAQAAADfAAAA4AAAAHQAAAAIAAAABAAAAOEAAADiAAAAdAAAABwAAAAEAAAA4wAAAOQAAAB0AAAACAAAAAQAAADlAAAA5gAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuNy4wL3NyYy9zaGFwZS9jdWJvaWQucnMAAAAceBAAYQAAAJcAAAASAAAAHHgQAGEAAACtAAAAEgAAABx4EABhAAAAqQAAABIAAAAceBAAYQAAAKUAAAASAAAAHHgQAGEAAAAKAQAAFQAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9w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AAAACQAAAKieEAB/AAAAWAAAABIAAAConhAAfwAAAFkAAAASAAAAqJ4QAH8AAABwAAAAFgAAAKieEAB/AAAAcQAAABYAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjcuMC9zcmMvdHJhbnNmb3JtYXRpb24vY29udmV4X2h1bGwzL3ZhbGlkYXRpb24ucnMABKAQAHsAAAAGAAAAEgAAAASgEAB7AAAACQAAABEAAABhc3NlcnRpb24gZmFpbGVkOiBmYWNldHNbZmFjZXQuYWRqW2ldXS52YWxpZASgEAB7AAAACQAAAAkAAAAEoBAAewAAAA0AAAAaAAAABKAQAHsAAAAPAAAAFAAAAASgEAB7AAAADwAAAAkAAAAEoBAAewAAABAAAAAJAAAABKAQAHsAAAARAAAACQAAAASgEAB7AAAAFQAAAAkAAAAvaG9tZS9zZWJjcm96ZXQvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvcGFycnkzZC0wLjcuMC9zcmMvdHJhbnNmb3JtYXRpb24vY29udmV4X2h1bGxfdXRpbHMucnMAAAA8oRAAdQAAACkAAAAiAAAAPKEQAHUAAABCAAAAIgAAAC9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuNy4wL3NyYy90cmFuc2Zvcm1hdGlvbi90b190cmltZXNoL2NvbnZleF9wb2x5aGVkcm9uX3RvX3RyaW1lc2gucnMA1KEQAIsAAAANAAAAHAAAANShEACLAAAADwAAABgAAABDYW5ub3QgY29tcHV0ZSB0aGUgY2VudGVyIG9mIGxlc3MgdGhhbiAxIHBvaW50Li9ob21lL3NlYmNyb3pldC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9wYXJyeTNkLTAuNy4wL3NyYy91dGlscy9jZW50ZXIucnOvohAAYQAAAAcAAAAFAAAAL2hvbWUvc2ViY3JvemV0Ly5jYXJnby9yZWdpc3RyeS9z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LwAAAA0AAAAJAAAAY29uZHZhciB3YWl0IG5vdCBzdXBwb3J0ZWRsaWJyYXJ5L3N0ZC9zcmMvc3lzL3dhc20vLi4vdW5zdXBwb3J0ZWQvY29uZHZhci5yc/KtEAAyAAAAFwAAAAkAAADyrRAAMgAAABsAAAAJAAAAY2Fubm90IHJlY3Vyc2l2ZWx5IGFjcXVpcmUgbXV0ZXhErhAAIAAAAGxpYnJhcnkvc3RkL3NyYy9zeXMvd2FzbS8uLi91bnN1cHBvcnRlZC9tdXRleC5yc2yuEAAwAAAAFwAAAAkAAABIYXNoIHRhYmxlIGNhcGFjaXR5IG92ZXJmbG93L2NhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvaGFzaGJyb3duLTAuMTEuMC9zcmMvcmF3L21vZC5ycwDIrhAATwAAAGMAAAAoAAAA/////1kDAAAEAAAABAAAAFoDAABbAwAAXAMAAC9ydXN0Yy81NzRkMzc1NjgwMjlmNWM2Mzc1NTdhODc0MjZhZGU1NDc3MGQ5YTE0L2xpYnJhcnkvY29yZS9zcmMvZm10L21vZC5ycwBErxAASwAAAHcBAAATAAAAWQMAAAAAAAABAAAAFAAAAGEgZm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvcmxpYnJhcnkvYWxsb2Mvc3JjL2ZtdC5ycwDjrxAAGAAAAEcCAAAcAAAAbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc2NhcGFjaXR5IG92ZXJmbG93AAAADLAQABwAAAAvAgAABQAAAHN3YXBfcmVtb3ZlIGluZGV4IChpcyApIHNob3VsZCBiZSA8IGxlbiAoaXMgKQAAAEywEAAWAAAAYrAQABYAAAB4sBAAAQAAAGxpYnJhcnkvYWxsb2Mvc3JjL3ZlYy9tb2QucnOUsBAAHAAAAA8FAAANAAAAcmVtb3ZhbCBpbmRleCAoaXMgAADAsBAAEgAAAGKwEAAWAAAAeLAQAAEAAABhc3NlcnRpb24gZmFpbGVkOiBlZGVsdGEgPj0gMGxpYnJhcnkvY29yZS9zcmMvbnVtL2RpeV9mbG9hdC5ycwAACbEQACEAAABMAAAACQAAAAmxEAAhAAAATgAAAAkAAAABAAAA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").buffer)];
        case 1:
          return A2.sent(), [2];
      }
    });
  });
}
function FI() {
  return function() {
    try {
      const C2 = A.__wbindgen_add_to_stack_pointer(-16);
      A.version(C2);
      var I2 = w()[C2 / 4 + 0], g2 = w()[C2 / 4 + 1];
      return o(I2, g2);
    } finally {
      A.__wbindgen_add_to_stack_pointer(16), A.__wbindgen_free(I2, g2);
    }
  }();
}
SI["-".charCodeAt(0)] = 62, SI["_".charCodeAt(0)] = 63;
Object.freeze({__proto__: null, version: FI, Vector3: AA, VectorOps: IA, Quaternion: gA, RotationOps: CA, get RigidBodyType() {
  return $;
}, RigidBody: EA, RigidBodyDesc: iA, RigidBodySet: DA, IntegrationParameters: oA, get JointType() {
  return BA;
}, get SpringModel() {
  return QA;
}, Joint: JA, UnitJoint: KA, FixedJoint: MA, PrismaticJoint: FA, BallJoint: hA, RevoluteJoint: aA, JointParams: yA, JointSet: qA, get CoefficientCombineRule() {
  return UA;
}, CCDSolver: RA, IslandManager: sA, BroadPhase: YA, NarrowPhase: cA, TempContactManifold: lA, get ShapeType() {
  return NA;
}, Ball: HA, Cuboid: pA, RoundCuboid: tA, Capsule: TA, Segment: nA, Triangle: eA, RoundTriangle: OA, Polyline: rA, TriMesh: dA, ConvexPolyhedron: ZA, RoundConvexPolyhedron: fA, Heightfield: WA, Cylinder: jA, RoundCylinder: bA, Cone: xA, RoundCone: XA, get ActiveCollisionTypes() {
  return LA;
}, Collider: mA, ColliderDesc: uA, ColliderSet: PA, Ray: zA, RayColliderIntersection: vA, RayColliderToi: _A, PointColliderProjection: $A, ShapeColliderTOI: AI, World: BI, PhysicsPipeline: II, SerializationPipeline: CI, get ActiveEvents() {
  return VA;
}, EventQueue: iI, get ActiveHooks() {
  return QI;
}, get SolverFlags() {
  return EI;
}, init: MI});
var GLTFLoader = function() {
  function GLTFLoader2(manager) {
    Loader.call(this, manager);
    this.dracoLoader = null;
    this.ktx2Loader = null;
    this.meshoptDecoder = null;
    this.pluginCallbacks = [];
    this.register(function(parser) {
      return new GLTFMaterialsClearcoatExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureBasisUExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureWebPExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsTransmissionExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFLightsExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshoptCompression(parser);
    });
  }
  GLTFLoader2.prototype = Object.assign(Object.create(Loader.prototype), {
    constructor: GLTFLoader2,
    load: function(url, onLoad, onProgress, onError) {
      var scope = this;
      var resourcePath;
      if (this.resourcePath !== "") {
        resourcePath = this.resourcePath;
      } else if (this.path !== "") {
        resourcePath = this.path;
      } else {
        resourcePath = LoaderUtils.extractUrlBase(url);
      }
      this.manager.itemStart(url);
      var _onError = function(e2) {
        if (onError) {
          onError(e2);
        } else {
          console.error(e2);
        }
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      };
      var loader = new FileLoader(this.manager);
      loader.setPath(this.path);
      loader.setResponseType("arraybuffer");
      loader.setRequestHeader(this.requestHeader);
      loader.setWithCredentials(this.withCredentials);
      loader.load(url, function(data) {
        try {
          scope.parse(data, resourcePath, function(gltf) {
            onLoad(gltf);
            scope.manager.itemEnd(url);
          }, _onError);
        } catch (e2) {
          _onError(e2);
        }
      }, onProgress, _onError);
    },
    setDRACOLoader: function(dracoLoader) {
      this.dracoLoader = dracoLoader;
      return this;
    },
    setDDSLoader: function() {
      throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
    },
    setKTX2Loader: function(ktx2Loader) {
      this.ktx2Loader = ktx2Loader;
      return this;
    },
    setMeshoptDecoder: function(meshoptDecoder) {
      this.meshoptDecoder = meshoptDecoder;
      return this;
    },
    register: function(callback) {
      if (this.pluginCallbacks.indexOf(callback) === -1) {
        this.pluginCallbacks.push(callback);
      }
      return this;
    },
    unregister: function(callback) {
      if (this.pluginCallbacks.indexOf(callback) !== -1) {
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
      }
      return this;
    },
    parse: function(data, path, onLoad, onError) {
      var content;
      var extensions = {};
      var plugins = {};
      if (typeof data === "string") {
        content = data;
      } else {
        var magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));
        if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
          try {
            extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
          } catch (error) {
            if (onError)
              onError(error);
            return;
          }
          content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;
        } else {
          content = LoaderUtils.decodeText(new Uint8Array(data));
        }
      }
      var json = JSON.parse(content);
      if (json.asset === void 0 || json.asset.version[0] < 2) {
        if (onError)
          onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
        return;
      }
      var parser = new GLTFParser(json, {
        path: path || this.resourcePath || "",
        crossOrigin: this.crossOrigin,
        requestHeader: this.requestHeader,
        manager: this.manager,
        ktx2Loader: this.ktx2Loader,
        meshoptDecoder: this.meshoptDecoder
      });
      parser.fileLoader.setRequestHeader(this.requestHeader);
      for (var i2 = 0; i2 < this.pluginCallbacks.length; i2++) {
        var plugin = this.pluginCallbacks[i2](parser);
        plugins[plugin.name] = plugin;
        extensions[plugin.name] = true;
      }
      if (json.extensionsUsed) {
        for (var i2 = 0; i2 < json.extensionsUsed.length; ++i2) {
          var extensionName = json.extensionsUsed[i2];
          var extensionsRequired = json.extensionsRequired || [];
          switch (extensionName) {
            case EXTENSIONS.KHR_MATERIALS_UNLIT:
              extensions[extensionName] = new GLTFMaterialsUnlitExtension();
              break;
            case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
              extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();
              break;
            case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
              extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
              break;
            case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
              extensions[extensionName] = new GLTFTextureTransformExtension();
              break;
            case EXTENSIONS.KHR_MESH_QUANTIZATION:
              extensions[extensionName] = new GLTFMeshQuantizationExtension();
              break;
            default:
              if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
                console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
              }
          }
        }
      }
      parser.setExtensions(extensions);
      parser.setPlugins(plugins);
      parser.parse(onLoad, onError);
    }
  });
  function GLTFRegistry() {
    var objects = {};
    return {
      get: function(key) {
        return objects[key];
      },
      add: function(key, object) {
        objects[key] = object;
      },
      remove: function(key) {
        delete objects[key];
      },
      removeAll: function() {
        objects = {};
      }
    };
  }
  var EXTENSIONS = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
  };
  function GLTFLightsExtension(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
    this.cache = {refs: {}, uses: {}};
  }
  GLTFLightsExtension.prototype._markDefs = function() {
    var parser = this.parser;
    var nodeDefs = this.parser.json.nodes || [];
    for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      var nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
      }
    }
  };
  GLTFLightsExtension.prototype._loadLight = function(lightIndex) {
    var parser = this.parser;
    var cacheKey = "light:" + lightIndex;
    var dependency = parser.cache.get(cacheKey);
    if (dependency)
      return dependency;
    var json = parser.json;
    var extensions = json.extensions && json.extensions[this.name] || {};
    var lightDefs = extensions.lights || [];
    var lightDef = lightDefs[lightIndex];
    var lightNode;
    var color = new Color(16777215);
    if (lightDef.color !== void 0)
      color.fromArray(lightDef.color);
    var range = lightDef.range !== void 0 ? lightDef.range : 0;
    switch (lightDef.type) {
      case "directional":
        lightNode = new DirectionalLight(color);
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      case "point":
        lightNode = new PointLight(color);
        lightNode.distance = range;
        break;
      case "spot":
        lightNode = new SpotLight(color);
        lightNode.distance = range;
        lightDef.spot = lightDef.spot || {};
        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
        lightNode.angle = lightDef.spot.outerConeAngle;
        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
    }
    lightNode.position.set(0, 0, 0);
    lightNode.decay = 2;
    if (lightDef.intensity !== void 0)
      lightNode.intensity = lightDef.intensity;
    lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
    dependency = Promise.resolve(lightNode);
    parser.cache.add(cacheKey, dependency);
    return dependency;
  };
  GLTFLightsExtension.prototype.createNodeAttachment = function(nodeIndex) {
    var self2 = this;
    var parser = this.parser;
    var json = parser.json;
    var nodeDef = json.nodes[nodeIndex];
    var lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
    var lightIndex = lightDef.light;
    if (lightIndex === void 0)
      return null;
    return this._loadLight(lightIndex).then(function(light) {
      return parser._getNodeRef(self2.cache, lightIndex, light);
    });
  };
  function GLTFMaterialsUnlitExtension() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  GLTFMaterialsUnlitExtension.prototype.getMaterialType = function() {
    return MeshBasicMaterial;
  };
  GLTFMaterialsUnlitExtension.prototype.extendParams = function(materialParams, materialDef, parser) {
    var pending = [];
    materialParams.color = new Color(1, 1, 1);
    materialParams.opacity = 1;
    var metallicRoughness = materialDef.pbrMetallicRoughness;
    if (metallicRoughness) {
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        var array = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture));
      }
    }
    return Promise.all(pending);
  };
  function GLTFMaterialsClearcoatExtension(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
  }
  GLTFMaterialsClearcoatExtension.prototype.getMaterialType = function(materialIndex) {
    var parser = this.parser;
    var materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  };
  GLTFMaterialsClearcoatExtension.prototype.extendMaterialParams = function(materialIndex, materialParams) {
    var parser = this.parser;
    var materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    var pending = [];
    var extension = materialDef.extensions[this.name];
    if (extension.clearcoatFactor !== void 0) {
      materialParams.clearcoat = extension.clearcoatFactor;
    }
    if (extension.clearcoatTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
    }
    if (extension.clearcoatRoughnessFactor !== void 0) {
      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
    }
    if (extension.clearcoatRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
    }
    if (extension.clearcoatNormalTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
      if (extension.clearcoatNormalTexture.scale !== void 0) {
        var scale = extension.clearcoatNormalTexture.scale;
        materialParams.clearcoatNormalScale = new Vector2(scale, -scale);
      }
    }
    return Promise.all(pending);
  };
  function GLTFMaterialsTransmissionExtension(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
  }
  GLTFMaterialsTransmissionExtension.prototype.getMaterialType = function(materialIndex) {
    var parser = this.parser;
    var materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  };
  GLTFMaterialsTransmissionExtension.prototype.extendMaterialParams = function(materialIndex, materialParams) {
    var parser = this.parser;
    var materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    var pending = [];
    var extension = materialDef.extensions[this.name];
    if (extension.transmissionFactor !== void 0) {
      materialParams.transmission = extension.transmissionFactor;
    }
    if (extension.transmissionTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
    }
    return Promise.all(pending);
  };
  function GLTFTextureBasisUExtension(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
  }
  GLTFTextureBasisUExtension.prototype.loadTexture = function(textureIndex) {
    var parser = this.parser;
    var json = parser.json;
    var textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[this.name]) {
      return null;
    }
    var extension = textureDef.extensions[this.name];
    var source = json.images[extension.source];
    var loader = parser.options.ktx2Loader;
    if (!loader) {
      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      } else {
        return null;
      }
    }
    return parser.loadTextureImage(textureIndex, source, loader);
  };
  function GLTFTextureWebPExtension(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
    this.isSupported = null;
  }
  GLTFTextureWebPExtension.prototype.loadTexture = function(textureIndex) {
    var name = this.name;
    var parser = this.parser;
    var json = parser.json;
    var textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    var extension = textureDef.extensions[name];
    var source = json.images[extension.source];
    var loader = parser.textureLoader;
    if (source.uri) {
      var handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null)
        loader = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported)
        return parser.loadTextureImage(textureIndex, source, loader);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  };
  GLTFTextureWebPExtension.prototype.detectSupport = function() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve) {
        var image = new Image();
        image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
        image.onload = image.onerror = function() {
          resolve(image.height === 1);
        };
      });
    }
    return this.isSupported;
  };
  function GLTFMeshoptCompression(parser) {
    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
    this.parser = parser;
  }
  GLTFMeshoptCompression.prototype.loadBufferView = function(index) {
    var json = this.parser.json;
    var bufferView = json.bufferViews[index];
    if (bufferView.extensions && bufferView.extensions[this.name]) {
      var extensionDef = bufferView.extensions[this.name];
      var buffer = this.parser.getDependency("buffer", extensionDef.buffer);
      var decoder = this.parser.options.meshoptDecoder;
      if (!decoder || !decoder.supported) {
        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        } else {
          return null;
        }
      }
      return Promise.all([buffer, decoder.ready]).then(function(res) {
        var byteOffset = extensionDef.byteOffset || 0;
        var byteLength = extensionDef.byteLength || 0;
        var count = extensionDef.count;
        var stride = extensionDef.byteStride;
        var result = new ArrayBuffer(count * stride);
        var source = new Uint8Array(res[0], byteOffset, byteLength);
        decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
        return result;
      });
    } else {
      return null;
    }
  };
  var BINARY_EXTENSION_HEADER_MAGIC = "glTF";
  var BINARY_EXTENSION_HEADER_LENGTH = 12;
  var BINARY_EXTENSION_CHUNK_TYPES = {JSON: 1313821514, BIN: 5130562};
  function GLTFBinaryExtension(data) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF;
    this.content = null;
    this.body = null;
    var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
    this.header = {
      magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
      version: headerView.getUint32(4, true),
      length: headerView.getUint32(8, true)
    };
    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    } else if (this.header.version < 2) {
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    }
    var chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
    var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
    var chunkIndex = 0;
    while (chunkIndex < chunkContentsLength) {
      var chunkLength = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      var chunkType = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
        this.content = LoaderUtils.decodeText(contentArray);
      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
        this.body = data.slice(byteOffset, byteOffset + chunkLength);
      }
      chunkIndex += chunkLength;
    }
    if (this.content === null) {
      throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
  function GLTFDracoMeshCompressionExtension(json, dracoLoader) {
    if (!dracoLoader) {
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    }
    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
    this.json = json;
    this.dracoLoader = dracoLoader;
    this.dracoLoader.preload();
  }
  GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function(primitive, parser) {
    var json = this.json;
    var dracoLoader = this.dracoLoader;
    var bufferViewIndex = primitive.extensions[this.name].bufferView;
    var gltfAttributeMap = primitive.extensions[this.name].attributes;
    var threeAttributeMap = {};
    var attributeNormalizedMap = {};
    var attributeTypeMap = {};
    for (var attributeName in gltfAttributeMap) {
      var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
    }
    for (attributeName in primitive.attributes) {
      var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      if (gltfAttributeMap[attributeName] !== void 0) {
        var accessorDef = json.accessors[primitive.attributes[attributeName]];
        var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        attributeTypeMap[threeAttributeName] = componentType;
        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
      }
    }
    return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
      return new Promise(function(resolve) {
        dracoLoader.decodeDracoFile(bufferView, function(geometry) {
          for (var attributeName2 in geometry.attributes) {
            var attribute = geometry.attributes[attributeName2];
            var normalized = attributeNormalizedMap[attributeName2];
            if (normalized !== void 0)
              attribute.normalized = normalized;
          }
          resolve(geometry);
        }, threeAttributeMap, attributeTypeMap);
      });
    });
  };
  function GLTFTextureTransformExtension() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }
  GLTFTextureTransformExtension.prototype.extendTexture = function(texture, transform) {
    texture = texture.clone();
    if (transform.offset !== void 0) {
      texture.offset.fromArray(transform.offset);
    }
    if (transform.rotation !== void 0) {
      texture.rotation = transform.rotation;
    }
    if (transform.scale !== void 0) {
      texture.repeat.fromArray(transform.scale);
    }
    if (transform.texCoord !== void 0) {
      console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.');
    }
    texture.needsUpdate = true;
    return texture;
  };
  function GLTFMeshStandardSGMaterial(params) {
    MeshStandardMaterial.call(this);
    this.isGLTFSpecularGlossinessMaterial = true;
    var specularMapParsFragmentChunk = [
      "#ifdef USE_SPECULARMAP",
      "	uniform sampler2D specularMap;",
      "#endif"
    ].join("\n");
    var glossinessMapParsFragmentChunk = [
      "#ifdef USE_GLOSSINESSMAP",
      "	uniform sampler2D glossinessMap;",
      "#endif"
    ].join("\n");
    var specularMapFragmentChunk = [
      "vec3 specularFactor = specular;",
      "#ifdef USE_SPECULARMAP",
      "	vec4 texelSpecular = texture2D( specularMap, vUv );",
      "	texelSpecular = sRGBToLinear( texelSpecular );",
      "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
      "	specularFactor *= texelSpecular.rgb;",
      "#endif"
    ].join("\n");
    var glossinessMapFragmentChunk = [
      "float glossinessFactor = glossiness;",
      "#ifdef USE_GLOSSINESSMAP",
      "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );",
      "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
      "	glossinessFactor *= texelGlossiness.a;",
      "#endif"
    ].join("\n");
    var lightPhysicalFragmentChunk = [
      "PhysicalMaterial material;",
      "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
      "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
      "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
      "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
      "material.specularRoughness += geometryRoughness;",
      "material.specularRoughness = min( material.specularRoughness, 1.0 );",
      "material.specularColor = specularFactor;"
    ].join("\n");
    var uniforms = {
      specular: {value: new Color().setHex(16777215)},
      glossiness: {value: 1},
      specularMap: {value: null},
      glossinessMap: {value: null}
    };
    this._extraUniforms = uniforms;
    this.onBeforeCompile = function(shader) {
      for (var uniformName in uniforms) {
        shader.uniforms[uniformName] = uniforms[uniformName];
      }
      shader.fragmentShader = shader.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", specularMapParsFragmentChunk).replace("#include <metalnessmap_pars_fragment>", glossinessMapParsFragmentChunk).replace("#include <roughnessmap_fragment>", specularMapFragmentChunk).replace("#include <metalnessmap_fragment>", glossinessMapFragmentChunk).replace("#include <lights_physical_fragment>", lightPhysicalFragmentChunk);
    };
    Object.defineProperties(this, {
      specular: {
        get: function() {
          return uniforms.specular.value;
        },
        set: function(v2) {
          uniforms.specular.value = v2;
        }
      },
      specularMap: {
        get: function() {
          return uniforms.specularMap.value;
        },
        set: function(v2) {
          uniforms.specularMap.value = v2;
          if (v2) {
            this.defines.USE_SPECULARMAP = "";
          } else {
            delete this.defines.USE_SPECULARMAP;
          }
        }
      },
      glossiness: {
        get: function() {
          return uniforms.glossiness.value;
        },
        set: function(v2) {
          uniforms.glossiness.value = v2;
        }
      },
      glossinessMap: {
        get: function() {
          return uniforms.glossinessMap.value;
        },
        set: function(v2) {
          uniforms.glossinessMap.value = v2;
          if (v2) {
            this.defines.USE_GLOSSINESSMAP = "";
            this.defines.USE_UV = "";
          } else {
            delete this.defines.USE_GLOSSINESSMAP;
            delete this.defines.USE_UV;
          }
        }
      }
    });
    delete this.metalness;
    delete this.roughness;
    delete this.metalnessMap;
    delete this.roughnessMap;
    this.setValues(params);
  }
  GLTFMeshStandardSGMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
  GLTFMeshStandardSGMaterial.prototype.constructor = GLTFMeshStandardSGMaterial;
  GLTFMeshStandardSGMaterial.prototype.copy = function(source) {
    MeshStandardMaterial.prototype.copy.call(this, source);
    this.specularMap = source.specularMap;
    this.specular.copy(source.specular);
    this.glossinessMap = source.glossinessMap;
    this.glossiness = source.glossiness;
    delete this.metalness;
    delete this.roughness;
    delete this.metalnessMap;
    delete this.roughnessMap;
    return this;
  };
  function GLTFMaterialsPbrSpecularGlossinessExtension() {
    return {
      name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
      specularGlossinessParams: [
        "color",
        "map",
        "lightMap",
        "lightMapIntensity",
        "aoMap",
        "aoMapIntensity",
        "emissive",
        "emissiveIntensity",
        "emissiveMap",
        "bumpMap",
        "bumpScale",
        "normalMap",
        "normalMapType",
        "displacementMap",
        "displacementScale",
        "displacementBias",
        "specularMap",
        "specular",
        "glossinessMap",
        "glossiness",
        "alphaMap",
        "envMap",
        "envMapIntensity",
        "refractionRatio"
      ],
      getMaterialType: function() {
        return GLTFMeshStandardSGMaterial;
      },
      extendParams: function(materialParams, materialDef, parser) {
        var pbrSpecularGlossiness = materialDef.extensions[this.name];
        materialParams.color = new Color(1, 1, 1);
        materialParams.opacity = 1;
        var pending = [];
        if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {
          var array = pbrSpecularGlossiness.diffuseFactor;
          materialParams.color.fromArray(array);
          materialParams.opacity = array[3];
        }
        if (pbrSpecularGlossiness.diffuseTexture !== void 0) {
          pending.push(parser.assignTexture(materialParams, "map", pbrSpecularGlossiness.diffuseTexture));
        }
        materialParams.emissive = new Color(0, 0, 0);
        materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== void 0 ? pbrSpecularGlossiness.glossinessFactor : 1;
        materialParams.specular = new Color(1, 1, 1);
        if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {
          materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);
        }
        if (pbrSpecularGlossiness.specularGlossinessTexture !== void 0) {
          var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
          pending.push(parser.assignTexture(materialParams, "glossinessMap", specGlossMapDef));
          pending.push(parser.assignTexture(materialParams, "specularMap", specGlossMapDef));
        }
        return Promise.all(pending);
      },
      createMaterial: function(materialParams) {
        var material = new GLTFMeshStandardSGMaterial(materialParams);
        material.fog = true;
        material.color = materialParams.color;
        material.map = materialParams.map === void 0 ? null : materialParams.map;
        material.lightMap = null;
        material.lightMapIntensity = 1;
        material.aoMap = materialParams.aoMap === void 0 ? null : materialParams.aoMap;
        material.aoMapIntensity = 1;
        material.emissive = materialParams.emissive;
        material.emissiveIntensity = 1;
        material.emissiveMap = materialParams.emissiveMap === void 0 ? null : materialParams.emissiveMap;
        material.bumpMap = materialParams.bumpMap === void 0 ? null : materialParams.bumpMap;
        material.bumpScale = 1;
        material.normalMap = materialParams.normalMap === void 0 ? null : materialParams.normalMap;
        material.normalMapType = TangentSpaceNormalMap;
        if (materialParams.normalScale)
          material.normalScale = materialParams.normalScale;
        material.displacementMap = null;
        material.displacementScale = 1;
        material.displacementBias = 0;
        material.specularMap = materialParams.specularMap === void 0 ? null : materialParams.specularMap;
        material.specular = materialParams.specular;
        material.glossinessMap = materialParams.glossinessMap === void 0 ? null : materialParams.glossinessMap;
        material.glossiness = materialParams.glossiness;
        material.alphaMap = null;
        material.envMap = materialParams.envMap === void 0 ? null : materialParams.envMap;
        material.envMapIntensity = 1;
        material.refractionRatio = 0.98;
        return material;
      }
    };
  }
  function GLTFMeshQuantizationExtension() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
  function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  GLTFCubicSplineInterpolant.prototype = Object.create(Interpolant.prototype);
  GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;
  GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function(index) {
    var result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
    for (var i2 = 0; i2 !== valueSize; i2++) {
      result[i2] = values[offset + i2];
    }
    return result;
  };
  GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
  GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
  GLTFCubicSplineInterpolant.prototype.interpolate_ = function(i1, t0, t2, t1) {
    var result = this.resultBuffer;
    var values = this.sampleValues;
    var stride = this.valueSize;
    var stride2 = stride * 2;
    var stride3 = stride * 3;
    var td = t1 - t0;
    var p2 = (t2 - t0) / td;
    var pp = p2 * p2;
    var ppp = pp * p2;
    var offset1 = i1 * stride3;
    var offset0 = offset1 - stride3;
    var s2 = -2 * ppp + 3 * pp;
    var s3 = ppp - pp;
    var s0 = 1 - s2;
    var s1 = s3 - pp + p2;
    for (var i2 = 0; i2 !== stride; i2++) {
      var p0 = values[offset0 + i2 + stride];
      var m0 = values[offset0 + i2 + stride2] * td;
      var p1 = values[offset1 + i2 + stride];
      var m1 = values[offset1 + i2] * td;
      result[i2] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
    }
    return result;
  };
  var WEBGL_CONSTANTS = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123
  };
  var WEBGL_COMPONENT_TYPES = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  };
  var WEBGL_FILTERS = {
    9728: NearestFilter,
    9729: LinearFilter,
    9984: NearestMipmapNearestFilter,
    9985: LinearMipmapNearestFilter,
    9986: NearestMipmapLinearFilter,
    9987: LinearMipmapLinearFilter
  };
  var WEBGL_WRAPPINGS = {
    33071: ClampToEdgeWrapping,
    33648: MirroredRepeatWrapping,
    10497: RepeatWrapping
  };
  var WEBGL_TYPE_SIZES = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var ATTRIBUTES = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
  };
  var PATH_PROPERTIES = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
  };
  var INTERPOLATION = {
    CUBICSPLINE: void 0,
    LINEAR: InterpolateLinear,
    STEP: InterpolateDiscrete
  };
  var ALPHA_MODES = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
  };
  function resolveURL(url, path) {
    if (typeof url !== "string" || url === "")
      return "";
    if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
      path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
    }
    if (/^(https?:)?\/\//i.test(url))
      return url;
    if (/^data:.*,.*$/i.test(url))
      return url;
    if (/^blob:.*$/i.test(url))
      return url;
    return path + url;
  }
  function createDefaultMaterial(cache) {
    if (cache["DefaultMaterial"] === void 0) {
      cache["DefaultMaterial"] = new MeshStandardMaterial({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: false,
        depthTest: true,
        side: FrontSide
      });
    }
    return cache["DefaultMaterial"];
  }
  function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
    for (var name in objectDef.extensions) {
      if (knownExtensions[name] === void 0) {
        object.userData.gltfExtensions = object.userData.gltfExtensions || {};
        object.userData.gltfExtensions[name] = objectDef.extensions[name];
      }
    }
  }
  function assignExtrasToUserData(object, gltfDef) {
    if (gltfDef.extras !== void 0) {
      if (typeof gltfDef.extras === "object") {
        Object.assign(object.userData, gltfDef.extras);
      } else {
        console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
      }
    }
  }
  function addMorphTargets(geometry, targets, parser) {
    var hasMorphPosition = false;
    var hasMorphNormal = false;
    for (var i2 = 0, il = targets.length; i2 < il; i2++) {
      var target = targets[i2];
      if (target.POSITION !== void 0)
        hasMorphPosition = true;
      if (target.NORMAL !== void 0)
        hasMorphNormal = true;
      if (hasMorphPosition && hasMorphNormal)
        break;
    }
    if (!hasMorphPosition && !hasMorphNormal)
      return Promise.resolve(geometry);
    var pendingPositionAccessors = [];
    var pendingNormalAccessors = [];
    for (var i2 = 0, il = targets.length; i2 < il; i2++) {
      var target = targets[i2];
      if (hasMorphPosition) {
        var pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
        pendingPositionAccessors.push(pendingAccessor);
      }
      if (hasMorphNormal) {
        var pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
        pendingNormalAccessors.push(pendingAccessor);
      }
    }
    return Promise.all([
      Promise.all(pendingPositionAccessors),
      Promise.all(pendingNormalAccessors)
    ]).then(function(accessors) {
      var morphPositions = accessors[0];
      var morphNormals = accessors[1];
      if (hasMorphPosition)
        geometry.morphAttributes.position = morphPositions;
      if (hasMorphNormal)
        geometry.morphAttributes.normal = morphNormals;
      geometry.morphTargetsRelative = true;
      return geometry;
    });
  }
  function updateMorphTargets(mesh, meshDef) {
    mesh.updateMorphTargets();
    if (meshDef.weights !== void 0) {
      for (var i2 = 0, il = meshDef.weights.length; i2 < il; i2++) {
        mesh.morphTargetInfluences[i2] = meshDef.weights[i2];
      }
    }
    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
      var targetNames = meshDef.extras.targetNames;
      if (mesh.morphTargetInfluences.length === targetNames.length) {
        mesh.morphTargetDictionary = {};
        for (var i2 = 0, il = targetNames.length; i2 < il; i2++) {
          mesh.morphTargetDictionary[targetNames[i2]] = i2;
        }
      } else {
        console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
      }
    }
  }
  function createPrimitiveKey(primitiveDef) {
    var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
    var geometryKey;
    if (dracoExtension) {
      geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
    } else {
      geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
    }
    return geometryKey;
  }
  function createAttributesKey(attributes) {
    var attributesKey = "";
    var keys = Object.keys(attributes).sort();
    for (var i2 = 0, il = keys.length; i2 < il; i2++) {
      attributesKey += keys[i2] + ":" + attributes[keys[i2]] + ";";
    }
    return attributesKey;
  }
  function GLTFParser(json, options) {
    this.json = json || {};
    this.extensions = {};
    this.plugins = {};
    this.options = options || {};
    this.cache = new GLTFRegistry();
    this.associations = new Map();
    this.primitiveCache = {};
    this.meshCache = {refs: {}, uses: {}};
    this.cameraCache = {refs: {}, uses: {}};
    this.lightCache = {refs: {}, uses: {}};
    this.nodeNamesUsed = {};
    if (typeof createImageBitmap !== "undefined" && /Firefox/.test(navigator.userAgent) === false) {
      this.textureLoader = new ImageBitmapLoader(this.options.manager);
    } else {
      this.textureLoader = new TextureLoader(this.options.manager);
    }
    this.textureLoader.setCrossOrigin(this.options.crossOrigin);
    this.textureLoader.setRequestHeader(this.options.requestHeader);
    this.fileLoader = new FileLoader(this.options.manager);
    this.fileLoader.setResponseType("arraybuffer");
    if (this.options.crossOrigin === "use-credentials") {
      this.fileLoader.setWithCredentials(true);
    }
  }
  GLTFParser.prototype.setExtensions = function(extensions) {
    this.extensions = extensions;
  };
  GLTFParser.prototype.setPlugins = function(plugins) {
    this.plugins = plugins;
  };
  GLTFParser.prototype.parse = function(onLoad, onError) {
    var parser = this;
    var json = this.json;
    var extensions = this.extensions;
    this.cache.removeAll();
    this._invokeAll(function(ext) {
      return ext._markDefs && ext._markDefs();
    });
    Promise.all(this._invokeAll(function(ext) {
      return ext.beforeRoot && ext.beforeRoot();
    })).then(function() {
      return Promise.all([
        parser.getDependencies("scene"),
        parser.getDependencies("animation"),
        parser.getDependencies("camera")
      ]);
    }).then(function(dependencies) {
      var result = {
        scene: dependencies[0][json.scene || 0],
        scenes: dependencies[0],
        animations: dependencies[1],
        cameras: dependencies[2],
        asset: json.asset,
        parser,
        userData: {}
      };
      addUnknownExtensionsToUserData(extensions, result, json);
      assignExtrasToUserData(result, json);
      Promise.all(parser._invokeAll(function(ext) {
        return ext.afterRoot && ext.afterRoot(result);
      })).then(function() {
        onLoad(result);
      });
    }).catch(onError);
  };
  GLTFParser.prototype._markDefs = function() {
    var nodeDefs = this.json.nodes || [];
    var skinDefs = this.json.skins || [];
    var meshDefs = this.json.meshes || [];
    for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
      var joints = skinDefs[skinIndex].joints;
      for (var i2 = 0, il = joints.length; i2 < il; i2++) {
        nodeDefs[joints[i2]].isBone = true;
      }
    }
    for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      var nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.mesh !== void 0) {
        this._addNodeRef(this.meshCache, nodeDef.mesh);
        if (nodeDef.skin !== void 0) {
          meshDefs[nodeDef.mesh].isSkinnedMesh = true;
        }
      }
      if (nodeDef.camera !== void 0) {
        this._addNodeRef(this.cameraCache, nodeDef.camera);
      }
    }
  };
  GLTFParser.prototype._addNodeRef = function(cache, index) {
    if (index === void 0)
      return;
    if (cache.refs[index] === void 0) {
      cache.refs[index] = cache.uses[index] = 0;
    }
    cache.refs[index]++;
  };
  GLTFParser.prototype._getNodeRef = function(cache, index, object) {
    if (cache.refs[index] <= 1)
      return object;
    var ref = object.clone();
    ref.name += "_instance_" + cache.uses[index]++;
    return ref;
  };
  GLTFParser.prototype._invokeOne = function(func) {
    var extensions = Object.values(this.plugins);
    extensions.push(this);
    for (var i2 = 0; i2 < extensions.length; i2++) {
      var result = func(extensions[i2]);
      if (result)
        return result;
    }
  };
  GLTFParser.prototype._invokeAll = function(func) {
    var extensions = Object.values(this.plugins);
    extensions.unshift(this);
    var pending = [];
    for (var i2 = 0; i2 < extensions.length; i2++) {
      var result = func(extensions[i2]);
      if (result)
        pending.push(result);
    }
    return pending;
  };
  GLTFParser.prototype.getDependency = function(type, index) {
    var cacheKey = type + ":" + index;
    var dependency = this.cache.get(cacheKey);
    if (!dependency) {
      switch (type) {
        case "scene":
          dependency = this.loadScene(index);
          break;
        case "node":
          dependency = this.loadNode(index);
          break;
        case "mesh":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMesh && ext.loadMesh(index);
          });
          break;
        case "accessor":
          dependency = this.loadAccessor(index);
          break;
        case "bufferView":
          dependency = this._invokeOne(function(ext) {
            return ext.loadBufferView && ext.loadBufferView(index);
          });
          break;
        case "buffer":
          dependency = this.loadBuffer(index);
          break;
        case "material":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMaterial && ext.loadMaterial(index);
          });
          break;
        case "texture":
          dependency = this._invokeOne(function(ext) {
            return ext.loadTexture && ext.loadTexture(index);
          });
          break;
        case "skin":
          dependency = this.loadSkin(index);
          break;
        case "animation":
          dependency = this.loadAnimation(index);
          break;
        case "camera":
          dependency = this.loadCamera(index);
          break;
        default:
          throw new Error("Unknown type: " + type);
      }
      this.cache.add(cacheKey, dependency);
    }
    return dependency;
  };
  GLTFParser.prototype.getDependencies = function(type) {
    var dependencies = this.cache.get(type);
    if (!dependencies) {
      var parser = this;
      var defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
      dependencies = Promise.all(defs.map(function(def, index) {
        return parser.getDependency(type, index);
      }));
      this.cache.add(type, dependencies);
    }
    return dependencies;
  };
  GLTFParser.prototype.loadBuffer = function(bufferIndex) {
    var bufferDef = this.json.buffers[bufferIndex];
    var loader = this.fileLoader;
    if (bufferDef.type && bufferDef.type !== "arraybuffer") {
      throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
    }
    if (bufferDef.uri === void 0 && bufferIndex === 0) {
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    }
    var options = this.options;
    return new Promise(function(resolve, reject) {
      loader.load(resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {
        reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
      });
    });
  };
  GLTFParser.prototype.loadBufferView = function(bufferViewIndex) {
    var bufferViewDef = this.json.bufferViews[bufferViewIndex];
    return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer) {
      var byteLength = bufferViewDef.byteLength || 0;
      var byteOffset = bufferViewDef.byteOffset || 0;
      return buffer.slice(byteOffset, byteOffset + byteLength);
    });
  };
  GLTFParser.prototype.loadAccessor = function(accessorIndex) {
    var parser = this;
    var json = this.json;
    var accessorDef = this.json.accessors[accessorIndex];
    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
      return Promise.resolve(null);
    }
    var pendingBufferViews = [];
    if (accessorDef.bufferView !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
    } else {
      pendingBufferViews.push(null);
    }
    if (accessorDef.sparse !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
    }
    return Promise.all(pendingBufferViews).then(function(bufferViews) {
      var bufferView = bufferViews[0];
      var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      var elementBytes = TypedArray.BYTES_PER_ELEMENT;
      var itemBytes = elementBytes * itemSize;
      var byteOffset = accessorDef.byteOffset || 0;
      var byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
      var normalized = accessorDef.normalized === true;
      var array, bufferAttribute;
      if (byteStride && byteStride !== itemBytes) {
        var ibSlice = Math.floor(byteOffset / byteStride);
        var ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
        var ib = parser.cache.get(ibCacheKey);
        if (!ib) {
          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
          ib = new InterleavedBuffer(array, byteStride / elementBytes);
          parser.cache.add(ibCacheKey, ib);
        }
        bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
      } else {
        if (bufferView === null) {
          array = new TypedArray(accessorDef.count * itemSize);
        } else {
          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
        }
        bufferAttribute = new BufferAttribute(array, itemSize, normalized);
      }
      if (accessorDef.sparse !== void 0) {
        var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
        var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
        var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
        var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
        var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
        var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
        if (bufferView !== null) {
          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
        }
        for (var i2 = 0, il = sparseIndices.length; i2 < il; i2++) {
          var index = sparseIndices[i2];
          bufferAttribute.setX(index, sparseValues[i2 * itemSize]);
          if (itemSize >= 2)
            bufferAttribute.setY(index, sparseValues[i2 * itemSize + 1]);
          if (itemSize >= 3)
            bufferAttribute.setZ(index, sparseValues[i2 * itemSize + 2]);
          if (itemSize >= 4)
            bufferAttribute.setW(index, sparseValues[i2 * itemSize + 3]);
          if (itemSize >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return bufferAttribute;
    });
  };
  GLTFParser.prototype.loadTexture = function(textureIndex) {
    var json = this.json;
    var options = this.options;
    var textureDef = json.textures[textureIndex];
    var source = json.images[textureDef.source];
    var loader = this.textureLoader;
    if (source.uri) {
      var handler = options.manager.getHandler(source.uri);
      if (handler !== null)
        loader = handler;
    }
    return this.loadTextureImage(textureIndex, source, loader);
  };
  GLTFParser.prototype.loadTextureImage = function(textureIndex, source, loader) {
    var parser = this;
    var json = this.json;
    var options = this.options;
    var textureDef = json.textures[textureIndex];
    var URL2 = self.URL || self.webkitURL;
    var sourceURI = source.uri;
    var isObjectURL = false;
    var hasAlpha = true;
    if (source.mimeType === "image/jpeg")
      hasAlpha = false;
    if (source.bufferView !== void 0) {
      sourceURI = parser.getDependency("bufferView", source.bufferView).then(function(bufferView) {
        if (source.mimeType === "image/png") {
          var colorType = new DataView(bufferView, 25, 1).getUint8(0, false);
          hasAlpha = colorType === 6 || colorType === 4 || colorType === 3;
        }
        isObjectURL = true;
        var blob = new Blob([bufferView], {type: source.mimeType});
        sourceURI = URL2.createObjectURL(blob);
        return sourceURI;
      });
    } else if (source.uri === void 0) {
      throw new Error("THREE.GLTFLoader: Image " + textureIndex + " is missing URI and bufferView");
    }
    return Promise.resolve(sourceURI).then(function(sourceURI2) {
      return new Promise(function(resolve, reject) {
        var onLoad = resolve;
        if (loader.isImageBitmapLoader === true) {
          onLoad = function(imageBitmap) {
            resolve(new CanvasTexture(imageBitmap));
          };
        }
        loader.load(resolveURL(sourceURI2, options.path), onLoad, void 0, reject);
      });
    }).then(function(texture) {
      if (isObjectURL === true) {
        URL2.revokeObjectURL(sourceURI);
      }
      texture.flipY = false;
      if (textureDef.name)
        texture.name = textureDef.name;
      if (!hasAlpha)
        texture.format = RGBFormat;
      var samplers = json.samplers || {};
      var sampler = samplers[textureDef.sampler] || {};
      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
      parser.associations.set(texture, {
        type: "textures",
        index: textureIndex
      });
      return texture;
    });
  };
  GLTFParser.prototype.assignTexture = function(materialParams, mapName, mapDef) {
    var parser = this;
    return this.getDependency("texture", mapDef.index).then(function(texture) {
      if (mapDef.texCoord !== void 0 && mapDef.texCoord != 0 && !(mapName === "aoMap" && mapDef.texCoord == 1)) {
        console.warn("THREE.GLTFLoader: Custom UV set " + mapDef.texCoord + " for texture " + mapName + " not yet supported.");
      }
      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
        var transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
        if (transform) {
          var gltfReference = parser.associations.get(texture);
          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
          parser.associations.set(texture, gltfReference);
        }
      }
      materialParams[mapName] = texture;
    });
  };
  GLTFParser.prototype.assignFinalMaterial = function(mesh) {
    var geometry = mesh.geometry;
    var material = mesh.material;
    var useVertexTangents = geometry.attributes.tangent !== void 0;
    var useVertexColors = geometry.attributes.color !== void 0;
    var useFlatShading = geometry.attributes.normal === void 0;
    var useSkinning = mesh.isSkinnedMesh === true;
    var useMorphTargets = Object.keys(geometry.morphAttributes).length > 0;
    var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== void 0;
    if (mesh.isPoints) {
      var cacheKey = "PointsMaterial:" + material.uuid;
      var pointsMaterial = this.cache.get(cacheKey);
      if (!pointsMaterial) {
        pointsMaterial = new PointsMaterial();
        Material.prototype.copy.call(pointsMaterial, material);
        pointsMaterial.color.copy(material.color);
        pointsMaterial.map = material.map;
        pointsMaterial.sizeAttenuation = false;
        this.cache.add(cacheKey, pointsMaterial);
      }
      material = pointsMaterial;
    } else if (mesh.isLine) {
      var cacheKey = "LineBasicMaterial:" + material.uuid;
      var lineMaterial = this.cache.get(cacheKey);
      if (!lineMaterial) {
        lineMaterial = new LineBasicMaterial();
        Material.prototype.copy.call(lineMaterial, material);
        lineMaterial.color.copy(material.color);
        this.cache.add(cacheKey, lineMaterial);
      }
      material = lineMaterial;
    }
    if (useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets) {
      var cacheKey = "ClonedMaterial:" + material.uuid + ":";
      if (material.isGLTFSpecularGlossinessMaterial)
        cacheKey += "specular-glossiness:";
      if (useSkinning)
        cacheKey += "skinning:";
      if (useVertexTangents)
        cacheKey += "vertex-tangents:";
      if (useVertexColors)
        cacheKey += "vertex-colors:";
      if (useFlatShading)
        cacheKey += "flat-shading:";
      if (useMorphTargets)
        cacheKey += "morph-targets:";
      if (useMorphNormals)
        cacheKey += "morph-normals:";
      var cachedMaterial = this.cache.get(cacheKey);
      if (!cachedMaterial) {
        cachedMaterial = material.clone();
        if (useSkinning)
          cachedMaterial.skinning = true;
        if (useVertexColors)
          cachedMaterial.vertexColors = true;
        if (useFlatShading)
          cachedMaterial.flatShading = true;
        if (useMorphTargets)
          cachedMaterial.morphTargets = true;
        if (useMorphNormals)
          cachedMaterial.morphNormals = true;
        if (useVertexTangents) {
          cachedMaterial.vertexTangents = true;
          if (cachedMaterial.normalScale)
            cachedMaterial.normalScale.y *= -1;
          if (cachedMaterial.clearcoatNormalScale)
            cachedMaterial.clearcoatNormalScale.y *= -1;
        }
        this.cache.add(cacheKey, cachedMaterial);
        this.associations.set(cachedMaterial, this.associations.get(material));
      }
      material = cachedMaterial;
    }
    if (material.aoMap && geometry.attributes.uv2 === void 0 && geometry.attributes.uv !== void 0) {
      geometry.setAttribute("uv2", geometry.attributes.uv);
    }
    mesh.material = material;
  };
  GLTFParser.prototype.getMaterialType = function() {
    return MeshStandardMaterial;
  };
  GLTFParser.prototype.loadMaterial = function(materialIndex) {
    var parser = this;
    var json = this.json;
    var extensions = this.extensions;
    var materialDef = json.materials[materialIndex];
    var materialType;
    var materialParams = {};
    var materialExtensions = materialDef.extensions || {};
    var pending = [];
    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
      var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
      materialType = sgExtension.getMaterialType();
      pending.push(sgExtension.extendParams(materialParams, materialDef, parser));
    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
      materialType = kmuExtension.getMaterialType();
      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
    } else {
      var metallicRoughness = materialDef.pbrMetallicRoughness || {};
      materialParams.color = new Color(1, 1, 1);
      materialParams.opacity = 1;
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        var array = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture));
      }
      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
      if (metallicRoughness.metallicRoughnessTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
        pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
      }
      materialType = this._invokeOne(function(ext) {
        return ext.getMaterialType && ext.getMaterialType(materialIndex);
      });
      pending.push(Promise.all(this._invokeAll(function(ext) {
        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
      })));
    }
    if (materialDef.doubleSided === true) {
      materialParams.side = DoubleSide;
    }
    var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
    if (alphaMode === ALPHA_MODES.BLEND) {
      materialParams.transparent = true;
      materialParams.depthWrite = false;
    } else {
      materialParams.transparent = false;
      if (alphaMode === ALPHA_MODES.MASK) {
        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
      }
    }
    if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
      materialParams.normalScale = new Vector2(1, -1);
      if (materialDef.normalTexture.scale !== void 0) {
        materialParams.normalScale.set(materialDef.normalTexture.scale, -materialDef.normalTexture.scale);
      }
    }
    if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
      if (materialDef.occlusionTexture.strength !== void 0) {
        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
      }
    }
    if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {
      materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);
    }
    if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture));
    }
    return Promise.all(pending).then(function() {
      var material;
      if (materialType === GLTFMeshStandardSGMaterial) {
        material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);
      } else {
        material = new materialType(materialParams);
      }
      if (materialDef.name)
        material.name = materialDef.name;
      if (material.map)
        material.map.encoding = sRGBEncoding;
      if (material.emissiveMap)
        material.emissiveMap.encoding = sRGBEncoding;
      assignExtrasToUserData(material, materialDef);
      parser.associations.set(material, {type: "materials", index: materialIndex});
      if (materialDef.extensions)
        addUnknownExtensionsToUserData(extensions, material, materialDef);
      return material;
    });
  };
  GLTFParser.prototype.createUniqueName = function(originalName) {
    var sanitizedName = PropertyBinding.sanitizeNodeName(originalName || "");
    var name = sanitizedName;
    for (var i2 = 1; this.nodeNamesUsed[name]; ++i2) {
      name = sanitizedName + "_" + i2;
    }
    this.nodeNamesUsed[name] = true;
    return name;
  };
  function computeBounds(geometry, primitiveDef, parser) {
    var attributes = primitiveDef.attributes;
    var box = new Box3();
    if (attributes.POSITION !== void 0) {
      var accessor = parser.json.accessors[attributes.POSITION];
      var min = accessor.min;
      var max = accessor.max;
      if (min !== void 0 && max !== void 0) {
        box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]));
      } else {
        console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        return;
      }
    } else {
      return;
    }
    var targets = primitiveDef.targets;
    if (targets !== void 0) {
      var maxDisplacement = new Vector3();
      var vector = new Vector3();
      for (var i2 = 0, il = targets.length; i2 < il; i2++) {
        var target = targets[i2];
        if (target.POSITION !== void 0) {
          var accessor = parser.json.accessors[target.POSITION];
          var min = accessor.min;
          var max = accessor.max;
          if (min !== void 0 && max !== void 0) {
            vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
            vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
            vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));
            maxDisplacement.max(vector);
          } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
          }
        }
      }
      box.expandByVector(maxDisplacement);
    }
    geometry.boundingBox = box;
    var sphere = new Sphere();
    box.getCenter(sphere.center);
    sphere.radius = box.min.distanceTo(box.max) / 2;
    geometry.boundingSphere = sphere;
  }
  function addPrimitiveAttributes(geometry, primitiveDef, parser) {
    var attributes = primitiveDef.attributes;
    var pending = [];
    function assignAttributeAccessor(accessorIndex, attributeName) {
      return parser.getDependency("accessor", accessorIndex).then(function(accessor2) {
        geometry.setAttribute(attributeName, accessor2);
      });
    }
    for (var gltfAttributeName in attributes) {
      var threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
      if (threeAttributeName in geometry.attributes)
        continue;
      pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
    }
    if (primitiveDef.indices !== void 0 && !geometry.index) {
      var accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
        geometry.setIndex(accessor2);
      });
      pending.push(accessor);
    }
    assignExtrasToUserData(geometry, primitiveDef);
    computeBounds(geometry, primitiveDef, parser);
    return Promise.all(pending).then(function() {
      return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
    });
  }
  function toTrianglesDrawMode(geometry, drawMode) {
    var index = geometry.getIndex();
    if (index === null) {
      var indices = [];
      var position = geometry.getAttribute("position");
      if (position !== void 0) {
        for (var i2 = 0; i2 < position.count; i2++) {
          indices.push(i2);
        }
        geometry.setIndex(indices);
        index = geometry.getIndex();
      } else {
        console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
        return geometry;
      }
    }
    var numberOfTriangles = index.count - 2;
    var newIndices = [];
    if (drawMode === TriangleFanDrawMode) {
      for (var i2 = 1; i2 <= numberOfTriangles; i2++) {
        newIndices.push(index.getX(0));
        newIndices.push(index.getX(i2));
        newIndices.push(index.getX(i2 + 1));
      }
    } else {
      for (var i2 = 0; i2 < numberOfTriangles; i2++) {
        if (i2 % 2 === 0) {
          newIndices.push(index.getX(i2));
          newIndices.push(index.getX(i2 + 1));
          newIndices.push(index.getX(i2 + 2));
        } else {
          newIndices.push(index.getX(i2 + 2));
          newIndices.push(index.getX(i2 + 1));
          newIndices.push(index.getX(i2));
        }
      }
    }
    if (newIndices.length / 3 !== numberOfTriangles) {
      console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    }
    var newGeometry = geometry.clone();
    newGeometry.setIndex(newIndices);
    return newGeometry;
  }
  GLTFParser.prototype.loadGeometries = function(primitives) {
    var parser = this;
    var extensions = this.extensions;
    var cache = this.primitiveCache;
    function createDracoPrimitive(primitive2) {
      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive2, parser).then(function(geometry) {
        return addPrimitiveAttributes(geometry, primitive2, parser);
      });
    }
    var pending = [];
    for (var i2 = 0, il = primitives.length; i2 < il; i2++) {
      var primitive = primitives[i2];
      var cacheKey = createPrimitiveKey(primitive);
      var cached = cache[cacheKey];
      if (cached) {
        pending.push(cached.promise);
      } else {
        var geometryPromise;
        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
          geometryPromise = createDracoPrimitive(primitive);
        } else {
          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
        }
        cache[cacheKey] = {primitive, promise: geometryPromise};
        pending.push(geometryPromise);
      }
    }
    return Promise.all(pending);
  };
  GLTFParser.prototype.loadMesh = function(meshIndex) {
    var parser = this;
    var json = this.json;
    var extensions = this.extensions;
    var meshDef = json.meshes[meshIndex];
    var primitives = meshDef.primitives;
    var pending = [];
    for (var i2 = 0, il = primitives.length; i2 < il; i2++) {
      var material = primitives[i2].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i2].material);
      pending.push(material);
    }
    pending.push(parser.loadGeometries(primitives));
    return Promise.all(pending).then(function(results) {
      var materials = results.slice(0, results.length - 1);
      var geometries = results[results.length - 1];
      var meshes = [];
      for (var i3 = 0, il2 = geometries.length; i3 < il2; i3++) {
        var geometry = geometries[i3];
        var primitive = primitives[i3];
        var mesh;
        var material2 = materials[i3];
        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {
          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material2) : new Mesh(geometry, material2);
          if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {
            mesh.normalizeSkinWeights();
          }
          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
          }
        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
          mesh = new LineSegments(geometry, material2);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
          mesh = new Line(geometry, material2);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
          mesh = new LineLoop(geometry, material2);
        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
          mesh = new Points(geometry, material2);
        } else {
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
        }
        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
          updateMorphTargets(mesh, meshDef);
        }
        mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
        assignExtrasToUserData(mesh, meshDef);
        if (primitive.extensions)
          addUnknownExtensionsToUserData(extensions, mesh, primitive);
        parser.assignFinalMaterial(mesh);
        meshes.push(mesh);
      }
      if (meshes.length === 1) {
        return meshes[0];
      }
      var group = new Group();
      for (var i3 = 0, il2 = meshes.length; i3 < il2; i3++) {
        group.add(meshes[i3]);
      }
      return group;
    });
  };
  GLTFParser.prototype.loadCamera = function(cameraIndex) {
    var camera;
    var cameraDef = this.json.cameras[cameraIndex];
    var params = cameraDef[cameraDef.type];
    if (!params) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    if (cameraDef.type === "perspective") {
      camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
    } else if (cameraDef.type === "orthographic") {
      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
    }
    if (cameraDef.name)
      camera.name = this.createUniqueName(cameraDef.name);
    assignExtrasToUserData(camera, cameraDef);
    return Promise.resolve(camera);
  };
  GLTFParser.prototype.loadSkin = function(skinIndex) {
    var skinDef = this.json.skins[skinIndex];
    var skinEntry = {joints: skinDef.joints};
    if (skinDef.inverseBindMatrices === void 0) {
      return Promise.resolve(skinEntry);
    }
    return this.getDependency("accessor", skinDef.inverseBindMatrices).then(function(accessor) {
      skinEntry.inverseBindMatrices = accessor;
      return skinEntry;
    });
  };
  GLTFParser.prototype.loadAnimation = function(animationIndex) {
    var json = this.json;
    var animationDef = json.animations[animationIndex];
    var pendingNodes = [];
    var pendingInputAccessors = [];
    var pendingOutputAccessors = [];
    var pendingSamplers = [];
    var pendingTargets = [];
    for (var i2 = 0, il = animationDef.channels.length; i2 < il; i2++) {
      var channel = animationDef.channels[i2];
      var sampler = animationDef.samplers[channel.sampler];
      var target = channel.target;
      var name = target.node !== void 0 ? target.node : target.id;
      var input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
      var output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
      pendingNodes.push(this.getDependency("node", name));
      pendingInputAccessors.push(this.getDependency("accessor", input));
      pendingOutputAccessors.push(this.getDependency("accessor", output));
      pendingSamplers.push(sampler);
      pendingTargets.push(target);
    }
    return Promise.all([
      Promise.all(pendingNodes),
      Promise.all(pendingInputAccessors),
      Promise.all(pendingOutputAccessors),
      Promise.all(pendingSamplers),
      Promise.all(pendingTargets)
    ]).then(function(dependencies) {
      var nodes = dependencies[0];
      var inputAccessors = dependencies[1];
      var outputAccessors = dependencies[2];
      var samplers = dependencies[3];
      var targets = dependencies[4];
      var tracks = [];
      for (var i3 = 0, il2 = nodes.length; i3 < il2; i3++) {
        var node = nodes[i3];
        var inputAccessor = inputAccessors[i3];
        var outputAccessor = outputAccessors[i3];
        var sampler2 = samplers[i3];
        var target2 = targets[i3];
        if (node === void 0)
          continue;
        node.updateMatrix();
        node.matrixAutoUpdate = true;
        var TypedKeyframeTrack;
        switch (PATH_PROPERTIES[target2.path]) {
          case PATH_PROPERTIES.weights:
            TypedKeyframeTrack = NumberKeyframeTrack;
            break;
          case PATH_PROPERTIES.rotation:
            TypedKeyframeTrack = QuaternionKeyframeTrack;
            break;
          case PATH_PROPERTIES.position:
          case PATH_PROPERTIES.scale:
          default:
            TypedKeyframeTrack = VectorKeyframeTrack;
            break;
        }
        var targetName = node.name ? node.name : node.uuid;
        var interpolation = sampler2.interpolation !== void 0 ? INTERPOLATION[sampler2.interpolation] : InterpolateLinear;
        var targetNames = [];
        if (PATH_PROPERTIES[target2.path] === PATH_PROPERTIES.weights) {
          node.traverse(function(object) {
            if (object.isMesh === true && object.morphTargetInfluences) {
              targetNames.push(object.name ? object.name : object.uuid);
            }
          });
        } else {
          targetNames.push(targetName);
        }
        var outputArray = outputAccessor.array;
        if (outputAccessor.normalized) {
          var scale;
          if (outputArray.constructor === Int8Array) {
            scale = 1 / 127;
          } else if (outputArray.constructor === Uint8Array) {
            scale = 1 / 255;
          } else if (outputArray.constructor == Int16Array) {
            scale = 1 / 32767;
          } else if (outputArray.constructor === Uint16Array) {
            scale = 1 / 65535;
          } else {
            throw new Error("THREE.GLTFLoader: Unsupported output accessor component type.");
          }
          var scaled = new Float32Array(outputArray.length);
          for (var j2 = 0, jl = outputArray.length; j2 < jl; j2++) {
            scaled[j2] = outputArray[j2] * scale;
          }
          outputArray = scaled;
        }
        for (var j2 = 0, jl = targetNames.length; j2 < jl; j2++) {
          var track = new TypedKeyframeTrack(targetNames[j2] + "." + PATH_PROPERTIES[target2.path], inputAccessor.array, outputArray, interpolation);
          if (sampler2.interpolation === "CUBICSPLINE") {
            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
              return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);
            };
            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
          }
          tracks.push(track);
        }
      }
      var name2 = animationDef.name ? animationDef.name : "animation_" + animationIndex;
      return new AnimationClip(name2, void 0, tracks);
    });
  };
  GLTFParser.prototype.loadNode = function(nodeIndex) {
    var json = this.json;
    var extensions = this.extensions;
    var parser = this;
    var nodeDef = json.nodes[nodeIndex];
    var nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
    return function() {
      var pending = [];
      if (nodeDef.mesh !== void 0) {
        pending.push(parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
          var node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
          if (nodeDef.weights !== void 0) {
            node.traverse(function(o2) {
              if (!o2.isMesh)
                return;
              for (var i2 = 0, il = nodeDef.weights.length; i2 < il; i2++) {
                o2.morphTargetInfluences[i2] = nodeDef.weights[i2];
              }
            });
          }
          return node;
        }));
      }
      if (nodeDef.camera !== void 0) {
        pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera) {
          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
        }));
      }
      parser._invokeAll(function(ext) {
        return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
      }).forEach(function(promise) {
        pending.push(promise);
      });
      return Promise.all(pending);
    }().then(function(objects) {
      var node;
      if (nodeDef.isBone === true) {
        node = new Bone();
      } else if (objects.length > 1) {
        node = new Group();
      } else if (objects.length === 1) {
        node = objects[0];
      } else {
        node = new Object3D();
      }
      if (node !== objects[0]) {
        for (var i2 = 0, il = objects.length; i2 < il; i2++) {
          node.add(objects[i2]);
        }
      }
      if (nodeDef.name) {
        node.userData.name = nodeDef.name;
        node.name = nodeName;
      }
      assignExtrasToUserData(node, nodeDef);
      if (nodeDef.extensions)
        addUnknownExtensionsToUserData(extensions, node, nodeDef);
      if (nodeDef.matrix !== void 0) {
        var matrix = new Matrix4();
        matrix.fromArray(nodeDef.matrix);
        node.applyMatrix4(matrix);
      } else {
        if (nodeDef.translation !== void 0) {
          node.position.fromArray(nodeDef.translation);
        }
        if (nodeDef.rotation !== void 0) {
          node.quaternion.fromArray(nodeDef.rotation);
        }
        if (nodeDef.scale !== void 0) {
          node.scale.fromArray(nodeDef.scale);
        }
      }
      parser.associations.set(node, {type: "nodes", index: nodeIndex});
      return node;
    });
  };
  GLTFParser.prototype.loadScene = function() {
    function buildNodeHierachy(nodeId, parentObject, json, parser) {
      var nodeDef = json.nodes[nodeId];
      return parser.getDependency("node", nodeId).then(function(node) {
        if (nodeDef.skin === void 0)
          return node;
        var skinEntry;
        return parser.getDependency("skin", nodeDef.skin).then(function(skin) {
          skinEntry = skin;
          var pendingJoints = [];
          for (var i2 = 0, il = skinEntry.joints.length; i2 < il; i2++) {
            pendingJoints.push(parser.getDependency("node", skinEntry.joints[i2]));
          }
          return Promise.all(pendingJoints);
        }).then(function(jointNodes) {
          node.traverse(function(mesh) {
            if (!mesh.isMesh)
              return;
            var bones = [];
            var boneInverses = [];
            for (var j2 = 0, jl = jointNodes.length; j2 < jl; j2++) {
              var jointNode = jointNodes[j2];
              if (jointNode) {
                bones.push(jointNode);
                var mat = new Matrix4();
                if (skinEntry.inverseBindMatrices !== void 0) {
                  mat.fromArray(skinEntry.inverseBindMatrices.array, j2 * 16);
                }
                boneInverses.push(mat);
              } else {
                console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[j2]);
              }
            }
            mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld);
          });
          return node;
        });
      }).then(function(node) {
        parentObject.add(node);
        var pending = [];
        if (nodeDef.children) {
          var children = nodeDef.children;
          for (var i2 = 0, il = children.length; i2 < il; i2++) {
            var child = children[i2];
            pending.push(buildNodeHierachy(child, node, json, parser));
          }
        }
        return Promise.all(pending);
      });
    }
    return function loadScene(sceneIndex) {
      var json = this.json;
      var extensions = this.extensions;
      var sceneDef = this.json.scenes[sceneIndex];
      var parser = this;
      var scene = new Group();
      if (sceneDef.name)
        scene.name = parser.createUniqueName(sceneDef.name);
      assignExtrasToUserData(scene, sceneDef);
      if (sceneDef.extensions)
        addUnknownExtensionsToUserData(extensions, scene, sceneDef);
      var nodeIds = sceneDef.nodes || [];
      var pending = [];
      for (var i2 = 0, il = nodeIds.length; i2 < il; i2++) {
        pending.push(buildNodeHierachy(nodeIds[i2], scene, json, parser));
      }
      return Promise.all(pending).then(function() {
        return scene;
      });
    };
  }();
  return GLTFLoader2;
}();
export {$, ArrowHelper as A, BoxGeometry as B, Clock as C, DynamicDrawUsage as D, ACESFilmicToneMapping as E, sRGBEncoding as F, GLTFLoader as G, HA as H, InstancedMesh as I, SphereGeometry as J, Mesh as M, Object3D as O, PerspectiveCamera as P, Quaternion as Q, RepeatWrapping as R, Scene as S, TextureLoader as T, Vector3 as V, WebGLRenderer as W, MeshBasicMaterial as a, addComponent as b, defineSystem as c, defineComponent as d, addEntity as e, Types as f, defineQuery as g, enterQuery as h, removeComponent as i, Vector2 as j, createWorld as k, MathUtils as l, BI as m, iA as n, pA as o, pipe as p, dA as q, removeEntity as r, MI as s, TA as t, uA as u, AnimationMixer as v, AudioListener as w, Audio as x, PositionalAudio as y, zA as z};
